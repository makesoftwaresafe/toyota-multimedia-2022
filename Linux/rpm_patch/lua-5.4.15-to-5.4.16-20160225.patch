Diff from rpm 5.4.15 to current development 5.4.16 (20160224)

Signed-off-by: Mark Hatle <mark.hatle@windriver.com>

diff -urN rpm-5.4.15/lua/lapi.c rpm-5.4-cvs/lua/lapi.c
--- rpm-5.4.15/lua/lapi.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lapi.c	2015-04-18 23:34:17.000000000 -0500
@@ -1,16 +1,18 @@
 /*
-** $Id: lapi.c,v 2.171 2013/03/16 21:10:18 roberto Exp $
+** $Id: lapi.c,v 2.244 2014/12/26 14:43:45 roberto Exp $
 ** Lua API
 ** See Copyright Notice in lua.h
 */
 
+#define lapi_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
 #include <stdarg.h>
 #include <string.h>
 
-#define lapi_c
-#define LUA_CORE
-
 #include "lua.h"
 
 #include "lapi.h"
@@ -43,32 +45,35 @@
 /* test for pseudo index */
 #define ispseudo(i)		((i) <= LUA_REGISTRYINDEX)
 
+/* test for upvalue */
+#define isupvalue(i)		((i) < LUA_REGISTRYINDEX)
+
 /* test for valid but not pseudo index */
 #define isstackindex(i, o)	(isvalid(o) && !ispseudo(i))
 
-#define api_checkvalidindex(L, o)  api_check(L, isvalid(o), "invalid index")
+#define api_checkvalidindex(o)  api_check(isvalid(o), "invalid index")
 
-#define api_checkstackindex(L, i, o)  \
-	api_check(L, isstackindex(i, o), "index not in the stack")
+#define api_checkstackindex(i, o)  \
+	api_check(isstackindex(i, o), "index not in the stack")
 
 
 static TValue *index2addr (lua_State *L, int idx) {
   CallInfo *ci = L->ci;
   if (idx > 0) {
     TValue *o = ci->func + idx;
-    api_check(L, idx <= ci->top - (ci->func + 1), "unacceptable index");
+    api_check(idx <= ci->top - (ci->func + 1), "unacceptable index");
     if (o >= L->top) return NONVALIDVALUE;
     else return o;
   }
   else if (!ispseudo(idx)) {  /* negative index */
-    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
+    api_check(idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
     return L->top + idx;
   }
   else if (idx == LUA_REGISTRYINDEX)
     return &G(L)->l_registry;
   else {  /* upvalues */
     idx = LUA_REGISTRYINDEX - idx;
-    api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
+    api_check(idx <= MAXUPVAL + 1, "upvalue index too large");
     if (ttislcf(ci->func))  /* light C function? */
       return NONVALIDVALUE;  /* it has no upvalues */
     else {
@@ -89,21 +94,22 @@
 }
 
 
-LUA_API int lua_checkstack (lua_State *L, int size) {
+LUA_API int lua_checkstack (lua_State *L, int n) {
   int res;
   CallInfo *ci = L->ci;
   lua_lock(L);
-  if (L->stack_last - L->top > size)  /* stack large enough? */
+  api_check(n >= 0, "negative 'n'");
+  if (L->stack_last - L->top > n)  /* stack large enough? */
     res = 1;  /* yes; check is OK */
   else {  /* no; need to grow stack */
     int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
-    if (inuse > LUAI_MAXSTACK - size)  /* can grow without overflow? */
+    if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */
       res = 0;  /* no */
     else  /* try to grow stack */
-      res = (luaD_rawrunprotected(L, &growstack, &size) == LUA_OK);
+      res = (luaD_rawrunprotected(L, &growstack, &n) == LUA_OK);
   }
-  if (res && ci->top < L->top + size)
-    ci->top = L->top + size;  /* adjust frame top */
+  if (res && ci->top < L->top + n)
+    ci->top = L->top + n;  /* adjust frame top */
   lua_unlock(L);
   return res;
 }
@@ -114,8 +120,8 @@
   if (from == to) return;
   lua_lock(to);
   api_checknelems(from, n);
-  api_check(from, G(from) == G(to), "moving among independent states");
-  api_check(from, to->ci->top - to->top >= n, "not enough elements to move");
+  api_check(G(from) == G(to), "moving among independent states");
+  api_check(to->ci->top - to->top >= n, "not enough elements to move");
   from->top -= n;
   for (i = 0; i < n; i++) {
     setobj2s(to, to->top++, from->top + i);
@@ -166,68 +172,63 @@
   StkId func = L->ci->func;
   lua_lock(L);
   if (idx >= 0) {
-    api_check(L, idx <= L->stack_last - (func + 1), "new top too large");
+    api_check(idx <= L->stack_last - (func + 1), "new top too large");
     while (L->top < (func + 1) + idx)
       setnilvalue(L->top++);
     L->top = (func + 1) + idx;
   }
   else {
-    api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
-    L->top += idx+1;  /* `subtract' index (index is negative) */
+    api_check(-(idx+1) <= (L->top - (func + 1)), "invalid new top");
+    L->top += idx+1;  /* 'subtract' index (index is negative) */
   }
   lua_unlock(L);
 }
 
 
-LUA_API void lua_remove (lua_State *L, int idx) {
-  StkId p;
-  lua_lock(L);
-  p = index2addr(L, idx);
-  api_checkstackindex(L, idx, p);
-  while (++p < L->top) setobjs2s(L, p-1, p);
-  L->top--;
-  lua_unlock(L);
+/*
+** Reverse the stack segment from 'from' to 'to'
+** (auxiliary to 'lua_rotate')
+*/
+static void reverse (lua_State *L, StkId from, StkId to) {
+  for (; from < to; from++, to--) {
+    TValue temp;
+    setobj(L, &temp, from);
+    setobjs2s(L, from, to);
+    setobj2s(L, to, &temp);
+  }
 }
 
 
-LUA_API void lua_insert (lua_State *L, int idx) {
-  StkId p;
-  StkId q;
+/*
+** Let x = AB, where A is a prefix of length 'n'. Then,
+** rotate x n == BA. But BA == (A^r . B^r)^r.
+*/
+LUA_API void lua_rotate (lua_State *L, int idx, int n) {
+  StkId p, t, m;
   lua_lock(L);
-  p = index2addr(L, idx);
-  api_checkstackindex(L, idx, p);
-  for (q = L->top; q > p; q--)  /* use L->top as a temporary */
-    setobjs2s(L, q, q - 1);
-  setobjs2s(L, p, L->top);
+  t = L->top - 1;  /* end of stack segment being rotated */
+  p = index2addr(L, idx);  /* start of segment */
+  api_checkstackindex(idx, p);
+  api_check((n >= 0 ? n : -n) <= (t - p + 1), "invalid 'n'");
+  m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */
+  reverse(L, p, m);  /* reverse the prefix with length 'n' */
+  reverse(L, m + 1, t);  /* reverse the suffix */
+  reverse(L, p, t);  /* reverse the entire segment */
   lua_unlock(L);
 }
 
 
-static void moveto (lua_State *L, TValue *fr, int idx) {
-  TValue *to = index2addr(L, idx);
-  api_checkvalidindex(L, to);
+LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
+  TValue *fr, *to;
+  lua_lock(L);
+  fr = index2addr(L, fromidx);
+  to = index2addr(L, toidx);
+  api_checkvalidindex(to);
   setobj(L, to, fr);
-  if (idx < LUA_REGISTRYINDEX)  /* function upvalue? */
+  if (isupvalue(toidx))  /* function upvalue? */
     luaC_barrier(L, clCvalue(L->ci->func), fr);
   /* LUA_REGISTRYINDEX does not need gc barrier
      (collector revisits it before finishing collection) */
-}
-
-
-LUA_API void lua_replace (lua_State *L, int idx) {
-  lua_lock(L);
-  api_checknelems(L, 1);
-  moveto(L, L->top - 1, idx);
-  L->top--;
-  lua_unlock(L);
-}
-
-
-LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
-  TValue *fr;
-  lua_lock(L);
-  fr = index2addr(L, fromidx);
-  moveto(L, fr, toidx);
   lua_unlock(L);
 }
 
@@ -248,12 +249,13 @@
 
 LUA_API int lua_type (lua_State *L, int idx) {
   StkId o = index2addr(L, idx);
-  return (isvalid(o) ? ttypenv(o) : LUA_TNONE);
+  return (isvalid(o) ? ttnov(o) : LUA_TNONE);
 }
 
 
 LUA_API const char *lua_typename (lua_State *L, int t) {
   UNUSED(L);
+  api_check(LUA_TNONE <= t && t < LUA_NUMTAGS, "invalid tag");
   return ttypename(t);
 }
 
@@ -264,22 +266,28 @@
 }
 
 
+LUA_API int lua_isinteger (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return ttisinteger(o);
+}
+
+
 LUA_API int lua_isnumber (lua_State *L, int idx) {
-  TValue n;
+  lua_Number n;
   const TValue *o = index2addr(L, idx);
   return tonumber(o, &n);
 }
 
 
 LUA_API int lua_isstring (lua_State *L, int idx) {
-  int t = lua_type(L, idx);
-  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+  const TValue *o = index2addr(L, idx);
+  return (ttisstring(o) || cvt2str(o));
 }
 
 
 LUA_API int lua_isuserdata (lua_State *L, int idx) {
   const TValue *o = index2addr(L, idx);
-  return (ttisuserdata(o) || ttislightuserdata(o));
+  return (ttisfulluserdata(o) || ttislightuserdata(o));
 }
 
 
@@ -291,24 +299,17 @@
 
 
 LUA_API void lua_arith (lua_State *L, int op) {
-  StkId o1;  /* 1st operand */
-  StkId o2;  /* 2nd operand */
   lua_lock(L);
-  if (op != LUA_OPUNM) /* all other operations expect two operands */
-    api_checknelems(L, 2);
-  else {  /* for unary minus, add fake 2nd operand */
+  if (op != LUA_OPUNM && op != LUA_OPBNOT)
+    api_checknelems(L, 2);  /* all other operations expect two operands */
+  else {  /* for unary operations, add fake 2nd operand */
     api_checknelems(L, 1);
     setobjs2s(L, L->top, L->top - 1);
     L->top++;
   }
-  o1 = L->top - 2;
-  o2 = L->top - 1;
-  if (ttisnumber(o1) && ttisnumber(o2)) {
-    setnvalue(o1, luaO_arith(op, nvalue(o1), nvalue(o2)));
-  }
-  else
-    luaV_arith(L, o1, o1, o2, cast(TMS, op - LUA_OPADD + TM_ADD));
-  L->top--;
+  /* first operand at top - 2, second at top - 1; result go to top - 2 */
+  luaO_arith(L, op, L->top - 2, L->top - 1, L->top - 2);
+  L->top--;  /* remove second operand */
   lua_unlock(L);
 }
 
@@ -321,10 +322,10 @@
   o2 = index2addr(L, index2);
   if (isvalid(o1) && isvalid(o2)) {
     switch (op) {
-      case LUA_OPEQ: i = equalobj(L, o1, o2); break;
+      case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;
       case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
       case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
-      default: api_check(L, 0, "invalid option");
+      default: api_check(0, "invalid option");
     }
   }
   lua_unlock(L);
@@ -332,51 +333,33 @@
 }
 
 
-LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum) {
-  TValue n;
-  const TValue *o = index2addr(L, idx);
-  if (tonumber(o, &n)) {
-    if (isnum) *isnum = 1;
-    return nvalue(o);
-  }
-  else {
-    if (isnum) *isnum = 0;
-    return 0;
-  }
+LUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {
+  size_t sz = luaO_str2num(s, L->top);
+  if (sz != 0)
+    api_incr_top(L);
+  return sz;
 }
 
 
-LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum) {
-  TValue n;
+LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {
+  lua_Number n;
   const TValue *o = index2addr(L, idx);
-  if (tonumber(o, &n)) {
-    lua_Integer res;
-    lua_Number num = nvalue(o);
-    lua_number2integer(res, num);
-    if (isnum) *isnum = 1;
-    return res;
-  }
-  else {
-    if (isnum) *isnum = 0;
-    return 0;
-  }
+  int isnum = tonumber(o, &n);
+  if (!isnum)
+    n = 0;  /* call to 'tonumber' may change 'n' even if it fails */
+  if (pisnum) *pisnum = isnum;
+  return n;
 }
 
 
-LUA_API lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum) {
-  TValue n;
+LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {
+  lua_Integer res;
   const TValue *o = index2addr(L, idx);
-  if (tonumber(o, &n)) {
-    lua_Unsigned res;
-    lua_Number num = nvalue(o);
-    lua_number2unsigned(res, num);
-    if (isnum) *isnum = 1;
-    return res;
-  }
-  else {
-    if (isnum) *isnum = 0;
-    return 0;
-  }
+  int isnum = tointeger(o, &res);
+  if (!isnum)
+    res = 0;  /* call to 'tointeger' may change 'n' even if it fails */
+  if (pisnum) *pisnum = isnum;
+  return res;
 }
 
 
@@ -389,14 +372,14 @@
 LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
   StkId o = index2addr(L, idx);
   if (!ttisstring(o)) {
-    lua_lock(L);  /* `luaV_tostring' may create a new string */
-    if (!luaV_tostring(L, o)) {  /* conversion failed? */
+    if (!cvt2str(o)) {  /* not convertible? */
       if (len != NULL) *len = 0;
-      lua_unlock(L);
       return NULL;
     }
+    lua_lock(L);  /* 'luaO_tostring' may create a new string */
     luaC_checkGC(L);
     o = index2addr(L, idx);  /* previous call may reallocate the stack */
+    luaO_tostring(L, o);
     lua_unlock(L);
   }
   if (len != NULL) *len = tsvalue(o)->len;
@@ -406,7 +389,7 @@
 
 LUA_API size_t lua_rawlen (lua_State *L, int idx) {
   StkId o = index2addr(L, idx);
-  switch (ttypenv(o)) {
+  switch (ttnov(o)) {
     case LUA_TSTRING: return tsvalue(o)->len;
     case LUA_TUSERDATA: return uvalue(o)->len;
     case LUA_TTABLE: return luaH_getn(hvalue(o));
@@ -426,8 +409,8 @@
 
 LUA_API void *lua_touserdata (lua_State *L, int idx) {
   StkId o = index2addr(L, idx);
-  switch (ttypenv(o)) {
-    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
+  switch (ttnov(o)) {
+    case LUA_TUSERDATA: return getudatamem(uvalue(o));
     case LUA_TLIGHTUSERDATA: return pvalue(o);
     default: return NULL;
   }
@@ -472,9 +455,7 @@
 
 LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
   lua_lock(L);
-  setnvalue(L->top, n);
-  luai_checknum(L, L->top,
-    luaG_runerror(L, "C API - attempt to push a signaling NaN"));
+  setfltvalue(L->top, n);
   api_incr_top(L);
   lua_unlock(L);
 }
@@ -482,17 +463,7 @@
 
 LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
   lua_lock(L);
-  setnvalue(L->top, cast_num(n));
-  api_incr_top(L);
-  lua_unlock(L);
-}
-
-
-LUA_API void lua_pushunsigned (lua_State *L, lua_Unsigned u) {
-  lua_Number n;
-  lua_lock(L);
-  n = lua_unsigned2number(u);
-  setnvalue(L->top, n);
+  setivalue(L->top, n);
   api_incr_top(L);
   lua_unlock(L);
 }
@@ -558,15 +529,17 @@
     setfvalue(L->top, fn);
   }
   else {
-    Closure *cl;
+    CClosure *cl;
     api_checknelems(L, n);
-    api_check(L, n <= MAXUPVAL, "upvalue index too large");
+    api_check(n <= MAXUPVAL, "upvalue index too large");
     luaC_checkGC(L);
     cl = luaF_newCclosure(L, n);
-    cl->c.f = fn;
+    cl->f = fn;
     L->top -= n;
-    while (n--)
-      setobj2n(L, &cl->c.upvalue[n], L->top + n);
+    while (n--) {
+      setobj2n(L, &cl->upvalue[n], L->top + n);
+      /* does not need barrier because closure is white */
+    }
     setclCvalue(L, L->top, cl);
   }
   api_incr_top(L);
@@ -605,27 +578,29 @@
 */
 
 
-LUA_API void lua_getglobal (lua_State *L, const char *var) {
+LUA_API int lua_getglobal (lua_State *L, const char *name) {
   Table *reg = hvalue(&G(L)->l_registry);
   const TValue *gt;  /* global table */
   lua_lock(L);
   gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
-  setsvalue2s(L, L->top++, luaS_new(L, var));
+  setsvalue2s(L, L->top++, luaS_new(L, name));
   luaV_gettable(L, gt, L->top - 1, L->top - 1);
   lua_unlock(L);
+  return ttnov(L->top - 1);
 }
 
 
-LUA_API void lua_gettable (lua_State *L, int idx) {
+LUA_API int lua_gettable (lua_State *L, int idx) {
   StkId t;
   lua_lock(L);
   t = index2addr(L, idx);
   luaV_gettable(L, t, L->top - 1, L->top - 1);
   lua_unlock(L);
+  return ttnov(L->top - 1);
 }
 
 
-LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
+LUA_API int lua_getfield (lua_State *L, int idx, const char *k) {
   StkId t;
   lua_lock(L);
   t = index2addr(L, idx);
@@ -633,40 +608,56 @@
   api_incr_top(L);
   luaV_gettable(L, t, L->top - 1, L->top - 1);
   lua_unlock(L);
+  return ttnov(L->top - 1);
 }
 
 
-LUA_API void lua_rawget (lua_State *L, int idx) {
+LUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {
   StkId t;
   lua_lock(L);
   t = index2addr(L, idx);
-  api_check(L, ttistable(t), "table expected");
+  setivalue(L->top, n);
+  api_incr_top(L);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+  return ttnov(L->top - 1);
+}
+
+
+LUA_API int lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(ttistable(t), "table expected");
   setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
   lua_unlock(L);
+  return ttnov(L->top - 1);
 }
 
 
-LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+LUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {
   StkId t;
   lua_lock(L);
   t = index2addr(L, idx);
-  api_check(L, ttistable(t), "table expected");
+  api_check(ttistable(t), "table expected");
   setobj2s(L, L->top, luaH_getint(hvalue(t), n));
   api_incr_top(L);
   lua_unlock(L);
+  return ttnov(L->top - 1);
 }
 
 
-LUA_API void lua_rawgetp (lua_State *L, int idx, const void *p) {
+LUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {
   StkId t;
   TValue k;
   lua_lock(L);
   t = index2addr(L, idx);
-  api_check(L, ttistable(t), "table expected");
+  api_check(ttistable(t), "table expected");
   setpvalue(&k, cast(void *, p));
   setobj2s(L, L->top, luaH_get(hvalue(t), &k));
   api_incr_top(L);
   lua_unlock(L);
+  return ttnov(L->top - 1);
 }
 
 
@@ -685,11 +676,11 @@
 
 LUA_API int lua_getmetatable (lua_State *L, int objindex) {
   const TValue *obj;
-  Table *mt = NULL;
-  int res;
+  Table *mt;
+  int res = 0;
   lua_lock(L);
   obj = index2addr(L, objindex);
-  switch (ttypenv(obj)) {
+  switch (ttnov(obj)) {
     case LUA_TTABLE:
       mt = hvalue(obj)->metatable;
       break;
@@ -697,12 +688,10 @@
       mt = uvalue(obj)->metatable;
       break;
     default:
-      mt = G(L)->mt[ttypenv(obj)];
+      mt = G(L)->mt[ttnov(obj)];
       break;
   }
-  if (mt == NULL)
-    res = 0;
-  else {
+  if (mt != NULL) {
     sethvalue(L, L->top, mt);
     api_incr_top(L);
     res = 1;
@@ -712,17 +701,15 @@
 }
 
 
-LUA_API void lua_getuservalue (lua_State *L, int idx) {
+LUA_API int lua_getuservalue (lua_State *L, int idx) {
   StkId o;
   lua_lock(L);
   o = index2addr(L, idx);
-  api_check(L, ttisuserdata(o), "userdata expected");
-  if (uvalue(o)->env) {
-    sethvalue(L, L->top, uvalue(o)->env);
-  } else
-    setnilvalue(L->top);
+  api_check(ttisfulluserdata(o), "full userdata expected");
+  getuservalue(L, uvalue(o), L->top);
   api_incr_top(L);
   lua_unlock(L);
+  return ttnov(L->top - 1);
 }
 
 
@@ -731,13 +718,13 @@
 */
 
 
-LUA_API void lua_setglobal (lua_State *L, const char *var) {
+LUA_API void lua_setglobal (lua_State *L, const char *name) {
   Table *reg = hvalue(&G(L)->l_registry);
   const TValue *gt;  /* global table */
   lua_lock(L);
   api_checknelems(L, 1);
   gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
-  setsvalue2s(L, L->top++, luaS_new(L, var));
+  setsvalue2s(L, L->top++, luaS_new(L, name));
   luaV_settable(L, gt, L->top - 1, L->top - 2);
   L->top -= 2;  /* pop value and key */
   lua_unlock(L);
@@ -767,43 +754,61 @@
 }
 
 
-LUA_API void lua_rawset (lua_State *L, int idx) {
+LUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {
   StkId t;
   lua_lock(L);
-  api_checknelems(L, 2);
+  api_checknelems(L, 1);
   t = index2addr(L, idx);
-  api_check(L, ttistable(t), "table expected");
-  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);
-  invalidateTMcache(hvalue(t));
-  luaC_barrierback(L, gcvalue(t), L->top-1);
+  setivalue(L->top++, n);
+  luaV_settable(L, t, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId o;
+  Table *t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  o = index2addr(L, idx);
+  api_check(ttistable(o), "table expected");
+  t = hvalue(o);
+  setobj2t(L, luaH_set(L, t, L->top-2), L->top-1);
+  invalidateTMcache(t);
+  luaC_barrierback(L, t, L->top-1);
   L->top -= 2;
   lua_unlock(L);
 }
 
 
-LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
-  StkId t;
+LUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {
+  StkId o;
+  Table *t;
   lua_lock(L);
   api_checknelems(L, 1);
-  t = index2addr(L, idx);
-  api_check(L, ttistable(t), "table expected");
-  luaH_setint(L, hvalue(t), n, L->top - 1);
-  luaC_barrierback(L, gcvalue(t), L->top-1);
+  o = index2addr(L, idx);
+  api_check(ttistable(o), "table expected");
+  t = hvalue(o);
+  luaH_setint(L, t, n, L->top - 1);
+  luaC_barrierback(L, t, L->top-1);
   L->top--;
   lua_unlock(L);
 }
 
 
 LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
-  StkId t;
+  StkId o;
+  Table *t;
   TValue k;
   lua_lock(L);
   api_checknelems(L, 1);
-  t = index2addr(L, idx);
-  api_check(L, ttistable(t), "table expected");
+  o = index2addr(L, idx);
+  api_check(ttistable(o), "table expected");
+  t = hvalue(o);
   setpvalue(&k, cast(void *, p));
-  setobj2t(L, luaH_set(L, hvalue(t), &k), L->top - 1);
-  luaC_barrierback(L, gcvalue(t), L->top - 1);
+  setobj2t(L, luaH_set(L, t, &k), L->top - 1);
+  luaC_barrierback(L, t, L->top - 1);
   L->top--;
   lua_unlock(L);
 }
@@ -818,14 +823,14 @@
   if (ttisnil(L->top - 1))
     mt = NULL;
   else {
-    api_check(L, ttistable(L->top - 1), "table expected");
+    api_check(ttistable(L->top - 1), "table expected");
     mt = hvalue(L->top - 1);
   }
-  switch (ttypenv(obj)) {
+  switch (ttnov(obj)) {
     case LUA_TTABLE: {
       hvalue(obj)->metatable = mt;
       if (mt) {
-        luaC_objbarrierback(L, gcvalue(obj), mt);
+        luaC_objbarrier(L, gcvalue(obj), mt);
         luaC_checkfinalizer(L, gcvalue(obj), mt);
       }
       break;
@@ -833,13 +838,13 @@
     case LUA_TUSERDATA: {
       uvalue(obj)->metatable = mt;
       if (mt) {
-        luaC_objbarrier(L, rawuvalue(obj), mt);
+        luaC_objbarrier(L, uvalue(obj), mt);
         luaC_checkfinalizer(L, gcvalue(obj), mt);
       }
       break;
     }
     default: {
-      G(L)->mt[ttypenv(obj)] = mt;
+      G(L)->mt[ttnov(obj)] = mt;
       break;
     }
   }
@@ -854,46 +859,32 @@
   lua_lock(L);
   api_checknelems(L, 1);
   o = index2addr(L, idx);
-  api_check(L, ttisuserdata(o), "userdata expected");
-  if (ttisnil(L->top - 1))
-    uvalue(o)->env = NULL;
-  else {
-    api_check(L, ttistable(L->top - 1), "table expected");
-    uvalue(o)->env = hvalue(L->top - 1);
-    luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
-  }
+  api_check(ttisfulluserdata(o), "full userdata expected");
+  setuservalue(L, uvalue(o), L->top - 1);
+  luaC_barrier(L, gcvalue(o), L->top - 1);
   L->top--;
   lua_unlock(L);
 }
 
 
 /*
-** `load' and `call' functions (run Lua code)
+** 'load' and 'call' functions (run Lua code)
 */
 
 
 #define checkresults(L,na,nr) \
-     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
+     api_check((nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
 	"results from function overflow current stack size")
 
 
-LUA_API int lua_getctx (lua_State *L, int *ctx) {
-  if (L->ci->callstatus & CIST_YIELDED) {
-    if (ctx) *ctx = L->ci->u.c.ctx;
-    return L->ci->u.c.status;
-  }
-  else return LUA_OK;
-}
-
-
-LUA_API void lua_callk (lua_State *L, int nargs, int nresults, int ctx,
-                        lua_CFunction k) {
+LUA_API void lua_callk (lua_State *L, int nargs, int nresults,
+                        lua_KContext ctx, lua_KFunction k) {
   StkId func;
   lua_lock(L);
-  api_check(L, k == NULL || !isLua(L->ci),
+  api_check(k == NULL || !isLua(L->ci),
     "cannot use continuations inside hooks");
   api_checknelems(L, nargs+1);
-  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  api_check(L->status == LUA_OK, "cannot do calls on non-normal thread");
   checkresults(L, nargs, nresults);
   func = L->top - (nargs+1);
   if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
@@ -912,7 +903,7 @@
 /*
 ** Execute a protected call.
 */
-struct CallS {  /* data to `f_call' */
+struct CallS {  /* data to 'f_call' */
   StkId func;
   int nresults;
 };
@@ -926,21 +917,21 @@
 
 
 LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
-                        int ctx, lua_CFunction k) {
+                        lua_KContext ctx, lua_KFunction k) {
   struct CallS c;
   int status;
   ptrdiff_t func;
   lua_lock(L);
-  api_check(L, k == NULL || !isLua(L->ci),
+  api_check(k == NULL || !isLua(L->ci),
     "cannot use continuations inside hooks");
   api_checknelems(L, nargs+1);
-  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  api_check(L->status == LUA_OK, "cannot do calls on non-normal thread");
   checkresults(L, nargs, nresults);
   if (errfunc == 0)
     func = 0;
   else {
     StkId o = index2addr(L, errfunc);
-    api_checkstackindex(L, errfunc, o);
+    api_checkstackindex(errfunc, o);
     func = savestack(L, o);
   }
   c.func = L->top - (nargs+1);  /* function to be called */
@@ -954,11 +945,10 @@
     ci->u.c.ctx = ctx;  /* save context */
     /* save information for error recovery */
     ci->extra = savestack(L, c.func);
-    ci->u.c.old_allowhook = L->allowhook;
     ci->u.c.old_errfunc = L->errfunc;
     L->errfunc = func;
-    /* mark that function may do error recovery */
-    ci->callstatus |= CIST_YPCALL;
+    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */
+    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */
     luaD_call(L, c.func, nresults, 1);  /* do the call */
     ci->callstatus &= ~CIST_YPCALL;
     L->errfunc = ci->u.c.old_errfunc;
@@ -980,13 +970,13 @@
   status = luaD_protectedparser(L, &z, chunkname, mode);
   if (status == LUA_OK) {  /* no errors? */
     LClosure *f = clLvalue(L->top - 1);  /* get newly created function */
-    if (f->nupvalues == 1) {  /* does it have one upvalue? */
+    if (f->nupvalues >= 1) {  /* does it have an upvalue? */
       /* get global table from registry */
       Table *reg = hvalue(&G(L)->l_registry);
       const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
       /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
       setobj(L, f->upvals[0]->v, gt);
-      luaC_barrier(L, f->upvals[0], gt);
+      luaC_upvalbarrier(L, f->upvals[0]);
     }
   }
   lua_unlock(L);
@@ -994,14 +984,14 @@
 }
 
 
-LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
+LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {
   int status;
   TValue *o;
   lua_lock(L);
   api_checknelems(L, 1);
   o = L->top - 1;
   if (isLfunction(o))
-    status = luaU_dump(L, getproto(o), writer, data, 0);
+    status = luaU_dump(L, getproto(o), writer, data, strip);
   else
     status = 1;
   lua_unlock(L);
@@ -1047,19 +1037,21 @@
       break;
     }
     case LUA_GCSTEP: {
-      if (g->gckind == KGC_GEN) {  /* generational mode? */
-        res = (g->GCestimate == 0);  /* true if it will do major collection */
-        luaC_forcestep(L);  /* do a single step */
+      l_mem debt = 1;  /* =1 to signal that it did an actual step */
+      int oldrunning = g->gcrunning;
+      g->gcrunning = 1;  /* allow GC to run */
+      if (data == 0) {
+        luaE_setdebt(g, -GCSTEPSIZE);  /* to do a "small" step */
+        luaC_step(L);
       }
-      else {
-       lu_mem debt = cast(lu_mem, data) * 1024 - GCSTEPSIZE;
-       if (g->gcrunning)
-         debt += g->GCdebt;  /* include current debt */
-       luaE_setdebt(g, debt);
-       luaC_forcestep(L);
-       if (g->gcstate == GCSpause)  /* end of cycle? */
-         res = 1;  /* signal it */
+      else {  /* add 'data' to total debt */
+        debt = cast(l_mem, data) * 1024 + g->GCdebt;
+        luaE_setdebt(g, debt);
+        luaC_checkGC(L);
       }
+      g->gcrunning = oldrunning;  /* restore previous state */
+      if (debt > 0 && g->gcstate == GCSpause)  /* end of cycle? */
+        res = 1;  /* signal it */
       break;
     }
     case LUA_GCSETPAUSE: {
@@ -1067,13 +1059,9 @@
       g->gcpause = data;
       break;
     }
-    case LUA_GCSETMAJORINC: {
-      res = g->gcmajorinc;
-      g->gcmajorinc = data;
-      break;
-    }
     case LUA_GCSETSTEPMUL: {
       res = g->gcstepmul;
+      if (data < 40) data = 40;  /* avoid ridiculous low values (and 0) */
       g->gcstepmul = data;
       break;
     }
@@ -1081,14 +1069,6 @@
       res = g->gcrunning;
       break;
     }
-    case LUA_GCGEN: {  /* change collector to generational mode */
-      luaC_changemode(L, KGC_GEN);
-      break;
-    }
-    case LUA_GCINC: {  /* change collector to incremental mode */
-      luaC_changemode(L, KGC_NORMAL);
-      break;
-    }
     default: res = -1;  /* invalid option */
   }
   lua_unlock(L);
@@ -1106,8 +1086,10 @@
   lua_lock(L);
   api_checknelems(L, 1);
   luaG_errormsg(L);
+#if	!(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
   /* code unreachable; will unlock when control actually leaves the kernel */
   return 0;  /* to avoid warnings */
+#endif
 }
 
 
@@ -1116,7 +1098,7 @@
   int more;
   lua_lock(L);
   t = index2addr(L, idx);
-  api_check(L, ttistable(t), "table expected");
+  api_check(ttistable(t), "table expected");
   more = luaH_next(L, hvalue(t), L->top - 1);
   if (more) {
     api_incr_top(L);
@@ -1176,23 +1158,23 @@
   Udata *u;
   lua_lock(L);
   luaC_checkGC(L);
-  u = luaS_newudata(L, size, NULL);
+  u = luaS_newudata(L, size);
   setuvalue(L, L->top, u);
   api_incr_top(L);
   lua_unlock(L);
-  return u + 1;
+  return getudatamem(u);
 }
 
 
 
 static const char *aux_upvalue (StkId fi, int n, TValue **val,
-                                GCObject **owner) {
+                                CClosure **owner, UpVal **uv) {
   switch (ttype(fi)) {
     case LUA_TCCL: {  /* C closure */
       CClosure *f = clCvalue(fi);
       if (!(1 <= n && n <= f->nupvalues)) return NULL;
       *val = &f->upvalue[n-1];
-      if (owner) *owner = obj2gco(f);
+      if (owner) *owner = f;
       return "";
     }
     case LUA_TLCL: {  /* Lua closure */
@@ -1201,9 +1183,9 @@
       Proto *p = f->p;
       if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
       *val = f->upvals[n-1]->v;
-      if (owner) *owner = obj2gco(f->upvals[n - 1]);
+      if (uv) *uv = f->upvals[n - 1];
       name = p->upvalues[n-1].name;
-      return (name == NULL) ? "" : getstr(name);
+      return (name == NULL) ? "(*no name)" : getstr(name);
     }
     default: return NULL;  /* not a closure */
   }
@@ -1214,7 +1196,7 @@
   const char *name;
   TValue *val = NULL;  /* to avoid warnings */
   lua_lock(L);
-  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL);
+  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL, NULL);
   if (name) {
     setobj2s(L, L->top, val);
     api_incr_top(L);
@@ -1227,16 +1209,18 @@
 LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
   const char *name;
   TValue *val = NULL;  /* to avoid warnings */
-  GCObject *owner = NULL;  /* to avoid warnings */
+  CClosure *owner = NULL;
+  UpVal *uv = NULL;
   StkId fi;
   lua_lock(L);
   fi = index2addr(L, funcindex);
   api_checknelems(L, 1);
-  name = aux_upvalue(fi, n, &val, &owner);
+  name = aux_upvalue(fi, n, &val, &owner, &uv);
   if (name) {
     L->top--;
     setobj(L, val, L->top);
-    luaC_barrier(L, owner, L->top);
+    if (owner) { luaC_barrier(L, owner, L->top); }
+    else if (uv) { luaC_upvalbarrier(L, uv); }
   }
   lua_unlock(L);
   return name;
@@ -1246,9 +1230,9 @@
 static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
   LClosure *f;
   StkId fi = index2addr(L, fidx);
-  api_check(L, ttisLclosure(fi), "Lua function expected");
+  api_check(ttisLclosure(fi), "Lua function expected");
   f = clLvalue(fi);
-  api_check(L, (1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
+  api_check((1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
   if (pf) *pf = f;
   return &f->upvals[n - 1];  /* get its upvalue pointer */
 }
@@ -1262,11 +1246,11 @@
     }
     case LUA_TCCL: {  /* C closure */
       CClosure *f = clCvalue(fi);
-      api_check(L, 1 <= n && n <= f->nupvalues, "invalid upvalue index");
+      api_check(1 <= n && n <= f->nupvalues, "invalid upvalue index");
       return &f->upvalue[n - 1];
     }
     default: {
-      api_check(L, 0, "closure expected");
+      api_check(0, "closure expected");
       return NULL;
     }
   }
@@ -1278,7 +1262,11 @@
   LClosure *f1;
   UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
   UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
+  luaC_upvdeccount(L, *up1);
   *up1 = *up2;
-  luaC_objbarrier(L, f1, *up2);
+  (*up1)->refcount++;
+  if (upisopen(*up1)) (*up1)->u.open.touched = 1;
+  luaC_upvalbarrier(L, *up1);
 }
 
+
diff -urN rpm-5.4.15/lua/lapi.h rpm-5.4-cvs/lua/lapi.h
--- rpm-5.4.15/lua/lapi.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lapi.h	2015-04-18 23:34:17.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lapi.h,v 2.7 2009/11/27 15:37:59 roberto Exp $
+** $Id: lapi.h,v 2.8 2014/07/15 21:26:50 roberto Exp $
 ** Auxiliary functions from Lua API
 ** See Copyright Notice in lua.h
 */
@@ -11,13 +11,13 @@
 #include "llimits.h"
 #include "lstate.h"
 
-#define api_incr_top(L)   {L->top++; api_check(L, L->top <= L->ci->top, \
+#define api_incr_top(L)   {L->top++; api_check(L->top <= L->ci->top, \
 				"stack overflow");}
 
 #define adjustresults(L,nres) \
     { if ((nres) == LUA_MULTRET && L->ci->top < L->top) L->ci->top = L->top; }
 
-#define api_checknelems(L,n)	api_check(L, (n) < (L->top - L->ci->func), \
+#define api_checknelems(L,n)	api_check((n) < (L->top - L->ci->func), \
 				  "not enough elements in the stack")
 
 
diff -urN rpm-5.4.15/lua/lauxlib.c rpm-5.4-cvs/lua/lauxlib.c
--- rpm-5.4.15/lua/lauxlib.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lauxlib.c	2015-04-18 23:34:17.000000000 -0500
@@ -1,9 +1,14 @@
 /*
-** $Id: lauxlib.c,v 1.248 2013/03/21 13:54:57 roberto Exp $
+** $Id: lauxlib.c,v 1.279 2014/12/14 18:32:26 roberto Exp $
 ** Auxiliary functions for building Lua libraries
 ** See Copyright Notice in lua.h
 */
 
+#define lauxlib_c
+#define LUA_LIB
+
+#include "lprefix.h"
+
 
 #include <errno.h>
 #include <stdarg.h>
@@ -16,9 +21,6 @@
 ** Any function declared here could be written as an application function.
 */
 
-#define lauxlib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
@@ -64,11 +66,20 @@
 }
 
 
+/*
+** Search for a name for a function in all loaded modules
+** (registry._LOADED).
+*/
 static int pushglobalfuncname (lua_State *L, lua_Debug *ar) {
   int top = lua_gettop(L);
   lua_getinfo(L, "f", ar);  /* push function */
-  lua_pushglobaltable(L);
+  lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
   if (findfield(L, top + 1, 2)) {
+    const char *name = lua_tostring(L, -1);
+    if (strncmp(name, "_G.", 3) == 0) {  /* name start with '_G.'? */
+      lua_pushstring(L, name + 3);  /* push name without prefix */
+      lua_remove(L, -2);  /* remove original name */
+    }
     lua_copy(L, -1, top + 1);  /* move name to proper place */
     lua_pop(L, 2);  /* remove pushed values */
     return 1;
@@ -81,20 +92,18 @@
 
 
 static void pushfuncname (lua_State *L, lua_Debug *ar) {
-  if (*ar->namewhat != '\0')  /* is there a name? */
-    lua_pushfstring(L, "function " LUA_QS, ar->name);
+  if (pushglobalfuncname(L, ar)) {  /* try first a global name */
+    lua_pushfstring(L, "function '%s'", lua_tostring(L, -1));
+    lua_remove(L, -2);  /* remove name */
+  }
+  else if (*ar->namewhat != '\0')  /* is there a name from code? */
+    lua_pushfstring(L, "%s '%s'", ar->namewhat, ar->name);  /* use it */
   else if (*ar->what == 'm')  /* main? */
       lua_pushliteral(L, "main chunk");
-  else if (*ar->what == 'C') {
-    if (pushglobalfuncname(L, ar)) {
-      lua_pushfstring(L, "function " LUA_QS, lua_tostring(L, -1));
-      lua_remove(L, -2);  /* remove name */
-    }
-    else
-      lua_pushliteral(L, "?");
-  }
-  else
+  else if (*ar->what != 'C')  /* for Lua functions, use <file:line> */
     lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
+  else  /* nothing left... */
+    lua_pushliteral(L, "?");
 }
 
 
@@ -150,33 +159,49 @@
 ** =======================================================
 */
 
-LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+LUALIB_API int luaL_argerror (lua_State *L, int arg, const char *extramsg) {
   lua_Debug ar;
   if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
-    return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
+#if	!(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
+    return
+#endif
+    luaL_error(L, "bad argument #%d (%s)", arg, extramsg);
   lua_getinfo(L, "n", &ar);
   if (strcmp(ar.namewhat, "method") == 0) {
-    narg--;  /* do not count `self' */
-    if (narg == 0)  /* error is in the self argument itself? */
-      return luaL_error(L, "calling " LUA_QS " on bad self (%s)",
+    arg--;  /* do not count 'self' */
+    if (arg == 0)  /* error is in the self argument itself? */
+#if	!(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
+      return
+#endif
+      luaL_error(L, "calling '%s' on bad self (%s)",
                            ar.name, extramsg);
   }
   if (ar.name == NULL)
     ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : "?";
-  return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
-                        narg, ar.name, extramsg);
+#if	!(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
+  return
+#endif
+  luaL_error(L, "bad argument #%d to '%s' (%s)",
+                        arg, ar.name, extramsg);
 }
 
 
-static int typeerror (lua_State *L, int narg, const char *tname) {
-  const char *msg = lua_pushfstring(L, "%s expected, got %s",
-                                    tname, luaL_typename(L, narg));
-  return luaL_argerror(L, narg, msg);
+static int typeerror (lua_State *L, int arg, const char *tname) {
+  const char *msg;
+  const char *typearg;  /* name for the type of the actual argument */
+  if (luaL_getmetafield(L, arg, "__name") == LUA_TSTRING)
+    typearg = lua_tostring(L, -1);  /* use the given type name */
+  else if (lua_type(L, arg) == LUA_TLIGHTUSERDATA)
+    typearg = "light userdata";  /* special name for messages */
+  else
+    typearg = luaL_typename(L, arg);  /* standard name */
+  msg = lua_pushfstring(L, "%s expected, got %s", tname, typearg);
+  return luaL_argerror(L, arg, msg);
 }
 
 
-static void tag_error (lua_State *L, int narg, int tag) {
-  typeerror(L, narg, lua_typename(L, tag));
+static void tag_error (lua_State *L, int arg, int tag) {
+  typeerror(L, arg, lua_typename(L, tag));
 }
 
 
@@ -200,7 +225,10 @@
   lua_pushvfstring(L, fmt, argp);
   va_end(argp);
   lua_concat(L, 2);
-  return lua_error(L);
+#if	!(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
+  return
+#endif
+  lua_error(L);
 }
 
 
@@ -222,7 +250,7 @@
 }
 
 
-#if !defined(inspectstat)	/* { */
+#if !defined(l_inspectstat)	/* { */
 
 #if defined(LUA_USE_POSIX)
 
@@ -231,13 +259,13 @@
 /*
 ** use appropriate macros to interpret 'pclose' return status
 */
-#define inspectstat(stat,what)  \
+#define l_inspectstat(stat,what)  \
    if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \
    else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }
 
 #else
 
-#define inspectstat(stat,what)  /* no op */
+#define l_inspectstat(stat,what)  /* no op */
 
 #endif
 
@@ -249,7 +277,7 @@
   if (stat == -1)  /* error? */
     return luaL_fileresult(L, 0, NULL);
   else {
-    inspectstat(stat, what);  /* interpret result */
+    l_inspectstat(stat, what);  /* interpret result */
     if (*what == 'e' && stat == 0)  /* successful termination? */
       lua_pushboolean(L, 1);
     else
@@ -270,11 +298,12 @@
 */
 
 LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
-  luaL_getmetatable(L, tname);  /* try to get metatable */
-  if (!lua_isnil(L, -1))  /* name already in use? */
+  if (luaL_getmetatable(L, tname))  /* name already in use? */
     return 0;  /* leave previous value on top, but return 0 */
   lua_pop(L, 1);
   lua_newtable(L);  /* create metatable */
+  lua_pushstring(L, tname);
+  lua_setfield(L, -2, "__name");  /* metatable.__name = tname */
   lua_pushvalue(L, -1);
   lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
   return 1;
@@ -317,16 +346,16 @@
 ** =======================================================
 */
 
-LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
+LUALIB_API int luaL_checkoption (lua_State *L, int arg, const char *def,
                                  const char *const lst[]) {
-  const char *name = (def) ? luaL_optstring(L, narg, def) :
-                             luaL_checkstring(L, narg);
+  const char *name = (def) ? luaL_optstring(L, arg, def) :
+                             luaL_checkstring(L, arg);
   int i;
   for (i=0; lst[i]; i++)
     if (strcmp(lst[i], name) == 0)
       return i;
-  return luaL_argerror(L, narg,
-                       lua_pushfstring(L, "invalid option " LUA_QS, name));
+  return luaL_argerror(L, arg,
+                       lua_pushfstring(L, "invalid option '%s'", name));
 }
 
 
@@ -342,77 +371,71 @@
 }
 
 
-LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
-  if (lua_type(L, narg) != t)
-    tag_error(L, narg, t);
+LUALIB_API void luaL_checktype (lua_State *L, int arg, int t) {
+  if (lua_type(L, arg) != t)
+    tag_error(L, arg, t);
 }
 
 
-LUALIB_API void luaL_checkany (lua_State *L, int narg) {
-  if (lua_type(L, narg) == LUA_TNONE)
-    luaL_argerror(L, narg, "value expected");
+LUALIB_API void luaL_checkany (lua_State *L, int arg) {
+  if (lua_type(L, arg) == LUA_TNONE)
+    luaL_argerror(L, arg, "value expected");
 }
 
 
-LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
-  const char *s = lua_tolstring(L, narg, len);
-  if (!s) tag_error(L, narg, LUA_TSTRING);
+LUALIB_API const char *luaL_checklstring (lua_State *L, int arg, size_t *len) {
+  const char *s = lua_tolstring(L, arg, len);
+  if (!s) tag_error(L, arg, LUA_TSTRING);
   return s;
 }
 
 
-LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+LUALIB_API const char *luaL_optlstring (lua_State *L, int arg,
                                         const char *def, size_t *len) {
-  if (lua_isnoneornil(L, narg)) {
+  if (lua_isnoneornil(L, arg)) {
     if (len)
       *len = (def ? strlen(def) : 0);
     return def;
   }
-  else return luaL_checklstring(L, narg, len);
+  else return luaL_checklstring(L, arg, len);
 }
 
 
-LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int arg) {
   int isnum;
-  lua_Number d = lua_tonumberx(L, narg, &isnum);
+  lua_Number d = lua_tonumberx(L, arg, &isnum);
   if (!isnum)
-    tag_error(L, narg, LUA_TNUMBER);
+    tag_error(L, arg, LUA_TNUMBER);
   return d;
 }
 
 
-LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
-  return luaL_opt(L, luaL_checknumber, narg, def);
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number def) {
+  return luaL_opt(L, luaL_checknumber, arg, def);
 }
 
 
-LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
-  int isnum;
-  lua_Integer d = lua_tointegerx(L, narg, &isnum);
-  if (!isnum)
-    tag_error(L, narg, LUA_TNUMBER);
-  return d;
+static void interror (lua_State *L, int arg) {
+  if (lua_isnumber(L, arg))
+    luaL_argerror(L, arg, "number has no integer representation");
+  else
+    tag_error(L, arg, LUA_TNUMBER);
 }
 
 
-LUALIB_API lua_Unsigned luaL_checkunsigned (lua_State *L, int narg) {
+LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int arg) {
   int isnum;
-  lua_Unsigned d = lua_tounsignedx(L, narg, &isnum);
-  if (!isnum)
-    tag_error(L, narg, LUA_TNUMBER);
+  lua_Integer d = lua_tointegerx(L, arg, &isnum);
+  if (!isnum) {
+    interror(L, arg);
+  }
   return d;
 }
 
 
-LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
+LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int arg,
                                                       lua_Integer def) {
-  return luaL_opt(L, luaL_checkinteger, narg, def);
-}
-
-
-LUALIB_API lua_Unsigned luaL_optunsigned (lua_State *L, int narg,
-                                                        lua_Unsigned def) {
-  return luaL_opt(L, luaL_checkunsigned, narg, def);
+  return luaL_opt(L, luaL_checkinteger, arg, def);
 }
 
 /* }====================================================== */
@@ -523,7 +546,7 @@
   int ref;
   if (lua_isnil(L, -1)) {
     lua_pop(L, 1);  /* remove from stack */
-    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+    return LUA_REFNIL;  /* 'nil' has a unique fixed reference */
   }
   t = lua_absindex(L, t);
   lua_rawgeti(L, t, freelist);  /* get first free element */
@@ -562,7 +585,7 @@
 typedef struct LoadF {
   int n;  /* number of pre-read characters */
   FILE *f;  /* file being read */
-  char buff[LUAL_BUFFERSIZE];  /* area for reading file */
+  char buff[BUFSIZ];  /* area for reading file */
 } LoadF;
 
 
@@ -655,7 +678,7 @@
   readstatus = ferror(lf.f);
   if (filename) fclose(lf.f);  /* close file (even in case of errors) */
   if (readstatus) {
-    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
     return errfile(L, "read", fnameindex);
   }
   lua_remove(L, fnameindex);
@@ -698,23 +721,23 @@
 
 LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
   if (!lua_getmetatable(L, obj))  /* no metatable? */
-    return 0;
-  lua_pushstring(L, event);
-  lua_rawget(L, -2);
-  if (lua_isnil(L, -1)) {
-    lua_pop(L, 2);  /* remove metatable and metafield */
-    return 0;
-  }
+    return LUA_TNIL;
   else {
-    lua_remove(L, -2);  /* remove only metatable */
-    return 1;
+    int tt;
+    lua_pushstring(L, event);
+    tt = lua_rawget(L, -2);
+    if (tt == LUA_TNIL)  /* is metafield nil? */
+      lua_pop(L, 2);  /* remove metatable and metafield */
+    else
+      lua_remove(L, -2);  /* remove only metatable */
+    return tt;  /* return metafield type */
   }
 }
 
 
 LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
   obj = lua_absindex(L, obj);
-  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+  if (luaL_getmetafield(L, obj, event) == LUA_TNIL)  /* no metafield? */
     return 0;
   lua_pushvalue(L, obj);
   lua_call(L, 1, 1);
@@ -722,13 +745,13 @@
 }
 
 
-LUALIB_API int luaL_len (lua_State *L, int idx) {
-  int l;
+LUALIB_API lua_Integer luaL_len (lua_State *L, int idx) {
+  lua_Integer l;
   int isnum;
   lua_len(L, idx);
-  l = (int)lua_tointegerx(L, -1, &isnum);
+  l = lua_tointegerx(L, -1, &isnum);
   if (!isnum)
-    luaL_error(L, "object length is not a number");
+    luaL_error(L, "object length is not an integer");
   lua_pop(L, 1);  /* remove object */
   return l;
 }
@@ -737,7 +760,13 @@
 LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
   if (!luaL_callmeta(L, idx, "__tostring")) {  /* no metafield? */
     switch (lua_type(L, idx)) {
-      case LUA_TNUMBER:
+      case LUA_TNUMBER: {
+        if (lua_isinteger(L, idx))
+          lua_pushfstring(L, "%I", lua_tointeger(L, idx));
+        else
+          lua_pushfstring(L, "%f", lua_tonumber(L, idx));
+        break;
+      }
       case LUA_TSTRING:
         lua_pushvalue(L, idx);
         break;
@@ -772,8 +801,7 @@
     e = strchr(fname, '.');
     if (e == NULL) e = fname + strlen(fname);
     lua_pushlstring(L, fname, e - fname);
-    lua_rawget(L, -2);
-    if (lua_isnil(L, -1)) {  /* no such field? */
+    if (lua_rawget(L, -2) == LUA_TNIL) {  /* no such field? */
       lua_pop(L, 1);  /* remove this nil */
       lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
       lua_pushlstring(L, fname, e - fname);
@@ -810,13 +838,12 @@
 LUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,
                                  int sizehint) {
   luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 1);  /* get _LOADED table */
-  lua_getfield(L, -1, modname);  /* get _LOADED[modname] */
-  if (!lua_istable(L, -1)) {  /* not found? */
+  if (lua_getfield(L, -1, modname) != LUA_TTABLE) {  /* no _LOADED[modname]? */
     lua_pop(L, 1);  /* remove previous result */
     /* try global variable (and create one if it does not exist) */
     lua_pushglobaltable(L);
     if (luaL_findtable(L, 0, modname, sizehint) != NULL)
-      luaL_error(L, "name conflict for module " LUA_QS, modname);
+      luaL_error(L, "name conflict for module '%s'", modname);
     lua_pushvalue(L, -1);
     lua_setfield(L, -3, modname);  /* _LOADED[modname] = new table */
   }
@@ -846,7 +873,6 @@
 ** Returns with only the table at the stack.
 */
 LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
-  luaL_checkversion(L);
   luaL_checkstack(L, nup, "too many upvalues");
   for (; l->name != NULL; l++) {  /* fill the table with given functions */
     int i;
@@ -864,8 +890,8 @@
 ** into the stack
 */
 LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
-  lua_getfield(L, idx, fname);
-  if (lua_istable(L, -1)) return 1;  /* table already there */
+  if (lua_getfield(L, idx, fname) == LUA_TTABLE)
+    return 1;  /* table already there */
   else {
     lua_pop(L, 1);  /* remove previous result */
     idx = lua_absindex(L, idx);
@@ -878,22 +904,26 @@
 
 
 /*
-** stripped-down 'require'. Calls 'openf' to open a module,
-** registers the result in 'package.loaded' table and, if 'glb'
-** is true, also registers the result in the global table.
+** Stripped-down 'require': After checking "loaded" table, calls 'openf'
+** to open a module, registers the result in 'package.loaded' table and,
+** if 'glb' is true, also registers the result in the global table.
 ** Leaves resulting module on the top.
 */
 LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
                                lua_CFunction openf, int glb) {
-  lua_pushcfunction(L, openf);
-  lua_pushstring(L, modname);  /* argument to open function */
-  lua_call(L, 1, 1);  /* open module */
   luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
-  lua_pushvalue(L, -2);  /* make copy of module (call result) */
-  lua_setfield(L, -2, modname);  /* _LOADED[modname] = module */
-  lua_pop(L, 1);  /* remove _LOADED table */
+  lua_getfield(L, -1, modname);  /* _LOADED[modname] */
+  if (!lua_toboolean(L, -1)) {  /* package not already loaded? */
+    lua_pop(L, 1);  /* remove field */
+    lua_pushcfunction(L, openf);
+    lua_pushstring(L, modname);  /* argument to open function */
+    lua_call(L, 1, 1);  /* call 'openf' to open module */
+    lua_pushvalue(L, -1);  /* make copy of module (call result) */
+    lua_setfield(L, -3, modname);  /* _LOADED[modname] = module */
+  }
+  lua_remove(L, -2);  /* remove _LOADED table */
   if (glb) {
-    lua_pushvalue(L, -1);  /* copy of 'mod' */
+    lua_pushvalue(L, -1);  /* copy of module */
     lua_setglobal(L, modname);  /* _G[modname] = module */
   }
 }
@@ -908,7 +938,7 @@
   while ((wild = strstr(s, p)) != NULL) {
     luaL_addlstring(&b, s, wild - s);  /* push prefix */
     luaL_addstring(&b, r);  /* push replacement in place of pattern */
-    s = wild + l;  /* continue after `p' */
+    s = wild + l;  /* continue after 'p' */
   }
   luaL_addstring(&b, s);  /* push last suffix */
   luaL_pushresult(&b);
@@ -928,8 +958,8 @@
 
 
 static int panic (lua_State *L) {
-  luai_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
-                   lua_tostring(L, -1));
+  lua_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
+                        lua_tostring(L, -1));
   return 0;  /* return to Lua to abort */
 }
 
@@ -941,19 +971,14 @@
 }
 
 
-LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver) {
+LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver, size_t sz) {
   const lua_Number *v = lua_version(L);
+  if (sz != LUAL_NUMSIZES)  /* check numeric types */
+    luaL_error(L, "core and library have incompatible numeric types");
   if (v != lua_version(NULL))
     luaL_error(L, "multiple Lua VMs detected");
   else if (*v != ver)
     luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
                   ver, *v);
-  /* check conversions number -> integer types */
-  lua_pushnumber(L, -(lua_Number)0x1234);
-  if (lua_tointeger(L, -1) != -0x1234 ||
-      lua_tounsigned(L, -1) != (lua_Unsigned)-0x1234)
-    luaL_error(L, "bad conversion number->int;"
-                  " must recompile Lua with proper settings");
-  lua_pop(L, 1);
 }
 
diff -urN rpm-5.4.15/lua/lauxlib.h rpm-5.4-cvs/lua/lauxlib.h
--- rpm-5.4.15/lua/lauxlib.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lauxlib.h	2015-04-18 23:34:17.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lauxlib.h,v 1.120 2011/11/29 15:55:08 roberto Exp $
+** $Id: lauxlib.h,v 1.128 2014/10/29 16:11:17 roberto Exp $
 ** Auxiliary functions for building Lua libraries
 ** See Copyright Notice in lua.h
 */
@@ -16,7 +16,7 @@
 
 
 
-/* extra error code for `luaL_load' */
+/* extra error code for 'luaL_load' */
 #define LUA_ERRFILE     (LUA_ERRERR+1)
 
 
@@ -26,30 +26,31 @@
 } luaL_Reg;
 
 
-LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver);
-#define luaL_checkversion(L)	luaL_checkversion_(L, LUA_VERSION_NUM)
+#define LUAL_NUMSIZES	(sizeof(lua_Integer)*16 + sizeof(lua_Number))
+
+LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);
+#define luaL_checkversion(L)  \
+	  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)
 
 LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
 LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
 LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
-LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
-LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
+LUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg)
+	LUA_GNUC_NORETURN;
+LUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,
                                                           size_t *l);
-LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
+LUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,
                                           const char *def, size_t *l);
-LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
-LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);
+LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);
+LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);
 
-LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
-LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
+LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);
+LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,
                                           lua_Integer def);
-LUALIB_API lua_Unsigned (luaL_checkunsigned) (lua_State *L, int numArg);
-LUALIB_API lua_Unsigned (luaL_optunsigned) (lua_State *L, int numArg,
-                                            lua_Unsigned def);
 
 LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
-LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
-LUALIB_API void (luaL_checkany) (lua_State *L, int narg);
+LUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);
+LUALIB_API void (luaL_checkany) (lua_State *L, int arg);
 
 LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
 LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
@@ -57,9 +58,10 @@
 LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);
 
 LUALIB_API void (luaL_where) (lua_State *L, int lvl);
-LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);
+LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...)
+	LUA_GNUC_NORETURN;
 
-LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
+LUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,
                                    const char *const lst[]);
 
 LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
@@ -83,7 +85,7 @@
 
 LUALIB_API lua_State *(luaL_newstate) (void);
 
-LUALIB_API int (luaL_len) (lua_State *L, int idx);
+LUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);
 
 LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                   const char *r);
@@ -108,16 +110,13 @@
 #define luaL_newlibtable(L,l)	\
   lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)
 
-#define luaL_newlib(L,l)	(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
+#define luaL_newlib(L,l)  \
+  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
 
-#define luaL_argcheck(L, cond,numarg,extramsg)	\
-		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
+#define luaL_argcheck(L, cond,arg,extramsg)	\
+		((void)((cond) || luaL_argerror(L, (arg), (extramsg))))
 #define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
 #define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
-#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
-#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
-#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
-#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))
 
 #define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))
 
@@ -207,6 +206,53 @@
 #endif
 
 
+/*
+** {==================================================================
+** "Abstraction Layer" for basic report of messages and errors
+** ===================================================================
+*/
+
+/* print a string */
+#if !defined(lua_writestring)
+#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)
+#endif
+
+/* print a newline and flush the output */
+#if !defined(lua_writeline)
+#define lua_writeline()        (lua_writestring("\n", 1), fflush(stdout))
+#endif
+
+/* print an error message */
+#if !defined(lua_writestringerror)
+#define lua_writestringerror(s,p) \
+        (fprintf(stderr, (s), (p)), fflush(stderr))
+#endif
+
+/* }================================================================== */
+
+
+/*
+** {============================================================
+** Compatibility with deprecated conversions
+** =============================================================
+*/
+#if defined(LUA_COMPAT_APIINTCASTS)
+
+#define luaL_checkunsigned(L,a)	((lua_Unsigned)luaL_checkinteger(L,a))
+#define luaL_optunsigned(L,a,d)	\
+	((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))
+
+#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
+#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
+
+#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
+#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))
+
+#endif
+/* }============================================================ */
+
+
+
 #endif
 
 
diff -urN rpm-5.4.15/lua/lbaselib.c rpm-5.4-cvs/lua/lbaselib.c
--- rpm-5.4.15/lua/lbaselib.c	2014-07-31 17:26:16.000000000 -0500
+++ rpm-5.4-cvs/lua/lbaselib.c	2015-04-18 23:34:17.000000000 -0500
@@ -1,9 +1,13 @@
 /*
-** $Id: lbaselib.c,v 1.276 2013/02/21 13:44:53 roberto Exp $
+** $Id: lbaselib.c,v 1.309 2014/12/10 12:26:42 roberto Exp $
 ** Basic library
 ** See Copyright Notice in lua.h
 */
 
+#define lbaselib_c
+#define LUA_LIB
+
+#include "lprefix.h"
 
 
 #include <ctype.h>
@@ -11,9 +15,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define lbaselib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
@@ -32,62 +33,74 @@
     lua_call(L, 1, 1);
     s = lua_tolstring(L, -1, &l);  /* get result */
     if (s == NULL)
-      return luaL_error(L,
-         LUA_QL("tostring") " must return a string to " LUA_QL("print"));
-    if (i>1) luai_writestring("\t", 1);
-    luai_writestring(s, l);
+      return luaL_error(L, "'tostring' must return a string to 'print'");
+    if (i>1) lua_writestring("\t", 1);
+    lua_writestring(s, l);
     lua_pop(L, 1);  /* pop result */
   }
-  luai_writeline();
+  lua_writeline();
   return 0;
 }
 
 
 #define SPACECHARS	" \f\n\r\t\v"
 
+static const char *b_str2int (const char *s, int base, lua_Integer *pn) {
+  lua_Unsigned n = 0;
+  int neg = 0;
+  s += strspn(s, SPACECHARS);  /* skip initial spaces */
+  if (*s == '-') { s++; neg = 1; }  /* handle signal */
+  else if (*s == '+') s++;
+  if (!isalnum((unsigned char)*s))  /* no digit? */
+    return NULL;
+  do {
+    int digit = (isdigit((unsigned char)*s)) ? *s - '0'
+                   : toupper((unsigned char)*s) - 'A' + 10;
+    if (digit >= base) return NULL;  /* invalid numeral */
+    n = n * base + digit;
+    s++;
+  } while (isalnum((unsigned char)*s));
+  s += strspn(s, SPACECHARS);  /* skip trailing spaces */
+  *pn = (lua_Integer)((neg) ? (0u - n) : n);
+  return s;
+}
+
+
 static int luaB_tonumber (lua_State *L) {
-  if (lua_isnoneornil(L, 2)) {  /* standard conversion */
-    int isnum;
-    lua_Number n = lua_tonumberx(L, 1, &isnum);
-    if (isnum) {
-      lua_pushnumber(L, n);
-      return 1;
-    }  /* else not a number; must be something */
+  if (lua_isnoneornil(L, 2)) {  /* standard conversion? */
     luaL_checkany(L, 1);
+    if (lua_type(L, 1) == LUA_TNUMBER) {  /* already a number? */
+      lua_settop(L, 1);  /* yes; return it */
+      return 1;
+    }
+    else {
+      size_t l;
+      const char *s = lua_tolstring(L, 1, &l);
+      if (s != NULL && lua_stringtonumber(L, s) == l + 1)
+        return 1;  /* successful conversion to number */
+      /* else not a number */
+    }
   }
   else {
     size_t l;
-    const char *s = luaL_checklstring(L, 1, &l);
-    const char *e = s + l;  /* end point for 's' */
-    int base = luaL_checkint(L, 2);
-    int neg = 0;
+    const char *s;
+    lua_Integer n = 0;  /* to avoid warnings */
+    lua_Integer base = luaL_checkinteger(L, 2);
+    luaL_checktype(L, 1, LUA_TSTRING);  /* before 'luaL_checklstring'! */
+    s = luaL_checklstring(L, 1, &l);
     luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
-    s += strspn(s, SPACECHARS);  /* skip initial spaces */
-    if (*s == '-') { s++; neg = 1; }  /* handle signal */
-    else if (*s == '+') s++;
-    if (isalnum((unsigned char)*s)) {
-      lua_Number n = 0;
-      do {
-        int digit = (isdigit((unsigned char)*s)) ? *s - '0'
-                       : toupper((unsigned char)*s) - 'A' + 10;
-        if (digit >= base) break;  /* invalid numeral; force a fail */
-        n = n * (lua_Number)base + (lua_Number)digit;
-        s++;
-      } while (isalnum((unsigned char)*s));
-      s += strspn(s, SPACECHARS);  /* skip trailing spaces */
-      if (s == e) {  /* no invalid trailing characters? */
-        lua_pushnumber(L, (neg) ? -n : n);
-        return 1;
-      }  /* else not a number */
+    if (b_str2int(s, (int)base, &n) == s + l) {
+      lua_pushinteger(L, n);
+      return 1;
     }  /* else not a number */
-  }
+  }  /* else not a number */
   lua_pushnil(L);  /* not a number */
   return 1;
 }
 
 
 static int luaB_error (lua_State *L) {
-  int level = luaL_optint(L, 2, 1);
+  int level = (int)luaL_optinteger(L, 2, 1);
   lua_settop(L, 1);
   if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */
     luaL_where(L, level);
@@ -114,7 +127,7 @@
   luaL_checktype(L, 1, LUA_TTABLE);
   luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
                     "nil or table expected");
-  if (luaL_getmetafield(L, 1, "__metatable"))
+  if (luaL_getmetafield(L, 1, "__metatable") != LUA_TNIL)
     return luaL_error(L, "cannot change a protected metatable");
   lua_settop(L, 2);
   lua_setmetatable(L, 1);
@@ -160,19 +173,18 @@
 static int luaB_collectgarbage (lua_State *L) {
   static const char *const opts[] = {"stop", "restart", "collect",
     "count", "step", "setpause", "setstepmul",
-    "setmajorinc", "isrunning", "generational", "incremental", NULL};
+    "isrunning", NULL};
   static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
     LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
-    LUA_GCSETMAJORINC, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};
+    LUA_GCISRUNNING};
   int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
-  int ex = luaL_optint(L, 2, 0);
+  int ex = (int)luaL_optinteger(L, 2, 0);
   int res = lua_gc(L, o, ex);
   switch (o) {
     case LUA_GCCOUNT: {
       int b = lua_gc(L, LUA_GCCOUNTB, 0);
-      lua_pushnumber(L, res + ((lua_Number)b/1024));
-      lua_pushinteger(L, b);
-      return 2;
+      lua_pushnumber(L, (lua_Number)res + ((lua_Number)b/1024));
+      return 1;
     }
     case LUA_GCSTEP: case LUA_GCISRUNNING: {
       lua_pushboolean(L, res);
@@ -186,16 +198,19 @@
 }
 
 
+/*
+** This function has all type names as upvalues, to maximize performance.
+*/
 static int luaB_type (lua_State *L) {
   luaL_checkany(L, 1);
-  lua_pushstring(L, luaL_typename(L, 1));
+  lua_pushvalue(L, lua_upvalueindex(lua_type(L, 1) + 1));
   return 1;
 }
 
 
 static int pairsmeta (lua_State *L, const char *method, int iszero,
                       lua_CFunction iter) {
-  if (!luaL_getmetafield(L, 1, method)) {  /* no metamethod? */
+  if (luaL_getmetafield(L, 1, method) == LUA_TNIL) {  /* no metamethod? */
     luaL_checktype(L, 1, LUA_TTABLE);  /* argument must be a table */
     lua_pushcfunction(L, iter);  /* will return generator, */
     lua_pushvalue(L, 1);  /* state, */
@@ -227,18 +242,44 @@
 }
 
 
-static int ipairsaux (lua_State *L) {
-  int i = luaL_checkint(L, 2);
+/*
+** Traversal function for 'ipairs' for raw tables
+*/
+static int ipairsaux_raw (lua_State *L) {
+  lua_Integer i = luaL_checkinteger(L, 2) + 1;
   luaL_checktype(L, 1, LUA_TTABLE);
-  i++;  /* next value */
   lua_pushinteger(L, i);
-  lua_rawgeti(L, 1, i);
-  return (lua_isnil(L, -1)) ? 1 : 2;
+  return (lua_rawgeti(L, 1, i) == LUA_TNIL) ? 1 : 2;
 }
 
 
+/*
+** Traversal function for 'ipairs' for tables with metamethods
+*/
+static int ipairsaux (lua_State *L) {
+  lua_Integer i = luaL_checkinteger(L, 2) + 1;
+  lua_pushinteger(L, i);
+  return (lua_geti(L, 1, i) == LUA_TNIL) ? 1 : 2;
+}
+
+
+/*
+** This function will use either 'ipairsaux' or 'ipairsaux_raw' to
+** traverse a table, depending on whether the table has metamethods
+** that can affect the traversal.
+*/
 static int luaB_ipairs (lua_State *L) {
-  return pairsmeta(L, "__ipairs", 1, ipairsaux);
+  lua_CFunction iter = (luaL_getmetafield(L, 1, "__index") != LUA_TNIL)
+                       ? ipairsaux : ipairsaux_raw;
+#if defined(LUA_COMPAT_IPAIRS)
+  return pairsmeta(L, "__ipairs", 1, iter);
+#else
+  luaL_checkany(L, 1);
+  lua_pushcfunction(L, iter);  /* iteration function */
+  lua_pushvalue(L, 1);  /* state */
+  lua_pushinteger(L, 0);  /* initial value */
+  return 3;
+#endif
 }
 
 
@@ -284,7 +325,7 @@
 
 
 /*
-** Reader for generic `load' function: `lua_load' uses the
+** Reader for generic 'load' function: 'lua_load' uses the
 ** stack for internal stuff, so the reader cannot change the
 ** stack top. Instead, it keeps its resulting string in a
 ** reserved slot inside the stack.
@@ -328,7 +369,8 @@
 /* }====================================================== */
 
 
-static int dofilecont (lua_State *L) {
+static int dofilecont (lua_State *L, int d1, lua_KContext d2) {
+  (void)d1;  (void)d2;  /* only to match 'lua_Kfunction' prototype */
   return lua_gettop(L) - 1;
 }
 
@@ -339,14 +381,20 @@
   if (luaL_loadfile(L, fname) != LUA_OK)
     return lua_error(L);
   lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
-  return dofilecont(L);
+  return dofilecont(L, 0, 0);
 }
 
 
 static int luaB_assert (lua_State *L) {
-  if (!lua_toboolean(L, 1))
-    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
-  return lua_gettop(L);
+  if (lua_toboolean(L, 1))  /* condition is true? */
+    return lua_gettop(L);  /* return all arguments */
+  else {  /* error */
+    luaL_checkany(L, 1);  /* there must be a condition */
+    lua_remove(L, 1);  /* remove it */
+    lua_pushliteral(L, "assertion failed!");  /* default message */
+    lua_settop(L, 1);  /* leave only message (default if no other one) */
+    return luaB_error(L);  /* call 'error' */
+  }
 }
 
 
@@ -357,53 +405,57 @@
     return 1;
   }
   else {
-    int i = luaL_checkint(L, 1);
+    lua_Integer i = luaL_checkinteger(L, 1);
     if (i < 0) i = n + i;
     else if (i > n) i = n;
     luaL_argcheck(L, 1 <= i, 1, "index out of range");
-    return n - i;
+    return n - (int)i;
   }
 }
 
 
-static int finishpcall (lua_State *L, int status) {
-  if (!lua_checkstack(L, 1)) {  /* no space for extra boolean? */
-    lua_settop(L, 0);  /* create space for return values */
-    lua_pushboolean(L, 0);
-    lua_pushstring(L, "stack overflow");
+/*
+** Continuation function for 'pcall' and 'xpcall'. Both functions
+** already pushed a 'true' before doing the call, so in case of success
+** 'finishpcall' only has to return everything in the stack minus
+** 'extra' values (where 'extra' is exactly the number of items to be
+** ignored).
+*/
+static int finishpcall (lua_State *L, int status, lua_KContext extra) {
+  if (status != LUA_OK && status != LUA_YIELD) {  /* error? */
+    lua_pushboolean(L, 0);  /* first result (false) */
+    lua_pushvalue(L, -2);  /* error message */
     return 2;  /* return false, msg */
   }
-  lua_pushboolean(L, status);  /* first result (status) */
-  lua_replace(L, 1);  /* put first result in first slot */
-  return lua_gettop(L);
-}
-
-
-static int pcallcont (lua_State *L) {
-  int status = lua_getctx(L, NULL);
-  return finishpcall(L, (status == LUA_YIELD));
+  else
+    return lua_gettop(L) - (int)extra;  /* return all results */
 }
 
 
 static int luaB_pcall (lua_State *L) {
   int status;
   luaL_checkany(L, 1);
-  lua_pushnil(L);
-  lua_insert(L, 1);  /* create space for status result */
-  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, pcallcont);
-  return finishpcall(L, (status == LUA_OK));
+  lua_pushboolean(L, 1);  /* first result if no errors */
+  lua_insert(L, 1);  /* put it in place */
+  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);
+  return finishpcall(L, status, 0);
 }
 
 
+/*
+** Do a protected call with error handling. After 'lua_rotate', the
+** stack will have <f, err, true, f, [args...]>; so, the function passes
+** 2 to 'finishpcall' to skip the 2 first values when returning results.
+*/
 static int luaB_xpcall (lua_State *L) {
   int status;
   int n = lua_gettop(L);
-  luaL_argcheck(L, n >= 2, 2, "value expected");
-  lua_pushvalue(L, 1);  /* exchange function... */
-  lua_copy(L, 2, 1);  /* ...and error handler */
-  lua_replace(L, 2);
-  status = lua_pcallk(L, n - 2, LUA_MULTRET, 1, 0, pcallcont);
-  return finishpcall(L, (status == LUA_OK));
+  luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */
+  lua_pushboolean(L, 1);  /* first result */
+  lua_pushvalue(L, 1);  /* function */
+  lua_rotate(L, 3, 2);  /* move them below function's arguments */
+  status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);
+  return finishpcall(L, status, 2);
 }
 
 
@@ -438,21 +490,31 @@
   {"setmetatable", luaB_setmetatable},
   {"tonumber", luaB_tonumber},
   {"tostring", luaB_tostring},
-  {"type", luaB_type},
   {"xpcall", luaB_xpcall},
+  /* placeholders */
+  {"type", NULL},
+  {"_G", NULL},
+  {"_VERSION", NULL},
   {NULL, NULL}
 };
 
 
 LUAMOD_API int luaopen_base (lua_State *L) {
-  /* set global _G */
-  lua_pushglobaltable(L);
-  lua_pushglobaltable(L);
-  lua_setfield(L, -2, "_G");
+  int i;
   /* open lib into global table */
+  lua_pushglobaltable(L);
   luaL_setfuncs(L, base_funcs, 0);
+  /* set global _G */
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -2, "_G");
+  /* set global _VERSION */
   lua_pushliteral(L, LUA_VERSION);
-  lua_setfield(L, -2, "_VERSION");  /* set global _VERSION */
+  lua_setfield(L, -2, "_VERSION");
+  /* set function 'type' with proper upvalues */
+  for (i = 0; i < LUA_NUMTAGS; i++)  /* push all type names as upvalues */
+    lua_pushstring(L, lua_typename(L, i));
+  lua_pushcclosure(L, luaB_type, LUA_NUMTAGS);
+  lua_setfield(L, -2, "type");
   return 1;
 }
 
diff -urN rpm-5.4.15/lua/lbitlib.c rpm-5.4-cvs/lua/lbitlib.c
--- rpm-5.4.15/lua/lbitlib.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lbitlib.c	2015-04-18 23:34:17.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lbitlib.c,v 1.1.2.1 2013/06/29 21:03:22 jbj Exp $
+** $Id: lbitlib.c,v 1.1.2.3 2015/04/19 04:34:17 jbj Exp $
 ** Standard library for bitwise operations
 ** See Copyright Notice in lua.h
 */
@@ -7,20 +7,32 @@
 #define lbitlib_c
 #define LUA_LIB
 
+#include "lprefix.h"
+
+
 #include "lua.h"
 
 #include "lauxlib.h"
 #include "lualib.h"
 
 
+#if defined(LUA_COMPAT_BITLIB)		/* { */
+
+
 /* number of bits to consider in a number */
 #if !defined(LUA_NBITS)
 #define LUA_NBITS	32
 #endif
 
 
+/*
+** a lua_Unsigned with its first LUA_NBITS bits equal to 1. (Shift must
+** be made in two parts to avoid problems when LUA_NBITS is equal to the
+** number of bits in a lua_Unsigned.)
+*/
 #define ALLONES		(~(((~(lua_Unsigned)0) << (LUA_NBITS - 1)) << 1))
 
+
 /* macro to trim extra bits */
 #define trim(x)		((x) & ALLONES)
 
@@ -29,13 +41,10 @@
 #define mask(n)		(~((ALLONES << 1) << ((n) - 1)))
 
 
-typedef lua_Unsigned b_uint;
-
 
-
-static b_uint andaux (lua_State *L) {
+static lua_Unsigned andaux (lua_State *L) {
   int i, n = lua_gettop(L);
-  b_uint r = ~(b_uint)0;
+  lua_Unsigned r = ~(lua_Unsigned)0;
   for (i = 1; i <= n; i++)
     r &= luaL_checkunsigned(L, i);
   return trim(r);
@@ -43,14 +52,14 @@
 
 
 static int b_and (lua_State *L) {
-  b_uint r = andaux(L);
+  lua_Unsigned r = andaux(L);
   lua_pushunsigned(L, r);
   return 1;
 }
 
 
 static int b_test (lua_State *L) {
-  b_uint r = andaux(L);
+  lua_Unsigned r = andaux(L);
   lua_pushboolean(L, r != 0);
   return 1;
 }
@@ -58,7 +67,7 @@
 
 static int b_or (lua_State *L) {
   int i, n = lua_gettop(L);
-  b_uint r = 0;
+  lua_Unsigned r = 0;
   for (i = 1; i <= n; i++)
     r |= luaL_checkunsigned(L, i);
   lua_pushunsigned(L, trim(r));
@@ -68,7 +77,7 @@
 
 static int b_xor (lua_State *L) {
   int i, n = lua_gettop(L);
-  b_uint r = 0;
+  lua_Unsigned r = 0;
   for (i = 1; i <= n; i++)
     r ^= luaL_checkunsigned(L, i);
   lua_pushunsigned(L, trim(r));
@@ -77,13 +86,13 @@
 
 
 static int b_not (lua_State *L) {
-  b_uint r = ~luaL_checkunsigned(L, 1);
+  lua_Unsigned r = ~luaL_checkunsigned(L, 1);
   lua_pushunsigned(L, trim(r));
   return 1;
 }
 
 
-static int b_shift (lua_State *L, b_uint r, int i) {
+static int b_shift (lua_State *L, lua_Unsigned r, lua_Integer i) {
   if (i < 0) {  /* shift right? */
     i = -i;
     r = trim(r);
@@ -101,47 +110,48 @@
 
 
 static int b_lshift (lua_State *L) {
-  return b_shift(L, luaL_checkunsigned(L, 1), luaL_checkint(L, 2));
+  return b_shift(L, luaL_checkunsigned(L, 1), luaL_checkinteger(L, 2));
 }
 
 
 static int b_rshift (lua_State *L) {
-  return b_shift(L, luaL_checkunsigned(L, 1), -luaL_checkint(L, 2));
+  return b_shift(L, luaL_checkunsigned(L, 1), -luaL_checkinteger(L, 2));
 }
 
 
 static int b_arshift (lua_State *L) {
-  b_uint r = luaL_checkunsigned(L, 1);
-  int i = luaL_checkint(L, 2);
-  if (i < 0 || !(r & ((b_uint)1 << (LUA_NBITS - 1))))
+  lua_Unsigned r = luaL_checkunsigned(L, 1);
+  lua_Integer i = luaL_checkinteger(L, 2);
+  if (i < 0 || !(r & ((lua_Unsigned)1 << (LUA_NBITS - 1))))
     return b_shift(L, r, -i);
   else {  /* arithmetic shift for 'negative' number */
     if (i >= LUA_NBITS) r = ALLONES;
     else
-      r = trim((r >> i) | ~(~(b_uint)0 >> i));  /* add signal bit */
+      r = trim((r >> i) | ~(trim(~(lua_Unsigned)0) >> i));  /* add signal bit */
     lua_pushunsigned(L, r);
     return 1;
   }
 }
 
 
-static int b_rot (lua_State *L, int i) {
-  b_uint r = luaL_checkunsigned(L, 1);
-  i &= (LUA_NBITS - 1);  /* i = i % NBITS */
+static int b_rot (lua_State *L, lua_Integer d) {
+  lua_Unsigned r = luaL_checkunsigned(L, 1);
+  int i = d & (LUA_NBITS - 1);  /* i = d % NBITS */
   r = trim(r);
-  r = (r << i) | (r >> (LUA_NBITS - i));
+  if (i != 0)  /* avoid undefined shift of LUA_NBITS when i == 0 */
+    r = (r << i) | (r >> (LUA_NBITS - i));
   lua_pushunsigned(L, trim(r));
   return 1;
 }
 
 
 static int b_lrot (lua_State *L) {
-  return b_rot(L, luaL_checkint(L, 2));
+  return b_rot(L, luaL_checkinteger(L, 2));
 }
 
 
 static int b_rrot (lua_State *L) {
-  return b_rot(L, -luaL_checkint(L, 2));
+  return b_rot(L, -luaL_checkinteger(L, 2));
 }
 
 
@@ -152,20 +162,20 @@
 ** 'width' being used uninitialized.)
 */
 static int fieldargs (lua_State *L, int farg, int *width) {
-  int f = luaL_checkint(L, farg);
-  int w = luaL_optint(L, farg + 1, 1);
+  lua_Integer f = luaL_checkinteger(L, farg);
+  lua_Integer w = luaL_optinteger(L, farg + 1, 1);
   luaL_argcheck(L, 0 <= f, farg, "field cannot be negative");
   luaL_argcheck(L, 0 < w, farg + 1, "width must be positive");
   if (f + w > LUA_NBITS)
     luaL_error(L, "trying to access non-existent bits");
-  *width = w;
-  return f;
+  *width = (int)w;
+  return (int)f;
 }
 
 
 static int b_extract (lua_State *L) {
   int w;
-  b_uint r = luaL_checkunsigned(L, 1);
+  lua_Unsigned r = trim(luaL_checkunsigned(L, 1));
   int f = fieldargs(L, 2, &w);
   r = (r >> f) & mask(w);
   lua_pushunsigned(L, r);
@@ -175,8 +185,8 @@
 
 static int b_replace (lua_State *L) {
   int w;
-  b_uint r = luaL_checkunsigned(L, 1);
-  b_uint v = luaL_checkunsigned(L, 2);
+  lua_Unsigned r = trim(luaL_checkunsigned(L, 1));
+  lua_Unsigned v = luaL_checkunsigned(L, 2);
   int f = fieldargs(L, 3, &w);
   int m = mask(w);
   v &= m;  /* erase bits outside given width */
@@ -209,3 +219,15 @@
   return 1;
 }
 
+
+#else					/* }{ */
+
+
+LUAMOD_API int luaopen_bit32 (lua_State *L) {
+#if	!(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
+  return
+#endif
+  luaL_error(L, "library 'bit32' has been deprecated");
+}
+
+#endif					/* } */
diff -urN rpm-5.4.15/lua/lcode.c rpm-5.4-cvs/lua/lcode.c
--- rpm-5.4.15/lua/lcode.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lcode.c	2015-04-18 23:34:17.000000000 -0500
@@ -1,15 +1,18 @@
 /*
-** $Id: lcode.c,v 2.62 2012/08/16 17:34:28 roberto Exp $
+** $Id: lcode.c,v 2.99 2014/12/29 16:49:25 roberto Exp $
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */
 
-
-#include <stdlib.h>
-
 #define lcode_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <math.h>
+#include <stdlib.h>
+
 #include "lua.h"
 
 #include "lcode.h"
@@ -26,11 +29,25 @@
 #include "lvm.h"
 
 
+/* Maximum number of registers in a Lua function */
+#define MAXREGS		250
+
+
 #define hasjumps(e)	((e)->t != (e)->f)
 
 
-static int isnumeral(expdesc *e) {
-  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
+static int tonumeral(expdesc *e, TValue *v) {
+  if (e->t != NO_JUMP || e->f != NO_JUMP)
+    return 0;  /* not a numeral */
+  switch (e->k) {
+    case VKINT:
+      if (v) setivalue(v, e->u.ival);
+      return 1;
+    case VKFLT:
+      if (v) setfltvalue(v, e->u.nval);
+      return 1;
+    default: return 0;
+  }
 }
 
 
@@ -88,7 +105,7 @@
 
 
 /*
-** returns current `pc' and marks it as a jump target (to avoid wrong
+** returns current 'pc' and marks it as a jump target (to avoid wrong
 ** optimizations with consecutive instructions not in the same basic block).
 */
 int luaK_getlabel (FuncState *fs) {
@@ -119,6 +136,7 @@
 ** check whether list has any jump that do not produce a value
 ** (or produce an inverted value)
 */
+LUA_GNUC_PURE
 static int need_value (FuncState *fs, int list) {
   for (; list != NO_JUMP; list = getjump(fs, list)) {
     Instruction i = *getjumpcontrol(fs, list);
@@ -176,7 +194,7 @@
 }
 
 
-LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level) {
+void luaK_patchclose (FuncState *fs, int list, int level) {
   level++;  /* argument is +1 to reserve 0 as non-op */
   while (list != NO_JUMP) {
     int next = getjump(fs, list);
@@ -211,7 +229,7 @@
 
 static int luaK_code (FuncState *fs, Instruction i) {
   Proto *f = fs->f;
-  dischargejpc(fs);  /* `pc' will change */
+  dischargejpc(fs);  /* 'pc' will change */
   /* put new instruction in code array */
   luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
                   MAX_INT, "opcodes");
@@ -261,7 +279,7 @@
 void luaK_checkstack (FuncState *fs, int n) {
   int newstack = fs->freereg + n;
   if (newstack > fs->f->maxstacksize) {
-    if (newstack >= MAXSTACK)
+    if (newstack >= MAXREGS)
       luaX_syntaxerror(fs->ls, "function or expression too complex");
     fs->f->maxstacksize = cast_byte(newstack);
   }
@@ -288,25 +306,28 @@
 }
 
 
+/*
+** Use scanner's table to cache position of constants in constant list
+** and try to reuse constants
+*/
 static int addk (FuncState *fs, TValue *key, TValue *v) {
   lua_State *L = fs->ls->L;
-  TValue *idx = luaH_set(L, fs->h, key);
   Proto *f = fs->f;
+  TValue *idx = luaH_set(L, fs->ls->h, key);  /* index scanner table */
   int k, oldsize;
-  if (ttisnumber(idx)) {
-    lua_Number n = nvalue(idx);
-    lua_number2int(k, n);
-    if (luaV_rawequalobj(&f->k[k], v))
-      return k;
-    /* else may be a collision (e.g., between 0.0 and "\0\0\0\0\0\0\0\0");
-       go through and create a new entry for this value */
+  if (ttisinteger(idx)) {  /* is there an index there? */
+    k = cast_int(ivalue(idx));
+    /* correct value? (warning: must distinguish floats from integers!) */
+    if (k < fs->nk && ttype(&f->k[k]) == ttype(v) &&
+                      luaV_rawequalobj(&f->k[k], v))
+      return k;  /* reuse index */
   }
   /* constant not found; create a new entry */
   oldsize = f->sizek;
   k = fs->nk;
   /* numerical value does not need GC barrier;
      table has no metatable, so it does not need to invalidate cache */
-  setnvalue(idx, cast_num(k));
+  setivalue(idx, k);
   luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
   while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
   setobj(L, &f->k[k], v);
@@ -323,20 +344,23 @@
 }
 
 
-int luaK_numberK (FuncState *fs, lua_Number r) {
-  int n;
-  lua_State *L = fs->ls->L;
+/*
+** Integers use userdata as keys to avoid collision with floats with same
+** value; conversion to 'void*' used only for hashing, no "precision"
+** problems
+*/
+int luaK_intK (FuncState *fs, lua_Integer n) {
+  TValue k, o;
+  setpvalue(&k, cast(void*, cast(size_t, n)));
+  setivalue(&o, n);
+  return addk(fs, &k, &o);
+}
+
+
+static int luaK_numberK (FuncState *fs, lua_Number r) {
   TValue o;
-  setnvalue(&o, r);
-  if (r == 0 || luai_numisnan(NULL, r)) {  /* handle -0 and NaN */
-    /* use raw representation as key to avoid numeric problems */
-    setsvalue(L, L->top++, luaS_newlstr(L, (char *)&r, sizeof(r)));
-    n = addk(fs, L->top - 1, &o);
-    L->top--;
-  }
-  else
-    n = addk(fs, &o, &o);  /* regular case */
-  return n;
+  setfltvalue(&o, r);
+  return addk(fs, &o, &o);
 }
 
 
@@ -351,7 +375,7 @@
   TValue k, v;
   setnilvalue(&v);
   /* cannot use nil as key; instead use table itself to represent nil */
-  sethvalue(fs->ls->L, &k, fs->h);
+  sethvalue(fs->ls->L, &k, fs->ls->h);
   return addk(fs, &k, &v);
 }
 
@@ -433,10 +457,14 @@
       luaK_codek(fs, reg, e->u.info);
       break;
     }
-    case VKNUM: {
+    case VKFLT: {
       luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));
       break;
     }
+    case VKINT: {
+      luaK_codek(fs, reg, luaK_intK(fs, e->u.ival));
+      break;
+    }
     case VRELOCABLE: {
       Instruction *pc = &getcode(fs, e);
       SETARG_A(*pc, reg);
@@ -468,7 +496,7 @@
 static void exp2reg (FuncState *fs, expdesc *e, int reg) {
   discharge2reg(fs, e, reg);
   if (e->k == VJMP)
-    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in `t' list */
+    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in 't' list */
   if (hasjumps(e)) {
     int final;  /* position after whole expression */
     int p_f = NO_JUMP;  /* position of an eventual LOAD false */
@@ -538,13 +566,19 @@
       }
       else break;
     }
-    case VKNUM: {
+    case VKINT: {
+      e->u.info = luaK_intK(fs, e->u.ival);
+      e->k = VK;
+      goto vk;
+    }
+    case VKFLT: {
       e->u.info = luaK_numberK(fs, e->u.nval);
       e->k = VK;
       /* go through */
     }
     case VK: {
-      if (e->u.info <= MAXINDEXRK)  /* constant fits in argC? */
+     vk:
+      if (e->u.info <= MAXINDEXRK)  /* constant fits in 'argC'? */
         return RKASK(e->u.info);
       else break;
     }
@@ -627,7 +661,7 @@
       pc = e->u.info;
       break;
     }
-    case VK: case VKNUM: case VTRUE: {
+    case VK: case VKFLT: case VKINT: case VTRUE: {
       pc = NO_JUMP;  /* always true; do nothing */
       break;
     }
@@ -636,7 +670,7 @@
       break;
     }
   }
-  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
+  luaK_concat(fs, &e->f, pc);  /* insert last jump in 'f' list */
   luaK_patchtohere(fs, e->t);
   e->t = NO_JUMP;
 }
@@ -659,7 +693,7 @@
       break;
     }
   }
-  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
+  luaK_concat(fs, &e->t, pc);  /* insert last jump in 't' list */
   luaK_patchtohere(fs, e->f);
   e->f = NO_JUMP;
 }
@@ -672,7 +706,7 @@
       e->k = VTRUE;
       break;
     }
-    case VK: case VKNUM: case VTRUE: {
+    case VK: case VKFLT: case VKINT: case VTRUE: {
       e->k = VFALSE;
       break;
     }
@@ -710,25 +744,70 @@
 }
 
 
-static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
-  lua_Number r;
-  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
-  if ((op == OP_DIV || op == OP_MOD) && e2->u.nval == 0)
-    return 0;  /* do not attempt to divide by 0 */
-  r = luaO_arith(op - OP_ADD + LUA_OPADD, e1->u.nval, e2->u.nval);
-  e1->u.nval = r;
+/*
+** return false if folding can raise an error
+*/
+static int validop (int op, TValue *v1, TValue *v2) {
+  switch (op) {
+    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
+    case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */
+      lua_Integer i;
+      return (tointeger(v1, &i) && tointeger(v2, &i));
+    }
+    case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */
+      return (nvalue(v2) != 0);
+    default: return 1;  /* everything else is valid */
+  }
+}
+
+
+/*
+** Try to "constant-fold" an operation; return 1 iff successful
+*/
+static int constfolding (FuncState *fs, int op, expdesc *e1, expdesc *e2) {
+  TValue v1, v2, res;
+  if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))
+    return 0;  /* non-numeric operands or not safe to fold */
+  luaO_arith(fs->ls->L, op, &v1, &v2, &res);  /* does operation */
+  if (ttisinteger(&res)) {
+    e1->k = VKINT;
+    e1->u.ival = ivalue(&res);
+  }
+  else {  /* folds neither NaN nor 0.0 (to avoid collapsing with -0.0) */
+    lua_Number n = fltvalue(&res);
+    if (luai_numisnan(n) || n == 0)
+      return 0;
+    e1->k = VKFLT;
+    e1->u.nval = n;
+  }
   return 1;
 }
 
 
-static void codearith (FuncState *fs, OpCode op,
-                       expdesc *e1, expdesc *e2, int line) {
-  if (constfolding(op, e1, e2))
-    return;
+/*
+** Code for binary and unary expressions that "produce values"
+** (arithmetic operations, bitwise operations, concat, length). First
+** try to do constant folding (only for numeric [arithmetic and
+** bitwise] operations, which is what 'lua_arith' accepts).
+** Expression to produce final result will be encoded in 'e1'.
+*/
+static void codeexpval (FuncState *fs, OpCode op,
+                        expdesc *e1, expdesc *e2, int line) {
+  lua_assert(op >= OP_ADD);
+  if (op <= OP_BNOT && constfolding(fs, op - OP_ADD + LUA_OPADD, e1, e2))
+    return;  /* result has been folded */
   else {
-    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
-    int o1 = luaK_exp2RK(fs, e1);
-    if (o1 > o2) {
+    int o1, o2;
+    /* move operands to registers (if needed) */
+    if (op == OP_UNM || op == OP_BNOT || op == OP_LEN) {  /* unary op? */
+      o2 = 0;  /* no second expression */
+      o1 = luaK_exp2anyreg(fs, e1);  /* cannot operate on constants */
+    }
+    else {  /* regular case (binary operators) */
+      o2 = luaK_exp2RK(fs, e2);  /* both operands are "RK" */
+      o1 = luaK_exp2RK(fs, e1);
+    }
+    if (o1 > o2) {  /* free registers in proper order */
       freeexp(fs, e1);
       freeexp(fs, e2);
     }
@@ -736,8 +815,8 @@
       freeexp(fs, e2);
       freeexp(fs, e1);
     }
-    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);
-    e1->k = VRELOCABLE;
+    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);  /* generate opcode */
+    e1->k = VRELOCABLE;  /* all those operations are relocable */
     luaK_fixline(fs, line);
   }
 }
@@ -750,7 +829,7 @@
   freeexp(fs, e2);
   freeexp(fs, e1);
   if (cond == 0 && op != OP_EQ) {
-    int temp;  /* exchange args to replace by `<' or `<=' */
+    int temp;  /* exchange args to replace by '<' or '<=' */
     temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
     cond = 1;
   }
@@ -761,23 +840,13 @@
 
 void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
   expdesc e2;
-  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
+  e2.t = e2.f = NO_JUMP; e2.k = VKINT; e2.u.ival = 0;
   switch (op) {
-    case OPR_MINUS: {
-      if (isnumeral(e))  /* minus constant? */
-        e->u.nval = luai_numunm(NULL, e->u.nval);  /* fold it */
-      else {
-        luaK_exp2anyreg(fs, e);
-        codearith(fs, OP_UNM, e, &e2, line);
-      }
+    case OPR_MINUS: case OPR_BNOT: case OPR_LEN: {
+      codeexpval(fs, cast(OpCode, (op - OPR_MINUS) + OP_UNM), e, &e2, line);
       break;
     }
     case OPR_NOT: codenot(fs, e); break;
-    case OPR_LEN: {
-      luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
-      codearith(fs, OP_LEN, e, &e2, line);
-      break;
-    }
     default: lua_assert(0);
   }
 }
@@ -794,12 +863,15 @@
       break;
     }
     case OPR_CONCAT: {
-      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      luaK_exp2nextreg(fs, v);  /* operand must be on the 'stack' */
       break;
     }
-    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
-    case OPR_MOD: case OPR_POW: {
-      if (!isnumeral(v)) luaK_exp2RK(fs, v);
+    case OPR_ADD: case OPR_SUB:
+    case OPR_MUL: case OPR_DIV: case OPR_IDIV:
+    case OPR_MOD: case OPR_POW:
+    case OPR_BAND: case OPR_BOR: case OPR_BXOR:
+    case OPR_SHL: case OPR_SHR: {
+      if (!tonumeral(v, NULL)) luaK_exp2RK(fs, v);
       break;
     }
     default: {
@@ -837,13 +909,15 @@
       }
       else {
         luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
-        codearith(fs, OP_CONCAT, e1, e2, line);
+        codeexpval(fs, OP_CONCAT, e1, e2, line);
       }
       break;
     }
     case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
-    case OPR_MOD: case OPR_POW: {
-      codearith(fs, cast(OpCode, op - OPR_ADD + OP_ADD), e1, e2, line);
+    case OPR_IDIV: case OPR_MOD: case OPR_POW:
+    case OPR_BAND: case OPR_BOR: case OPR_BXOR:
+    case OPR_SHL: case OPR_SHR: {
+      codeexpval(fs, cast(OpCode, (op - OPR_ADD) + OP_ADD), e1, e2, line);
       break;
     }
     case OPR_EQ: case OPR_LT: case OPR_LE: {
diff -urN rpm-5.4.15/lua/lcode.h rpm-5.4-cvs/lua/lcode.h
--- rpm-5.4.15/lua/lcode.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lcode.h	2015-04-18 23:34:17.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lcode.h,v 1.58 2011/08/30 16:26:41 roberto Exp $
+** $Id: lcode.h,v 1.63 2013/12/30 20:47:58 roberto Exp $
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */
@@ -24,7 +24,11 @@
 ** grep "ORDER OPR" if you change these enums  (ORDER OP)
 */
 typedef enum BinOpr {
-  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
+  OPR_ADD, OPR_SUB, OPR_MUL, OPR_MOD, OPR_POW,
+  OPR_DIV,
+  OPR_IDIV,
+  OPR_BAND, OPR_BOR, OPR_BXOR,
+  OPR_SHL, OPR_SHR,
   OPR_CONCAT,
   OPR_EQ, OPR_LT, OPR_LE,
   OPR_NE, OPR_GT, OPR_GE,
@@ -33,7 +37,7 @@
 } BinOpr;
 
 
-typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
+typedef enum UnOpr { OPR_MINUS, OPR_BNOT, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
 
 
 #define getcode(fs,e)	((fs)->f->code[(e)->u.info])
@@ -52,7 +56,7 @@
 LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
 LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
 LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
-LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
+LUAI_FUNC int luaK_intK (FuncState *fs, lua_Integer n);
 LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
 LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
 LUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);
diff -urN rpm-5.4.15/lua/lcorolib.c rpm-5.4-cvs/lua/lcorolib.c
--- rpm-5.4.15/lua/lcorolib.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lcorolib.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,15 +1,16 @@
 /*
-** $Id: lcorolib.c,v 1.1.2.1 2013/06/29 21:03:22 jbj Exp $
+** $Id: lcorolib.c,v 1.1.2.3 2015/04/19 04:34:18 jbj Exp $
 ** Coroutine Library
 ** See Copyright Notice in lua.h
 */
 
+#define lcorolib_c
+#define LUA_LIB
 
-#include <stdlib.h>
+#include "lprefix.h"
 
 
-#define lcorolib_c
-#define LUA_LIB
+#include <stdlib.h>
 
 #include "lua.h"
 
@@ -17,6 +18,13 @@
 #include "lualib.h"
 
 
+static lua_State *getco (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "thread expected");
+  return co;
+}
+
+
 static int auxresume (lua_State *L, lua_State *co, int narg) {
   int status;
   if (!lua_checkstack(co, narg)) {
@@ -47,9 +55,8 @@
 
 
 static int luaB_coresume (lua_State *L) {
-  lua_State *co = lua_tothread(L, 1);
+  lua_State *co = getco(L);
   int r;
-  luaL_argcheck(L, co, 1, "coroutine expected");
   r = auxresume(L, co, lua_gettop(L) - 1);
   if (r < 0) {
     lua_pushboolean(L, 0);
@@ -59,7 +66,7 @@
   else {
     lua_pushboolean(L, 1);
     lua_insert(L, -(r + 1));
-    return r + 1;  /* return true + `resume' returns */
+    return r + 1;  /* return true + 'resume' returns */
   }
 }
 
@@ -102,8 +109,7 @@
 
 
 static int luaB_costatus (lua_State *L) {
-  lua_State *co = lua_tothread(L, 1);
-  luaL_argcheck(L, co, 1, "coroutine expected");
+  lua_State *co = getco(L);
   if (L == co) lua_pushliteral(L, "running");
   else {
     switch (lua_status(co)) {
@@ -129,6 +135,12 @@
 }
 
 
+static int luaB_yieldable (lua_State *L) {
+  lua_pushboolean(L, lua_isyieldable(L));
+  return 1;
+}
+
+
 static int luaB_corunning (lua_State *L) {
   int ismain = lua_pushthread(L);
   lua_pushboolean(L, ismain);
@@ -143,6 +155,7 @@
   {"status", luaB_costatus},
   {"wrap", luaB_cowrap},
   {"yield", luaB_yield},
+  {"isyieldable", luaB_yieldable},
   {NULL, NULL}
 };
 
diff -urN rpm-5.4.15/lua/lctype.c rpm-5.4-cvs/lua/lctype.c
--- rpm-5.4.15/lua/lctype.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lctype.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lctype.c,v 1.1.2.1 2013/06/29 21:03:22 jbj Exp $
+** $Id: lctype.c,v 1.1.2.3 2015/04/19 04:34:18 jbj Exp $
 ** 'ctype' functions for Lua
 ** See Copyright Notice in lua.h
 */
@@ -7,6 +7,9 @@
 #define lctype_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
 #include "lctype.h"
 
 #if !LUA_USE_CTYPE	/* { */
diff -urN rpm-5.4.15/lua/lctype.h rpm-5.4-cvs/lua/lctype.h
--- rpm-5.4.15/lua/lctype.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lctype.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lctype.h,v 1.1.2.1 2013/06/29 21:03:22 jbj Exp $
+** $Id: lctype.h,v 1.1.2.3 2015/04/19 04:34:18 jbj Exp $
 ** 'ctype' functions for Lua
 ** See Copyright Notice in lua.h
 */
diff -urN rpm-5.4.15/lua/ldblib.c rpm-5.4-cvs/lua/ldblib.c
--- rpm-5.4.15/lua/ldblib.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/ldblib.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,25 +1,30 @@
 /*
-** $Id: ldblib.c,v 1.132 2012/01/19 20:14:44 roberto Exp $
+** $Id: ldblib.c,v 1.148 2015/01/02 12:52:22 roberto Exp $
 ** Interface from Lua to its debug API
 ** See Copyright Notice in lua.h
 */
 
+#define ldblib_c
+#define LUA_LIB
+
+#include "lprefix.h"
+
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define ldblib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
 #include "lualib.h"
 
 
-#define HOOKKEY		"_HKEY"
-
+/*
+** The hook table at registry[&HOOKKEY] maps threads to their current
+** hook function. (We only need the unique address of 'HOOKKEY'.)
+*/
+static const int HOOKKEY = 0;
 
 
 static int db_getregistry (lua_State *L) {
@@ -57,35 +62,20 @@
 
 
 static int db_setuservalue (lua_State *L) {
-  if (lua_type(L, 1) == LUA_TLIGHTUSERDATA)
-    luaL_argerror(L, 1, "full userdata expected, got light userdata");
   luaL_checktype(L, 1, LUA_TUSERDATA);
-  if (!lua_isnoneornil(L, 2))
-    luaL_checktype(L, 2, LUA_TTABLE);
+  luaL_checkany(L, 2);
   lua_settop(L, 2);
   lua_setuservalue(L, 1);
   return 1;
 }
 
 
-static void settabss (lua_State *L, const char *i, const char *v) {
-  lua_pushstring(L, v);
-  lua_setfield(L, -2, i);
-}
-
-
-static void settabsi (lua_State *L, const char *i, int v) {
-  lua_pushinteger(L, v);
-  lua_setfield(L, -2, i);
-}
-
-
-static void settabsb (lua_State *L, const char *i, int v) {
-  lua_pushboolean(L, v);
-  lua_setfield(L, -2, i);
-}
-
-
+/*
+** Auxiliary function used by several library functions: check for
+** an optional thread as function's first argument and set 'arg' with
+** 1 if this argument is present (so that functions can skip it to
+** access their other arguments)
+*/
 static lua_State *getthread (lua_State *L, int *arg) {
   if (lua_isthread(L, 1)) {
     *arg = 1;
@@ -93,44 +83,70 @@
   }
   else {
     *arg = 0;
-    return L;
+    return L;  /* function will operate over current thread */
   }
 }
 
 
+/*
+** Variations of 'lua_settable', used by 'db_getinfo' to put results
+** from 'lua_getinfo' into result table. Key is always a string;
+** value can be a string, an int, or a boolean.
+*/
+static void settabss (lua_State *L, const char *k, const char *v) {
+  lua_pushstring(L, v);
+  lua_setfield(L, -2, k);
+}
+
+static void settabsi (lua_State *L, const char *k, int v) {
+  lua_pushinteger(L, v);
+  lua_setfield(L, -2, k);
+}
+
+static void settabsb (lua_State *L, const char *k, int v) {
+  lua_pushboolean(L, v);
+  lua_setfield(L, -2, k);
+}
+
+
+/*
+** In function 'db_getinfo', the call to 'lua_getinfo' may push
+** results on the stack; later it creates the result table to put
+** these objects. Function 'treatstackoption' puts the result from
+** 'lua_getinfo' on top of the result table so that it can call
+** 'lua_setfield'.
+*/
 static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
-  if (L == L1) {
-    lua_pushvalue(L, -2);
-    lua_remove(L, -3);
-  }
+  if (L == L1)
+    lua_rotate(L, -2, 1);  /* exchange object and table */
   else
-    lua_xmove(L1, L, 1);
-  lua_setfield(L, -2, fname);
+    lua_xmove(L1, L, 1);  /* move object to the "main" stack */
+  lua_setfield(L, -2, fname);  /* put object into table */
 }
 
 
+/*
+** Calls 'lua_getinfo' and collects all results in a new table.
+*/
 static int db_getinfo (lua_State *L) {
   lua_Debug ar;
   int arg;
   lua_State *L1 = getthread(L, &arg);
   const char *options = luaL_optstring(L, arg+2, "flnStu");
-  if (lua_isnumber(L, arg+1)) {
-    if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), &ar)) {
+  if (lua_isfunction(L, arg + 1)) {  /* info about a function? */
+    options = lua_pushfstring(L, ">%s", options);  /* add '>' to 'options' */
+    lua_pushvalue(L, arg + 1);  /* move function to 'L1' stack */
+    lua_xmove(L, L1, 1);
+  }
+  else {  /* stack level */
+    if (!lua_getstack(L1, (int)luaL_checkinteger(L, arg + 1), &ar)) {
       lua_pushnil(L);  /* level out of range */
       return 1;
     }
   }
-  else if (lua_isfunction(L, arg+1)) {
-    lua_pushfstring(L, ">%s", options);
-    options = lua_tostring(L, -1);
-    lua_pushvalue(L, arg+1);
-    lua_xmove(L, L1, 1);
-  }
-  else
-    return luaL_argerror(L, arg+1, "function or level expected");
   if (!lua_getinfo(L1, options, &ar))
     return luaL_argerror(L, arg+2, "invalid option");
-  lua_createtable(L, 0, 2);
+  lua_newtable(L);  /* table to collect results */
   if (strchr(options, 'S')) {
     settabss(L, "source", ar.source);
     settabss(L, "short_src", ar.short_src);
@@ -164,20 +180,21 @@
   lua_State *L1 = getthread(L, &arg);
   lua_Debug ar;
   const char *name;
-  int nvar = luaL_checkint(L, arg+2);  /* local-variable index */
+  int nvar = (int)luaL_checkinteger(L, arg + 2);  /* local-variable index */
   if (lua_isfunction(L, arg + 1)) {  /* function argument? */
     lua_pushvalue(L, arg + 1);  /* push function */
     lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */
-    return 1;
+    return 1;  /* return only name (there is no value) */
   }
   else {  /* stack-level argument */
-    if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+    int level = (int)luaL_checkinteger(L, arg + 1);
+    if (!lua_getstack(L1, level, &ar))  /* out of range? */
       return luaL_argerror(L, arg+1, "level out of range");
     name = lua_getlocal(L1, &ar, nvar);
     if (name) {
-      lua_xmove(L1, L, 1);  /* push local value */
+      lua_xmove(L1, L, 1);  /* move local value */
       lua_pushstring(L, name);  /* push name */
-      lua_pushvalue(L, -2);  /* re-order */
+      lua_rotate(L, -2, 1);  /* re-order */
       return 2;
     }
     else {
@@ -190,26 +207,35 @@
 
 static int db_setlocal (lua_State *L) {
   int arg;
+  const char *name;
   lua_State *L1 = getthread(L, &arg);
   lua_Debug ar;
-  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+  int level = (int)luaL_checkinteger(L, arg + 1);
+  int nvar = (int)luaL_checkinteger(L, arg + 2);
+  if (!lua_getstack(L1, level, &ar))  /* out of range? */
     return luaL_argerror(L, arg+1, "level out of range");
   luaL_checkany(L, arg+3);
   lua_settop(L, arg+3);
   lua_xmove(L, L1, 1);
-  lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
+  name = lua_setlocal(L1, &ar, nvar);
+  if (name == NULL)
+    lua_pop(L1, 1);  /* pop value (if not popped by 'lua_setlocal') */
+  lua_pushstring(L, name);
   return 1;
 }
 
 
+/*
+** get (if 'get' is true) or set an upvalue from a closure
+*/
 static int auxupvalue (lua_State *L, int get) {
   const char *name;
-  int n = luaL_checkint(L, 2);
-  luaL_checktype(L, 1, LUA_TFUNCTION);
+  int n = (int)luaL_checkinteger(L, 2);  /* upvalue index */
+  luaL_checktype(L, 1, LUA_TFUNCTION);  /* closure */
   name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
   if (name == NULL) return 0;
   lua_pushstring(L, name);
-  lua_insert(L, -(get+1));
+  lua_insert(L, -(get+1));  /* no-op if get is false */
   return get + 1;
 }
 
@@ -225,13 +251,15 @@
 }
 
 
+/*
+** Check whether a given upvalue from a given closure exists and
+** returns its index
+*/
 static int checkupval (lua_State *L, int argf, int argnup) {
-  lua_Debug ar;
-  int nup = luaL_checkint(L, argnup);
-  luaL_checktype(L, argf, LUA_TFUNCTION);
-  lua_pushvalue(L, argf);
-  lua_getinfo(L, ">u", &ar);
-  luaL_argcheck(L, 1 <= nup && nup <= ar.nups, argnup, "invalid upvalue index");
+  int nup = (int)luaL_checkinteger(L, argnup);  /* upvalue index */
+  luaL_checktype(L, argf, LUA_TFUNCTION);  /* closure */
+  luaL_argcheck(L, (lua_getupvalue(L, argf, nup) != NULL), argnup,
+                   "invalid upvalue index");
   return nup;
 }
 
@@ -253,26 +281,29 @@
 }
 
 
-#define gethooktable(L)	luaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)
-
-
+/*
+** Call hook function registered at hook table for the current
+** thread (if there is one)
+*/
 static void hookf (lua_State *L, lua_Debug *ar) {
   static const char *const hooknames[] =
     {"call", "return", "line", "count", "tail call"};
-  gethooktable(L);
+  lua_rawgetp(L, LUA_REGISTRYINDEX, &HOOKKEY);
   lua_pushthread(L);
-  lua_rawget(L, -2);
-  if (lua_isfunction(L, -1)) {
-    lua_pushstring(L, hooknames[(int)ar->event]);
+  if (lua_rawget(L, -2) == LUA_TFUNCTION) {  /* is there a hook function? */
+    lua_pushstring(L, hooknames[(int)ar->event]);  /* push event name */
     if (ar->currentline >= 0)
-      lua_pushinteger(L, ar->currentline);
+      lua_pushinteger(L, ar->currentline);  /* push current line */
     else lua_pushnil(L);
     lua_assert(lua_getinfo(L, "lS", ar));
-    lua_call(L, 2, 0);
+    lua_call(L, 2, 0);  /* call hook function */
   }
 }
 
 
+/*
+** Convert a string mask (for 'sethook') into a bit mask
+*/
 static int makemask (const char *smask, int count) {
   int mask = 0;
   if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
@@ -283,6 +314,9 @@
 }
 
 
+/*
+** Convert a bit mask (for 'gethook') into a string mask
+*/
 static char *unmakemask (int mask, char *smask) {
   int i = 0;
   if (mask & LUA_MASKCALL) smask[i++] = 'c';
@@ -297,26 +331,29 @@
   int arg, mask, count;
   lua_Hook func;
   lua_State *L1 = getthread(L, &arg);
-  if (lua_isnoneornil(L, arg+1)) {
+  if (lua_isnoneornil(L, arg+1)) {  /* no hook? */
     lua_settop(L, arg+1);
     func = NULL; mask = 0; count = 0;  /* turn off hooks */
   }
   else {
     const char *smask = luaL_checkstring(L, arg+2);
     luaL_checktype(L, arg+1, LUA_TFUNCTION);
-    count = luaL_optint(L, arg+3, 0);
+    count = (int)luaL_optinteger(L, arg + 3, 0);
     func = hookf; mask = makemask(smask, count);
   }
-  if (gethooktable(L) == 0) {  /* creating hook table? */
+  if (lua_rawgetp(L, LUA_REGISTRYINDEX, &HOOKKEY) == LUA_TNIL) {
+    lua_createtable(L, 0, 2);  /* create a hook table */
+    lua_pushvalue(L, -1);
+    lua_rawsetp(L, LUA_REGISTRYINDEX, &HOOKKEY);  /* set it in position */
     lua_pushstring(L, "k");
     lua_setfield(L, -2, "__mode");  /** hooktable.__mode = "k" */
     lua_pushvalue(L, -1);
     lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */
   }
-  lua_pushthread(L1); lua_xmove(L1, L, 1);
-  lua_pushvalue(L, arg+1);
-  lua_rawset(L, -3);  /* set new hook */
-  lua_sethook(L1, func, mask, count);  /* set hooks */
+  lua_pushthread(L1); lua_xmove(L1, L, 1);  /* key (thread) */
+  lua_pushvalue(L, arg + 1);  /* value (hook function) */
+  lua_rawset(L, -3);  /* hooktable[L1] = new Lua hook */
+  lua_sethook(L1, func, mask, count);
   return 0;
 }
 
@@ -327,16 +364,18 @@
   char buff[5];
   int mask = lua_gethookmask(L1);
   lua_Hook hook = lua_gethook(L1);
-  if (hook != NULL && hook != hookf)  /* external hook? */
+  if (hook == NULL)  /* no hook? */
+    lua_pushnil(L);
+  else if (hook != hookf)  /* external hook? */
     lua_pushliteral(L, "external hook");
-  else {
-    gethooktable(L);
+  else {  /* hook table must exist */
+    lua_rawgetp(L, LUA_REGISTRYINDEX, &HOOKKEY);
     lua_pushthread(L1); lua_xmove(L1, L, 1);
-    lua_rawget(L, -2);   /* get hook */
+    lua_rawget(L, -2);   /* 1st result = hooktable[L1] */
     lua_remove(L, -2);  /* remove hook table */
   }
-  lua_pushstring(L, unmakemask(mask, buff));
-  lua_pushinteger(L, lua_gethookcount(L1));
+  lua_pushstring(L, unmakemask(mask, buff));  /* 2nd result = mask */
+  lua_pushinteger(L, lua_gethookcount(L1));  /* 3rd result = count */
   return 3;
 }
 
@@ -344,13 +383,13 @@
 static int db_debug (lua_State *L) {
   for (;;) {
     char buffer[250];
-    luai_writestringerror("%s", "lua_debug> ");
+    lua_writestringerror("%s", "lua_debug> ");
     if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
         strcmp(buffer, "cont\n") == 0)
       return 0;
     if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
         lua_pcall(L, 0, 0, 0))
-      luai_writestringerror("%s\n", lua_tostring(L, -1));
+      lua_writestringerror("%s\n", lua_tostring(L, -1));
     lua_settop(L, 0);  /* remove eventual returns */
   }
 }
@@ -363,7 +402,7 @@
   if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */
     lua_pushvalue(L, arg + 1);  /* return it untouched */
   else {
-    int level = luaL_optint(L, arg + 2, (L == L1) ? 1 : 0);
+    int level = (int)luaL_optinteger(L, arg + 2, (L == L1) ? 1 : 0);
     luaL_traceback(L, L1, msg, level);
   }
   return 1;
diff -urN rpm-5.4.15/lua/ldebug.c rpm-5.4-cvs/lua/ldebug.c
--- rpm-5.4.15/lua/ldebug.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/ldebug.c	2015-04-19 13:24:57.000000000 -0500
@@ -1,18 +1,19 @@
 /*
-** $Id: ldebug.c,v 2.90 2012/08/16 17:34:28 roberto Exp $
+** $Id: ldebug.c,v 2.110 2015/01/02 12:52:22 roberto Exp $
 ** Debug Interface
 ** See Copyright Notice in lua.h
 */
 
+#define ldebug_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
 #include <stdarg.h>
 #include <stddef.h>
 #include <string.h>
 
-
-#define ldebug_c
-#define LUA_CORE
-
 #include "lua.h"
 
 #include "lapi.h"
@@ -47,10 +48,20 @@
 }
 
 
+static void swapextra (lua_State *L) {
+  if (L->status == LUA_YIELD) {
+    CallInfo *ci = L->ci;  /* get function that yielded */
+    StkId temp = ci->func;  /* exchange its 'func' and 'extra' values */
+    ci->func = restorestack(L, ci->extra);
+    ci->extra = savestack(L, temp);
+  }
+}
+
+
 /*
 ** this function can be called asynchronous (e.g. during a signal)
 */
-LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
   if (func == NULL || mask == 0) {  /* turn off hooks? */
     mask = 0;
     func = NULL;
@@ -61,7 +72,6 @@
   L->basehookcount = count;
   resethookcount(L);
   L->hookmask = cast_byte(mask);
-  return 1;
 }
 
 
@@ -144,6 +154,7 @@
 LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
   const char *name;
   lua_lock(L);
+  swapextra(L);
   if (ar == NULL) {  /* information about non-active function? */
     if (!isLfunction(L->top - 1))  /* not a Lua function? */
       name = NULL;
@@ -158,6 +169,7 @@
       api_incr_top(L);
     }
   }
+  swapextra(L);
   lua_unlock(L);
   return name;
 }
@@ -165,11 +177,15 @@
 
 LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
   StkId pos = 0;  /* to avoid warnings */
-  const char *name = findlocal(L, ar->i_ci, n, &pos);
+  const char *name;
   lua_lock(L);
-  if (name)
+  swapextra(L);
+  name = findlocal(L, ar->i_ci, n, &pos);
+  if (name) {
     setobjs2s(L, pos, L->top - 1);
-  L->top--;  /* pop value */
+    L->top--;  /* pop value */
+  }
+  swapextra(L);
   lua_unlock(L);
   return name;
 }
@@ -269,10 +285,11 @@
   CallInfo *ci;
   StkId func;
   lua_lock(L);
+  swapextra(L);
   if (*what == '>') {
     ci = NULL;
     func = L->top - 1;
-    api_check(L, ttisfunction(func), "function expected");
+    api_check(ttisfunction(func), "function expected");
     what++;  /* skip the '>' */
     L->top--;  /* pop function */
   }
@@ -289,6 +306,7 @@
   }
   if (strchr(what, 'L'))
     collectvalidlines(L, cl);
+  swapextra(L);
   lua_unlock(L);
   return status;
 }
@@ -327,12 +345,20 @@
 }
 
 
+static int filterpc (int pc, int jmptarget) {
+  if (pc < jmptarget)  /* is code conditional (inside a jump)? */
+    return -1;  /* cannot know who sets that register */
+  else return pc;  /* current position sets that register */
+}
+
+
 /*
 ** try to find last instruction before 'lastpc' that modified register 'reg'
 */
 static int findsetreg (Proto *p, int lastpc, int reg) {
   int pc;
   int setreg = -1;  /* keep last instruction that changed 'reg' */
+  int jmptarget = 0;  /* any code before this address is conditional */
   for (pc = 0; pc < lastpc; pc++) {
     Instruction i = p->code[pc];
     OpCode op = GET_OPCODE(i);
@@ -341,33 +367,33 @@
       case OP_LOADNIL: {
         int b = GETARG_B(i);
         if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */
-          setreg = pc;
+          setreg = filterpc(pc, jmptarget);
         break;
       }
       case OP_TFORCALL: {
-        if (reg >= a + 2) setreg = pc;  /* affect all regs above its base */
+        if (reg >= a + 2)  /* affect all regs above its base */
+          setreg = filterpc(pc, jmptarget);
         break;
       }
       case OP_CALL:
       case OP_TAILCALL: {
-        if (reg >= a) setreg = pc;  /* affect all registers above base */
+        if (reg >= a)  /* affect all registers above base */
+          setreg = filterpc(pc, jmptarget);
         break;
       }
       case OP_JMP: {
         int b = GETARG_sBx(i);
         int dest = pc + 1 + b;
-        /* jump is forward and do not skip `lastpc'? */
-        if (pc < dest && dest <= lastpc)
-          pc += b;  /* do the jump */
-        break;
-      }
-      case OP_TEST: {
-        if (reg == a) setreg = pc;  /* jumped code can change 'a' */
+        /* jump is forward and do not skip 'lastpc'? */
+        if (pc < dest && dest <= lastpc) {
+          if (dest > jmptarget)
+            jmptarget = dest;  /* update 'jmptarget' */
+        }
         break;
       }
       default:
         if (testAMode(op) && reg == a)  /* any instruction that set A */
-          setreg = pc;
+          setreg = filterpc(pc, jmptarget);
         break;
     }
   }
@@ -430,10 +456,14 @@
 
 
 static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
-  TMS tm;
+  TMS tm = (TMS)0;  /* to avoid warnings */
   Proto *p = ci_func(ci)->p;  /* calling function */
   int pc = currentpc(ci);  /* calling instruction index */
   Instruction i = p->code[pc];  /* calling instruction */
+  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */
+    *name = "?";
+    return "hook";
+  }
   switch (GET_OPCODE(i)) {
     case OP_CALL:
     case OP_TAILCALL:  /* get function name */
@@ -443,25 +473,27 @@
        return "for iterator";
     }
     /* all other instructions can call only through metamethods */
-    case OP_SELF:
-    case OP_GETTABUP:
-    case OP_GETTABLE: tm = TM_INDEX; break;
-    case OP_SETTABUP:
-    case OP_SETTABLE: tm = TM_NEWINDEX; break;
-    case OP_EQ: tm = TM_EQ; break;
-    case OP_ADD: tm = TM_ADD; break;
-    case OP_SUB: tm = TM_SUB; break;
-    case OP_MUL: tm = TM_MUL; break;
-    case OP_DIV: tm = TM_DIV; break;
-    case OP_MOD: tm = TM_MOD; break;
-    case OP_POW: tm = TM_POW; break;
+    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:
+      tm = TM_INDEX;
+      break;
+    case OP_SETTABUP: case OP_SETTABLE:
+      tm = TM_NEWINDEX;
+      break;
+    case OP_ADD: case OP_SUB: case OP_MUL: case OP_MOD:
+    case OP_POW: case OP_DIV: case OP_IDIV: case OP_BAND:
+    case OP_BOR: case OP_BXOR: case OP_SHL: case OP_SHR: {
+      int offset = cast_int(GET_OPCODE(i)) - cast_int(OP_ADD);  /* ORDER OP */
+      tm = cast(TMS, offset + cast_int(TM_ADD));  /* ORDER TM */
+      break;
+    }
     case OP_UNM: tm = TM_UNM; break;
+    case OP_BNOT: tm = TM_BNOT; break;
     case OP_LEN: tm = TM_LEN; break;
+    case OP_CONCAT: tm = TM_CONCAT; break;
+    case OP_EQ: tm = TM_EQ; break;
     case OP_LT: tm = TM_LT; break;
     case OP_LE: tm = TM_LE; break;
-    case OP_CONCAT: tm = TM_CONCAT; break;
-    default:
-      return NULL;  /* else no useful name can be found */
+    default: lua_assert(0);  /* other instructions cannot call a function */
   }
   *name = getstr(G(L)->tmname[tm]);
   return "metamethod";
@@ -472,17 +504,21 @@
 
 
 /*
-** only ANSI way to check whether a pointer points to an array
-** (used only for error messages, so efficiency is not a big concern)
+** The subtraction of two potentially unrelated pointers is
+** not ISO C, but it should not crash a program; the subsequent
+** checks are ISO C and ensure a correct result.
 */
 static int isinstack (CallInfo *ci, const TValue *o) {
-  StkId p;
-  for (p = ci->u.l.base; p < ci->top; p++)
-    if (o == p) return 1;
-  return 0;
+  ptrdiff_t i = o - ci->u.l.base;
+  return (0 <= i && i < (ci->top - ci->u.l.base) && ci->u.l.base + i == o);
 }
 
 
+/*
+** Checks whether value 'o' came from an upvalue. (That can only happen
+** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on
+** upvalues.)
+*/
 static const char *getupvalname (CallInfo *ci, const TValue *o,
                                  const char **name) {
   LClosure *c = ci_func(ci);
@@ -497,10 +533,9 @@
 }
 
 
-l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
+static const char *varinfo (lua_State *L, const TValue *o) {
+  const char *name = NULL;  /* to avoid warnings */
   CallInfo *ci = L->ci;
-  const char *name = NULL;
-  const char *t = objtypename(o);
   const char *kind = NULL;
   if (isLua(ci)) {
     kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
@@ -508,26 +543,39 @@
       kind = getobjname(ci_func(ci)->p, currentpc(ci),
                         cast_int(o - ci->u.l.base), &name);
   }
-  if (kind)
-    luaG_runerror(L, "attempt to %s %s " LUA_QS " (a %s value)",
-                op, kind, name, t);
-  else
-    luaG_runerror(L, "attempt to %s a %s value", op, t);
+  return (kind) ? luaO_pushfstring(L, " (%s '%s')", kind, name) : "";
 }
 
 
-l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
-  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
-  lua_assert(!ttisstring(p1) && !ttisnumber(p2));
+l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
+  const char *t = objtypename(o);
+  luaG_runerror(L, "attempt to %s a %s value%s", op, t, varinfo(L, o));
+}
+
+
+l_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {
+  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;
   luaG_typeerror(L, p1, "concatenate");
 }
 
 
-l_noret luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
-  TValue temp;
-  if (luaV_tonumber(p1, &temp) == NULL)
-    p2 = p1;  /* first operand is wrong */
-  luaG_typeerror(L, p2, "perform arithmetic on");
+l_noret luaG_opinterror (lua_State *L, const TValue *p1,
+                         const TValue *p2, const char *msg) {
+  lua_Number temp;
+  if (!tonumber(p1, &temp))  /* first operand is wrong? */
+    p2 = p1;  /* now second is wrong */
+  luaG_typeerror(L, p2, msg);
+}
+
+
+/*
+** Error when both values are convertible to numbers, but not to integers
+*/
+l_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {
+  lua_Integer temp;
+  if (!tointeger(p1, &temp))
+    p2 = p1;
+  luaG_runerror(L, "number%s has no integer representation", varinfo(L, p2));
 }
 
 
@@ -560,10 +608,9 @@
 l_noret luaG_errormsg (lua_State *L) {
   if (L->errfunc != 0) {  /* is there an error handling function? */
     StkId errfunc = restorestack(L, L->errfunc);
-    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
     setobjs2s(L, L->top, L->top - 1);  /* move argument */
     setobjs2s(L, L->top - 1, errfunc);  /* push function */
-    L->top++;
+    L->top++;  /* assume EXTRA_STACK */
     luaD_call(L, L->top - 2, 1, 0);  /* call it */
   }
   luaD_throw(L, LUA_ERRRUN);
@@ -578,3 +625,36 @@
   luaG_errormsg(L);
 }
 
+
+void luaG_traceexec (lua_State *L) {
+  CallInfo *ci = L->ci;
+  lu_byte mask = L->hookmask;
+  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);
+  if (counthook)
+    resethookcount(L);  /* reset count */
+  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
+    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
+    return;  /* do not call hook again (VM yielded, so it did not move) */
+  }
+  if (counthook)
+    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */
+  if (mask & LUA_MASKLINE) {
+    Proto *p = ci_func(ci)->p;
+    int npc = pcRel(ci->u.l.savedpc, p);
+    int newline = getfuncline(p, npc);
+    if (npc == 0 ||  /* call linehook when enter a new function, */
+        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */
+        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */
+      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */
+  }
+  L->oldpc = ci->u.l.savedpc;
+  if (L->status == LUA_YIELD) {  /* did hook yield? */
+    if (counthook)
+      L->hookcount = 1;  /* undo decrement to zero */
+    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
+    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */
+    ci->func = L->top - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+}
+
diff -urN rpm-5.4.15/lua/ldebug.h rpm-5.4-cvs/lua/ldebug.h
--- rpm-5.4.15/lua/ldebug.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/ldebug.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: ldebug.h,v 2.7 2011/10/07 20:45:19 roberto Exp $
+** $Id: ldebug.h,v 2.12 2014/11/10 14:46:05 roberto Exp $
 ** Auxiliary functions from Debug Interface module
 ** See Copyright Notice in lua.h
 */
@@ -13,7 +13,7 @@
 
 #define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
 
-#define getfuncline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+#define getfuncline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : -1)
 
 #define resethookcount(L)	(L->hookcount = L->basehookcount)
 
@@ -23,12 +23,18 @@
 
 LUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,
                                                 const char *opname);
-LUAI_FUNC l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2);
-LUAI_FUNC l_noret luaG_aritherror (lua_State *L, const TValue *p1,
+LUAI_FUNC l_noret luaG_concaterror (lua_State *L, const TValue *p1,
+                                                  const TValue *p2);
+LUAI_FUNC l_noret luaG_opinterror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2,
+                                                 const char *msg);
+LUAI_FUNC l_noret luaG_tointerror (lua_State *L, const TValue *p1,
                                                  const TValue *p2);
 LUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,
                                                  const TValue *p2);
 LUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);
 LUAI_FUNC l_noret luaG_errormsg (lua_State *L);
+LUAI_FUNC void luaG_traceexec (lua_State *L);
+
 
 #endif
diff -urN rpm-5.4.15/lua/ldo.c rpm-5.4-cvs/lua/ldo.c
--- rpm-5.4.15/lua/ldo.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/ldo.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,17 +1,19 @@
 /*
-** $Id: ldo.c,v 2.108 2012/10/01 14:05:04 roberto Exp $
+** $Id: ldo.c,v 2.135 2014/11/11 17:13:39 roberto Exp $
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */
 
+#define ldo_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
 #include <setjmp.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define ldo_c
-#define LUA_CORE
-
 #include "lua.h"
 
 #include "lapi.h"
@@ -33,6 +35,8 @@
 
 
 
+#define errorstatus(s)	((s) > LUA_YIELD)
+
 
 /*
 ** {======================================================
@@ -46,30 +50,33 @@
 ** C++ code, with _longjmp/_setjmp when asked to use them, and with
 ** longjmp/setjmp otherwise.
 */
-#if !defined(LUAI_THROW)
+#if !defined(LUAI_THROW)				/* { */
+
+#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)	/* { */
 
-#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)
 /* C++ exceptions */
 #define LUAI_THROW(L,c)		throw(c)
 #define LUAI_TRY(L,c,a) \
 	try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
 #define luai_jmpbuf		int  /* dummy variable */
 
-#elif defined(LUA_USE_ULONGJMP)
-/* in Unix, try _longjmp/_setjmp (more efficient) */
+#elif defined(LUA_USE_POSIX)				/* }{ */
+
+/* in POSIX, try _longjmp/_setjmp (more efficient) */
 #define LUAI_THROW(L,c)		_longjmp((c)->b, 1)
 #define LUAI_TRY(L,c,a)		if (_setjmp((c)->b) == 0) { a }
 #define luai_jmpbuf		jmp_buf
 
-#else
-/* default handling with long jumps */
+#else							/* }{ */
+
+/* ISO C handling with long jumps */
 #define LUAI_THROW(L,c)		longjmp((c)->b, 1)
 #define LUAI_TRY(L,c,a)		if (setjmp((c)->b) == 0) { a }
 #define luai_jmpbuf		jmp_buf
 
-#endif
+#endif							/* } */
 
-#endif
+#endif							/* } */
 
 
 
@@ -106,15 +113,19 @@
     LUAI_THROW(L, L->errorJmp);  /* jump to it */
   }
   else {  /* thread has no error handler */
+    global_State *g = G(L);
     L->status = cast_byte(errcode);  /* mark it as dead */
-    if (G(L)->mainthread->errorJmp) {  /* main thread has a handler? */
-      setobjs2s(L, G(L)->mainthread->top++, L->top - 1);  /* copy error obj. */
-      luaD_throw(G(L)->mainthread, errcode);  /* re-throw in main thread */
+    if (g->mainthread->errorJmp) {  /* main thread has a handler? */
+      setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */
+      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */
     }
     else {  /* no handler at all; abort */
-      if (G(L)->panic) {  /* panic function? */
+      if (g->panic) {  /* panic function? */
+        seterrorobj(L, errcode, L->top);  /* assume EXTRA_STACK */
+        if (L->ci->top < L->top)
+          L->ci->top = L->top;  /* pushing msg. can break this invariant */
         lua_unlock(L);
-        G(L)->panic(L);  /* call it (last chance to jump out) */
+        g->panic(L);  /* call panic function (last chance to jump out) */
       }
       abort();
     }
@@ -141,10 +152,10 @@
 
 static void correctstack (lua_State *L, TValue *oldstack) {
   CallInfo *ci;
-  GCObject *up;
+  UpVal *up;
   L->top = (L->top - oldstack) + L->stack;
-  for (up = L->openupval; up != NULL; up = up->gch.next)
-    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
+  for (up = L->openupval; up != NULL; up = up->u.open.next)
+    up->v = (up->v - oldstack) + L->stack;
   for (ci = L->ci; ci != NULL; ci = ci->previous) {
     ci->top = (ci->top - oldstack) + L->stack;
     ci->func = (ci->func - oldstack) + L->stack;
@@ -191,6 +202,7 @@
 }
 
 
+LUA_GNUC_PURE
 static int stackinuse (lua_State *L) {
   CallInfo *ci;
   StkId lim = L->top;
@@ -206,7 +218,11 @@
   int inuse = stackinuse(L);
   int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;
   if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;
-  if (inuse > LUAI_MAXSTACK ||  /* handling stack overflow? */
+  if (L->stacksize > LUAI_MAXSTACK)  /* was handling stack overflow? */
+    luaE_freeCI(L);  /* free all CIs (list grew because of an error) */
+  else
+    luaE_shrinkCI(L);  /* shrink list */
+  if (inuse > LUAI_MAXSTACK ||  /* still handling stack overflow? */
       goodsize >= L->stacksize)  /* would grow instead of shrink? */
     condmovestack(L);  /* don't change stack (change only for debugging) */
   else
@@ -260,6 +276,7 @@
   StkId base, fixed;
   lua_assert(actual >= nfixargs);
   /* move fixed parameters to final position */
+  luaD_checkstack(L, p->maxstacksize);  /* check again for new 'base' */
   fixed = L->top - actual;  /* first fixed argument */
   base = L->top;  /* final position of first argument */
   for (i=0; i<nfixargs; i++) {
@@ -270,18 +287,21 @@
 }
 
 
-static StkId tryfuncTM (lua_State *L, StkId func) {
+/*
+** Check whether __call metafield of 'func' is a function. If so, put
+** it in stack below original 'func' so that 'luaD_precall' can call
+** it. Raise an error if __call metafield is not a function.
+*/
+static void tryfuncTM (lua_State *L, StkId func) {
   const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
   StkId p;
-  ptrdiff_t funcr = savestack(L, func);
   if (!ttisfunction(tm))
     luaG_typeerror(L, func, "call");
-  /* Open a hole inside the stack at `func' */
-  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);
-  incr_top(L);
-  func = restorestack(L, funcr);  /* previous call may change stack */
+  /* Open a hole inside the stack at 'func' */
+  for (p = L->top; p > func; p--)
+    setobjs2s(L, p, p-1);
+  L->top++;  /* slot ensured by caller */
   setobj2s(L, func, tm);  /* tag method is the new function to be called */
-  return func;
 }
 
 
@@ -324,12 +344,18 @@
     case LUA_TLCL: {  /* Lua function: prepare its call */
       StkId base;
       Proto *p = clLvalue(func)->p;
-      luaD_checkstack(L, p->maxstacksize);
-      func = restorestack(L, funcr);
       n = cast_int(L->top - func) - 1;  /* number of real arguments */
+      luaD_checkstack(L, p->maxstacksize);
       for (; n < p->numparams; n++)
         setnilvalue(L->top++);  /* complete missing arguments */
-      base = (!p->is_vararg) ? func + 1 : adjust_varargs(L, p, n);
+      if (!p->is_vararg) {
+        func = restorestack(L, funcr);
+        base = func + 1;
+      }
+      else {
+        base = adjust_varargs(L, p, n);
+        func = restorestack(L, funcr);  /* previous call can change stack */
+      }
       ci = next_ci(L);  /* now 'enter' new function */
       ci->nresults = nresults;
       ci->func = func;
@@ -345,7 +371,9 @@
       return 0;
     }
     default: {  /* not a function */
-      func = tryfuncTM(L, func);  /* retry with 'function' tag method */
+      luaD_checkstack(L, 1);  /* ensure space for metamethod */
+      func = restorestack(L, funcr);  /* previous call may change stack */
+      tryfuncTM(L, func);  /* try to get '__call' metamethod */
       return luaD_precall(L, func, nresults);  /* now it must be a function */
     }
   }
@@ -398,24 +426,27 @@
 }
 
 
-static void finishCcall (lua_State *L) {
+/*
+** Completes the execution of an interrupted C function, calling its
+** continuation function.
+*/
+static void finishCcall (lua_State *L, int status) {
   CallInfo *ci = L->ci;
   int n;
-  lua_assert(ci->u.c.k != NULL);  /* must have a continuation */
-  lua_assert(L->nny == 0);
+  /* must have a continuation and must be able to call it */
+  lua_assert(ci->u.c.k != NULL && L->nny == 0);
+  /* error status can only happen in a protected call */
+  lua_assert((ci->callstatus & CIST_YPCALL) || status == LUA_YIELD);
   if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */
     ci->callstatus &= ~CIST_YPCALL;  /* finish 'lua_pcall' */
     L->errfunc = ci->u.c.old_errfunc;
   }
-  /* finish 'lua_callk'/'lua_pcall' */
+  /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already
+     handled */
   adjustresults(L, ci->nresults);
   /* call continuation function */
-  if (!(ci->callstatus & CIST_STAT))  /* no call status? */
-    ci->u.c.status = LUA_YIELD;  /* 'default' status */
-  lua_assert(ci->u.c.status != LUA_OK);
-  ci->callstatus = (ci->callstatus & ~(CIST_YPCALL | CIST_STAT)) | CIST_YIELDED;
   lua_unlock(L);
-  n = (*ci->u.c.k)(L);
+  n = (*ci->u.c.k)(L, status, ci->u.c.ctx);
   lua_lock(L);
   api_checknelems(L, n);
   /* finish 'luaD_precall' */
@@ -423,13 +454,20 @@
 }
 
 
+/*
+** Executes "full continuation" (everything in the stack) of a
+** previously interrupted coroutine until the stack is empty (or another
+** interruption long-jumps out of the loop). If the coroutine is
+** recovering from an error, 'ud' points to the error status, which must
+** be passed to the first continuation function (otherwise the default
+** status is LUA_YIELD).
+*/
 static void unroll (lua_State *L, void *ud) {
-  UNUSED(ud);
-  for (;;) {
-    if (L->ci == &L->base_ci)  /* stack is empty? */
-      return;  /* coroutine finished normally */
+  if (ud != NULL)  /* error status? */
+    finishCcall(L, *(int *)ud);  /* finish 'lua_pcallk' callee */
+  while (L->ci != &L->base_ci) {  /* something in the stack */
     if (!isLua(L->ci))  /* C function? */
-      finishCcall(L);
+      finishCcall(L, LUA_YIELD);  /* complete its execution */
     else {  /* Lua function */
       luaV_finishOp(L);  /* finish interrupted instruction */
       luaV_execute(L);  /* execute down to higher C 'boundary' */
@@ -439,8 +477,10 @@
 
 
 /*
-** check whether thread has a suspended protected call
+** Try to find a suspended protected call (a "recover point") for the
+** given thread.
 */
+LUA_GNUC_PURE
 static CallInfo *findpcall (lua_State *L) {
   CallInfo *ci;
   for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */
@@ -451,6 +491,11 @@
 }
 
 
+/*
+** Recovers from an error in a coroutine. Finds a recover point (if
+** there is one) and completes the execution of the interrupted
+** 'luaD_pcall'. If there is no recover point, returns zero.
+*/
 static int recover (lua_State *L, int status) {
   StkId oldtop;
   CallInfo *ci = findpcall(L);
@@ -460,12 +505,10 @@
   luaF_close(L, oldtop);
   seterrorobj(L, status, oldtop);
   L->ci = ci;
-  L->allowhook = ci->u.c.old_allowhook;
+  L->allowhook = getoah(ci->callstatus);  /* restore original 'allowhook' */
   L->nny = 0;  /* should be zero to be yieldable */
   luaD_shrinkstack(L);
   L->errfunc = ci->u.c.old_errfunc;
-  ci->callstatus |= CIST_STAT;  /* call has error status */
-  ci->u.c.status = status;  /* (here it is) */
   return 1;  /* continue running the coroutine */
 }
 
@@ -484,7 +527,11 @@
 
 
 /*
-** do the work for 'lua_resume' in protected mode
+** Do the work for 'lua_resume' in protected mode. Most of the work
+** depends on the status of the coroutine: initial state, suspended
+** inside a hook, or regularly suspended (optionally with a continuation
+** function), plus erroneous cases: non-suspended coroutine or dead
+** coroutine.
 */
 static void resume (lua_State *L, void *ud) {
   int nCcalls = L->nCcalls;
@@ -502,24 +549,22 @@
   else if (L->status != LUA_YIELD)
     resume_error(L, "cannot resume dead coroutine", firstArg);
   else {  /* resuming from previous yield */
-    L->status = LUA_OK;
+    L->status = LUA_OK;  /* mark that it is running (again) */
     ci->func = restorestack(L, ci->extra);
     if (isLua(ci))  /* yielded inside a hook? */
       luaV_execute(L);  /* just continue running Lua code */
     else {  /* 'common' yield */
-      if (ci->u.c.k != NULL) {  /* does it have a continuation? */
+      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */
         int n;
-        ci->u.c.status = LUA_YIELD;  /* 'default' status */
-        ci->callstatus |= CIST_YIELDED;
         lua_unlock(L);
-        n = (*ci->u.c.k)(L);  /* call continuation */
+        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */
         lua_lock(L);
         api_checknelems(L, n);
         firstArg = L->top - n;  /* yield results come from continuation */
       }
       luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */
     }
-    unroll(L, NULL);
+    unroll(L, NULL);  /* run continuation */
   }
   lua_assert(nCcalls == L->nCcalls);
 }
@@ -527,6 +572,7 @@
 
 LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {
   int status;
+  int oldnny = L->nny;  /* save "number of non-yieldable" calls */
   lua_lock(L);
   luai_userstateresume(L, nargs);
   L->nCcalls = (from) ? from->nCcalls + 1 : 1;
@@ -535,20 +581,19 @@
   status = luaD_rawrunprotected(L, resume, L->top - nargs);
   if (status == -1)  /* error calling 'lua_resume'? */
     status = LUA_ERRRUN;
-  else {  /* yield or regular error */
-    while (status != LUA_OK && status != LUA_YIELD) {  /* error? */
-      if (recover(L, status))  /* recover point? */
-        status = luaD_rawrunprotected(L, unroll, NULL);  /* run continuation */
-      else {  /* unrecoverable error */
-        L->status = cast_byte(status);  /* mark thread as `dead' */
-        seterrorobj(L, status, L->top);
-        L->ci->top = L->top;
-        break;
-      }
+  else {  /* continue running after recoverable errors */
+    while (errorstatus(status) && recover(L, status)) {
+      /* unroll continuation */
+      status = luaD_rawrunprotected(L, unroll, &status);
+    }
+    if (errorstatus(status)) {  /* unrecoverable error? */
+      L->status = cast_byte(status);  /* mark thread as 'dead' */
+      seterrorobj(L, status, L->top);  /* push error message */
+      L->ci->top = L->top;
     }
-    lua_assert(status == L->status);
+    else lua_assert(status == L->status);  /* normal end or yield */
   }
-  L->nny = 1;  /* do not allow yields */
+  L->nny = oldnny;  /* restore 'nny' */
   L->nCcalls--;
   lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));
   lua_unlock(L);
@@ -556,7 +601,13 @@
 }
 
 
-LUA_API int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k) {
+LUA_API int lua_isyieldable (lua_State *L) {
+  return (L->nny == 0);
+}
+
+
+LUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,
+                        lua_KFunction k) {
   CallInfo *ci = L->ci;
   luai_userstateyield(L, nresults);
   lua_lock(L);
@@ -570,7 +621,7 @@
   L->status = LUA_YIELD;
   ci->extra = savestack(L, ci->func);  /* save current 'func' */
   if (isLua(ci)) {  /* inside a hook? */
-    api_check(L, k == NULL, "hooks cannot continue after yielding");
+    api_check(k == NULL, "hooks cannot continue after yielding");
   }
   else {
     if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
@@ -611,7 +662,7 @@
 /*
 ** Execute a protected parser.
 */
-struct SParser {  /* data to `f_parser' */
+struct SParser {  /* data to 'f_parser' */
   ZIO *z;
   Mbuffer buff;  /* dynamic structure used by the scanner */
   Dyndata dyd;  /* dynamic structures used by the parser */
@@ -623,15 +674,14 @@
 static void checkmode (lua_State *L, const char *mode, const char *x) {
   if (mode && strchr(mode, x[0]) == NULL) {
     luaO_pushfstring(L,
-       "attempt to load a %s chunk (mode is " LUA_QS ")", x, mode);
+       "attempt to load a %s chunk (mode is '%s')", x, mode);
     luaD_throw(L, LUA_ERRSYNTAX);
   }
 }
 
 
 static void f_parser (lua_State *L, void *ud) {
-  int i;
-  Closure *cl;
+  LClosure *cl;
   struct SParser *p = cast(struct SParser *, ud);
   int c = zgetc(p->z);  /* read first character */
   if (c == LUA_SIGNATURE[0]) {
@@ -642,12 +692,8 @@
     checkmode(L, p->mode, "text");
     cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
   }
-  lua_assert(cl->l.nupvalues == cl->l.p->sizeupvalues);
-  for (i = 0; i < cl->l.nupvalues; i++) {  /* initialize upvalues */
-    UpVal *up = luaF_newupval(L);
-    cl->l.upvals[i] = up;
-    luaC_objbarrier(L, cl, up);
-  }
+  lua_assert(cl->nupvalues == cl->p->sizeupvalues);
+  luaF_initupvals(L, cl);
 }
 
 
diff -urN rpm-5.4.15/lua/ldo.h rpm-5.4-cvs/lua/ldo.h
--- rpm-5.4.15/lua/ldo.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/ldo.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: ldo.h,v 2.20 2011/11/29 15:55:08 roberto Exp $
+** $Id: ldo.h,v 2.21 2014/10/25 11:50:46 roberto Exp $
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */
@@ -23,7 +23,7 @@
 #define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))
 
 
-/* type of protected functions, to be ran by `runprotected' */
+/* type of protected functions, to be ran by 'runprotected' */
 typedef void (*Pfunc) (lua_State *L, void *ud);
 
 LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
diff -urN rpm-5.4.15/lua/ldump.c rpm-5.4-cvs/lua/ldump.c
--- rpm-5.4.15/lua/ldump.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/ldump.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,173 +1,214 @@
 /*
-** $Id: ldump.c,v 2.17 2012/01/23 23:02:10 roberto Exp $
+** $Id: ldump.c,v 2.34 2014/11/02 19:19:04 roberto Exp $
 ** save precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
 
-#include <stddef.h>
-
 #define ldump_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <stddef.h>
+
 #include "lua.h"
 
 #include "lobject.h"
 #include "lstate.h"
 #include "lundump.h"
 
+
 typedef struct {
- lua_State* L;
- lua_Writer writer;
- void* data;
- int strip;
- int status;
+  lua_State *L;
+  lua_Writer writer;
+  void *data;
+  int strip;
+  int status;
 } DumpState;
 
-#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
-#define DumpVar(x,D)		DumpMem(&x,1,sizeof(x),D)
 
-static void DumpBlock(const void* b, size_t size, DumpState* D)
-{
- if (D->status==0)
- {
-  lua_unlock(D->L);
-  D->status=(*D->writer)(D->L,b,size,D->data);
-  lua_lock(D->L);
- }
-}
-
-static void DumpChar(int y, DumpState* D)
-{
- char x=(char)y;
- DumpVar(x,D);
-}
-
-static void DumpInt(int x, DumpState* D)
-{
- DumpVar(x,D);
-}
-
-static void DumpNumber(lua_Number x, DumpState* D)
-{
- DumpVar(x,D);
-}
-
-static void DumpVector(const void* b, int n, size_t size, DumpState* D)
-{
- DumpInt(n,D);
- DumpMem(b,n,size,D);
-}
-
-static void DumpString(const TString* s, DumpState* D)
-{
- if (s==NULL)
- {
-  size_t size=0;
-  DumpVar(size,D);
- }
- else
- {
-  size_t size=s->tsv.len+1;		/* include trailing '\0' */
-  DumpVar(size,D);
-  DumpBlock(getstr(s),size*sizeof(char),D);
- }
-}
-
-#define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)
-
-static void DumpFunction(const Proto* f, DumpState* D);
-
-static void DumpConstants(const Proto* f, DumpState* D)
-{
- int i,n=f->sizek;
- DumpInt(n,D);
- for (i=0; i<n; i++)
- {
-  const TValue* o=&f->k[i];
-  DumpChar(ttypenv(o),D);
-  switch (ttypenv(o))
-  {
-   case LUA_TNIL:
-	break;
-   case LUA_TBOOLEAN:
-	DumpChar(bvalue(o),D);
-	break;
-   case LUA_TNUMBER:
-	DumpNumber(nvalue(o),D);
-	break;
-   case LUA_TSTRING:
-	DumpString(rawtsvalue(o),D);
-	break;
-    default: lua_assert(0);
+/*
+** All high-level dumps go through DumpVector; you can change it to
+** change the endianness of the result
+*/
+#define DumpVector(v,n,D)	DumpBlock(v,(n)*sizeof((v)[0]),D)
+
+#define DumpLiteral(s,D)	DumpBlock(s, sizeof(s) - sizeof(char), D)
+
+
+static void DumpBlock (const void *b, size_t size, DumpState *D) {
+  if (D->status == 0) {
+    lua_unlock(D->L);
+    D->status = (*D->writer)(D->L, b, size, D->data);
+    lua_lock(D->L);
+  }
+}
+
+
+#define DumpVar(x,D)		DumpVector(&x,1,D)
+
+
+static void DumpByte (int y, DumpState *D) {
+  lu_byte x = (lu_byte)y;
+  DumpVar(x, D);
+}
+
+
+static void DumpInt (int x, DumpState *D) {
+  DumpVar(x, D);
+}
+
+
+static void DumpNumber (lua_Number x, DumpState *D) {
+  DumpVar(x, D);
+}
+
+
+static void DumpInteger (lua_Integer x, DumpState *D) {
+  DumpVar(x, D);
+}
+
+
+static void DumpString (const TString *s, DumpState *D) {
+  if (s == NULL)
+    DumpByte(0, D);
+  else {
+    size_t size = s->len + 1;  /* include trailing '\0' */
+    if (size < 0xFF)
+      DumpByte(cast_int(size), D);
+    else {
+      DumpByte(0xFF, D);
+      DumpVar(size, D);
+    }
+    DumpVector(getstr(s), size - 1, D);  /* no need to save '\0' */
+  }
+}
+
+
+static void DumpCode (const Proto *f, DumpState *D) {
+  DumpInt(f->sizecode, D);
+  DumpVector(f->code, f->sizecode, D);
+}
+
+
+static void DumpFunction(const Proto *f, TString *psource, DumpState *D);
+
+static void DumpConstants (const Proto *f, DumpState *D) {
+  int i;
+  int n = f->sizek;
+  DumpInt(n, D);
+  for (i = 0; i < n; i++) {
+    const TValue *o = &f->k[i];
+    DumpByte(ttype(o), D);
+    switch (ttype(o)) {
+    case LUA_TNIL:
+      break;
+    case LUA_TBOOLEAN:
+      DumpByte(bvalue(o), D);
+      break;
+    case LUA_TNUMFLT:
+      DumpNumber(fltvalue(o), D);
+      break;
+    case LUA_TNUMINT:
+      DumpInteger(ivalue(o), D);
+      break;
+    case LUA_TSHRSTR:
+    case LUA_TLNGSTR:
+      DumpString(tsvalue(o), D);
+      break;
+    default:
+      lua_assert(0);
+    }
+  }
+}
+
+
+static void DumpProtos (const Proto *f, DumpState *D) {
+  int i;
+  int n = f->sizep;
+  DumpInt(n, D);
+  for (i = 0; i < n; i++)
+    DumpFunction(f->p[i], f->source, D);
+}
+
+
+static void DumpUpvalues (const Proto *f, DumpState *D) {
+  int i, n = f->sizeupvalues;
+  DumpInt(n, D);
+  for (i = 0; i < n; i++) {
+    DumpByte(f->upvalues[i].instack, D);
+    DumpByte(f->upvalues[i].idx, D);
   }
- }
- n=f->sizep;
- DumpInt(n,D);
- for (i=0; i<n; i++) DumpFunction(f->p[i],D);
-}
-
-static void DumpUpvalues(const Proto* f, DumpState* D)
-{
- int i,n=f->sizeupvalues;
- DumpInt(n,D);
- for (i=0; i<n; i++)
- {
-  DumpChar(f->upvalues[i].instack,D);
-  DumpChar(f->upvalues[i].idx,D);
- }
-}
-
-static void DumpDebug(const Proto* f, DumpState* D)
-{
- int i,n;
- DumpString((D->strip) ? NULL : f->source,D);
- n= (D->strip) ? 0 : f->sizelineinfo;
- DumpVector(f->lineinfo,n,sizeof(int),D);
- n= (D->strip) ? 0 : f->sizelocvars;
- DumpInt(n,D);
- for (i=0; i<n; i++)
- {
-  DumpString(f->locvars[i].varname,D);
-  DumpInt(f->locvars[i].startpc,D);
-  DumpInt(f->locvars[i].endpc,D);
- }
- n= (D->strip) ? 0 : f->sizeupvalues;
- DumpInt(n,D);
- for (i=0; i<n; i++) DumpString(f->upvalues[i].name,D);
-}
-
-static void DumpFunction(const Proto* f, DumpState* D)
-{
- DumpInt(f->linedefined,D);
- DumpInt(f->lastlinedefined,D);
- DumpChar(f->numparams,D);
- DumpChar(f->is_vararg,D);
- DumpChar(f->maxstacksize,D);
- DumpCode(f,D);
- DumpConstants(f,D);
- DumpUpvalues(f,D);
- DumpDebug(f,D);
-}
-
-static void DumpHeader(DumpState* D)
-{
- lu_byte h[LUAC_HEADERSIZE];
- luaU_header(h);
- DumpBlock(h,LUAC_HEADERSIZE,D);
 }
 
+
+static void DumpDebug (const Proto *f, DumpState *D) {
+  int i, n;
+  n = (D->strip) ? 0 : f->sizelineinfo;
+  DumpInt(n, D);
+  DumpVector(f->lineinfo, n, D);
+  n = (D->strip) ? 0 : f->sizelocvars;
+  DumpInt(n, D);
+  for (i = 0; i < n; i++) {
+    DumpString(f->locvars[i].varname, D);
+    DumpInt(f->locvars[i].startpc, D);
+    DumpInt(f->locvars[i].endpc, D);
+  }
+  n = (D->strip) ? 0 : f->sizeupvalues;
+  DumpInt(n, D);
+  for (i = 0; i < n; i++)
+    DumpString(f->upvalues[i].name, D);
+}
+
+
+static void DumpFunction (const Proto *f, TString *psource, DumpState *D) {
+  if (D->strip || f->source == psource)
+    DumpString(NULL, D);  /* no debug info or same source as its parent */
+  else
+    DumpString(f->source, D);
+  DumpInt(f->linedefined, D);
+  DumpInt(f->lastlinedefined, D);
+  DumpByte(f->numparams, D);
+  DumpByte(f->is_vararg, D);
+  DumpByte(f->maxstacksize, D);
+  DumpCode(f, D);
+  DumpConstants(f, D);
+  DumpUpvalues(f, D);
+  DumpProtos(f, D);
+  DumpDebug(f, D);
+}
+
+
+static void DumpHeader (DumpState *D) {
+  DumpLiteral(LUA_SIGNATURE, D);
+  DumpByte(LUAC_VERSION, D);
+  DumpByte(LUAC_FORMAT, D);
+  DumpLiteral(LUAC_DATA, D);
+  DumpByte(sizeof(int), D);
+  DumpByte(sizeof(size_t), D);
+  DumpByte(sizeof(Instruction), D);
+  DumpByte(sizeof(lua_Integer), D);
+  DumpByte(sizeof(lua_Number), D);
+  DumpInteger(LUAC_INT, D);
+  DumpNumber(LUAC_NUM, D);
+}
+
+
 /*
 ** dump Lua function as precompiled chunk
 */
-int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
-{
- DumpState D;
- D.L=L;
- D.writer=w;
- D.data=data;
- D.strip=strip;
- D.status=0;
- DumpHeader(&D);
- DumpFunction(f,&D);
- return D.status;
+int luaU_dump(lua_State *L, const Proto *f, lua_Writer w, void *data,
+              int strip) {
+  DumpState D;
+  D.L = L;
+  D.writer = w;
+  D.data = data;
+  D.strip = strip;
+  D.status = 0;
+  DumpHeader(&D);
+  DumpByte(f->sizeupvalues, &D);
+  DumpFunction(f, NULL, &D);
+  return D.status;
 }
+
diff -urN rpm-5.4.15/lua/lfunc.c rpm-5.4-cvs/lua/lfunc.c
--- rpm-5.4.15/lua/lfunc.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lfunc.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,15 +1,17 @@
 /*
-** $Id: lfunc.c,v 2.30 2012/10/03 12:36:46 roberto Exp $
+** $Id: lfunc.c,v 2.45 2014/11/02 19:19:04 roberto Exp $
 ** Auxiliary functions to manipulate prototypes and closures
 ** See Copyright Notice in lua.h
 */
 
-
-#include <stddef.h>
-
 #define lfunc_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <stddef.h>
+
 #include "lua.h"
 
 #include "lfunc.h"
@@ -20,95 +22,83 @@
 
 
 
-Closure *luaF_newCclosure (lua_State *L, int n) {
-  Closure *c = &luaC_newobj(L, LUA_TCCL, sizeCclosure(n), NULL, 0)->cl;
-  c->c.nupvalues = cast_byte(n);
+CClosure *luaF_newCclosure (lua_State *L, int n) {
+  GCObject *o = luaC_newobj(L, LUA_TCCL, sizeCclosure(n));
+  CClosure *c = gco2ccl(o);
+  c->nupvalues = cast_byte(n);
   return c;
 }
 
 
-Closure *luaF_newLclosure (lua_State *L, int n) {
-  Closure *c = &luaC_newobj(L, LUA_TLCL, sizeLclosure(n), NULL, 0)->cl;
-  c->l.p = NULL;
-  c->l.nupvalues = cast_byte(n);
-  while (n--) c->l.upvals[n] = NULL;
+LClosure *luaF_newLclosure (lua_State *L, int n) {
+  GCObject *o = luaC_newobj(L, LUA_TLCL, sizeLclosure(n));
+  LClosure *c = gco2lcl(o);
+  c->p = NULL;
+  c->nupvalues = cast_byte(n);
+  while (n--) c->upvals[n] = NULL;
   return c;
 }
 
-
-UpVal *luaF_newupval (lua_State *L) {
-  UpVal *uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), NULL, 0)->uv;
-  uv->v = &uv->u.value;
-  setnilvalue(uv->v);
-  return uv;
+/*
+** fill a closure with new closed upvalues
+*/
+void luaF_initupvals (lua_State *L, LClosure *cl) {
+  int i;
+  for (i = 0; i < cl->nupvalues; i++) {
+    UpVal *uv = luaM_new(L, UpVal);
+    uv->refcount = 1;
+    uv->v = &uv->u.value;  /* make it closed */
+    setnilvalue(uv->v);
+    cl->upvals[i] = uv;
+  }
 }
 
 
 UpVal *luaF_findupval (lua_State *L, StkId level) {
-  global_State *g = G(L);
-  GCObject **pp = &L->openupval;
+  UpVal **pp = &L->openupval;
   UpVal *p;
   UpVal *uv;
-  while (*pp != NULL && (p = gco2uv(*pp))->v >= level) {
-    GCObject *o = obj2gco(p);
-    lua_assert(p->v != &p->u.value);
-    lua_assert(!isold(o) || isold(obj2gco(L)));
-    if (p->v == level) {  /* found a corresponding upvalue? */
-      if (isdead(g, o))  /* is it dead? */
-        changewhite(o);  /* resurrect it */
-      return p;
-    }
-    pp = &p->next;
+  lua_assert(isintwups(L) || L->openupval == NULL);
+  while (*pp != NULL && (p = *pp)->v >= level) {
+    lua_assert(upisopen(p));
+    if (p->v == level)  /* found a corresponding upvalue? */
+      return p;  /* return it */
+    pp = &p->u.open.next;
   }
-  /* not found: create a new one */
-  uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), pp, 0)->uv;
+  /* not found: create a new upvalue */
+  uv = luaM_new(L, UpVal);
+  uv->refcount = 0;
+  uv->u.open.next = *pp;  /* link it to list of open upvalues */
+  uv->u.open.touched = 1;
+  *pp = uv;
   uv->v = level;  /* current value lives in the stack */
-  uv->u.l.prev = &g->uvhead;  /* double link it in `uvhead' list */
-  uv->u.l.next = g->uvhead.u.l.next;
-  uv->u.l.next->u.l.prev = uv;
-  g->uvhead.u.l.next = uv;
-  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  if (!isintwups(L)) {  /* thread not in list of threads with upvalues? */
+    L->twups = G(L)->twups;  /* link it to the list */
+    G(L)->twups = L;
+  }
   return uv;
 }
 
 
-static void unlinkupval (UpVal *uv) {
-  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
-  uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
-  uv->u.l.prev->u.l.next = uv->u.l.next;
-}
-
-
-void luaF_freeupval (lua_State *L, UpVal *uv) {
-  if (uv->v != &uv->u.value)  /* is it open? */
-    unlinkupval(uv);  /* remove from open list */
-  luaM_free(L, uv);  /* free upvalue */
-}
-
-
 void luaF_close (lua_State *L, StkId level) {
   UpVal *uv;
-  global_State *g = G(L);
-  while (L->openupval != NULL && (uv = gco2uv(L->openupval))->v >= level) {
-    GCObject *o = obj2gco(uv);
-    lua_assert(!isblack(o) && uv->v != &uv->u.value);
-    L->openupval = uv->next;  /* remove from `open' list */
-    if (isdead(g, o))
-      luaF_freeupval(L, uv);  /* free upvalue */
+  while (L->openupval != NULL && (uv = L->openupval)->v >= level) {
+    lua_assert(upisopen(uv));
+    L->openupval = uv->u.open.next;  /* remove from 'open' list */
+    if (uv->refcount == 0)  /* no references? */
+      luaM_free(L, uv);  /* free upvalue */
     else {
-      unlinkupval(uv);  /* remove upvalue from 'uvhead' list */
       setobj(L, &uv->u.value, uv->v);  /* move value to upvalue slot */
       uv->v = &uv->u.value;  /* now current value lives here */
-      gch(o)->next = g->allgc;  /* link upvalue into 'allgc' list */
-      g->allgc = o;
-      luaC_checkupvalcolor(g, uv);
+      luaC_upvalbarrier(L, uv);
     }
   }
 }
 
 
 Proto *luaF_newproto (lua_State *L) {
-  Proto *f = &luaC_newobj(L, LUA_TPROTO, sizeof(Proto), NULL, 0)->p;
+  GCObject *o = luaC_newobj(L, LUA_TPROTO, sizeof(Proto));
+  Proto *f = gco2p(o);
   f->k = NULL;
   f->sizek = 0;
   f->p = NULL;
@@ -144,7 +134,7 @@
 
 
 /*
-** Look for n-th local variable at line `line' in function `func'.
+** Look for n-th local variable at line 'line' in function 'func'.
 ** Returns NULL if not found.
 */
 const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
diff -urN rpm-5.4.15/lua/lfunc.h rpm-5.4-cvs/lua/lfunc.h
--- rpm-5.4.15/lua/lfunc.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lfunc.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lfunc.h,v 2.8 2012/05/08 13:53:33 roberto Exp $
+** $Id: lfunc.h,v 2.14 2014/06/19 18:27:20 roberto Exp $
 ** Auxiliary functions to manipulate prototypes and closures
 ** See Copyright Notice in lua.h
 */
@@ -18,16 +18,38 @@
                          cast(int, sizeof(TValue *)*((n)-1)))
 
 
+/* test whether thread is in 'twups' list */
+#define isintwups(L)	(L->twups != L)
+
+
+/*
+** Upvalues for Lua closures
+*/
+struct UpVal {
+  TValue *v;  /* points to stack or to its own value */
+  lu_mem refcount;  /* reference counter */
+  union {
+    struct {  /* (when open) */
+      UpVal *next;  /* linked list */
+      int touched;  /* mark to avoid cycles with dead threads */
+    } open;
+    TValue value;  /* the value (when closed) */
+  } u;
+};
+
+#define upisopen(up)	((up)->v != &(up)->u.value)
+
+
 LUAI_FUNC Proto *luaF_newproto (lua_State *L);
-LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems);
-LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems);
-LUAI_FUNC UpVal *luaF_newupval (lua_State *L);
+LUAI_FUNC CClosure *luaF_newCclosure (lua_State *L, int nelems);
+LUAI_FUNC LClosure *luaF_newLclosure (lua_State *L, int nelems);
+LUAI_FUNC void luaF_initupvals (lua_State *L, LClosure *cl);
 LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
 LUAI_FUNC void luaF_close (lua_State *L, StkId level);
 LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
-LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
 LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
-                                         int pc);
+                                         int pc)
+			LUA_GNUC_PURE;
 
 
 #endif
diff -urN rpm-5.4.15/lua/lgc.c rpm-5.4-cvs/lua/lgc.c
--- rpm-5.4.15/lua/lgc.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lgc.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,14 +1,17 @@
 /*
-** $Id: lgc.c,v 2.140 2013/03/16 21:10:18 roberto Exp $
+** $Id: lgc.c,v 2.201 2014/12/20 13:58:15 roberto Exp $
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */
 
-#include <string.h>
-
 #define lgc_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <string.h>
+
 #include "lua.h"
 
 #include "ldebug.h"
@@ -23,6 +26,11 @@
 #include "ltm.h"
 
 
+/*
+** internal state for collector while inside the atomic phase. The
+** collector should never be in this state while running regular code.
+*/
+#define GCSinsideatomic		(GCSpause + 1)
 
 /*
 ** cost of sweeping one element (the size of a small object divided
@@ -33,8 +41,8 @@
 /* maximum number of elements to sweep in each single step */
 #define GCSWEEPMAX	(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))
 
-/* maximum number of finalizers to call in each GC step */
-#define GCFINALIZENUM	4
+/* cost of calling one finalizer */
+#define GCFINALIZECOST	GCSWEEPCOST
 
 
 /*
@@ -52,18 +60,18 @@
 
 
 /*
-** 'makewhite' erases all color bits plus the old bit and then
-** sets only the current white bit
+** 'makewhite' erases all color bits then sets only the current white
+** bit
 */
-#define maskcolors	(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))
+#define maskcolors	(~(bitmask(BLACKBIT) | WHITEBITS))
 #define makewhite(g,x)	\
- (gch(x)->marked = cast_byte((gch(x)->marked & maskcolors) | luaC_white(g)))
+ (x->marked = cast_byte((x->marked & maskcolors) | luaC_white(g)))
 
-#define white2gray(x)	resetbits(gch(x)->marked, WHITEBITS)
-#define black2gray(x)	resetbit(gch(x)->marked, BLACKBIT)
+#define white2gray(x)	resetbits(x->marked, WHITEBITS)
+#define black2gray(x)	resetbit(x->marked, BLACKBIT)
 
 
-#define isfinalized(x)		testbit(gch(x)->marked, FINALIZEDBIT)
+#define valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))
 
 #define checkdeadkey(n)	lua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))
 
@@ -75,8 +83,8 @@
 #define markvalue(g,o) { checkconsistency(o); \
   if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }
 
-#define markobject(g,t) { if ((t) && iswhite(obj2gco(t))) \
-		reallymarkobject(g, obj2gco(t)); }
+#define markobject(g,t) \
+  { if ((t) && iswhite(t)) reallymarkobject(g, obj2gco(t)); }
 
 static void reallymarkobject (global_State *g, GCObject *o);
 
@@ -95,9 +103,9 @@
 
 
 /*
-** link table 'h' into list pointed by 'p'
+** link collectable object 'o' into list pointed by 'p'
 */
-#define linktable(h,p)	((h)->gclist = *(p), *(p) = obj2gco(h))
+#define linkgclist(o,p)	((o)->gclist = (p), (p) = obj2gco(o))
 
 
 /*
@@ -107,21 +115,21 @@
 static void removeentry (Node *n) {
   lua_assert(ttisnil(gval(n)));
   if (valiswhite(gkey(n)))
-    setdeadvalue(gkey(n));  /* unused and unmarked key; remove it */
+    setdeadvalue(wgkey(n));  /* unused and unmarked key; remove it */
 }
 
 
 /*
 ** tells whether a key or value can be cleared from a weak
 ** table. Non-collectable objects are never removed from weak
-** tables. Strings behave as `values', so are never removed too. for
+** tables. Strings behave as 'values', so are never removed too. for
 ** other objects: if really collected, cannot keep them; for objects
 ** being finalized, keep them in keys, but not in values
 */
 static int iscleared (global_State *g, const TValue *o) {
   if (!iscollectable(o)) return 0;
   else if (ttisstring(o)) {
-    markobject(g, rawtsvalue(o));  /* strings are `values', so are never weak */
+    markobject(g, tsvalue(o));  /* strings are 'values', so are never weak */
     return 0;
   }
   else return iswhite(gcvalue(o));
@@ -130,14 +138,14 @@
 
 /*
 ** barrier that moves collector forward, that is, mark the white object
-** being pointed by a black object.
+** being pointed by a black object. (If in sweep phase, clear the black
+** object to white [sweep it] to avoid other barrier calls for this
+** same object.)
 */
 void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
   global_State *g = G(L);
   lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
-  lua_assert(g->gcstate != GCSpause);
-  lua_assert(gch(o)->tt != LUA_TTABLE);
-  if (keepinvariantout(g))  /* must keep invariant? */
+  if (keepinvariant(g))  /* must keep invariant? */
     reallymarkobject(g, v);  /* restore invariant */
   else {  /* sweep phase */
     lua_assert(issweepphase(g));
@@ -148,78 +156,52 @@
 
 /*
 ** barrier that moves collector backward, that is, mark the black object
-** pointing to a white object as gray again. (Current implementation
-** only works for tables; access to 'gclist' is not uniform across
-** different types.)
+** pointing to a white object as gray again.
 */
-void luaC_barrierback_ (lua_State *L, GCObject *o) {
+void luaC_barrierback_ (lua_State *L, Table *t) {
   global_State *g = G(L);
-  lua_assert(isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE);
-  black2gray(o);  /* make object gray (again) */
-  gco2t(o)->gclist = g->grayagain;
-  g->grayagain = o;
+  lua_assert(isblack(t) && !isdead(g, t));
+  black2gray(t);  /* make table gray (again) */
+  linkgclist(t, g->grayagain);
 }
 
 
 /*
-** barrier for prototypes. When creating first closure (cache is
-** NULL), use a forward barrier; this may be the only closure of the
-** prototype (if it is a "regular" function, with a single instance)
-** and the prototype may be big, so it is better to avoid traversing
-** it again. Otherwise, use a backward barrier, to avoid marking all
-** possible instances.
+** barrier for assignments to closed upvalues. Because upvalues are
+** shared among closures, it is impossible to know the color of all
+** closures pointing to it. So, we assume that the object being assigned
+** must be marked.
 */
-LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c) {
+void luaC_upvalbarrier_ (lua_State *L, UpVal *uv) {
   global_State *g = G(L);
-  lua_assert(isblack(obj2gco(p)));
-  if (p->cache == NULL) {  /* first time? */
-    luaC_objbarrier(L, p, c);
-  }
-  else {  /* use a backward barrier */
-    black2gray(obj2gco(p));  /* make prototype gray (again) */
-    p->gclist = g->grayagain;
-    g->grayagain = obj2gco(p);
-  }
+  GCObject *o = gcvalue(uv->v);
+  lua_assert(!upisopen(uv));  /* ensured by macro luaC_upvalbarrier */
+  if (keepinvariant(g))
+    markobject(g, o);
 }
 
 
-/*
-** check color (and invariants) for an upvalue that was closed,
-** i.e., moved into the 'allgc' list
-*/
-void luaC_checkupvalcolor (global_State *g, UpVal *uv) {
-  GCObject *o = obj2gco(uv);
-  lua_assert(!isblack(o));  /* open upvalues are never black */
-  if (isgray(o)) {
-    if (keepinvariant(g)) {
-      resetoldbit(o);  /* see MOVE OLD rule */
-      gray2black(o);  /* it is being visited now */
-      markvalue(g, uv->v);
-    }
-    else {
-      lua_assert(issweepphase(g));
-      makewhite(g, o);
-    }
-  }
+void luaC_fix (lua_State *L, GCObject *o) {
+  global_State *g = G(L);
+  lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */
+  white2gray(o);  /* they will be gray forever */
+  g->allgc = o->next;  /* remove object from 'allgc' list */
+  o->next = g->fixedgc;  /* link it to 'fixedgc' list */
+  g->fixedgc = o;
 }
 
 
 /*
 ** create a new collectable object (with given type and size) and link
-** it to '*list'. 'offset' tells how many bytes to allocate before the
-** object itself (used only by states).
+** it to 'allgc' list.
 */
-GCObject *luaC_newobj (lua_State *L, int tt, size_t sz, GCObject **list,
-                       int offset) {
+GCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {
   global_State *g = G(L);
-  char *raw = cast(char *, luaM_newobject(L, novariant(tt), sz));
-  GCObject *o = obj2gco(raw + offset);
-  if (list == NULL)
-    list = &g->allgc;  /* standard list for collectable objects */
-  gch(o)->marked = luaC_white(g);
-  gch(o)->tt = tt;
-  gch(o)->next = *list;
-  *list = o;
+  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));
+  o->marked = luaC_white(g);
+  o->tt = tt;
+  o->next = g->allgc;
+  g->allgc = o;
   return o;
 }
 
@@ -241,57 +223,49 @@
 ** upvalues are already linked in 'headuv' list.)
 */
 static void reallymarkobject (global_State *g, GCObject *o) {
-  lu_mem size;
+ reentry:
   white2gray(o);
-  switch (gch(o)->tt) {
+  switch (o->tt) {
     case LUA_TSHRSTR:
     case LUA_TLNGSTR: {
-      size = sizestring(gco2ts(o));
-      break;  /* nothing else to mark; make it black */
-    }
-    case LUA_TUSERDATA: {
-      Table *mt = gco2u(o)->metatable;
-      markobject(g, mt);
-      markobject(g, gco2u(o)->env);
-      size = sizeudata(gco2u(o));
+      gray2black(o);
+      g->GCmemtrav += sizestring(gco2ts(o));
       break;
     }
-    case LUA_TUPVAL: {
-      UpVal *uv = gco2uv(o);
-      markvalue(g, uv->v);
-      if (uv->v != &uv->u.value)  /* open? */
-        return;  /* open upvalues remain gray */
-      size = sizeof(UpVal);
+    case LUA_TUSERDATA: {
+      TValue uvalue;
+      markobject(g, gco2u(o)->metatable);  /* mark its metatable */
+      gray2black(o);
+      g->GCmemtrav += sizeudata(gco2u(o));
+      getuservalue(g->mainthread, gco2u(o), &uvalue);
+      if (valiswhite(&uvalue)) {  /* markvalue(g, &uvalue); */
+        o = gcvalue(&uvalue);
+        goto reentry;
+      }
       break;
     }
     case LUA_TLCL: {
-      gco2lcl(o)->gclist = g->gray;
-      g->gray = o;
-      return;
+      linkgclist(gco2lcl(o), g->gray);
+      break;
     }
     case LUA_TCCL: {
-      gco2ccl(o)->gclist = g->gray;
-      g->gray = o;
-      return;
+      linkgclist(gco2ccl(o), g->gray);
+      break;
     }
     case LUA_TTABLE: {
-      linktable(gco2t(o), &g->gray);
-      return;
+      linkgclist(gco2t(o), g->gray);
+      break;
     }
     case LUA_TTHREAD: {
-      gco2th(o)->gclist = g->gray;
-      g->gray = o;
-      return;
+      linkgclist(gco2th(o), g->gray);
+      break;
     }
     case LUA_TPROTO: {
-      gco2p(o)->gclist = g->gray;
-      g->gray = o;
-      return;
+      linkgclist(gco2p(o), g->gray);
+      break;
     }
-    default: lua_assert(0); return;
+    default: lua_assert(0); break;
   }
-  gray2black(o);
-  g->GCmemtrav += size;
 }
 
 
@@ -310,29 +284,41 @@
 */
 static void markbeingfnz (global_State *g) {
   GCObject *o;
-  for (o = g->tobefnz; o != NULL; o = gch(o)->next) {
-    makewhite(g, o);
-    reallymarkobject(g, o);
-  }
+  for (o = g->tobefnz; o != NULL; o = o->next)
+    markobject(g, o);
 }
 
 
 /*
-** mark all values stored in marked open upvalues. (See comment in
-** 'lstate.h'.)
+** Mark all values stored in marked open upvalues from non-marked threads.
+** (Values from marked threads were already marked when traversing the
+** thread.) Remove from the list threads that no longer have upvalues and
+** not-marked threads.
 */
 static void remarkupvals (global_State *g) {
-  UpVal *uv;
-  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
-    if (isgray(obj2gco(uv)))
-      markvalue(g, uv->v);
+  lua_State *thread;
+  lua_State **p = &g->twups;
+  while ((thread = *p) != NULL) {
+    lua_assert(!isblack(thread));  /* threads are never black */
+    if (isgray(thread) && thread->openupval != NULL)
+      p = &thread->twups;  /* keep marked thread with upvalues in the list */
+    else {  /* thread is not marked or without upvalues */
+      UpVal *uv;
+      *p = thread->twups;  /* remove thread from the list */
+      thread->twups = thread;  /* mark that it is out of list */
+      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {
+        if (uv->u.open.touched) {
+          markvalue(g, uv->v);  /* remark upvalue's value */
+          uv->u.open.touched = 0;
+        }
+      }
+    }
   }
 }
 
 
 /*
-** mark root set and reset all gray lists, to start a new
-** incremental (or full) collection
+** mark root set and reset all gray lists, to start a new collection
 */
 static void restartcollection (global_State *g) {
   g->gray = g->grayagain = NULL;
@@ -352,12 +338,18 @@
 ** =======================================================
 */
 
+/*
+** Traverse a table with weak values and link it to proper list. During
+** propagate phase, keep it in 'grayagain' list, to be revisited in the
+** atomic phase. In the atomic phase, if table has any white value,
+** put it in 'weak' list, to be cleared.
+*/
 static void traverseweakvalue (global_State *g, Table *h) {
   Node *n, *limit = gnodelast(h);
-  /* if there is array part, assume it may have white values (do not
-     traverse it just to check) */
+  /* if there is array part, assume it may have white values (it is not
+     worth traversing it now just to check) */
   int hasclears = (h->sizearray > 0);
-  for (n = gnode(h, 0); n < limit; n++) {
+  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
     checkdeadkey(n);
     if (ttisnil(gval(n)))  /* entry is empty? */
       removeentry(n);  /* remove it */
@@ -368,20 +360,30 @@
         hasclears = 1;  /* table will have to be cleared */
     }
   }
-  if (hasclears)
-    linktable(h, &g->weak);  /* has to be cleared later */
-  else  /* no white values */
-    linktable(h, &g->grayagain);  /* no need to clean */
+  if (g->gcstate == GCSpropagate)
+    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
+  else if (hasclears)
+    linkgclist(h, g->weak);  /* has to be cleared later */
 }
 
 
+/*
+** Traverse an ephemeron table and link it to proper list. Returns true
+** iff any object was marked during this traversal (which implies that
+** convergence has to continue). During propagation phase, keep table
+** in 'grayagain' list, to be visited again in the atomic phase. In
+** the atomic phase, if table has any white->white entry, it has to
+** be revisited during ephemeron convergence (as that key may turn
+** black). Otherwise, if it has any white key, table has to be cleared
+** (in the atomic phase).
+*/
 static int traverseephemeron (global_State *g, Table *h) {
   int marked = 0;  /* true if an object is marked in this traversal */
   int hasclears = 0;  /* true if table has white keys */
-  int prop = 0;  /* true if table has entry "white-key -> white-value" */
+  int hasww = 0;  /* true if table has entry "white-key -> white-value" */
   Node *n, *limit = gnodelast(h);
-  int i;
-  /* traverse array part (numeric keys are 'strong') */
+  unsigned int i;
+  /* traverse array part */
   for (i = 0; i < h->sizearray; i++) {
     if (valiswhite(&h->array[i])) {
       marked = 1;
@@ -396,26 +398,27 @@
     else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */
       hasclears = 1;  /* table must be cleared */
       if (valiswhite(gval(n)))  /* value not marked yet? */
-        prop = 1;  /* must propagate again */
+        hasww = 1;  /* white-white entry */
     }
     else if (valiswhite(gval(n))) {  /* value not marked yet? */
       marked = 1;
       reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
     }
   }
-  if (prop)
-    linktable(h, &g->ephemeron);  /* have to propagate again */
-  else if (hasclears)  /* does table have white keys? */
-    linktable(h, &g->allweak);  /* may have to clean white keys */
-  else  /* no white keys */
-    linktable(h, &g->grayagain);  /* no need to clean */
+  /* link table into proper list */
+  if (g->gcstate == GCSpropagate)
+    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
+  else if (hasww)  /* table has white->white entries? */
+    linkgclist(h, g->ephemeron);  /* have to propagate again */
+  else if (hasclears)  /* table has white keys? */
+    linkgclist(h, g->allweak);  /* may have to clean white keys */
   return marked;
 }
 
 
 static void traversestrongtable (global_State *g, Table *h) {
   Node *n, *limit = gnodelast(h);
-  int i;
+  unsigned int i;
   for (i = 0; i < h->sizearray; i++)  /* traverse array part */
     markvalue(g, &h->array[i]);
   for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
@@ -439,13 +442,13 @@
       ((weakkey = strchr(svalue(mode), 'k')),
        (weakvalue = strchr(svalue(mode), 'v')),
        (weakkey || weakvalue))) {  /* is really weak? */
-    black2gray(obj2gco(h));  /* keep table gray */
+    black2gray(h);  /* keep table gray */
     if (!weakkey)  /* strong keys? */
       traverseweakvalue(g, h);
     else if (!weakvalue)  /* strong values? */
       traverseephemeron(g, h);
     else  /* all weak */
-      linktable(h, &g->allweak);  /* nothing to traverse now */
+      linkgclist(h, g->allweak);  /* nothing to traverse now */
   }
   else  /* not weak */
     traversestrongtable(g, h);
@@ -456,7 +459,7 @@
 
 static int traverseproto (global_State *g, Proto *f) {
   int i;
-  if (f->cache && iswhite(obj2gco(f->cache)))
+  if (f->cache && iswhite(f->cache))
     f->cache = NULL;  /* allow cache to be collected */
   markobject(g, f->source);
   for (i = 0; i < f->sizek; i++)  /* mark literals */
@@ -483,27 +486,49 @@
   return sizeCclosure(cl->nupvalues);
 }
 
+/*
+** open upvalues point to values in a thread, so those values should
+** be marked when the thread is traversed except in the atomic phase
+** (because then the value cannot be changed by the thread and the
+** thread may not be traversed again)
+*/
 static lu_mem traverseLclosure (global_State *g, LClosure *cl) {
   int i;
   markobject(g, cl->p);  /* mark its prototype */
-  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
-    markobject(g, cl->upvals[i]);
+  for (i = 0; i < cl->nupvalues; i++) {  /* mark its upvalues */
+    UpVal *uv = cl->upvals[i];
+    if (uv != NULL) {
+      if (upisopen(uv) && g->gcstate != GCSinsideatomic)
+        uv->u.open.touched = 1;  /* can be marked in 'remarkupvals' */
+      else
+        markvalue(g, uv->v);
+    }
+  }
   return sizeLclosure(cl->nupvalues);
 }
 
 
-static lu_mem traversestack (global_State *g, lua_State *th) {
+static lu_mem traversethread (global_State *g, lua_State *th) {
   StkId o = th->stack;
   if (o == NULL)
     return 1;  /* stack not completely built yet */
-  for (; o < th->top; o++)
+  lua_assert(g->gcstate == GCSinsideatomic ||
+             th->openupval == NULL || isintwups(th));
+  for (; o < th->top; o++)  /* mark live elements in the stack */
     markvalue(g, o);
-  if (g->gcstate == GCSatomic) {  /* final traversal? */
+  if (g->gcstate == GCSinsideatomic) {  /* final traversal? */
     StkId lim = th->stack + th->stacksize;  /* real end of stack */
     for (; o < lim; o++)  /* clear not-marked stack slice */
       setnilvalue(o);
+    /* 'remarkupvals' may have removed thread from 'twups' list */ 
+    if (!isintwups(th) && th->openupval != NULL) {
+      th->twups = g->twups;  /* link it back to the list */
+      g->twups = th;
+    }
   }
-  return sizeof(lua_State) + sizeof(TValue) * th->stacksize;
+  else if (g->gckind != KGC_EMERGENCY)
+    luaD_shrinkstack(th); /* do not change stack in emergency cycle */
+  return (sizeof(lua_State) + sizeof(TValue) * th->stacksize);
 }
 
 
@@ -516,7 +541,7 @@
   GCObject *o = g->gray;
   lua_assert(isgray(o));
   gray2black(o);
-  switch (gch(o)->tt) {
+  switch (o->tt) {
     case LUA_TTABLE: {
       Table *h = gco2t(o);
       g->gray = h->gclist;  /* remove from 'gray' list */
@@ -538,10 +563,9 @@
     case LUA_TTHREAD: {
       lua_State *th = gco2th(o);
       g->gray = th->gclist;  /* remove from 'gray' list */
-      th->gclist = g->grayagain;
-      g->grayagain = o;  /* insert into 'grayagain' list */
+      linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */
       black2gray(o);
-      size = traversestack(g, th);
+      size = traversethread(g, th);
       break;
     }
     case LUA_TPROTO: {
@@ -561,35 +585,12 @@
 }
 
 
-static void propagatelist (global_State *g, GCObject *l) {
-  lua_assert(g->gray == NULL);  /* no grays left */
-  g->gray = l;
-  propagateall(g);  /* traverse all elements from 'l' */
-}
-
-/*
-** retraverse all gray lists. Because tables may be reinserted in other
-** lists when traversed, traverse the original lists to avoid traversing
-** twice the same table (which is not wrong, but inefficient)
-*/
-static void retraversegrays (global_State *g) {
-  GCObject *weak = g->weak;  /* save original lists */
-  GCObject *grayagain = g->grayagain;
-  GCObject *ephemeron = g->ephemeron;
-  g->weak = g->grayagain = g->ephemeron = NULL;
-  propagateall(g);  /* traverse main gray list */
-  propagatelist(g, grayagain);
-  propagatelist(g, weak);
-  propagatelist(g, ephemeron);
-}
-
-
 static void convergeephemerons (global_State *g) {
   int changed;
   do {
     GCObject *w;
     GCObject *next = g->ephemeron;  /* get ephemeron list */
-    g->ephemeron = NULL;  /* tables will return to this list when traversed */
+    g->ephemeron = NULL;  /* tables may return to this list when traversed */
     changed = 0;
     while ((w = next) != NULL) {
       next = gco2t(w)->gclist;
@@ -637,7 +638,7 @@
   for (; l != f; l = gco2t(l)->gclist) {
     Table *h = gco2t(l);
     Node *n, *limit = gnodelast(h);
-    int i;
+    unsigned int i;
     for (i = 0; i < h->sizearray; i++) {
       TValue *o = &h->array[i];
       if (iscleared(g, o))  /* value was collected? */
@@ -653,23 +654,41 @@
 }
 
 
+void luaC_upvdeccount (lua_State *L, UpVal *uv) {
+  lua_assert(uv->refcount > 0);
+  uv->refcount--;
+  if (uv->refcount == 0 && !upisopen(uv))
+    luaM_free(L, uv);
+}
+
+
+static void freeLclosure (lua_State *L, LClosure *cl) {
+  int i;
+  for (i = 0; i < cl->nupvalues; i++) {
+    UpVal *uv = cl->upvals[i];
+    if (uv)
+      luaC_upvdeccount(L, uv);
+  }
+  luaM_freemem(L, cl, sizeLclosure(cl->nupvalues));
+}
+
+
 static void freeobj (lua_State *L, GCObject *o) {
-  switch (gch(o)->tt) {
+  switch (o->tt) {
     case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
     case LUA_TLCL: {
-      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));
+      freeLclosure(L, gco2lcl(o));
       break;
     }
     case LUA_TCCL: {
       luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));
       break;
     }
-    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;
     case LUA_TTABLE: luaH_free(L, gco2t(o)); break;
     case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;
     case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;
     case LUA_TSHRSTR:
-      G(L)->strt.nuse--;
+      luaS_remove(L, gco2ts(o));  /* remove it from hash table */
       /* go through */
     case LUA_TLNGSTR: {
       luaM_freemem(L, o, sizestring(gco2ts(o)));
@@ -685,60 +704,26 @@
 
 
 /*
-** sweep the (open) upvalues of a thread and resize its stack and
-** list of call-info structures.
-*/
-static void sweepthread (lua_State *L, lua_State *L1) {
-  if (L1->stack == NULL) return;  /* stack not completely built yet */
-  sweepwholelist(L, &L1->openupval);  /* sweep open upvalues */
-  luaE_freeCI(L1);  /* free extra CallInfo slots */
-  /* should not change the stack during an emergency gc cycle */
-  if (G(L)->gckind != KGC_EMERGENCY)
-    luaD_shrinkstack(L1);
-}
-
-
-/*
 ** sweep at most 'count' elements from a list of GCObjects erasing dead
-** objects, where a dead (not alive) object is one marked with the "old"
-** (non current) white and not fixed.
-** In non-generational mode, change all non-dead objects back to white,
-** preparing for next collection cycle.
-** In generational mode, keep black objects black, and also mark them as
-** old; stop when hitting an old object, as all objects after that
-** one will be old too.
-** When object is a thread, sweep its list of open upvalues too.
+** objects, where a dead object is one marked with the old (non current)
+** white; change all non-dead objects back to white, preparing for next
+** collection cycle. Return where to continue the traversal or NULL if
+** list is finished.
 */
 static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
   global_State *g = G(L);
   int ow = otherwhite(g);
-  int toclear, toset;  /* bits to clear and to set in all live objects */
-  int tostop;  /* stop sweep when this is true */
-  if (isgenerational(g)) {  /* generational mode? */
-    toclear = ~0;  /* clear nothing */
-    toset = bitmask(OLDBIT);  /* set the old bit of all surviving objects */
-    tostop = bitmask(OLDBIT);  /* do not sweep old generation */
-  }
-  else {  /* normal mode */
-    toclear = maskcolors;  /* clear all color bits + old bit */
-    toset = luaC_white(g);  /* make object white */
-    tostop = 0;  /* do not stop */
-  }
+  int white = luaC_white(g);  /* current white */
   while (*p != NULL && count-- > 0) {
     GCObject *curr = *p;
-    int marked = gch(curr)->marked;
+    int marked = curr->marked;
     if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
-      *p = gch(curr)->next;  /* remove 'curr' from list */
+      *p = curr->next;  /* remove 'curr' from list */
       freeobj(L, curr);  /* erase 'curr' */
     }
-    else {
-      if (testbits(marked, tostop))
-        return NULL;  /* stop sweeping this list */
-      if (gch(curr)->tt == LUA_TTHREAD)
-        sweepthread(L, gco2th(curr));  /* sweep thread's upvalues */
-      /* update marks */
-      gch(curr)->marked = cast_byte((marked & toclear) | toset);
-      p = &gch(curr)->next;  /* go to next element */
+    else {  /* change mark to 'white' */
+      curr->marked = cast_byte((marked & maskcolors) | white);
+      p = &curr->next;  /* go to next element */
     }
   }
   return (*p == NULL) ? NULL : p;
@@ -749,7 +734,7 @@
 ** sweep a list until a live object (or end of list)
 */
 static GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {
-  GCObject ** old = p;
+  GCObject **old = p;
   int i = 0;
   do {
     i++;
@@ -768,26 +753,28 @@
 ** =======================================================
 */
 
-static void checkSizes (lua_State *L) {
-  global_State *g = G(L);
-  if (g->gckind != KGC_EMERGENCY) {  /* do not change sizes in emergency */
-    int hs = g->strt.size / 2;  /* half the size of the string table */
-    if (g->strt.nuse < cast(lu_int32, hs))  /* using less than that half? */
-      luaS_resize(L, hs);  /* halve its size */
+/*
+** If possible, free concatenation buffer and shrink string table
+*/
+static void checkSizes (lua_State *L, global_State *g) {
+  if (g->gckind != KGC_EMERGENCY) {
+    l_mem olddebt = g->GCdebt;
     luaZ_freebuffer(L, &g->buff);  /* free concatenation buffer */
+    if (g->strt.nuse < g->strt.size / 4)  /* string table too big? */
+      luaS_resize(L, g->strt.size / 2);  /* shrink it a little */
+    g->GCestimate += g->GCdebt - olddebt;  /* update estimate */
   }
 }
 
 
 static GCObject *udata2finalize (global_State *g) {
   GCObject *o = g->tobefnz;  /* get first element */
-  lua_assert(isfinalized(o));
-  g->tobefnz = gch(o)->next;  /* remove it from 'tobefnz' list */
-  gch(o)->next = g->allgc;  /* return it to 'allgc' list */
+  lua_assert(tofinalize(o));
+  g->tobefnz = o->next;  /* remove it from 'tobefnz' list */
+  o->next = g->allgc;  /* return it to 'allgc' list */
   g->allgc = o;
-  resetbit(gch(o)->marked, SEPARATED);  /* mark that it is not in 'tobefnz' */
-  lua_assert(!isold(o));  /* see MOVE OLD rule */
-  if (!keepinvariantout(g))  /* not keeping invariant? */
+  resetbit(o->marked, FINALIZEDBIT);  /* object is "normal" again */
+  if (issweepphase(g))
     makewhite(g, o);  /* "sweep" object */
   return o;
 }
@@ -832,28 +819,58 @@
 
 
 /*
+** call a few (up to 'g->gcfinnum') finalizers
+*/
+static int runafewfinalizers (lua_State *L) {
+  global_State *g = G(L);
+  unsigned int i;
+  lua_assert(!g->tobefnz || g->gcfinnum > 0);
+  for (i = 0; g->tobefnz && i < g->gcfinnum; i++)
+    GCTM(L, 1);  /* call one finalizer */
+  g->gcfinnum = (!g->tobefnz) ? 0  /* nothing more to finalize? */
+                    : g->gcfinnum * 2;  /* else call a few more next time */
+  return i;
+}
+
+
+/*
+** call all pending finalizers
+*/
+static void callallpendingfinalizers (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  while (g->tobefnz)
+    GCTM(L, propagateerrors);
+}
+
+
+/*
+** find last 'next' field in list 'p' list (to add elements in its end)
+*/
+LUA_GNUC_PURE
+static GCObject **findlast (GCObject **p) {
+  while (*p != NULL)
+    p = &(*p)->next;
+  return p;
+}
+
+
+/*
 ** move all unreachable objects (or 'all' objects) that need
 ** finalization from list 'finobj' to list 'tobefnz' (to be finalized)
 */
-static void separatetobefnz (lua_State *L, int all) {
-  global_State *g = G(L);
-  GCObject **p = &g->finobj;
+static void separatetobefnz (global_State *g, int all) {
   GCObject *curr;
-  GCObject **lastnext = &g->tobefnz;
-  /* find last 'next' field in 'tobefnz' list (to add elements in its end) */
-  while (*lastnext != NULL)
-    lastnext = &gch(*lastnext)->next;
+  GCObject **p = &g->finobj;
+  GCObject **lastnext = findlast(&g->tobefnz);
   while ((curr = *p) != NULL) {  /* traverse all finalizable objects */
-    lua_assert(!isfinalized(curr));
-    lua_assert(testbit(gch(curr)->marked, SEPARATED));
+    lua_assert(tofinalize(curr));
     if (!(iswhite(curr) || all))  /* not being collected? */
-      p = &gch(curr)->next;  /* don't bother with it */
+      p = &curr->next;  /* don't bother with it */
     else {
-      l_setbit(gch(curr)->marked, FINALIZEDBIT); /* won't be finalized again */
-      *p = gch(curr)->next;  /* remove 'curr' from 'finobj' list */
-      gch(curr)->next = *lastnext;  /* link at the end of 'tobefnz' list */
+      *p = curr->next;  /* remove 'curr' from 'finobj' list */
+      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */
       *lastnext = curr;
-      lastnext = &gch(curr)->next;
+      lastnext = &curr->next;
     }
   }
 }
@@ -865,33 +882,29 @@
 */
 void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {
   global_State *g = G(L);
-  if (testbit(gch(o)->marked, SEPARATED) || /* obj. is already separated... */
-      isfinalized(o) ||                           /* ... or is finalized... */
-      gfasttm(g, mt, TM_GC) == NULL)                /* or has no finalizer? */
+  if (tofinalize(o) ||                 /* obj. is already marked... */
+      gfasttm(g, mt, TM_GC) == NULL)   /* or has no finalizer? */
     return;  /* nothing to be done */
   else {  /* move 'o' to 'finobj' list */
     GCObject **p;
-    GCheader *ho = gch(o);
-    if (g->sweepgc == &ho->next) {  /* avoid removing current sweep object */
-      lua_assert(issweepphase(g));
-      g->sweepgc = sweeptolive(L, g->sweepgc, NULL);
+    if (issweepphase(g)) {
+      makewhite(g, o);  /* "sweep" object 'o' */
+      if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */
+        g->sweepgc = sweeptolive(L, g->sweepgc, NULL);  /* change 'sweepgc' */
     }
     /* search for pointer pointing to 'o' */
-    for (p = &g->allgc; *p != o; p = &gch(*p)->next) { /* empty */ }
-    *p = ho->next;  /* remove 'o' from root list */
-    ho->next = g->finobj;  /* link it in list 'finobj' */
+    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }
+    *p = o->next;  /* remove 'o' from 'allgc' list */
+    o->next = g->finobj;  /* link it in 'finobj' list */
     g->finobj = o;
-    l_setbit(ho->marked, SEPARATED);  /* mark it as such */
-    if (!keepinvariantout(g))  /* not keeping invariant? */
-      makewhite(g, o);  /* "sweep" object */
-    else
-      resetoldbit(o);  /* see MOVE OLD rule */
+    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */
   }
 }
 
 /* }====================================================== */
 
 
+
 /*
 ** {======================================================
 ** GC control
@@ -900,127 +913,93 @@
 
 
 /*
-** set a reasonable "time" to wait before starting a new GC cycle;
-** cycle will start when memory use hits threshold
-*/
-static void setpause (global_State *g, l_mem estimate) {
-  l_mem debt, threshold;
-  estimate = estimate / PAUSEADJ;  /* adjust 'estimate' */
+** Set a reasonable "time" to wait before starting a new GC cycle; cycle
+** will start when memory use hits threshold. (Division by 'estimate'
+** should be OK: it cannot be zero (because Lua cannot even start with
+** less than PAUSEADJ bytes).
+*/
+static void setpause (global_State *g) {
+  l_mem threshold, debt;
+  l_mem estimate = g->GCestimate / PAUSEADJ;  /* adjust 'estimate' */
+  lua_assert(estimate > 0);
   threshold = (g->gcpause < MAX_LMEM / estimate)  /* overflow? */
             ? estimate * g->gcpause  /* no overflow */
             : MAX_LMEM;  /* overflow; truncate to maximum */
-  debt = -cast(l_mem, threshold - gettotalbytes(g));
+  debt = gettotalbytes(g) - threshold;
   luaE_setdebt(g, debt);
 }
 
 
-#define sweepphases  \
-	(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))
-
-
 /*
-** enter first sweep phase (strings) and prepare pointers for other
-** sweep phases.  The calls to 'sweeptolive' make pointers point to an
-** object inside the list (instead of to the header), so that the real
-** sweep do not need to skip objects created between "now" and the start
-** of the real sweep.
+** Enter first sweep phase.
+** The call to 'sweeptolive' makes pointer point to an object inside
+** the list (instead of to the header), so that the real sweep do not
+** need to skip objects created between "now" and the start of the real
+** sweep.
 ** Returns how many objects it swept.
 */
 static int entersweep (lua_State *L) {
   global_State *g = G(L);
   int n = 0;
-  g->gcstate = GCSsweepstring;
-  lua_assert(g->sweepgc == NULL && g->sweepfin == NULL);
-  /* prepare to sweep strings, finalizable objects, and regular objects */
-  g->sweepstrgc = 0;
-  g->sweepfin = sweeptolive(L, &g->finobj, &n);
+  g->gcstate = GCSswpallgc;
+  lua_assert(g->sweepgc == NULL);
   g->sweepgc = sweeptolive(L, &g->allgc, &n);
   return n;
 }
 
 
-/*
-** change GC mode
-*/
-void luaC_changemode (lua_State *L, int mode) {
-  global_State *g = G(L);
-  if (mode == g->gckind) return;  /* nothing to change */
-  if (mode == KGC_GEN) {  /* change to generational mode */
-    /* make sure gray lists are consistent */
-    luaC_runtilstate(L, bitmask(GCSpropagate));
-    g->GCestimate = gettotalbytes(g);
-    g->gckind = KGC_GEN;
-  }
-  else {  /* change to incremental mode */
-    /* sweep all objects to turn them back to white
-       (as white has not changed, nothing extra will be collected) */
-    g->gckind = KGC_NORMAL;
-    entersweep(L);
-    luaC_runtilstate(L, ~sweepphases);
-  }
-}
-
-
-/*
-** call all pending finalizers
-*/
-static void callallpendingfinalizers (lua_State *L, int propagateerrors) {
-  global_State *g = G(L);
-  while (g->tobefnz) {
-    resetoldbit(g->tobefnz);
-    GCTM(L, propagateerrors);
-  }
-}
-
-
 void luaC_freeallobjects (lua_State *L) {
   global_State *g = G(L);
-  int i;
-  separatetobefnz(L, 1);  /* separate all objects with finalizers */
+  separatetobefnz(g, 1);  /* separate all objects with finalizers */
   lua_assert(g->finobj == NULL);
   callallpendingfinalizers(L, 0);
+  lua_assert(g->tobefnz == NULL);
   g->currentwhite = WHITEBITS; /* this "white" makes all objects look dead */
   g->gckind = KGC_NORMAL;
-  sweepwholelist(L, &g->finobj);  /* finalizers can create objs. in 'finobj' */
+  sweepwholelist(L, &g->finobj);
   sweepwholelist(L, &g->allgc);
-  for (i = 0; i < g->strt.size; i++)  /* free all string lists */
-    sweepwholelist(L, &g->strt.hash[i]);
+  sweepwholelist(L, &g->fixedgc);  /* collect fixed objects */
   lua_assert(g->strt.nuse == 0);
 }
 
 
 static l_mem atomic (lua_State *L) {
   global_State *g = G(L);
-  l_mem work = -cast(l_mem, g->GCmemtrav);  /* start counting work */
+  l_mem work;
   GCObject *origweak, *origall;
-  lua_assert(!iswhite(obj2gco(g->mainthread)));
+  GCObject *grayagain = g->grayagain;  /* save original list */
+  lua_assert(g->ephemeron == NULL && g->weak == NULL);
+  lua_assert(!iswhite(g->mainthread));
+  g->gcstate = GCSinsideatomic;
+  g->GCmemtrav = 0;  /* start counting work */
   markobject(g, L);  /* mark running thread */
   /* registry and global metatables may be changed by API */
   markvalue(g, &g->l_registry);
-  markmt(g);  /* mark basic metatables */
+  markmt(g);  /* mark global metatables */
   /* remark occasional upvalues of (maybe) dead threads */
   remarkupvals(g);
   propagateall(g);  /* propagate changes */
-  work += g->GCmemtrav;  /* stop counting (do not (re)count grays) */
-  /* traverse objects caught by write barrier and by 'remarkupvals' */
-  retraversegrays(g);
-  work -= g->GCmemtrav;  /* restart counting */
+  work = g->GCmemtrav;  /* stop counting (do not recount 'grayagain') */
+  g->gray = grayagain;
+  propagateall(g);  /* traverse 'grayagain' list */
+  g->GCmemtrav = 0;  /* restart counting */
   convergeephemerons(g);
   /* at this point, all strongly accessible objects are marked. */
-  /* clear values from weak tables, before checking finalizers */
+  /* Clear values from weak tables, before checking finalizers */
   clearvalues(g, g->weak, NULL);
   clearvalues(g, g->allweak, NULL);
   origweak = g->weak; origall = g->allweak;
   work += g->GCmemtrav;  /* stop counting (objects being finalized) */
-  separatetobefnz(L, 0);  /* separate objects to be finalized */
+  separatetobefnz(g, 0);  /* separate objects to be finalized */
+  g->gcfinnum = 1;  /* there may be objects to be finalized */
   markbeingfnz(g);  /* mark objects that will be finalized */
-  propagateall(g);  /* remark, to propagate `preserveness' */
-  work -= g->GCmemtrav;  /* restart counting */
+  propagateall(g);  /* remark, to propagate 'resurrection' */
+  g->GCmemtrav = 0;  /* restart counting */
   convergeephemerons(g);
   /* at this point, all resurrected objects are marked. */
   /* remove dead objects from weak tables */
   clearkeys(g, g->ephemeron, NULL);  /* clear keys from all ephemeron tables */
-  clearkeys(g, g->allweak, NULL);  /* clear keys from all allweak tables */
+  clearkeys(g, g->allweak, NULL);  /* clear keys from all 'allweak' tables */
   /* clear values from resurrected weak tables */
   clearvalues(g, g->weak, origweak);
   clearvalues(g, g->allweak, origall);
@@ -1030,65 +1009,71 @@
 }
 
 
+static lu_mem sweepstep (lua_State *L, global_State *g,
+                         int nextstate, GCObject **nextlist) {
+  if (g->sweepgc) {
+    l_mem olddebt = g->GCdebt;
+    g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
+    g->GCestimate += g->GCdebt - olddebt;  /* update estimate */
+    if (g->sweepgc)  /* is there still something to sweep? */
+      return (GCSWEEPMAX * GCSWEEPCOST);
+  }
+  /* else enter next state */
+  g->gcstate = nextstate;
+  g->sweepgc = nextlist;
+  return 0;
+}
+
+
 static lu_mem singlestep (lua_State *L) {
   global_State *g = G(L);
   switch (g->gcstate) {
     case GCSpause: {
-      /* start to count memory traversed */
       g->GCmemtrav = g->strt.size * sizeof(GCObject*);
-      lua_assert(!isgenerational(g));
       restartcollection(g);
       g->gcstate = GCSpropagate;
       return g->GCmemtrav;
     }
     case GCSpropagate: {
-      if (g->gray) {
-        lu_mem oldtrav = g->GCmemtrav;
-        propagatemark(g);
-        return g->GCmemtrav - oldtrav;  /* memory traversed in this step */
-      }
-      else {  /* no more `gray' objects */
-        lu_mem work;
-        int sw;
-        g->gcstate = GCSatomic;  /* finish mark phase */
-        g->GCestimate = g->GCmemtrav;  /* save what was counted */;
-        work = atomic(L);  /* add what was traversed by 'atomic' */
-        g->GCestimate += work;  /* estimate of total memory traversed */ 
-        sw = entersweep(L);
-        return work + sw * GCSWEEPCOST;
+      g->GCmemtrav = 0;
+      lua_assert(g->gray);
+      propagatemark(g);
+       if (g->gray == NULL)  /* no more gray objects? */
+        g->gcstate = GCSatomic;  /* finish propagate phase */
+      return g->GCmemtrav;  /* memory traversed in this step */
+    }
+    case GCSatomic: {
+      lu_mem work;
+      int sw;
+      propagateall(g);  /* make sure gray list is empty */
+      work = atomic(L);  /* work is what was traversed by 'atomic' */
+      sw = entersweep(L);
+      g->GCestimate = gettotalbytes(g);  /* first estimate */;
+      return work + sw * GCSWEEPCOST;
+    }
+    case GCSswpallgc: {  /* sweep "regular" objects */
+      return sweepstep(L, g, GCSswpfinobj, &g->finobj);
+    }
+    case GCSswpfinobj: {  /* sweep objects with finalizers */
+      return sweepstep(L, g, GCSswptobefnz, &g->tobefnz);
+    }
+    case GCSswptobefnz: {  /* sweep objects to be finalized */
+      return sweepstep(L, g, GCSswpend, NULL);
+    }
+    case GCSswpend: {  /* finish sweeps */
+      makewhite(g, g->mainthread);  /* sweep main thread */
+      checkSizes(L, g);
+      g->gcstate = GCScallfin;
+      return 0;
+    }
+    case GCScallfin: {  /* call remaining finalizers */
+      if (g->tobefnz && g->gckind != KGC_EMERGENCY) {
+        int n = runafewfinalizers(L);
+        return (n * GCFINALIZECOST);
       }
-    }
-    case GCSsweepstring: {
-      int i;
-      for (i = 0; i < GCSWEEPMAX && g->sweepstrgc + i < g->strt.size; i++)
-        sweepwholelist(L, &g->strt.hash[g->sweepstrgc + i]);
-      g->sweepstrgc += i;
-      if (g->sweepstrgc >= g->strt.size)  /* no more strings to sweep? */
-        g->gcstate = GCSsweepudata;
-      return i * GCSWEEPCOST;
-    }
-    case GCSsweepudata: {
-      if (g->sweepfin) {
-        g->sweepfin = sweeplist(L, g->sweepfin, GCSWEEPMAX);
-        return GCSWEEPMAX*GCSWEEPCOST;
-      }
-      else {
-        g->gcstate = GCSsweep;
-        return 0;
-      }
-    }
-    case GCSsweep: {
-      if (g->sweepgc) {
-        g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
-        return GCSWEEPMAX*GCSWEEPCOST;
-      }
-      else {
-        /* sweep main thread */
-        GCObject *mt = obj2gco(g->mainthread);
-        sweeplist(L, &mt, 1);
-        checkSizes(L);
+      else {  /* emergency mode or no more finalizers */
         g->gcstate = GCSpause;  /* finish collection */
-        return GCSWEEPCOST;
+        return 0;
       }
     }
     default: lua_assert(0); return 0;
@@ -1107,105 +1092,67 @@
 }
 
 
-static void generationalcollection (lua_State *L) {
-  global_State *g = G(L);
-  lua_assert(g->gcstate == GCSpropagate);
-  if (g->GCestimate == 0) {  /* signal for another major collection? */
-    luaC_fullgc(L, 0);  /* perform a full regular collection */
-    g->GCestimate = gettotalbytes(g);  /* update control */
-  }
-  else {
-    lu_mem estimate = g->GCestimate;
-    luaC_runtilstate(L, bitmask(GCSpause));  /* run complete (minor) cycle */
-    g->gcstate = GCSpropagate;  /* skip restart */
-    if (gettotalbytes(g) > (estimate / 100) * g->gcmajorinc)
-      g->GCestimate = 0;  /* signal for a major collection */
-    else
-      g->GCestimate = estimate;  /* keep estimate from last major coll. */
-
-  }
-  setpause(g, gettotalbytes(g));
-  lua_assert(g->gcstate == GCSpropagate);
-}
-
-
-static void incstep (lua_State *L) {
-  global_State *g = G(L);
+/*
+** get GC debt and convert it from Kb to 'work units' (avoid zero debt
+** and overflows)
+*/
+static l_mem getdebt (global_State *g) {
   l_mem debt = g->GCdebt;
   int stepmul = g->gcstepmul;
-  if (stepmul < 40) stepmul = 40;  /* avoid ridiculous low values (and 0) */
-  /* convert debt from Kb to 'work units' (avoid zero debt and overflows) */
   debt = (debt / STEPMULADJ) + 1;
   debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;
-  do {  /* always perform at least one single step */
-    lu_mem work = singlestep(L);  /* do some work */
-    debt -= work;
-  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);
-  if (g->gcstate == GCSpause)
-    setpause(g, g->GCestimate);  /* pause until next cycle */
-  else {
-    debt = (debt / stepmul) * STEPMULADJ;  /* convert 'work units' to Kb */
-    luaE_setdebt(g, debt);
-  }
+  return debt;
 }
 
-
-/*
-** performs a basic GC step
-*/
-void luaC_forcestep (lua_State *L) {
-  global_State *g = G(L);
-  int i;
-  if (isgenerational(g)) generationalcollection(L);
-  else incstep(L);
-  /* run a few finalizers (or all of them at the end of a collect cycle) */
-  for (i = 0; g->tobefnz && (i < GCFINALIZENUM || g->gcstate == GCSpause); i++)
-    GCTM(L, 1);  /* call one finalizer */
-}
-
-
 /*
-** performs a basic GC step only if collector is running
+** performs a basic GC step when collector is running
 */
 void luaC_step (lua_State *L) {
   global_State *g = G(L);
-  if (g->gcrunning) luaC_forcestep(L);
-  else luaE_setdebt(g, -GCSTEPSIZE);  /* avoid being called too often */
+  l_mem debt = getdebt(g);  /* GC deficit (be paid now) */
+  if (!g->gcrunning) {  /* not running? */
+    luaE_setdebt(g, -GCSTEPSIZE * 10);  /* avoid being called too often */
+    return;
+  }
+  do {  /* repeat until pause or enough "credit" (negative debt) */
+    lu_mem work = singlestep(L);  /* perform one single step */
+    debt -= work;
+  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);
+  if (g->gcstate == GCSpause)
+    setpause(g);  /* pause until next cycle */
+  else {
+    debt = (debt / g->gcstepmul) * STEPMULADJ;  /* convert 'work units' to Kb */
+    luaE_setdebt(g, debt);
+    runafewfinalizers(L);
+  }
 }
 
 
-
 /*
-** performs a full GC cycle; if "isemergency", does not call
-** finalizers (which could change stack positions)
+** Performs a full GC cycle; if 'isemergency', set a flag to avoid
+** some operations which could change the interpreter state in some
+** unexpected ways (running finalizers and shrinking some structures).
+** Before running the collection, check 'keepinvariant'; if it is true,
+** there may be some objects marked as black, so the collector has
+** to sweep all objects to turn them back to white (as white has not
+** changed, nothing will be collected).
 */
 void luaC_fullgc (lua_State *L, int isemergency) {
   global_State *g = G(L);
-  int origkind = g->gckind;
-  lua_assert(origkind != KGC_EMERGENCY);
-  if (isemergency)  /* do not run finalizers during emergency GC */
-    g->gckind = KGC_EMERGENCY;
-  else {
-    g->gckind = KGC_NORMAL;
-    callallpendingfinalizers(L, 1);
-  }
-  if (keepinvariant(g)) {  /* may there be some black objects? */
-    /* must sweep all objects to turn them back to white
-       (as white has not changed, nothing will be collected) */
-    entersweep(L);
+  lua_assert(g->gckind == KGC_NORMAL);
+  if (isemergency) g->gckind = KGC_EMERGENCY;  /* set flag */
+  if (keepinvariant(g)) {  /* black objects? */
+    entersweep(L); /* sweep everything to turn them back to white */
   }
   /* finish any pending sweep phase to start a new cycle */
   luaC_runtilstate(L, bitmask(GCSpause));
   luaC_runtilstate(L, ~bitmask(GCSpause));  /* start new collection */
-  luaC_runtilstate(L, bitmask(GCSpause));  /* run entire collection */
-  if (origkind == KGC_GEN) {  /* generational mode? */
-    /* generational mode must be kept in propagate phase */
-    luaC_runtilstate(L, bitmask(GCSpropagate));
-  }
-  g->gckind = origkind;
-  setpause(g, gettotalbytes(g));
-  if (!isemergency)   /* do not run finalizers during emergency GC */
-    callallpendingfinalizers(L, 1);
+  luaC_runtilstate(L, bitmask(GCScallfin));  /* run up to finalizers */
+  /* estimate must be correct after a full GC cycle */
+  lua_assert(g->GCestimate == gettotalbytes(g));
+  luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */
+  g->gckind = KGC_NORMAL;
+  setpause(g);
 }
 
 /* }====================================================== */
diff -urN rpm-5.4.15/lua/lgc.h rpm-5.4-cvs/lua/lgc.h
--- rpm-5.4.15/lua/lgc.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lgc.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lgc.h,v 2.58 2012/09/11 12:53:08 roberto Exp $
+** $Id: lgc.h,v 2.86 2014/10/25 11:50:46 roberto Exp $
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */
@@ -38,36 +38,27 @@
 */
 #define GCSpropagate	0
 #define GCSatomic	1
-#define GCSsweepstring	2
-#define GCSsweepudata	3
-#define GCSsweep	4
-#define GCSpause	5
+#define GCSswpallgc	2
+#define GCSswpfinobj	3
+#define GCSswptobefnz	4
+#define GCSswpend	5
+#define GCScallfin	6
+#define GCSpause	7
 
 
 #define issweepphase(g)  \
-	(GCSsweepstring <= (g)->gcstate && (g)->gcstate <= GCSsweep)
+	(GCSswpallgc <= (g)->gcstate && (g)->gcstate <= GCSswpend)
 
-#define isgenerational(g)	((g)->gckind == KGC_GEN)
 
 /*
-** macros to tell when main invariant (white objects cannot point to black
-** ones) must be kept. During a non-generational collection, the sweep
+** macro to tell when main invariant (white objects cannot point to black
+** ones) must be kept. During a collection, the sweep
 ** phase may break the invariant, as objects turned white may point to
 ** still-black objects. The invariant is restored when sweep ends and
-** all objects are white again. During a generational collection, the
-** invariant must be kept all times.
+** all objects are white again.
 */
 
-#define keepinvariant(g)	(isgenerational(g) || g->gcstate <= GCSatomic)
-
-
-/*
-** Outside the collector, the state in generational mode is kept in
-** 'propagate', so 'keepinvariant' is always true.
-*/
-#define keepinvariantout(g)  \
-  check_exp(g->gcstate == GCSpropagate || !isgenerational(g),  \
-            g->gcstate <= GCSatomic)
+#define keepinvariant(g)	((g)->gcstate <= GCSatomic)
 
 
 /*
@@ -83,38 +74,29 @@
 #define testbit(x,b)		testbits(x, bitmask(b))
 
 
-/* Layout for bit use in `marked' field: */
+/* Layout for bit use in 'marked' field: */
 #define WHITE0BIT	0  /* object is white (type 0) */
 #define WHITE1BIT	1  /* object is white (type 1) */
 #define BLACKBIT	2  /* object is black */
-#define FINALIZEDBIT	3  /* object has been separated for finalization */
-#define SEPARATED	4  /* object is in 'finobj' list or in 'tobefnz' */
-#define FIXEDBIT	5  /* object is fixed (should not be collected) */
-#define OLDBIT		6  /* object is old (only in generational mode) */
+#define FINALIZEDBIT	3  /* object has been marked for finalization */
 /* bit 7 is currently used by tests (luaL_checkmemory) */
 
 #define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)
 
 
-#define iswhite(x)      testbits((x)->gch.marked, WHITEBITS)
-#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)
+#define iswhite(x)      testbits((x)->marked, WHITEBITS)
+#define isblack(x)      testbit((x)->marked, BLACKBIT)
 #define isgray(x)  /* neither white nor black */  \
-	(!testbits((x)->gch.marked, WHITEBITS | bitmask(BLACKBIT)))
+	(!testbits((x)->marked, WHITEBITS | bitmask(BLACKBIT)))
 
-#define isold(x)	testbit((x)->gch.marked, OLDBIT)
+#define tofinalize(x)	testbit((x)->marked, FINALIZEDBIT)
 
-/* MOVE OLD rule: whenever an object is moved to the beginning of
-   a GC list, its old bit must be cleared */
-#define resetoldbit(o)	resetbit((o)->gch.marked, OLDBIT)
-
-#define otherwhite(g)	(g->currentwhite ^ WHITEBITS)
+#define otherwhite(g)	((g)->currentwhite ^ WHITEBITS)
 #define isdeadm(ow,m)	(!(((m) ^ WHITEBITS) & (ow)))
-#define isdead(g,v)	isdeadm(otherwhite(g), (v)->gch.marked)
-
-#define changewhite(x)	((x)->gch.marked ^= WHITEBITS)
-#define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)
+#define isdead(g,v)	isdeadm(otherwhite(g), (v)->marked)
 
-#define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))
+#define changewhite(x)	((x)->marked ^= WHITEBITS)
+#define gray2black(x)	l_setbit((x)->marked, BLACKBIT)
 
 #define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)
 
@@ -124,34 +106,33 @@
 #define luaC_checkGC(L)		luaC_condGC(L, luaC_step(L);)
 
 
-#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+#define luaC_barrier(L,p,v) {  \
+	if (iscollectable(v) && isblack(p) && iswhite(gcvalue(v)))  \
 	luaC_barrier_(L,obj2gco(p),gcvalue(v)); }
 
-#define luaC_barrierback(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+#define luaC_barrierback(L,p,v) {  \
+	if (iscollectable(v) && isblack(p) && iswhite(gcvalue(v)))  \
 	luaC_barrierback_(L,p); }
 
-#define luaC_objbarrier(L,p,o)  \
-	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
+#define luaC_objbarrier(L,p,o) {  \
+	if (isblack(p) && iswhite(o)) \
 		luaC_barrier_(L,obj2gco(p),obj2gco(o)); }
 
-#define luaC_objbarrierback(L,p,o)  \
-   { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierback_(L,p); }
-
-#define luaC_barrierproto(L,p,c) \
-   { if (isblack(obj2gco(p))) luaC_barrierproto_(L,p,c); }
+#define luaC_upvalbarrier(L,uv) \
+  { if (iscollectable((uv)->v) && !upisopen(uv)) \
+         luaC_upvalbarrier_(L,uv); }
 
+LUAI_FUNC void luaC_fix (lua_State *L, GCObject *o);
 LUAI_FUNC void luaC_freeallobjects (lua_State *L);
 LUAI_FUNC void luaC_step (lua_State *L);
-LUAI_FUNC void luaC_forcestep (lua_State *L);
 LUAI_FUNC void luaC_runtilstate (lua_State *L, int statesmask);
 LUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);
-LUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz,
-                                 GCObject **list, int offset);
+LUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz);
 LUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
-LUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);
-LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c);
+LUAI_FUNC void luaC_barrierback_ (lua_State *L, Table *o);
+LUAI_FUNC void luaC_upvalbarrier_ (lua_State *L, UpVal *uv);
 LUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);
-LUAI_FUNC void luaC_checkupvalcolor (global_State *g, UpVal *uv);
-LUAI_FUNC void luaC_changemode (lua_State *L, int mode);
+LUAI_FUNC void luaC_upvdeccount (lua_State *L, UpVal *uv);
+
 
 #endif
diff -urN rpm-5.4.15/lua/linit.c rpm-5.4-cvs/lua/linit.c
--- rpm-5.4.15/lua/linit.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/linit.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,20 +1,33 @@
 /*
-** $Id: linit.c,v 1.32 2011/04/08 19:17:36 roberto Exp $
+** $Id: linit.c,v 1.38 2015/01/05 13:48:33 roberto Exp $
 ** Initialization of libraries for lua.c and other clients
 ** See Copyright Notice in lua.h
 */
 
 
+#define linit_c
+#define LUA_LIB
+
 /*
 ** If you embed Lua in your program and need to open the standard
 ** libraries, call luaL_openlibs in your program. If you need a
 ** different set of libraries, copy this file to your project and edit
 ** it to suit your needs.
+**
+** You can also *preload* libraries, so that a later 'require' can
+** open the library, which is already linked to the application.
+** For that, do the following code:
+**
+**  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+**  lua_pushcfunction(L, luaopen_modname);
+**  lua_setfield(L, -2, modname);
+**  lua_pop(L, 1);  // remove _PRELOAD table
 */
 
+#include "lprefix.h"
 
-#define linit_c
-#define LUA_LIB
+
+#include <stddef.h>
 
 #include "lua.h"
 
@@ -34,34 +47,22 @@
   {LUA_IOLIBNAME, luaopen_io},
   {LUA_OSLIBNAME, luaopen_os},
   {LUA_STRLIBNAME, luaopen_string},
-  {LUA_BITLIBNAME, luaopen_bit32},
   {LUA_MATHLIBNAME, luaopen_math},
+  {LUA_UTF8LIBNAME, luaopen_utf8},
   {LUA_DBLIBNAME, luaopen_debug},
-  {NULL, NULL}
-};
-
-
-/*
-** these libs are preloaded and must be required before used
-*/
-static const luaL_Reg preloadedlibs[] = {
+#if defined(LUA_COMPAT_BITLIB)
+  {LUA_BITLIBNAME, luaopen_bit32},
+#endif
   {NULL, NULL}
 };
 
 
 LUALIB_API void luaL_openlibs (lua_State *L) {
   const luaL_Reg *lib;
-  /* call open functions from 'loadedlibs' and set results to global table */
+  /* "require" functions from 'loadedlibs' and set results to global table */
   for (lib = loadedlibs; lib->func; lib++) {
     luaL_requiref(L, lib->name, lib->func, 1);
     lua_pop(L, 1);  /* remove lib */
   }
-  /* add open functions from 'preloadedlibs' into 'package.preload' table */
-  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
-  for (lib = preloadedlibs; lib->func; lib++) {
-    lua_pushcfunction(L, lib->func);
-    lua_setfield(L, -2, lib->name);
-  }
-  lua_pop(L, 1);  /* remove _PRELOAD table */
 }
 
diff -urN rpm-5.4.15/lua/liolib.c rpm-5.4-cvs/lua/liolib.c
--- rpm-5.4.15/lua/liolib.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/liolib.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,42 +1,36 @@
 /*
-** $Id: liolib.c,v 2.111 2013/03/21 13:57:27 roberto Exp $
+** $Id: liolib.c,v 2.142 2015/01/02 12:50:28 roberto Exp $
 ** Standard I/O (and system) library
 ** See Copyright Notice in lua.h
 */
 
+#define liolib_c
+#define LUA_LIB
 
-/*
-** POSIX idiosyncrasy!
-** This definition must come before the inclusion of 'stdio.h'; it
-** should not affect non-POSIX systems
-*/
-#if !defined(_FILE_OFFSET_BITS)
-#define _FILE_OFFSET_BITS 64
-#endif
+#include "lprefix.h"
 
 
+#include <ctype.h>
 #include <errno.h>
+#include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define liolib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
 #include "lualib.h"
 
 
-#if !defined(lua_checkmode)
+#if !defined(l_checkmode)
 
 /*
 ** Check whether 'mode' matches '[rwa]%+?b?'.
 ** Change this macro to accept other modes for 'fopen' besides
 ** the standard ones.
 */
-#define lua_checkmode(mode) \
+#define l_checkmode(mode) \
 	(*mode != '\0' && strchr("rwa", *(mode++)) != NULL &&	\
 	(*mode != '+' || ++mode) &&  /* skip if char is '+' */	\
 	(*mode != 'b' || ++mode) &&  /* skip if char is 'b' */	\
@@ -46,74 +40,94 @@
 
 /*
 ** {======================================================
-** lua_popen spawns a new process connected to the current
+** l_popen spawns a new process connected to the current
 ** one through the file streams.
 ** =======================================================
 */
 
-#if !defined(lua_popen)	/* { */
-
-#if defined(LUA_USE_POPEN)	/* { */
+#if !defined(l_popen)		/* { */
 
-#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
-#define lua_pclose(L,file)	((void)L, pclose(file))
+#if defined(LUA_USE_POSIX)	/* { */
 
-#elif defined(LUA_WIN)		/* }{ */
+#define l_popen(L,c,m)		(fflush(NULL), popen(c,m))
+#define l_pclose(L,file)	(pclose(file))
 
-#define lua_popen(L,c,m)		((void)L, _popen(c,m))
-#define lua_pclose(L,file)		((void)L, _pclose(file))
+#elif defined(LUA_USE_WINDOWS)	/* }{ */
 
+#define l_popen(L,c,m)		(_popen(c,m))
+#define l_pclose(L,file)	(_pclose(file))
 
 #else				/* }{ */
 
-#define lua_popen(L,c,m)		((void)((void)c, m),  \
-		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
-#define lua_pclose(L,file)		((void)((void)L, file), -1)
-
+/* ISO C definitions */
+#define l_popen(L,c,m)  \
+	  ((void)((void)c, m), \
+	  luaL_error(L, "'popen' not supported"), \
+	  (FILE*)0)
+#define l_pclose(L,file)		((void)L, (void)file, -1)
 
 #endif				/* } */
 
-#endif			/* } */
+#endif				/* } */
 
 /* }====================================================== */
 
 
+#if !defined(l_getc)		/* { */
+
+#if defined(LUA_USE_POSIX)
+#define l_getc(f)		getc_unlocked(f)
+#define l_lockfile(f)		flockfile(f)
+#define l_unlockfile(f)		funlockfile(f)
+#else
+#define l_getc(f)		getc(f)
+#define l_lockfile(f)		((void)0)
+#define l_unlockfile(f)		((void)0)
+#endif
+
+#endif				/* } */
+
+
 /*
 ** {======================================================
-** lua_fseek/lua_ftell: configuration for longer offsets
+** l_fseek: configuration for longer offsets
 ** =======================================================
 */
 
-#if !defined(lua_fseek)	/* { */
+#if !defined(l_fseek)		/* { */
 
-#if defined(LUA_USE_POSIX)
+#if defined(LUA_USE_POSIX)	/* { */
+
+#include <sys/types.h>
 
 #define l_fseek(f,o,w)		fseeko(f,o,w)
 #define l_ftell(f)		ftello(f)
 #define l_seeknum		off_t
 
-#elif defined(LUA_WIN) && !defined(_CRTIMP_TYPEINFO) \
-   && defined(_MSC_VER) && (_MSC_VER >= 1400)
-/* Windows (but not DDK) and Visual C++ 2005 or higher */
+#elif defined(LUA_USE_WINDOWS) && !defined(_CRTIMP_TYPEINFO) \
+   && defined(_MSC_VER) && (_MSC_VER >= 1400)	/* }{ */
 
+/* Windows (but not DDK) and Visual C++ 2005 or higher */
 #define l_fseek(f,o,w)		_fseeki64(f,o,w)
 #define l_ftell(f)		_ftelli64(f)
 #define l_seeknum		__int64
 
-#else
+#else				/* }{ */
 
+/* ISO C definitions */
 #define l_fseek(f,o,w)		fseek(f,o,w)
 #define l_ftell(f)		ftell(f)
 #define l_seeknum		long
 
-#endif
+#endif				/* } */
 
-#endif			/* } */
+#endif				/* } */
 
 /* }====================================================== */
 
 
 #define IO_PREFIX	"_IO_"
+#define IOPREF_LEN	(sizeof(IO_PREFIX)/sizeof(char) - 1)
 #define IO_INPUT	(IO_PREFIX "input")
 #define IO_OUTPUT	(IO_PREFIX "output")
 
@@ -160,7 +174,7 @@
 
 
 /*
-** When creating file handles, always creates a `closed' file handle
+** When creating file handles, always creates a 'closed' file handle
 ** before opening the actual file; so, if there is a memory error, the
 ** file is not left opened.
 */
@@ -172,9 +186,14 @@
 }
 
 
+/*
+** Calls the 'close' function from a file handle. The 'volatile' avoids
+** a bug in some versions of the Clang compiler (e.g., clang 3.0 for
+** 32 bits).
+*/
 static int aux_close (lua_State *L) {
   LStream *p = tolstream(L);
-  lua_CFunction cf = p->closef;
+  volatile lua_CFunction cf = p->closef;
   p->closef = NULL;  /* mark stream as closed */
   return (*cf)(L);  /* close it */
 }
@@ -218,7 +237,7 @@
   LStream *p = newfile(L);
   p->f = fopen(fname, mode);
   if (p->f == NULL)
-    luaL_error(L, "cannot open file " LUA_QS " (%s)", fname, strerror(errno));
+    luaL_error(L, "cannot open file '%s' (%s)", fname, strerror(errno));
 }
 
 
@@ -227,7 +246,7 @@
   const char *mode = luaL_optstring(L, 2, "r");
   LStream *p = newfile(L);
   const char *md = mode;  /* to traverse/check mode */
-  luaL_argcheck(L, lua_checkmode(md), 2, "invalid mode");
+  luaL_argcheck(L, l_checkmode(md), 2, "invalid mode");
   p->f = fopen(filename, mode);
   return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
 }
@@ -238,7 +257,7 @@
 */
 static int io_pclose (lua_State *L) {
   LStream *p = tolstream(L);
-  return luaL_execresult(L, lua_pclose(L, p->f));
+  return luaL_execresult(L, l_pclose(L, p->f));
 }
 
 
@@ -246,7 +265,7 @@
   const char *filename = luaL_checkstring(L, 1);
   const char *mode = luaL_optstring(L, 2, "r");
   LStream *p = newprefile(L);
-  p->f = lua_popen(L, filename, mode);
+  p->f = l_popen(L, filename, mode);
   p->closef = &io_pclose;
   return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
 }
@@ -264,7 +283,7 @@
   lua_getfield(L, LUA_REGISTRYINDEX, findex);
   p = (LStream *)lua_touserdata(L, -1);
   if (isclosed(p))
-    luaL_error(L, "standard %s file is closed", findex + strlen(IO_PREFIX));
+    luaL_error(L, "standard %s file is closed", findex + IOPREF_LEN);
   return p->f;
 }
 
@@ -300,14 +319,10 @@
 
 
 static void aux_lines (lua_State *L, int toclose) {
-  int i;
   int n = lua_gettop(L) - 1;  /* number of arguments to read */
-  /* ensure that arguments will fit here and into 'io_readline' stack */
-  luaL_argcheck(L, n <= LUA_MINSTACK - 3, LUA_MINSTACK - 3, "too many options");
-  lua_pushvalue(L, 1);  /* file handle */
   lua_pushinteger(L, n);  /* number of arguments to read */
   lua_pushboolean(L, toclose);  /* close/not close file when finished */
-  for (i = 1; i <= n; i++) lua_pushvalue(L, i + 1);  /* copy arguments */
+  lua_rotate(L, 2, 2);  /* move 'n' and 'toclose' to their positions */
   lua_pushcclosure(L, io_readline, 3 + n);
 }
 
@@ -346,13 +361,93 @@
 */
 
 
-static int read_number (lua_State *L, FILE *f) {
-  lua_Number d;
-  if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
-    lua_pushnumber(L, d);
-    return 1;
+/* maximum length of a numeral */
+#define MAXRN		200
+
+/* auxiliary structure used by 'read_number' */
+typedef struct {
+  FILE *f;  /* file being read */
+  int c;  /* current character (look ahead) */
+  int n;  /* number of elements in buffer 'buff' */
+  char buff[MAXRN + 1];  /* +1 for ending '\0' */
+} RN;
+
+
+/*
+** Add current char to buffer (if not out of space) and read next one
+*/
+static int nextc (RN *rn) {
+  if (rn->n >= MAXRN) {  /* buffer overflow? */
+    rn->buff[0] = '\0';  /* invalidate result */
+    return 0;  /* fail */
   }
   else {
+    rn->buff[rn->n++] = rn->c;  /* save current char */
+    rn->c = l_getc(rn->f);  /* read next one */
+    return 1;
+  }
+}
+
+
+/*
+** Accept current char if it is in 'set' (of size 1 or 2)
+*/
+static int test2 (RN *rn, const char *set) {
+  if (rn->c == set[0] || (rn->c == set[1] && rn->c != '\0'))
+    return nextc(rn);
+  else return 0;
+}
+
+
+/*
+** Read a sequence of (hex)digits
+*/
+static int readdigits (RN *rn, int hex) {
+  int count = 0;
+  while ((hex ? isxdigit(rn->c) : isdigit(rn->c)) && nextc(rn))
+    count++;
+  return count;
+}
+
+
+/* access to locale "radix character" (decimal point) */
+#if !defined(l_getlocaledecpoint)
+#define l_getlocaledecpoint()     (localeconv()->decimal_point[0])
+#endif
+
+
+/*
+** Read a number: first reads a valid prefix of a numeral into a buffer.
+** Then it calls 'lua_stringtonumber' to check whether the format is
+** correct and to convert it to a Lua number
+*/
+static int read_number (lua_State *L, FILE *f) {
+  RN rn;
+  int count = 0;
+  int hex = 0;
+  char decp[2] = ".";
+  rn.f = f; rn.n = 0;
+  decp[0] = l_getlocaledecpoint();  /* get decimal point from locale */
+  l_lockfile(rn.f);
+  do { rn.c = l_getc(rn.f); } while (isspace(rn.c));  /* skip spaces */
+  test2(&rn, "-+");  /* optional signal */
+  if (test2(&rn, "0")) {
+    if (test2(&rn, "xX")) hex = 1;  /* numeral is hexadecimal */
+    else count = 1;  /* count initial '0' as a valid digit */
+  }
+  count += readdigits(&rn, hex);  /* integral part */
+  if (test2(&rn, decp))  /* decimal point? */
+    count += readdigits(&rn, hex);  /* fractional part */
+  if (count > 0 && test2(&rn, (hex ? "pP" : "eE"))) {  /* exponent mark? */
+    test2(&rn, "-+");  /* exponent signal */
+    readdigits(&rn, 0);  /* exponent digits */
+  }
+  ungetc(rn.c, rn.f);  /* unread look-ahead char */
+  l_unlockfile(rn.f);
+  rn.buff[rn.n] = '\0';  /* finish string */
+  if (lua_stringtonumber(L, rn.buff))  /* is this a valid number? */
+    return 1;  /* ok */
+  else {  /* invalid format */
    lua_pushnil(L);  /* "result" to be removed */
    return 0;  /* read fails */
   }
@@ -361,7 +456,7 @@
 
 static int test_eof (lua_State *L, FILE *f) {
   int c = getc(f);
-  ungetc(c, f);
+  ungetc(c, f);  /* no-op when c == EOF */
   lua_pushlstring(L, NULL, 0);
   return (c != EOF);
 }
@@ -369,40 +464,34 @@
 
 static int read_line (lua_State *L, FILE *f, int chop) {
   luaL_Buffer b;
+  int c = '\0';
   luaL_buffinit(L, &b);
-  for (;;) {
-    size_t l;
-    char *p = luaL_prepbuffer(&b);
-    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
-      luaL_pushresult(&b);  /* close buffer */
-      return (lua_rawlen(L, -1) > 0);  /* check whether read something */
-    }
-    l = strlen(p);
-    if (l == 0 || p[l-1] != '\n')
-      luaL_addsize(&b, l);
-    else {
-      luaL_addsize(&b, l - chop);  /* chop 'eol' if needed */
-      luaL_pushresult(&b);  /* close buffer */
-      return 1;  /* read at least an `eol' */
-    }
+  while (c != EOF && c != '\n') {  /* repeat until end of line */
+    char *buff = luaL_prepbuffer(&b);  /* pre-allocate buffer */
+    int i = 0;
+    l_lockfile(f);  /* no memory errors can happen inside the lock */
+    while (i < LUAL_BUFFERSIZE && (c = l_getc(f)) != EOF && c != '\n')
+      buff[i++] = c;
+    l_unlockfile(f);
+    luaL_addsize(&b, i);
   }
+  if (!chop && c == '\n')  /* want a newline and have one? */
+    luaL_addchar(&b, c);  /* add ending newline to result */
+  luaL_pushresult(&b);  /* close buffer */
+  /* return ok if read something (either a newline or something else) */
+  return (c == '\n' || lua_rawlen(L, -1) > 0);
 }
 
 
-#define MAX_SIZE_T	(~(size_t)0)
-
 static void read_all (lua_State *L, FILE *f) {
-  size_t rlen = LUAL_BUFFERSIZE;  /* how much to read in each cycle */
+  size_t nr;
   luaL_Buffer b;
   luaL_buffinit(L, &b);
-  for (;;) {
-    char *p = luaL_prepbuffsize(&b, rlen);
-    size_t nr = fread(p, sizeof(char), rlen, f);
+  do {  /* read file in chunks of LUAL_BUFFERSIZE bytes */
+    char *p = luaL_prepbuffsize(&b, LUAL_BUFFERSIZE);
+    nr = fread(p, sizeof(char), LUAL_BUFFERSIZE, f);
     luaL_addsize(&b, nr);
-    if (nr < rlen) break;  /* eof? */
-    else if (rlen <= (MAX_SIZE_T / 4))  /* avoid buffers too large */
-      rlen *= 2;  /* double buffer size at each iteration */
-  }
+  } while (nr == LUAL_BUFFERSIZE);
   luaL_pushresult(&b);  /* close buffer */
 }
 
@@ -434,13 +523,13 @@
     success = 1;
     for (n = first; nargs-- && success; n++) {
       if (lua_type(L, n) == LUA_TNUMBER) {
-        size_t l = (size_t)lua_tointeger(L, n);
+        size_t l = (size_t)luaL_checkinteger(L, n);
         success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
       }
       else {
-        const char *p = lua_tostring(L, n);
-        luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
-        switch (p[1]) {
+        const char *p = luaL_checkstring(L, n);
+        if (*p == '*') p++;  /* skip optional '*' (for compatibility) */
+        switch (*p) {
           case 'n':  /* number */
             success = read_number(L, f);
             break;
@@ -487,11 +576,12 @@
   if (isclosed(p))  /* file is already closed? */
     return luaL_error(L, "file is already closed");
   lua_settop(L , 1);
+  luaL_checkstack(L, n, "too many arguments");
   for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */
     lua_pushvalue(L, lua_upvalueindex(3 + i));
   n = g_read(L, p->f, 2);  /* 'n' is number of results */
   lua_assert(n > 0);  /* should return at least a nil */
-  if (!lua_isnil(L, -n))  /* read at least one value? */
+  if (lua_toboolean(L, -n))  /* read at least one value? */
     return n;  /* return them */
   else {  /* first result is nil: EOF or error */
     if (n > 1) {  /* is there error information? */
@@ -516,8 +606,10 @@
   for (; nargs--; arg++) {
     if (lua_type(L, arg) == LUA_TNUMBER) {
       /* optimization: could be done exactly as for strings */
-      status = status &&
-          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+      int len = lua_isinteger(L, arg)
+                ? fprintf(f, LUA_INTEGER_FMT, lua_tointeger(L, arg))
+                : fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg));
+      status = status && (len > 0);
     }
     else {
       size_t l;
@@ -547,15 +639,15 @@
   static const char *const modenames[] = {"set", "cur", "end", NULL};
   FILE *f = tofile(L);
   int op = luaL_checkoption(L, 2, "cur", modenames);
-  lua_Number p3 = luaL_optnumber(L, 3, 0);
+  lua_Integer p3 = luaL_optinteger(L, 3, 0);
   l_seeknum offset = (l_seeknum)p3;
-  luaL_argcheck(L, (lua_Number)offset == p3, 3,
+  luaL_argcheck(L, (lua_Integer)offset == p3, 3,
                   "not an integer in proper range");
   op = l_fseek(f, offset, mode[op]);
   if (op)
     return luaL_fileresult(L, 0, NULL);  /* error */
   else {
-    lua_pushnumber(L, (lua_Number)l_ftell(f));
+    lua_pushinteger(L, (lua_Integer)l_ftell(f));
     return 1;
   }
 }
@@ -567,7 +659,7 @@
   FILE *f = tofile(L);
   int op = luaL_checkoption(L, 2, NULL, modenames);
   lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
-  int res = setvbuf(f, NULL, mode[op], sz);
+  int res = setvbuf(f, NULL, mode[op], (size_t)sz);
   return luaL_fileresult(L, res == 0, NULL);
 }
 
diff -urN rpm-5.4.15/lua/llex.c rpm-5.4-cvs/lua/llex.c
--- rpm-5.4.15/lua/llex.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/llex.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,20 +1,23 @@
 /*
-** $Id: llex.c,v 2.63 2013/03/16 21:10:18 roberto Exp $
+** $Id: llex.c,v 2.89 2014/11/14 16:06:09 roberto Exp $
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */
 
+#define llex_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
 #include <locale.h>
 #include <string.h>
 
-#define llex_c
-#define LUA_CORE
-
 #include "lua.h"
 
 #include "lctype.h"
 #include "ldo.h"
+#include "lgc.h"
 #include "llex.h"
 #include "lobject.h"
 #include "lparser.h"
@@ -38,8 +41,9 @@
     "end", "false", "for", "function", "goto", "if",
     "in", "local", "nil", "not", "or", "repeat",
     "return", "then", "true", "until", "while",
-    "..", "...", "==", ">=", "<=", "~=", "::", "<eof>",
-    "<number>", "<name>", "<string>"
+    "//", "..", "...", "==", ">=", "<=", "~=",
+    "<<", ">>", "::", "<eof>",
+    "<number>", "<integer>", "<name>", "<string>"
 };
 
 
@@ -53,7 +57,7 @@
   Mbuffer *b = ls->buff;
   if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {
     size_t newsize;
-    if (luaZ_sizebuffer(b) >= MAX_SIZET/2)
+    if (luaZ_sizebuffer(b) >= MAX_SIZE/2)
       lexerror(ls, "lexical element too long", 0);
     newsize = luaZ_sizebuffer(b) * 2;
     luaZ_resizebuffer(ls->L, b, newsize);
@@ -64,24 +68,25 @@
 
 void luaX_init (lua_State *L) {
   int i;
+  TString *e = luaS_new(L, LUA_ENV);  /* create env name */
+  luaC_fix(L, obj2gco(e));  /* never collect this name */
   for (i=0; i<NUM_RESERVED; i++) {
     TString *ts = luaS_new(L, luaX_tokens[i]);
-    luaS_fix(ts);  /* reserved words are never collected */
-    ts->tsv.extra = cast_byte(i+1);  /* reserved word */
+    luaC_fix(L, obj2gco(ts));  /* reserved words are never collected */
+    ts->extra = cast_byte(i+1);  /* reserved word */
   }
 }
 
 
 const char *luaX_token2str (LexState *ls, int token) {
   if (token < FIRST_RESERVED) {  /* single-byte symbols? */
-    lua_assert(token == cast(unsigned char, token));
-    return (lisprint(token)) ? luaO_pushfstring(ls->L, LUA_QL("%c"), token) :
-                              luaO_pushfstring(ls->L, "char(%d)", token);
+    lua_assert(token == cast_uchar(token));
+    return luaO_pushfstring(ls->L, "'%c'", token);
   }
   else {
     const char *s = luaX_tokens[token - FIRST_RESERVED];
     if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */
-      return luaO_pushfstring(ls->L, LUA_QS, s);
+      return luaO_pushfstring(ls->L, "'%s'", s);
     else  /* names, strings, and numerals */
       return s;
   }
@@ -90,11 +95,10 @@
 
 static const char *txtToken (LexState *ls, int token) {
   switch (token) {
-    case TK_NAME:
-    case TK_STRING:
-    case TK_NUMBER:
+    case TK_NAME: case TK_STRING:
+    case TK_FLT: case TK_INT:
       save(ls, '\0');
-      return luaO_pushfstring(ls->L, LUA_QS, luaZ_buffer(ls->buff));
+      return luaO_pushfstring(ls->L, "'%s'", luaZ_buffer(ls->buff));
     default:
       return luaX_token2str(ls, token);
   }
@@ -117,22 +121,25 @@
 
 
 /*
-** creates a new string and anchors it in function's table so that
-** it will not be collected until the end of the function's compilation
-** (by that time it should be anchored in function's prototype)
+** creates a new string and anchors it in scanner's table so that
+** it will not be collected until the end of the compilation
+** (by that time it should be anchored somewhere)
 */
 TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
   lua_State *L = ls->L;
-  TValue *o;  /* entry for `str' */
+  TValue *o;  /* entry for 'str' */
   TString *ts = luaS_newlstr(L, str, l);  /* create new string */
   setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */
-  o = luaH_set(L, ls->fs->h, L->top - 1);
-  if (ttisnil(o)) {  /* not in use yet? (see 'addK') */
+  o = luaH_set(L, ls->h, L->top - 1);
+  if (ttisnil(o)) {  /* not in use yet? */
     /* boolean value does not need GC barrier;
        table has no metatable, so it does not need to invalidate cache */
     setbvalue(o, 1);  /* t[string] = true */
     luaC_checkGC(L);
   }
+  else {  /* string already present */
+    ts = tsvalue(keyfromval(o));  /* re-use value previously stored */
+  }
   L->top--;  /* remove string from stack */
   return ts;
 }
@@ -145,16 +152,17 @@
 static void inclinenumber (LexState *ls) {
   int old = ls->current;
   lua_assert(currIsNewline(ls));
-  next(ls);  /* skip `\n' or `\r' */
+  next(ls);  /* skip '\n' or '\r' */
   if (currIsNewline(ls) && ls->current != old)
-    next(ls);  /* skip `\n\r' or `\r\n' */
+    next(ls);  /* skip '\n\r' or '\r\n' */
   if (++ls->linenumber >= MAX_INT)
-    luaX_syntaxerror(ls, "chunk has too many lines");
+    lexerror(ls, "chunk has too many lines", 0);
 }
 
 
 void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
                     int firstchar) {
+  ls->t.token = 0;
   ls->decpoint = '.';
   ls->L = L;
   ls->current = firstchar;
@@ -164,8 +172,7 @@
   ls->linenumber = 1;
   ls->lastline = 1;
   ls->source = source;
-  ls->envn = luaS_new(L, LUA_ENV);  /* create env name */
-  luaS_fix(ls->envn);  /* never collect this name */
+  ls->envn = luaS_new(L, LUA_ENV);  /* get env name */
   luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */
 }
 
@@ -178,12 +185,26 @@
 */
 
 
+static int check_next1 (LexState *ls, int c) {
+  if (ls->current == c) {
+    next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
 
-static int check_next (LexState *ls, const char *set) {
-  if (ls->current == '\0' || !strchr(set, ls->current))
-    return 0;
-  save_and_next(ls);
-  return 1;
+/*
+** Check whether current char is in set 'set' (with two chars) and
+** saves it
+*/
+static int check_next2 (LexState *ls, const char *set) {
+  lua_assert(set[2] == '\0');
+  if (ls->current == set[0] || ls->current == set[1]) {
+    save_and_next(ls);
+    return 1;
+  }
+  else return 0;
 }
 
 
@@ -191,59 +212,73 @@
 ** change all characters 'from' in buffer to 'to'
 */
 static void buffreplace (LexState *ls, char from, char to) {
-  size_t n = luaZ_bufflen(ls->buff);
-  char *p = luaZ_buffer(ls->buff);
-  while (n--)
-    if (p[n] == from) p[n] = to;
+  if (from != to) {
+    size_t n = luaZ_bufflen(ls->buff);
+    char *p = luaZ_buffer(ls->buff);
+    while (n--)
+      if (p[n] == from) p[n] = to;
+  }
 }
 
 
-#if !defined(getlocaledecpoint)
-#define getlocaledecpoint()	(localeconv()->decimal_point[0])
+#if !defined(l_getlocaledecpoint)
+#define l_getlocaledecpoint()	(localeconv()->decimal_point[0])
 #endif
 
 
-#define buff2d(b,e)	luaO_str2d(luaZ_buffer(b), luaZ_bufflen(b) - 1, e)
+#define buff2num(b,o)	(luaO_str2num(luaZ_buffer(b), o) != 0)
 
 /*
 ** in case of format error, try to change decimal point separator to
 ** the one defined in the current locale and check again
 */
-static void trydecpoint (LexState *ls, SemInfo *seminfo) {
+static void trydecpoint (LexState *ls, TValue *o) {
   char old = ls->decpoint;
-  ls->decpoint = getlocaledecpoint();
+  ls->decpoint = l_getlocaledecpoint();
   buffreplace(ls, old, ls->decpoint);  /* try new decimal separator */
-  if (!buff2d(ls->buff, &seminfo->r)) {
+  if (!buff2num(ls->buff, o)) {
     /* format error with correct decimal point: no more options */
     buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */
-    lexerror(ls, "malformed number", TK_NUMBER);
+    lexerror(ls, "malformed number", TK_FLT);
   }
 }
 
 
 /* LUA_NUMBER */
 /*
-** this function is quite liberal in what it accepts, as 'luaO_str2d'
+** this function is quite liberal in what it accepts, as 'luaO_str2num'
 ** will reject ill-formed numerals.
 */
-static void read_numeral (LexState *ls, SemInfo *seminfo) {
+static int read_numeral (LexState *ls, SemInfo *seminfo) {
+  TValue obj;
   const char *expo = "Ee";
   int first = ls->current;
   lua_assert(lisdigit(ls->current));
   save_and_next(ls);
-  if (first == '0' && check_next(ls, "Xx"))  /* hexadecimal? */
+  if (first == '0' && check_next2(ls, "xX"))  /* hexadecimal? */
     expo = "Pp";
   for (;;) {
-    if (check_next(ls, expo))  /* exponent part? */
-      check_next(ls, "+-");  /* optional exponent sign */
-    if (lisxdigit(ls->current) || ls->current == '.')
+    if (check_next2(ls, expo))  /* exponent part? */
+      check_next2(ls, "-+");  /* optional exponent sign */
+    if (lisxdigit(ls->current))
+      save_and_next(ls);
+    else if (ls->current == '.')
       save_and_next(ls);
-    else  break;
+    else break;
   }
   save(ls, '\0');
   buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */
-  if (!buff2d(ls->buff, &seminfo->r))  /* format error? */
-    trydecpoint(ls, seminfo); /* try to update decimal point separator */
+  if (!buff2num(ls->buff, &obj))  /* format error? */
+    trydecpoint(ls, &obj); /* try to update decimal point separator */
+  if (ttisinteger(&obj)) {
+    seminfo->i = ivalue(&obj);
+    return TK_INT;
+  }
+  else {
+    lua_assert(ttisfloat(&obj));
+    seminfo->r = fltvalue(&obj);
+    return TK_FLT;
+  }
 }
 
 
@@ -265,18 +300,22 @@
 
 
 static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {
-  save_and_next(ls);  /* skip 2nd `[' */
+  int line = ls->linenumber;  /* initial line (for error message) */
+  save_and_next(ls);  /* skip 2nd '[' */
   if (currIsNewline(ls))  /* string starts with a newline? */
     inclinenumber(ls);  /* skip it */
   for (;;) {
     switch (ls->current) {
-      case EOZ:
-        lexerror(ls, (seminfo) ? "unfinished long string" :
-                                 "unfinished long comment", TK_EOS);
+      case EOZ: {  /* error */
+        const char *what = (seminfo ? "string" : "comment");
+        const char *msg = luaO_pushfstring(ls->L,
+                     "unfinished long %s (starting at line %d)", what, line);
+        lexerror(ls, msg, TK_EOS);
         break;  /* to avoid warnings */
+      }
       case ']': {
         if (skip_sep(ls) == sep) {
-          save_and_next(ls);  /* skip 2nd `]' */
+          save_and_next(ls);  /* skip 2nd ']' */
           goto endloop;
         }
         break;
@@ -299,40 +338,65 @@
 }
 
 
-static void escerror (LexState *ls, int *c, int n, const char *msg) {
-  int i;
-  luaZ_resetbuffer(ls->buff);  /* prepare error message */
-  save(ls, '\\');
-  for (i = 0; i < n && c[i] != EOZ; i++)
-    save(ls, c[i]);
-  lexerror(ls, msg, TK_STRING);
+static void esccheck (LexState *ls, int c, const char *msg) {
+  if (!c) {
+    if (ls->current != EOZ)
+      save_and_next(ls);  /* add current to buffer for error message */
+    lexerror(ls, msg, TK_STRING);
+  }
+}
+
+
+static int gethexa (LexState *ls) {
+  save_and_next(ls);
+  esccheck (ls, lisxdigit(ls->current), "hexadecimal digit expected");
+  return luaO_hexavalue(ls->current);
 }
 
 
 static int readhexaesc (LexState *ls) {
-  int c[3], i;  /* keep input for error message */
-  int r = 0;  /* result accumulator */
-  c[0] = 'x';  /* for error message */
-  for (i = 1; i < 3; i++) {  /* read two hexadecimal digits */
-    c[i] = next(ls);
-    if (!lisxdigit(c[i]))
-      escerror(ls, c, i + 1, "hexadecimal digit expected");
-    r = (r << 4) + luaO_hexavalue(c[i]);
-  }
+  int r = gethexa(ls);
+  r = (r << 4) + gethexa(ls);
+  luaZ_buffremove(ls->buff, 2);  /* remove saved chars from buffer */
+  return r;
+}
+
+
+static unsigned long readutf8esc (LexState *ls) {
+  unsigned long r;
+  int i = 4;  /* chars to be removed: '\', 'u', '{', and first digit */
+  save_and_next(ls);  /* skip 'u' */
+  esccheck(ls, ls->current == '{', "missing '{'");
+  r = gethexa(ls);  /* must have at least one digit */
+  while ((save_and_next(ls), lisxdigit(ls->current))) {
+    i++;
+    r = (r << 4) + luaO_hexavalue(ls->current);
+    esccheck(ls, r <= 0x10FFFF, "UTF-8 value too large");
+  }
+  esccheck(ls, ls->current == '}', "missing '}'");
+  next(ls);  /* skip '}' */
+  luaZ_buffremove(ls->buff, i);  /* remove saved chars from buffer */
   return r;
 }
 
 
+static void utf8esc (LexState *ls) {
+  char buff[UTF8BUFFSZ];
+  int n = luaO_utf8esc(buff, readutf8esc(ls));
+  for (; n > 0; n--)  /* add 'buff' to string */
+    save(ls, buff[UTF8BUFFSZ - n]);
+}
+
+
 static int readdecesc (LexState *ls) {
-  int c[3], i;
+  int i;
   int r = 0;  /* result accumulator */
   for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */
-    c[i] = ls->current;
-    r = 10*r + c[i] - '0';
-    next(ls);
+    r = 10*r + ls->current - '0';
+    save_and_next(ls);
   }
-  if (r > UCHAR_MAX)
-    escerror(ls, c, i, "decimal escape too large");
+  esccheck(ls, r <= UCHAR_MAX, "decimal escape too large");
+  luaZ_buffremove(ls->buff, i);  /* remove read digits from buffer */
   return r;
 }
 
@@ -350,7 +414,7 @@
         break;  /* to avoid warnings */
       case '\\': {  /* escape sequences */
         int c;  /* final character to be saved */
-        next(ls);  /* do not save the `\' */
+        save_and_next(ls);  /* keep '\\' for error messages */
         switch (ls->current) {
           case 'a': c = '\a'; goto read_save;
           case 'b': c = '\b'; goto read_save;
@@ -360,12 +424,14 @@
           case 't': c = '\t'; goto read_save;
           case 'v': c = '\v'; goto read_save;
           case 'x': c = readhexaesc(ls); goto read_save;
+          case 'u': utf8esc(ls);  goto no_save;
           case '\n': case '\r':
             inclinenumber(ls); c = '\n'; goto only_save;
           case '\\': case '\"': case '\'':
             c = ls->current; goto read_save;
           case EOZ: goto no_save;  /* will raise an error next loop */
           case 'z': {  /* zap following span of spaces */
+            luaZ_buffremove(ls->buff, 1);  /* remove '\\' */
             next(ls);  /* skip the 'z' */
             while (lisspace(ls->current)) {
               if (currIsNewline(ls)) inclinenumber(ls);
@@ -374,15 +440,18 @@
             goto no_save;
           }
           default: {
-            if (!lisdigit(ls->current))
-              escerror(ls, &ls->current, 1, "invalid escape sequence");
-            /* digital escape \ddd */
-            c = readdecesc(ls);
+            esccheck(ls, lisdigit(ls->current), "invalid escape sequence");
+            c = readdecesc(ls);  /* digital escape '\ddd' */
             goto only_save;
           }
         }
-       read_save: next(ls);  /* read next character */
-       only_save: save(ls, c);  /* save 'c' */
+       read_save:
+         next(ls);
+         /* go through */
+       only_save:
+         luaZ_buffremove(ls->buff, 1);  /* remove '\\' */
+         save(ls, c);
+         /* go through */
        no_save: break;
       }
       default:
@@ -414,7 +483,7 @@
         next(ls);
         if (ls->current == '[') {  /* long comment? */
           int sep = skip_sep(ls);
-          luaZ_resetbuffer(ls->buff);  /* `skip_sep' may dirty the buffer */
+          luaZ_resetbuffer(ls->buff);  /* 'skip_sep' may dirty the buffer */
           if (sep >= 0) {
             read_long_string(ls, NULL, sep);  /* skip long comment */
             luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */
@@ -437,28 +506,35 @@
       }
       case '=': {
         next(ls);
-        if (ls->current != '=') return '=';
-        else { next(ls); return TK_EQ; }
+        if (check_next1(ls, '=')) return TK_EQ;
+        else return '=';
       }
       case '<': {
         next(ls);
-        if (ls->current != '=') return '<';
-        else { next(ls); return TK_LE; }
+        if (check_next1(ls, '=')) return TK_LE;
+        else if (check_next1(ls, '<')) return TK_SHL;
+        else return '<';
       }
       case '>': {
         next(ls);
-        if (ls->current != '=') return '>';
-        else { next(ls); return TK_GE; }
+        if (check_next1(ls, '=')) return TK_GE;
+        else if (check_next1(ls, '>')) return TK_SHR;
+        else return '>';
+      }
+      case '/': {
+        next(ls);
+        if (check_next1(ls, '/')) return TK_IDIV;
+        else return '/';
       }
       case '~': {
         next(ls);
-        if (ls->current != '=') return '~';
-        else { next(ls); return TK_NE; }
+        if (check_next1(ls, '=')) return TK_NE;
+        else return '~';
       }
       case ':': {
         next(ls);
-        if (ls->current != ':') return ':';
-        else { next(ls); return TK_DBCOLON; }
+        if (check_next1(ls, ':')) return TK_DBCOLON;
+        else return ':';
       }
       case '"': case '\'': {  /* short literal strings */
         read_string(ls, ls->current, seminfo);
@@ -466,18 +542,17 @@
       }
       case '.': {  /* '.', '..', '...', or number */
         save_and_next(ls);
-        if (check_next(ls, ".")) {
-          if (check_next(ls, "."))
+        if (check_next1(ls, '.')) {
+          if (check_next1(ls, '.'))
             return TK_DOTS;   /* '...' */
           else return TK_CONCAT;   /* '..' */
         }
         else if (!lisdigit(ls->current)) return '.';
-        /* else go through */
+        else return read_numeral(ls, seminfo);
       }
       case '0': case '1': case '2': case '3': case '4':
       case '5': case '6': case '7': case '8': case '9': {
-        read_numeral(ls, seminfo);
-        return TK_NUMBER;
+        return read_numeral(ls, seminfo);
       }
       case EOZ: {
         return TK_EOS;
@@ -492,7 +567,7 @@
                                   luaZ_bufflen(ls->buff));
           seminfo->ts = ts;
           if (isreserved(ts))  /* reserved word? */
-            return ts->tsv.extra - 1 + FIRST_RESERVED;
+            return ts->extra - 1 + FIRST_RESERVED;
           else {
             return TK_NAME;
           }
diff -urN rpm-5.4.15/lua/llex.h rpm-5.4-cvs/lua/llex.h
--- rpm-5.4.15/lua/llex.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/llex.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: llex.h,v 1.72 2011/11/30 12:43:51 roberto Exp $
+** $Id: llex.h,v 1.78 2014/10/29 15:38:24 roberto Exp $
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */
@@ -14,6 +14,10 @@
 #define FIRST_RESERVED	257
 
 
+#if !defined(LUA_ENV)
+#define LUA_ENV		"_ENV"
+#endif
+
 
 /*
 * WARNING: if you change the order of this enumeration,
@@ -26,8 +30,10 @@
   TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
   TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
   /* other terminal symbols */
-  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_DBCOLON, TK_EOS,
-  TK_NUMBER, TK_NAME, TK_STRING
+  TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
+  TK_SHL, TK_SHR,
+  TK_DBCOLON, TK_EOS,
+  TK_FLT, TK_INT, TK_NAME, TK_STRING
 };
 
 /* number of reserved words */
@@ -36,6 +42,7 @@
 
 typedef union {
   lua_Number r;
+  lua_Integer i;
   TString *ts;
 } SemInfo;  /* semantics information */
 
@@ -51,13 +58,14 @@
 typedef struct LexState {
   int current;  /* current character (charint) */
   int linenumber;  /* input line counter */
-  int lastline;  /* line of last token `consumed' */
+  int lastline;  /* line of last token 'consumed' */
   Token t;  /* current token */
   Token lookahead;  /* look ahead token */
   struct FuncState *fs;  /* current function (parser) */
   struct lua_State *L;
   ZIO *z;  /* input stream */
   Mbuffer *buff;  /* buffer for tokens */
+  Table *h;  /* to avoid collection/reuse strings */
   struct Dyndata *dyd;  /* dynamic structures used by the parser */
   TString *source;  /* current source name */
   TString *envn;  /* environment variable name */
diff -urN rpm-5.4.15/lua/llimits.h rpm-5.4-cvs/lua/llimits.h
--- rpm-5.4.15/lua/llimits.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/llimits.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,6 +1,6 @@
 /*
-** $Id: llimits.h,v 1.103 2013/02/20 14:08:56 roberto Exp $
-** Limits, basic types, and some other `installation-dependent' definitions
+** $Id: llimits.h,v 1.125 2014/12/19 13:30:23 roberto Exp $
+** Limits, basic types, and some other 'installation-dependent' definitions
 ** See Copyright Notice in lua.h
 */
 
@@ -14,47 +14,64 @@
 
 #include "lua.h"
 
-
-typedef unsigned LUA_INT32 lu_int32;
-
+/*
+** 'lu_mem' and 'l_mem' are unsigned/signed integers big enough to count
+** the total memory used by Lua (in bytes). Usually, 'size_t' and
+** 'ptrdiff_t' should work, but we use 'long' for 16-bit machines.
+*/
+#if defined(LUAI_MEM)		/* { external definitions? */
 typedef LUAI_UMEM lu_mem;
-
 typedef LUAI_MEM l_mem;
+#elif LUAI_BITSINT >= 32	/* }{ */
+typedef size_t lu_mem;
+typedef ptrdiff_t l_mem;
+#else  /* 16-bit ints */	/* }{ */
+typedef unsigned long lu_mem;
+typedef long l_mem;
+#endif				/* } */
 
 
-
-/* chars used as small naturals (so that `char' is reserved for characters) */
+/* chars used as small naturals (so that 'char' is reserved for characters) */
 typedef unsigned char lu_byte;
 
 
-#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+/* maximum value for size_t */
+#define MAX_SIZET	((size_t)(~(size_t)0))
+
+/* maximum size visible for Lua (must be representable in a lua_Integer */
+#define MAX_SIZE	(sizeof(size_t) < sizeof(lua_Integer) ? MAX_SIZET \
+                          : (size_t)(LUA_MAXINTEGER))
 
-#define MAX_LUMEM	((lu_mem)(~(lu_mem)0)-2)
 
-#define MAX_LMEM	((l_mem) ((MAX_LUMEM >> 1) - 2))
+#define MAX_LUMEM	((lu_mem)(~(lu_mem)0))
 
+#define MAX_LMEM	((l_mem)(MAX_LUMEM >> 1))
+
+
+#define MAX_INT		INT_MAX  /* maximum value of an int */
 
-#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
 
 /*
-** conversion of pointer to integer
+** conversion of pointer to integer:
 ** this is for hashing only; there is no problem if the integer
 ** cannot hold the whole pointer value
 */
-#define IntPoint(p)  ((unsigned int)(lu_mem)(p))
+#define point2int(p)	((unsigned int)((size_t)(p) & UINT_MAX))
 
 
 
 /* type to ensure maximum alignment */
-#if !defined(LUAI_USER_ALIGNMENT_T)
-#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }
+#if defined(LUAI_USER_ALIGNMENT_T)
+typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;
+#else
+typedef union { double u; void *s; lua_Integer i; long l; } L_Umaxalign;
 #endif
 
-typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;
 
 
-/* result of a `usual argument conversion' over lua_Number */
+/* types of 'usual argument conversions' for lua_Number and lua_Integer */
 typedef LUAI_UACNUMBER l_uacNumber;
+typedef LUAI_UACINT l_uacInt;
 
 
 /* internal assertions for in-house debugging */
@@ -71,18 +88,15 @@
 /*
 ** assertion for checking API calls
 */
-#if !defined(luai_apicheck)
-
 #if defined(LUA_USE_APICHECK)
 #include <assert.h>
-#define luai_apicheck(L,e)	assert(e)
+#define luai_apicheck(e)	assert(e)
 #else
-#define luai_apicheck(L,e)	lua_assert(e)
+#define luai_apicheck(e)	lua_assert(e)
 #endif
 
-#endif
 
-#define api_check(l,e,msg)	luai_apicheck(l,(e) && msg)
+#define api_check(e,msg)	luai_apicheck((e) && msg)
 
 
 #if !defined(UNUSED)
@@ -92,18 +106,34 @@
 
 #define cast(t, exp)	((t)(exp))
 
+#define cast_void(i)	cast(void, (i))
 #define cast_byte(i)	cast(lu_byte, (i))
 #define cast_num(i)	cast(lua_Number, (i))
 #define cast_int(i)	cast(int, (i))
 #define cast_uchar(i)	cast(unsigned char, (i))
 
 
+/* cast a signed lua_Integer to lua_Unsigned */
+#if !defined(l_castS2U)
+#define l_castS2U(i)	((lua_Unsigned)(i))
+#endif
+
+/*
+** cast a lua_Unsigned to a signed lua_Integer; this cast is
+** not strict ISO C, but two-complement architectures should
+** work fine.
+*/
+#if !defined(l_castU2S)
+#define l_castU2S(i)	((lua_Integer)(i))
+#endif
+
+
 /*
 ** non-return type
 */
 #if defined(__GNUC__)
 #define l_noret		void __attribute__((noreturn))
-#elif defined(_MSC_VER)
+#elif defined(_MSC_VER) && _MSC_VER >= 1200
 #define l_noret		void __declspec(noreturn)
 #else
 #define l_noret		void
@@ -127,21 +157,21 @@
 
 
 /*
-** type for virtual-machine instructions
+** type for virtual-machine instructions;
 ** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
 */
-typedef lu_int32 Instruction;
-
-
+#if LUAI_BITSINT >= 32
+typedef unsigned int Instruction;
+#else
+typedef unsigned long Instruction;
+#endif
 
-/* maximum stack for a Lua function */
-#define MAXSTACK	250
 
 
 
 /* minimum size for the string table (must be power of 2) */
 #if !defined(MINSTRTABSIZE)
-#define MINSTRTABSIZE	32
+#define MINSTRTABSIZE	64	/* minimum size for "predefined" strings */
 #endif
 
 
@@ -152,12 +182,12 @@
 
 
 #if !defined(lua_lock)
-#define lua_lock(L)     ((void) 0)
-#define lua_unlock(L)   ((void) 0)
+#define lua_lock(L)	((void) 0)
+#define lua_unlock(L)	((void) 0)
 #endif
 
 #if !defined(luai_threadyield)
-#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}
+#define luai_threadyield(L)	{lua_unlock(L); lua_lock(L);}
 #endif
 
 
@@ -183,108 +213,11 @@
 #endif
 
 #if !defined(luai_userstateresume)
-#define luai_userstateresume(L,n)       ((void)L)
+#define luai_userstateresume(L,n)	((void)L)
 #endif
 
 #if !defined(luai_userstateyield)
-#define luai_userstateyield(L,n)        ((void)L)
-#endif
-
-/*
-** lua_number2int is a macro to convert lua_Number to int.
-** lua_number2integer is a macro to convert lua_Number to lua_Integer.
-** lua_number2unsigned is a macro to convert a lua_Number to a lua_Unsigned.
-** lua_unsigned2number is a macro to convert a lua_Unsigned to a lua_Number.
-** luai_hashnum is a macro to hash a lua_Number value into an integer.
-** The hash must be deterministic and give reasonable values for
-** both small and large values (outside the range of integers).
-*/
-
-#if defined(MS_ASMTRICK) || defined(LUA_MSASMTRICK)	/* { */
-/* trick with Microsoft assembler for X86 */
-
-#define lua_number2int(i,n)  __asm {__asm fld n   __asm fistp i}
-#define lua_number2integer(i,n)		lua_number2int(i, n)
-#define lua_number2unsigned(i,n)  \
-  {__int64 l; __asm {__asm fld n   __asm fistp l} i = (unsigned int)l;}
-
-
-#elif defined(LUA_IEEE754TRICK)		/* }{ */
-/* the next trick should work on any machine using IEEE754 with
-   a 32-bit int type */
-
-union luai_Cast { double l_d; LUA_INT32 l_p[2]; };
-
-#if !defined(LUA_IEEEENDIAN)	/* { */
-#define LUAI_EXTRAIEEE	\
-  static const union luai_Cast ieeeendian = {-(33.0 + 6755399441055744.0)};
-#define LUA_IEEEENDIANLOC	(ieeeendian.l_p[1] == 33)
-#else
-#define LUA_IEEEENDIANLOC	LUA_IEEEENDIAN
-#define LUAI_EXTRAIEEE		/* empty */
-#endif				/* } */
-
-#define lua_number2int32(i,n,t) \
-  { LUAI_EXTRAIEEE \
-    volatile union luai_Cast u; u.l_d = (n) + 6755399441055744.0; \
-    (i) = (t)u.l_p[LUA_IEEEENDIANLOC]; }
-
-#define luai_hashnum(i,n)  \
-  { volatile union luai_Cast u; u.l_d = (n) + 1.0;  /* avoid -0 */ \
-    (i) = u.l_p[0]; (i) += u.l_p[1]; }  /* add double bits for his hash */
-
-#define lua_number2int(i,n)		lua_number2int32(i, n, int)
-#define lua_number2unsigned(i,n)	lua_number2int32(i, n, lua_Unsigned)
-
-/* the trick can be expanded to lua_Integer when it is a 32-bit value */
-#if defined(LUA_IEEELL)
-#define lua_number2integer(i,n)		lua_number2int32(i, n, lua_Integer)
-#endif
-
-#endif				/* } */
-
-
-/* the following definitions always work, but may be slow */
-
-#if !defined(lua_number2int)
-#define lua_number2int(i,n)	((i)=(int)(n))
-#endif
-
-#if !defined(lua_number2integer)
-#define lua_number2integer(i,n)	((i)=(lua_Integer)(n))
-#endif
-
-#if !defined(lua_number2unsigned)	/* { */
-/* the following definition assures proper modulo behavior */
-#if defined(LUA_NUMBER_DOUBLE) || defined(LUA_NUMBER_FLOAT)
-#include <math.h>
-#define SUPUNSIGNED	((lua_Number)(~(lua_Unsigned)0) + 1)
-#define lua_number2unsigned(i,n)  \
-	((i)=(lua_Unsigned)((n) - floor((n)/SUPUNSIGNED)*SUPUNSIGNED))
-#else
-#define lua_number2unsigned(i,n)	((i)=(lua_Unsigned)(n))
-#endif
-#endif				/* } */
-
-
-#if !defined(lua_unsigned2number)
-/* on several machines, coercion from unsigned to double is slow,
-   so it may be worth to avoid */
-#define lua_unsigned2number(u)  \
-    (((u) <= (lua_Unsigned)INT_MAX) ? (lua_Number)(int)(u) : (lua_Number)(u))
-#endif
-
-
-
-#if defined(ltable_c) && !defined(luai_hashnum)
-
-#include <float.h>
-#include <math.h>
-
-#define luai_hashnum(i,n) { int e;  \
-  n = l_mathop(frexp)(n, &e) * (lua_Number)(INT_MAX - DBL_MAX_EXP);  \
-  lua_number2int(i, n); i += e; }
-
+#define luai_userstateyield(L,n)	((void)L)
 #endif
 
 
diff -urN rpm-5.4.15/lua/lmathlib.c rpm-5.4-cvs/lua/lmathlib.c
--- rpm-5.4.15/lua/lmathlib.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lmathlib.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,16 +1,18 @@
 /*
-** $Id: lmathlib.c,v 1.83 2013/03/07 18:21:32 roberto Exp $
+** $Id: lmathlib.c,v 1.114 2014/12/27 20:32:26 roberto Exp $
 ** Standard mathematical library
 ** See Copyright Notice in lua.h
 */
 
+#define lmathlib_c
+#define LUA_LIB
+
+#include "lprefix.h"
+
 
 #include <stdlib.h>
 #include <math.h>
 
-#define lmathlib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
@@ -18,13 +20,30 @@
 
 
 #undef PI
-#define PI	((lua_Number)(3.1415926535897932384626433832795))
-#define RADIANS_PER_DEGREE	((lua_Number)(PI/180.0))
+#define PI	(l_mathop(3.141592653589793238462643383279502884))
 
 
+#if !defined(l_rand)		/* { */
+#if defined(LUA_USE_POSIX)
+#define l_rand()	random()
+#define l_srand(x)	srandom(x)
+#define L_RANDMAX	2147483647	/* (2^31 - 1), following POSIX */
+#else
+#define l_rand()	rand()
+#define l_srand(x)	srand(x)
+#define L_RANDMAX	RAND_MAX
+#endif
+#endif				/* } */
+
 
 static int math_abs (lua_State *L) {
-  lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));
+  if (lua_isinteger(L, 1)) {
+    lua_Integer n = lua_tointeger(L, 1);
+    if (n < 0) n = (lua_Integer)(0u - n);
+    lua_pushinteger(L, n);
+  }
+  else
+    lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));
   return 1;
 }
 
@@ -33,31 +52,16 @@
   return 1;
 }
 
-static int math_sinh (lua_State *L) {
-  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));
-  return 1;
-}
-
 static int math_cos (lua_State *L) {
   lua_pushnumber(L, l_mathop(cos)(luaL_checknumber(L, 1)));
   return 1;
 }
 
-static int math_cosh (lua_State *L) {
-  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));
-  return 1;
-}
-
 static int math_tan (lua_State *L) {
   lua_pushnumber(L, l_mathop(tan)(luaL_checknumber(L, 1)));
   return 1;
 }
 
-static int math_tanh (lua_State *L) {
-  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));
-  return 1;
-}
-
 static int math_asin (lua_State *L) {
   lua_pushnumber(L, l_mathop(asin)(luaL_checknumber(L, 1)));
   return 1;
@@ -69,49 +73,106 @@
 }
 
 static int math_atan (lua_State *L) {
-  lua_pushnumber(L, l_mathop(atan)(luaL_checknumber(L, 1)));
+  lua_Number y = luaL_checknumber(L, 1);
+  lua_Number x = luaL_optnumber(L, 2, 1);
+  lua_pushnumber(L, l_mathop(atan2)(y, x));
   return 1;
 }
 
-static int math_atan2 (lua_State *L) {
-  lua_pushnumber(L, l_mathop(atan2)(luaL_checknumber(L, 1),
-                                luaL_checknumber(L, 2)));
+
+static int math_toint (lua_State *L) {
+  int valid;
+  lua_Integer n = lua_tointegerx(L, 1, &valid);
+  if (valid)
+    lua_pushinteger(L, n);
+  else {
+    luaL_checkany(L, 1);
+    lua_pushnil(L);  /* value is not convertible to integer */
+  }
   return 1;
 }
 
-static int math_ceil (lua_State *L) {
-  lua_pushnumber(L, l_mathop(ceil)(luaL_checknumber(L, 1)));
-  return 1;
+
+static void pushnumint (lua_State *L, lua_Number d) {
+  lua_Integer n;
+  if (lua_numbertointeger(d, &n))  /* does 'd' fit in an integer? */
+    lua_pushinteger(L, n);  /* result is integer */
+  else
+    lua_pushnumber(L, d);  /* result is float */
 }
 
+
 static int math_floor (lua_State *L) {
-  lua_pushnumber(L, l_mathop(floor)(luaL_checknumber(L, 1)));
+  if (lua_isinteger(L, 1))
+    lua_settop(L, 1);  /* integer is its own floor */
+  else {
+    lua_Number d = l_mathop(floor)(luaL_checknumber(L, 1));
+    pushnumint(L, d);
+  }
   return 1;
 }
 
+
+static int math_ceil (lua_State *L) {
+  if (lua_isinteger(L, 1))
+    lua_settop(L, 1);  /* integer is its own ceil */
+  else {
+    lua_Number d = l_mathop(ceil)(luaL_checknumber(L, 1));
+    pushnumint(L, d);
+  }
+  return 1;
+}
+
+
 static int math_fmod (lua_State *L) {
-  lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),
-                               luaL_checknumber(L, 2)));
+  if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {
+    lua_Integer d = lua_tointeger(L, 2);
+    if ((lua_Unsigned)d + 1u <= 1u) {  /* special cases: -1 or 0 */
+      luaL_argcheck(L, d != 0, 2, "zero");
+      lua_pushinteger(L, 0);  /* avoid overflow with 0x80000... / -1 */
+    }
+    else
+      lua_pushinteger(L, lua_tointeger(L, 1) % d);
+  }
+  else
+    lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),
+                                     luaL_checknumber(L, 2)));
   return 1;
 }
 
+
+/*
+** next function does not use 'modf', avoiding problems with 'double*'
+** (which is not compatible with 'float*') when lua_Number is not
+** 'double'.
+*/
 static int math_modf (lua_State *L) {
-  lua_Number ip;
-  lua_Number fp = l_mathop(modf)(luaL_checknumber(L, 1), &ip);
-  lua_pushnumber(L, ip);
-  lua_pushnumber(L, fp);
+  if (lua_isinteger(L ,1)) {
+    lua_settop(L, 1);  /* number is its own integer part */
+    lua_pushnumber(L, 0);  /* no fractional part */
+  }
+  else {
+    lua_Number n = luaL_checknumber(L, 1);
+    /* integer part (rounds toward zero) */
+    lua_Number ip = (n < 0) ? l_mathop(ceil)(n) : l_mathop(floor)(n);
+    pushnumint(L, ip);
+    /* fractional part (test needed for inf/-inf) */
+    lua_pushnumber(L, (n == ip) ? l_mathop(0.0) : (n - ip));
+  }
   return 2;
 }
 
+
 static int math_sqrt (lua_State *L) {
   lua_pushnumber(L, l_mathop(sqrt)(luaL_checknumber(L, 1)));
   return 1;
 }
 
-static int math_pow (lua_State *L) {
-  lua_Number x = luaL_checknumber(L, 1);
-  lua_Number y = luaL_checknumber(L, 2);
-  lua_pushnumber(L, l_mathop(pow)(x, y));
+
+static int math_ult (lua_State *L) {
+  lua_Integer a = luaL_checkinteger(L, 1);
+  lua_Integer b = luaL_checkinteger(L, 2);
+  lua_pushboolean(L, (lua_Unsigned)a < (lua_Unsigned)b);
   return 1;
 }
 
@@ -122,145 +183,205 @@
     res = l_mathop(log)(x);
   else {
     lua_Number base = luaL_checknumber(L, 2);
-    if (base == (lua_Number)10.0) res = l_mathop(log10)(x);
+    if (base == 10.0) res = l_mathop(log10)(x);
     else res = l_mathop(log)(x)/l_mathop(log)(base);
   }
   lua_pushnumber(L, res);
   return 1;
 }
 
-#if defined(LUA_COMPAT_LOG10)
-static int math_log10 (lua_State *L) {
-  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));
-  return 1;
-}
-#endif
-
 static int math_exp (lua_State *L) {
   lua_pushnumber(L, l_mathop(exp)(luaL_checknumber(L, 1)));
   return 1;
 }
 
 static int math_deg (lua_State *L) {
-  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  lua_pushnumber(L, luaL_checknumber(L, 1) * (l_mathop(180.0) / PI));
   return 1;
 }
 
 static int math_rad (lua_State *L) {
-  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
-  return 1;
-}
-
-static int math_frexp (lua_State *L) {
-  int e;
-  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));
-  lua_pushinteger(L, e);
-  return 2;
-}
-
-static int math_ldexp (lua_State *L) {
-  lua_Number x = luaL_checknumber(L, 1);
-  int ep = luaL_checkint(L, 2);
-  lua_pushnumber(L, l_mathop(ldexp)(x, ep));
+  lua_pushnumber(L, luaL_checknumber(L, 1) * (PI / l_mathop(180.0)));
   return 1;
 }
 
 
-
 static int math_min (lua_State *L) {
   int n = lua_gettop(L);  /* number of arguments */
-  lua_Number dmin = luaL_checknumber(L, 1);
+  int imin = 1;  /* index of current minimum value */
   int i;
-  for (i=2; i<=n; i++) {
-    lua_Number d = luaL_checknumber(L, i);
-    if (d < dmin)
-      dmin = d;
+  luaL_argcheck(L, n >= 1, 1, "value expected");
+  for (i = 2; i <= n; i++) {
+    if (lua_compare(L, i, imin, LUA_OPLT))
+      imin = i;
   }
-  lua_pushnumber(L, dmin);
+  lua_pushvalue(L, imin);
   return 1;
 }
 
 
 static int math_max (lua_State *L) {
   int n = lua_gettop(L);  /* number of arguments */
-  lua_Number dmax = luaL_checknumber(L, 1);
+  int imax = 1;  /* index of current maximum value */
   int i;
-  for (i=2; i<=n; i++) {
-    lua_Number d = luaL_checknumber(L, i);
-    if (d > dmax)
-      dmax = d;
+  luaL_argcheck(L, n >= 1, 1, "value expected");
+  for (i = 2; i <= n; i++) {
+    if (lua_compare(L, imax, i, LUA_OPLT))
+      imax = i;
   }
-  lua_pushnumber(L, dmax);
+  lua_pushvalue(L, imax);
   return 1;
 }
 
-
+/*
+** This function uses 'double' (instead of 'lua_Number') to ensure that
+** all bits from 'l_rand' can be represented, and that 'RANDMAX + 1.0'
+** will keep full precision (ensuring that 'r' is always less than 1.0.)
+*/
 static int math_random (lua_State *L) {
-  /* the `%' avoids the (rare) case of r==1, and is needed also because on
-     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
-  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  lua_Integer low, up;
+  double r = (double)l_rand() * (1.0 / ((double)L_RANDMAX + 1.0));
   switch (lua_gettop(L)) {  /* check number of arguments */
     case 0: {  /* no arguments */
-      lua_pushnumber(L, r);  /* Number between 0 and 1 */
-      break;
+      lua_pushnumber(L, (lua_Number)r);  /* Number between 0 and 1 */
+      return 1;
     }
     case 1: {  /* only upper limit */
-      lua_Number u = luaL_checknumber(L, 1);
-      luaL_argcheck(L, (lua_Number)1.0 <= u, 1, "interval is empty");
-      lua_pushnumber(L, l_mathop(floor)(r*u) + (lua_Number)(1.0));  /* [1, u] */
+      low = 1;
+      up = luaL_checkinteger(L, 1);
       break;
     }
     case 2: {  /* lower and upper limits */
-      lua_Number l = luaL_checknumber(L, 1);
-      lua_Number u = luaL_checknumber(L, 2);
-      luaL_argcheck(L, l <= u, 2, "interval is empty");
-      lua_pushnumber(L, l_mathop(floor)(r*(u-l+1)) + l);  /* [l, u] */
+      low = luaL_checkinteger(L, 1);
+      up = luaL_checkinteger(L, 2);
       break;
     }
     default: return luaL_error(L, "wrong number of arguments");
   }
+  /* random integer in the interval [low, up] */
+  luaL_argcheck(L, low <= up, 1, "interval is empty"); 
+  luaL_argcheck(L, low >= 0 || up <= LUA_MAXINTEGER + low, 1,
+                   "interval too large");
+  r *= (double)(up - low) + 1.0;
+  lua_pushinteger(L, (lua_Integer)r + low);
   return 1;
 }
 
 
 static int math_randomseed (lua_State *L) {
-  srand(luaL_checkunsigned(L, 1));
+  l_srand((unsigned int)(lua_Integer)luaL_checknumber(L, 1));
   (void)rand(); /* discard first value to avoid undesirable correlations */
   return 0;
 }
 
 
+static int math_type (lua_State *L) {
+  if (lua_type(L, 1) == LUA_TNUMBER) {
+      if (lua_isinteger(L, 1))
+        lua_pushliteral(L, "integer"); 
+      else
+        lua_pushliteral(L, "float"); 
+  }
+  else {
+    luaL_checkany(L, 1);
+    lua_pushnil(L);
+  }
+  return 1;
+}
+
+
+/*
+** {==================================================================
+** Deprecated functions (for compatibility only)
+** ===================================================================
+*/
+#if defined(LUA_COMPAT_MATHLIB)
+
+static int math_cosh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sinh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tanh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  lua_Number y = luaL_checknumber(L, 2);
+  lua_pushnumber(L, l_mathop(pow)(x, y));
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));
+  lua_pushinteger(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  int ep = (int)luaL_checkinteger(L, 2);
+  lua_pushnumber(L, l_mathop(ldexp)(x, ep));
+  return 1;
+}
+
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+#endif
+/* }================================================================== */
+
+
+
 static const luaL_Reg mathlib[] = {
   {"abs",   math_abs},
   {"acos",  math_acos},
   {"asin",  math_asin},
-  {"atan2", math_atan2},
   {"atan",  math_atan},
   {"ceil",  math_ceil},
-  {"cosh",   math_cosh},
   {"cos",   math_cos},
   {"deg",   math_deg},
   {"exp",   math_exp},
+  {"tointeger", math_toint},
   {"floor", math_floor},
   {"fmod",   math_fmod},
-  {"frexp", math_frexp},
-  {"ldexp", math_ldexp},
-#if defined(LUA_COMPAT_LOG10)
-  {"log10", math_log10},
-#endif
+  {"ult",   math_ult},
   {"log",   math_log},
   {"max",   math_max},
   {"min",   math_min},
   {"modf",   math_modf},
-  {"pow",   math_pow},
   {"rad",   math_rad},
   {"random",     math_random},
   {"randomseed", math_randomseed},
-  {"sinh",   math_sinh},
   {"sin",   math_sin},
   {"sqrt",  math_sqrt},
-  {"tanh",   math_tanh},
   {"tan",   math_tan},
+  {"type", math_type},
+#if defined(LUA_COMPAT_MATHLIB)
+  {"atan2", math_atan},
+  {"cosh",   math_cosh},
+  {"sinh",   math_sinh},
+  {"tanh",   math_tanh},
+  {"pow",   math_pow},
+  {"frexp", math_frexp},
+  {"ldexp", math_ldexp},
+  {"log10", math_log10},
+#endif
+  /* placeholders */
+  {"pi", NULL},
+  {"huge", NULL},
+  {"maxinteger", NULL},
+  {"mininteger", NULL},
   {NULL, NULL}
 };
 
@@ -272,8 +393,12 @@
   luaL_newlib(L, mathlib);
   lua_pushnumber(L, PI);
   lua_setfield(L, -2, "pi");
-  lua_pushnumber(L, HUGE_VAL);
+  lua_pushnumber(L, (lua_Number)HUGE_VAL);
   lua_setfield(L, -2, "huge");
+  lua_pushinteger(L, LUA_MAXINTEGER);
+  lua_setfield(L, -2, "maxinteger");
+  lua_pushinteger(L, LUA_MININTEGER);
+  lua_setfield(L, -2, "mininteger");
   return 1;
 }
 
diff -urN rpm-5.4.15/lua/lmem.c rpm-5.4-cvs/lua/lmem.c
--- rpm-5.4.15/lua/lmem.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lmem.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,15 +1,17 @@
 /*
-** $Id: lmem.c,v 1.84 2012/05/23 15:41:53 roberto Exp $
+** $Id: lmem.c,v 1.89 2014/11/02 19:33:33 roberto Exp $
 ** Interface to Memory Manager
 ** See Copyright Notice in lua.h
 */
 
-
-#include <stddef.h>
-
 #define lmem_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <stddef.h>
+
 #include "lua.h"
 
 #include "ldebug.h"
@@ -24,15 +26,15 @@
 /*
 ** About the realloc function:
 ** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
-** (`osize' is the old size, `nsize' is the new size)
+** ('osize' is the old size, 'nsize' is the new size)
 **
-** * frealloc(ud, NULL, x, s) creates a new block of size `s' (no
+** * frealloc(ud, NULL, x, s) creates a new block of size 's' (no
 ** matter 'x').
 **
-** * frealloc(ud, p, x, 0) frees the block `p'
+** * frealloc(ud, p, x, 0) frees the block 'p'
 ** (in this specific case, frealloc must return NULL);
 ** particularly, frealloc(ud, NULL, 0, 0) does nothing
-** (which is equivalent to free(NULL) in ANSI C)
+** (which is equivalent to free(NULL) in ISO C)
 **
 ** frealloc returns NULL if it cannot create or reallocate the area
 ** (any reallocation to an equal or smaller size cannot fail!)
@@ -83,12 +85,10 @@
 #endif
   newblock = (*g->frealloc)(g->ud, block, osize, nsize);
   if (newblock == NULL && nsize > 0) {
-    api_check(L, nsize > realosize,
+    api_check( nsize > realosize,
                  "realloc cannot fail when shrinking a block");
-    if (g->gcrunning) {
-      luaC_fullgc(L, 1);  /* try to free some memory... */
-      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
-    }
+    luaC_fullgc(L, 1);  /* try to free some memory... */
+    newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
     if (newblock == NULL)
       luaD_throw(L, LUA_ERRMEM);
   }
diff -urN rpm-5.4.15/lua/lmem.h rpm-5.4-cvs/lua/lmem.h
--- rpm-5.4.15/lua/lmem.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lmem.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lmem.h,v 1.40 2013/02/20 14:08:21 roberto Exp $
+** $Id: lmem.h,v 1.43 2014/12/19 17:26:14 roberto Exp $
 ** Interface to Memory Manager
 ** See Copyright Notice in lua.h
 */
@@ -15,20 +15,32 @@
 
 
 /*
-** This macro avoids the runtime division MAX_SIZET/(e), as 'e' is
-** always constant.
-** The macro is somewhat complex to avoid warnings:
-** +1 avoids warnings of "comparison has constant result";
-** cast to 'void' avoids warnings of "value unused".
+** This macro reallocs a vector 'b' from 'on' to 'n' elements, where
+** each element has size 'e'. In case of arithmetic overflow of the
+** product 'n'*'e', it raises an error (calling 'luaM_toobig'). Because
+** 'e' is always constant, it avoids the runtime division MAX_SIZET/(e).
+**
+** (The macro is somewhat complex to avoid warnings:  The 'sizeof'
+** comparison avoids a runtime comparison when overflow cannot occur.
+** The compiler should be able to optimize the real test by itself, but
+** when it does it, it may give a warning about "comparison is always
+** false due to limited range of data type"; the +1 tricks the compiler,
+** avoiding this warning but also this optimization.)
 */
 #define luaM_reallocv(L,b,on,n,e) \
-  (cast(void, \
-     (cast(size_t, (n)+1) > MAX_SIZET/(e)) ? (luaM_toobig(L), 0) : 0), \
+  (((sizeof(n) >= sizeof(size_t) && cast(size_t, (n)) + 1 > MAX_SIZET/(e)) \
+      ? luaM_toobig(L) : cast_void(0)) , \
    luaM_realloc_(L, (b), (on)*(e), (n)*(e)))
 
+/*
+** Arrays of chars do not need any test
+*/
+#define luaM_reallocvchar(L,b,on,n)  \
+    cast(char *, luaM_realloc_(L, (b), (on)*sizeof(char), (n)*sizeof(char)))
+
 #define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
 #define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
-#define luaM_freearray(L, b, n)   luaM_reallocv(L, (b), n, 0, sizeof((b)[0]))
+#define luaM_freearray(L, b, n)   luaM_realloc_(L, (b), (n)*sizeof(*(b)), 0)
 
 #define luaM_malloc(L,s)	luaM_realloc_(L, NULL, 0, (s))
 #define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
diff -urN rpm-5.4.15/lua/loadlib.c rpm-5.4-cvs/lua/loadlib.c
--- rpm-5.4.15/lua/loadlib.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/loadlib.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: loadlib.c,v 1.111 2012/05/30 12:33:44 roberto Exp $
+** $Id: loadlib.c,v 1.124 2015/01/05 13:51:39 roberto Exp $
 ** Dynamic library loader for Lua
 ** See Copyright Notice in lua.h
 **
@@ -8,22 +8,15 @@
 ** systems.
 */
 
+#define loadlib_c
+#define LUA_LIB
 
-/*
-** if needed, includes windows header before everything else
-*/
-#if defined(_WIN32)
-#include <windows.h>
-#endif
+#include "lprefix.h"
 
 
 #include <stdlib.h>
 #include <string.h>
 
-
-#define loadlib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
@@ -31,21 +24,21 @@
 
 
 /*
-** LUA_PATH and LUA_CPATH are the names of the environment
+** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment
 ** variables that Lua check to set its paths.
 */
-#if !defined(LUA_PATH)
-#define LUA_PATH	"LUA_PATH"
+#if !defined(LUA_PATH_VAR)
+#define LUA_PATH_VAR	"LUA_PATH"
 #endif
 
-#if !defined(LUA_CPATH)
-#define LUA_CPATH	"LUA_CPATH"
+#if !defined(LUA_CPATH_VAR)
+#define LUA_CPATH_VAR	"LUA_CPATH"
 #endif
 
 #define LUA_PATHSUFFIX		"_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
 
-#define LUA_PATHVERSION		LUA_PATH LUA_PATHSUFFIX
-#define LUA_CPATHVERSION	LUA_CPATH LUA_PATHSUFFIX
+#define LUA_PATHVARVERSION		LUA_PATH_VAR LUA_PATHSUFFIX
+#define LUA_CPATHVARVERSION		LUA_CPATH_VAR LUA_PATHSUFFIX
 
 /*
 ** LUA_PATH_SEP is the character that separates templates in a path.
@@ -92,29 +85,45 @@
 #define LUA_OFSEP	"_"
 
 
-/* table (in the registry) that keeps handles for all loaded C libraries */
-#define CLIBS		"_CLIBS"
+/*
+** unique key for table in the registry that keeps handles
+** for all loaded C libraries
+*/
+static const int CLIBS = 0;
 
 #define LIB_FAIL	"open"
 
-
-/* error codes for ll_loadfunc */
-#define ERRLIB		1
-#define ERRFUNC		2
-
 #define setprogdir(L)		((void)0)
 
 
 /*
 ** system-dependent functions
 */
-static void ll_unloadlib (void *lib);
-static void *ll_load (lua_State *L, const char *path, int seeglb);
-static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);
 
+/*
+** unload library 'lib'
+*/
+static void lsys_unloadlib (void *lib);
+
+/*
+** load C library in file 'path'. If 'seeglb', load with all names in
+** the library global.
+** Returns the library; in case of error, returns NULL plus an
+** error string in the stack.
+*/
+static void *lsys_load (lua_State *L, const char *path, int seeglb);
+
+/*
+** Try to find a function named 'sym' in library 'lib'.
+** Returns the function; in case of error, returns NULL plus an
+** error string in the stack.
+*/
+static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);
 
 
-#if defined(LUA_USE_DLOPEN)
+
+
+#if defined(LUA_USE_DLOPEN)	/* { */
 /*
 ** {========================================================================
 ** This is an implementation of loadlib based on the dlfcn interface.
@@ -126,20 +135,32 @@
 
 #include <dlfcn.h>
 
-static void ll_unloadlib (void *lib) {
+/*
+** Macro to covert pointer to void* to pointer to function. This cast
+** is undefined according to ISO C, but POSIX assumes that it must work.
+** (The '__extension__' in gnu compilers is only to avoid warnings.)
+*/
+#if defined(__GNUC__)
+#define cast_func(p) (__extension__ (lua_CFunction)(p))
+#else
+#define cast_func(p) ((lua_CFunction)(p))
+#endif
+
+
+static void lsys_unloadlib (void *lib) {
   dlclose(lib);
 }
 
 
-static void *ll_load (lua_State *L, const char *path, int seeglb) {
+static void *lsys_load (lua_State *L, const char *path, int seeglb) {
   void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));
   if (lib == NULL) lua_pushstring(L, dlerror());
   return lib;
 }
 
 
-static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
-  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
+static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = cast_func(dlsym(lib, sym));
   if (f == NULL) lua_pushstring(L, dlerror());
   return f;
 }
@@ -148,13 +169,15 @@
 
 
 
-#elif defined(LUA_DL_DLL)
+#elif defined(LUA_DL_DLL)	/* }{ */
 /*
 ** {======================================================================
 ** This is an implementation of loadlib for Windows using native functions.
 ** =======================================================================
 */
 
+#include <windows.h>
+
 #undef setprogdir
 
 /*
@@ -190,12 +213,12 @@
     lua_pushfstring(L, "system error %d\n", error);
 }
 
-static void ll_unloadlib (void *lib) {
+static void lsys_unloadlib (void *lib) {
   FreeLibrary((HMODULE)lib);
 }
 
 
-static void *ll_load (lua_State *L, const char *path, int seeglb) {
+static void *lsys_load (lua_State *L, const char *path, int seeglb) {
   HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);
   (void)(seeglb);  /* not used: symbols are 'global' by default */
   if (lib == NULL) pusherror(L);
@@ -203,7 +226,7 @@
 }
 
 
-static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {
   lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);
   if (f == NULL) pusherror(L);
   return f;
@@ -212,7 +235,7 @@
 /* }====================================================== */
 
 
-#else
+#else				/* }{ */
 /*
 ** {======================================================
 ** Fallback for other systems
@@ -226,31 +249,34 @@
 #define DLMSG	"dynamic libraries not enabled; check your Lua installation"
 
 
-static void ll_unloadlib (void *lib) {
+static void lsys_unloadlib (void *lib) {
   (void)(lib);  /* not used */
 }
 
 
-static void *ll_load (lua_State *L, const char *path, int seeglb) {
+static void *lsys_load (lua_State *L, const char *path, int seeglb) {
   (void)(path); (void)(seeglb);  /* not used */
   lua_pushliteral(L, DLMSG);
   return NULL;
 }
 
 
-static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {
   (void)(lib); (void)(sym);  /* not used */
   lua_pushliteral(L, DLMSG);
   return NULL;
 }
 
 /* }====================================================== */
-#endif
+#endif				/* } */
 
 
-static void *ll_checkclib (lua_State *L, const char *path) {
+/*
+** return registry.CLIBS[path]
+*/
+static void *checkclib (lua_State *L, const char *path) {
   void *plib;
-  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);
   lua_getfield(L, -1, path);
   plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */
   lua_pop(L, 2);  /* pop CLIBS table and 'plib' */
@@ -258,8 +284,12 @@
 }
 
 
-static void ll_addtoclib (lua_State *L, const char *path, void *plib) {
-  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+/*
+** registry.CLIBS[path] = plib        -- for queries
+** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries
+*/
+static void addtoclib (lua_State *L, const char *path, void *plib) {
+  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);
   lua_pushlightuserdata(L, plib);
   lua_pushvalue(L, -1);
   lua_setfield(L, -3, path);  /* CLIBS[path] = plib */
@@ -269,33 +299,49 @@
 
 
 /*
-** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib
+** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib
 ** handles in list CLIBS
 */
 static int gctm (lua_State *L) {
-  int n = luaL_len(L, 1);
+  lua_Integer n = luaL_len(L, 1);
   for (; n >= 1; n--) {  /* for each handle, in reverse order */
     lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */
-    ll_unloadlib(lua_touserdata(L, -1));
+    lsys_unloadlib(lua_touserdata(L, -1));
     lua_pop(L, 1);  /* pop handle */
   }
   return 0;
 }
 
 
-static int ll_loadfunc (lua_State *L, const char *path, const char *sym) {
-  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */
+
+/* error codes for 'lookforfunc' */
+#define ERRLIB		1
+#define ERRFUNC		2
+
+/*
+** Look for a C function named 'sym' in a dynamically loaded library
+** 'path'.
+** First, check whether the library is already loaded; if not, try
+** to load it.
+** Then, if 'sym' is '*', return true (as library has been loaded).
+** Otherwise, look for symbol 'sym' in the library and push a
+** C function with that symbol.
+** Return 0 and 'true' or a function in the stack; in case of
+** errors, return an error code and an error message in the stack.
+*/
+static int lookforfunc (lua_State *L, const char *path, const char *sym) {
+  void *reg = checkclib(L, path);  /* check loaded C libraries */
   if (reg == NULL) {  /* must load library? */
-    reg = ll_load(L, path, *sym == '*');
+    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */
     if (reg == NULL) return ERRLIB;  /* unable to load library */
-    ll_addtoclib(L, path, reg);
+    addtoclib(L, path, reg);
   }
   if (*sym == '*') {  /* loading only library (no function)? */
     lua_pushboolean(L, 1);  /* return 'true' */
     return 0;  /* no errors */
   }
   else {
-    lua_CFunction f = ll_sym(L, reg, sym);
+    lua_CFunction f = lsys_sym(L, reg, sym);
     if (f == NULL)
       return ERRFUNC;  /* unable to find function */
     lua_pushcfunction(L, f);  /* else create new function */
@@ -307,7 +353,7 @@
 static int ll_loadlib (lua_State *L) {
   const char *path = luaL_checkstring(L, 1);
   const char *init = luaL_checkstring(L, 2);
-  int stat = ll_loadfunc(L, path, init);
+  int stat = lookforfunc(L, path, init);
   if (stat == 0)  /* no errors? */
     return 1;  /* return the loaded function */
   else {  /* error; error message is on stack top */
@@ -360,7 +406,7 @@
     lua_remove(L, -2);  /* remove path template */
     if (readable(filename))  /* does file exist and is readable? */
       return filename;  /* return that file name */
-    lua_pushfstring(L, "\n\tno file " LUA_QS, filename);
+    lua_pushfstring(L, "\n\tno file '%s'", filename);
     lua_remove(L, -2);  /* remove file name */
     luaL_addvalue(&msg);  /* concatenate error msg. entry */
   }
@@ -390,7 +436,7 @@
   lua_getfield(L, lua_upvalueindex(1), pname);
   path = lua_tostring(L, -1);
   if (path == NULL)
-    luaL_error(L, LUA_QL("package.%s") " must be a string", pname);
+    luaL_error(L, "'package.%s' must be a string", pname);
   return searchpath(L, name, path, ".", dirsep);
 }
 
@@ -401,8 +447,7 @@
     return 2;  /* return open function and file name */
   }
   else
-    return luaL_error(L, "error loading module " LUA_QS
-                         " from file " LUA_QS ":\n\t%s",
+    return luaL_error(L, "error loading module '%s' from file '%s':\n\t%s",
                           lua_tostring(L, 1), filename, lua_tostring(L, -1));
 }
 
@@ -416,21 +461,29 @@
 }
 
 
+/*
+** Try to find a load function for module 'modname' at file 'filename'.
+** First, change '.' to '_' in 'modname'; then, if 'modname' has
+** the form X-Y (that is, it has an "ignore mark"), build a function
+** name "luaopen_X" and look for it. (For compatibility, if that
+** fails, it also tries "luaopen_Y".) If there is no ignore mark,
+** look for a function named "luaopen_modname".
+*/
 static int loadfunc (lua_State *L, const char *filename, const char *modname) {
-  const char *funcname;
+  const char *openfunc;
   const char *mark;
   modname = luaL_gsub(L, modname, ".", LUA_OFSEP);
   mark = strchr(modname, *LUA_IGMARK);
   if (mark) {
     int stat;
-    funcname = lua_pushlstring(L, modname, mark - modname);
-    funcname = lua_pushfstring(L, LUA_POF"%s", funcname);
-    stat = ll_loadfunc(L, filename, funcname);
+    openfunc = lua_pushlstring(L, modname, mark - modname);
+    openfunc = lua_pushfstring(L, LUA_POF"%s", openfunc);
+    stat = lookforfunc(L, filename, openfunc);
     if (stat != ERRFUNC) return stat;
     modname = mark + 1;  /* else go ahead and try old-style name */
   }
-  funcname = lua_pushfstring(L, LUA_POF"%s", modname);
-  return ll_loadfunc(L, filename, funcname);
+  openfunc = lua_pushfstring(L, LUA_POF"%s", modname);
+  return lookforfunc(L, filename, openfunc);
 }
 
 
@@ -455,8 +508,7 @@
     if (stat != ERRFUNC)
       return checkload(L, 0, filename);  /* real error */
     else {  /* open function not found */
-      lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
-                         name, filename);
+      lua_pushfstring(L, "\n\tno module '%s' in file '%s'", name, filename);
       return 1;
     }
   }
@@ -468,8 +520,7 @@
 static int searcher_preload (lua_State *L) {
   const char *name = luaL_checkstring(L, 1);
   lua_getfield(L, LUA_REGISTRYINDEX, "_PRELOAD");
-  lua_getfield(L, -1, name);
-  if (lua_isnil(L, -1))  /* not found? */
+  if (lua_getfield(L, -1, name) == LUA_TNIL)  /* not found? */
     lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
   return 1;
 }
@@ -479,17 +530,15 @@
   int i;
   luaL_Buffer msg;  /* to build error message */
   luaL_buffinit(L, &msg);
-  lua_getfield(L, lua_upvalueindex(1), "searchers");  /* will be at index 3 */
-  if (!lua_istable(L, 3))
-    luaL_error(L, LUA_QL("package.searchers") " must be a table");
+  /* push 'package.searchers' to index 3 in the stack */
+  if (lua_getfield(L, lua_upvalueindex(1), "searchers") != LUA_TTABLE)
+    luaL_error(L, "'package.searchers' must be a table");
   /*  iterate over available searchers to find a loader */
   for (i = 1; ; i++) {
-    lua_rawgeti(L, 3, i);  /* get a searcher */
-    if (lua_isnil(L, -1)) {  /* no more searchers? */
+    if (lua_rawgeti(L, 3, i) == LUA_TNIL) {  /* no more searchers? */
       lua_pop(L, 1);  /* remove nil */
       luaL_pushresult(&msg);  /* create error message */
-      luaL_error(L, "module " LUA_QS " not found:%s",
-                    name, lua_tostring(L, -1));
+      luaL_error(L, "module '%s' not found:%s", name, lua_tostring(L, -1));
     }
     lua_pushstring(L, name);
     lua_call(L, 1, 2);  /* call it */
@@ -520,8 +569,7 @@
   lua_call(L, 2, 1);  /* run loader to load module */
   if (!lua_isnil(L, -1))  /* non-nil return? */
     lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */
-  lua_getfield(L, 2, name);
-  if (lua_isnil(L, -1)) {   /* module did not set a value? */
+  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */
     lua_pushboolean(L, 1);  /* use true as result */
     lua_pushvalue(L, -1);  /* extra copy to be returned */
     lua_setfield(L, 2, name);  /* _LOADED[name] = true */
@@ -548,7 +596,7 @@
   if (lua_getstack(L, 1, &ar) == 0 ||
       lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
       lua_iscfunction(L, -1))
-    luaL_error(L, LUA_QL("module") " not called from a Lua function");
+    luaL_error(L, "'module' not called from a Lua function");
   lua_pushvalue(L, -2);  /* copy new environment table to top */
   lua_setupvalue(L, -2, 1);
   lua_pop(L, 1);  /* remove function */
@@ -587,9 +635,8 @@
   int lastarg = lua_gettop(L);  /* last parameter */
   luaL_pushmodule(L, modname, 1);  /* get/create module table */
   /* check whether table already has a _NAME field */
-  lua_getfield(L, -1, "_NAME");
-  if (!lua_isnil(L, -1))  /* is table an initialized module? */
-    lua_pop(L, 1);
+  if (lua_getfield(L, -1, "_NAME") != LUA_TNIL)
+    lua_pop(L, 1);  /* table is an initialized module */
   else {  /* no; initialize it */
     lua_pop(L, 1);
     modinit(L, modname);
@@ -659,6 +706,12 @@
 #if defined(LUA_COMPAT_MODULE)
   {"seeall", ll_seeall},
 #endif
+  /* placeholders */
+  {"preload", NULL},
+  {"cpath", NULL},
+  {"path", NULL},
+  {"searchers", NULL},
+  {"loaded", NULL},
   {NULL, NULL}
 };
 
@@ -684,36 +737,44 @@
     lua_pushcclosure(L, searchers[i], 1);
     lua_rawseti(L, -2, i+1);
   }
+#if defined(LUA_COMPAT_LOADERS)
+  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */
+  lua_setfield(L, -3, "loaders");  /* put it in field 'loaders' */
+#endif
+  lua_setfield(L, -2, "searchers");  /* put it in field 'searchers' */
 }
 
 
-LUAMOD_API int luaopen_package (lua_State *L) {
-  /* create table CLIBS to keep track of loaded C libraries */
-  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);
-  lua_createtable(L, 0, 1);  /* metatable for CLIBS */
+/*
+** create table CLIBS to keep track of loaded C libraries,
+** setting a finalizer to close all libraries when closing state.
+*/
+static void createclibstable (lua_State *L) {
+  lua_newtable(L);  /* create CLIBS table */
+  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */
   lua_pushcfunction(L, gctm);
   lua_setfield(L, -2, "__gc");  /* set finalizer for CLIBS table */
   lua_setmetatable(L, -2);
-  /* create `package' table */
-  luaL_newlib(L, pk_funcs);
+  lua_rawsetp(L, LUA_REGISTRYINDEX, &CLIBS);  /* set CLIBS table in registry */
+}
+
+
+LUAMOD_API int luaopen_package (lua_State *L) {
+  createclibstable(L);
+  luaL_newlib(L, pk_funcs);  /* create 'package' table */
   createsearcherstable(L);
-#if defined(LUA_COMPAT_LOADERS)
-  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */
-  lua_setfield(L, -3, "loaders");  /* put it in field `loaders' */
-#endif
-  lua_setfield(L, -2, "searchers");  /* put it in field 'searchers' */
   /* set field 'path' */
-  setpath(L, "path", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);
+  setpath(L, "path", LUA_PATHVARVERSION, LUA_PATH_VAR, LUA_PATH_DEFAULT);
   /* set field 'cpath' */
-  setpath(L, "cpath", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);
+  setpath(L, "cpath", LUA_CPATHVARVERSION, LUA_CPATH_VAR, LUA_CPATH_DEFAULT);
   /* store config information */
   lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
                      LUA_EXEC_DIR "\n" LUA_IGMARK "\n");
   lua_setfield(L, -2, "config");
-  /* set field `loaded' */
+  /* set field 'loaded' */
   luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
   lua_setfield(L, -2, "loaded");
-  /* set field `preload' */
+  /* set field 'preload' */
   luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
   lua_setfield(L, -2, "preload");
   lua_pushglobaltable(L);
diff -urN rpm-5.4.15/lua/lobject.c rpm-5.4-cvs/lua/lobject.c
--- rpm-5.4.15/lua/lobject.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lobject.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,17 +1,20 @@
 /*
-** $Id: lobject.c,v 2.58 2013/02/20 14:08:56 roberto Exp $
+** $Id: lobject.c,v 2.101 2014/12/26 14:43:45 roberto Exp $
 ** Some generic functions over Lua objects
 ** See Copyright Notice in lua.h
 */
 
+#define lobject_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
+
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define lobject_c
-#define LUA_CORE
-
 #include "lua.h"
 
 #include "lctype.h"
@@ -70,29 +73,90 @@
 }
 
 
-lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2) {
+static lua_Integer intarith (lua_State *L, int op, lua_Integer v1,
+                                                   lua_Integer v2) {
   switch (op) {
-    case LUA_OPADD: return luai_numadd(NULL, v1, v2);
-    case LUA_OPSUB: return luai_numsub(NULL, v1, v2);
-    case LUA_OPMUL: return luai_nummul(NULL, v1, v2);
-    case LUA_OPDIV: return luai_numdiv(NULL, v1, v2);
-    case LUA_OPMOD: return luai_nummod(NULL, v1, v2);
-    case LUA_OPPOW: return luai_numpow(NULL, v1, v2);
-    case LUA_OPUNM: return luai_numunm(NULL, v1);
+    case LUA_OPADD: return intop(+, v1, v2);
+    case LUA_OPSUB:return intop(-, v1, v2);
+    case LUA_OPMUL:return intop(*, v1, v2);
+    case LUA_OPMOD: return luaV_mod(L, v1, v2);
+    case LUA_OPIDIV: return luaV_div(L, v1, v2);
+    case LUA_OPBAND: return intop(&, v1, v2);
+    case LUA_OPBOR: return intop(|, v1, v2);
+    case LUA_OPBXOR: return intop(^, v1, v2);
+    case LUA_OPSHL: return luaV_shiftl(v1, v2);
+    case LUA_OPSHR: return luaV_shiftl(v1, -v2);
+    case LUA_OPUNM: return intop(-, 0, v1);
+    case LUA_OPBNOT: return intop(^, ~l_castS2U(0), v1);
     default: lua_assert(0); return 0;
   }
 }
 
 
-int luaO_hexavalue (int c) {
-  if (lisdigit(c)) return c - '0';
-  else return ltolower(c) - 'a' + 10;
+static lua_Number numarith (lua_State *L, int op, lua_Number v1,
+                                                  lua_Number v2) {
+  switch (op) {
+    case LUA_OPADD: return luai_numadd(L, v1, v2);
+    case LUA_OPSUB: return luai_numsub(L, v1, v2);
+    case LUA_OPMUL: return luai_nummul(L, v1, v2);
+    case LUA_OPDIV: return luai_numdiv(L, v1, v2);
+    case LUA_OPPOW: return luai_numpow(L, v1, v2);
+    case LUA_OPIDIV: return luai_numidiv(L, v1, v2);
+    case LUA_OPUNM: return luai_numunm(L, v1);
+    case LUA_OPMOD: {
+      lua_Number m;
+      luai_nummod(L, v1, v2, m);
+      return m;
+    }
+    default: lua_assert(0); return 0;
+  }
 }
 
 
-#if !defined(lua_strx2number)
+void luaO_arith (lua_State *L, int op, const TValue *p1, const TValue *p2,
+                 TValue *res) {
+  switch (op) {
+    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
+    case LUA_OPSHL: case LUA_OPSHR:
+    case LUA_OPBNOT: {  /* operate only on integers */
+      lua_Integer i1; lua_Integer i2;
+      if (tointeger(p1, &i1) && tointeger(p2, &i2)) {
+        setivalue(res, intarith(L, op, i1, i2));
+        return;
+      }
+      else break;  /* go to the end */
+    }
+    case LUA_OPDIV: case LUA_OPPOW: {  /* operate only on floats */
+      lua_Number n1; lua_Number n2;
+      if (tonumber(p1, &n1) && tonumber(p2, &n2)) {
+        setfltvalue(res, numarith(L, op, n1, n2));
+        return;
+      }
+      else break;  /* go to the end */
+    }
+    default: {  /* other operations */
+      lua_Number n1; lua_Number n2;
+      if (ttisinteger(p1) && ttisinteger(p2)) {
+        setivalue(res, intarith(L, op, ivalue(p1), ivalue(p2)));
+        return;
+      }
+      else if (tonumber(p1, &n1) && tonumber(p2, &n2)) {
+        setfltvalue(res, numarith(L, op, n1, n2));
+        return;
+      }
+      else break;  /* go to the end */
+    }
+  }
+  /* could not perform raw operation; try metamethod */
+  lua_assert(L != NULL);  /* should not fail when folding (compile time) */
+  luaT_trybinTM(L, p1, p2, res, cast(TMS, op - LUA_OPADD + TM_ADD));
+}
 
-#include <math.h>
+
+int luaO_hexavalue (int c) {
+  if (lisdigit(c)) return c - '0';
+  else return ltolower(c) - 'a' + 10;
+}
 
 
 static int isneg (const char **s) {
@@ -102,80 +166,185 @@
 }
 
 
-static lua_Number readhexa (const char **s, lua_Number r, int *count) {
-  for (; lisxdigit(cast_uchar(**s)); (*s)++) {  /* read integer part */
-    r = (r * cast_num(16.0)) + cast_num(luaO_hexavalue(cast_uchar(**s)));
-    (*count)++;
-  }
-  return r;
-}
 
+/*
+** {==================================================================
+** Lua's implementation for 'lua_strx2number'
+** ===================================================================
+*/
+#if !defined(lua_strx2number)
+
+#include <math.h>
+
+/* maximum number of significant digits to read (to avoid overflows
+   even with single floats) */
+#define MAXSIGDIG	30
 
 /*
 ** convert an hexadecimal numeric string to a number, following
 ** C99 specification for 'strtod'
 */
 static lua_Number lua_strx2number (const char *s, char **endptr) {
-  lua_Number r = 0.0;
-  int e = 0, i = 0;
-  int neg = 0;  /* 1 if number is negative */
+  lua_Number r = 0.0;  /* result (accumulator) */
+  int sigdig = 0;  /* number of significant digits */
+  int nosigdig = 0;  /* number of non-significant digits */
+  int e = 0;  /* exponent correction */
+  int neg;  /* 1 if number is negative */
+  int dot = 0;  /* true after seen a dot */
   *endptr = cast(char *, s);  /* nothing is valid yet */
   while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
   neg = isneg(&s);  /* check signal */
   if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */
     return 0.0;  /* invalid format (no '0x') */
-  s += 2;  /* skip '0x' */
-  r = readhexa(&s, r, &i);  /* read integer part */
-  if (*s == '.') {
-    s++;  /* skip dot */
-    r = readhexa(&s, r, &e);  /* read fractional part */
-  }
-  if (i == 0 && e == 0)
-    return 0.0;  /* invalid format (no digit) */
-  e *= -4;  /* each fractional digit divides value by 2^-4 */
+  for (s += 2; ; s++) {  /* skip '0x' and read numeral */
+    if (*s == '.') {
+      if (dot) break;  /* second dot? stop loop */
+      else dot = 1;
+    }
+    else if (lisxdigit(cast_uchar(*s))) {
+      if (sigdig == 0 && *s == '0')  /* non-significant digit (zero)? */
+        nosigdig++;
+      else if (++sigdig <= MAXSIGDIG)  /* can read it without overflow? */
+          r = (r * cast_num(16.0)) + luaO_hexavalue(*s);
+      else e++; /* too many digits; ignore, but still count for exponent */
+      if (dot) e--;  /* decimal digit? correct exponent */
+    }
+    else break;  /* neither a dot nor a digit */
+  }
+  if (nosigdig + sigdig == 0)  /* no digits? */
+    return 0.0;  /* invalid format */
   *endptr = cast(char *, s);  /* valid up to here */
+  e *= 4;  /* each digit multiplies/divides value by 2^4 */
   if (*s == 'p' || *s == 'P') {  /* exponent part? */
-    int exp1 = 0;
-    int neg1;
+    int exp1 = 0;  /* exponent value */
+    int neg1;  /* exponent signal */
     s++;  /* skip 'p' */
     neg1 = isneg(&s);  /* signal */
     if (!lisdigit(cast_uchar(*s)))
-      goto ret;  /* must have at least one digit */
+      return 0.0;  /* invalid; must have at least one digit */
     while (lisdigit(cast_uchar(*s)))  /* read exponent */
       exp1 = exp1 * 10 + *(s++) - '0';
     if (neg1) exp1 = -exp1;
     e += exp1;
+    *endptr = cast(char *, s);  /* valid up to here */
   }
-  *endptr = cast(char *, s);  /* valid up to here */
- ret:
   if (neg) r = -r;
   return l_mathop(ldexp)(r, e);
 }
 
 #endif
+/* }====================================================== */
 
 
-int luaO_str2d (const char *s, size_t len, lua_Number *result) {
+static const char *l_str2d (const char *s, lua_Number *result) {
   char *endptr;
   if (strpbrk(s, "nN"))  /* reject 'inf' and 'nan' */
-    return 0;
-  else if (strpbrk(s, "xX"))  /* hexa? */
+    return NULL;
+  else if (strpbrk(s, "xX"))  /* hex? */
     *result = lua_strx2number(s, &endptr);
   else
     *result = lua_str2number(s, &endptr);
   if (endptr == s) return 0;  /* nothing recognized */
   while (lisspace(cast_uchar(*endptr))) endptr++;
-  return (endptr == s + len);  /* OK if no trailing characters */
+  return (*endptr == '\0' ? endptr : NULL);  /* OK if no trailing characters */
+}
+
+
+static const char *l_str2int (const char *s, lua_Integer *result) {
+  lua_Unsigned a = 0;
+  int empty = 1;
+  int neg;
+  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
+  neg = isneg(&s);
+  if (s[0] == '0' &&
+      (s[1] == 'x' || s[1] == 'X')) {  /* hex? */
+    s += 2;  /* skip '0x' */
+    for (; lisxdigit(cast_uchar(*s)); s++) {
+      a = a * 16 + luaO_hexavalue(*s);
+      empty = 0;
+    }
+  }
+  else {  /* decimal */
+    for (; lisdigit(cast_uchar(*s)); s++) {
+      a = a * 10 + *s - '0';
+      empty = 0;
+    }
+  }
+  while (lisspace(cast_uchar(*s))) s++;  /* skip trailing spaces */
+  if (empty || *s != '\0') return NULL;  /* something wrong in the numeral */
+  else {
+    *result = l_castU2S((neg) ? 0u - a : a);
+    return s;
+  }
+}
+
+
+size_t luaO_str2num (const char *s, TValue *o) {
+  lua_Integer i; lua_Number n;
+  const char *e;
+  if ((e = l_str2int(s, &i)) != NULL) {  /* try as an integer */
+    setivalue(o, i);
+  }
+  else if ((e = l_str2d(s, &n)) != NULL) {  /* else try as a float */
+    setfltvalue(o, n);
+  }
+  else
+    return 0;  /* conversion failed */
+  return (e - s + 1);  /* success; return string size */
+}
+
+
+int luaO_utf8esc (char *buff, unsigned long x) {
+  int n = 1;  /* number of bytes put in buffer (backwards) */
+  lua_assert(x <= 0x10FFFF);
+  if (x < 0x80)  /* ascii? */
+    buff[UTF8BUFFSZ - 1] = cast(char, x);
+  else {  /* need continuation bytes */
+    unsigned int mfb = 0x3f;  /* maximum that fits in first byte */
+    do {  /* add continuation bytes */
+      buff[UTF8BUFFSZ - (n++)] = cast(char, 0x80 | (x & 0x3f));
+      x >>= 6;  /* remove added bits */
+      mfb >>= 1;  /* now there is one less bit available in first byte */
+    } while (x > mfb);  /* still needs continuation byte? */
+    buff[UTF8BUFFSZ - n] = cast(char, (~mfb << 1) | x);  /* add first byte */
+  }
+  return n;
 }
 
 
+/* maximum length of the conversion of a number to a string */
+#define MAXNUMBER2STR	50
+
+
+/*
+** Convert a number object to a string
+*/
+void luaO_tostring (lua_State *L, StkId obj) {
+  char buff[MAXNUMBER2STR];
+  size_t len;
+  lua_assert(ttisnumber(obj));
+  if (ttisinteger(obj))
+    len = lua_integer2str(buff, ivalue(obj));
+  else {
+    len = lua_number2str(buff, fltvalue(obj));
+#if !defined(LUA_COMPAT_FLOATSTRING)
+    if (buff[strspn(buff, "-0123456789")] == '\0') {  /* looks like an int? */
+      buff[len++] = '.';
+      buff[len++] = '0';  /* adds '.0' to result */
+    }
+#endif
+  }
+  setsvalue2s(L, obj, luaS_newlstr(L, buff, len));
+}
+
 
 static void pushstr (lua_State *L, const char *str, size_t l) {
   setsvalue2s(L, L->top++, luaS_newlstr(L, str, l));
 }
 
 
-/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
+/* this function handles only '%d', '%c', '%f', '%p', and '%s' 
+   conventional formats, plus Lua-specific '%I' and '%U' */
 const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
   int n = 0;
   for (;;) {
@@ -191,33 +360,47 @@
         break;
       }
       case 'c': {
-        char buff;
-        buff = cast(char, va_arg(argp, int));
-        pushstr(L, &buff, 1);
+        char buff = cast(char, va_arg(argp, int));
+        if (lisprint(cast_uchar(buff)))
+          pushstr(L, &buff, 1);
+        else  /* non-printable character; print its code */
+          luaO_pushfstring(L, "<\\%d>", cast_uchar(buff));
         break;
       }
       case 'd': {
-        setnvalue(L->top++, cast_num(va_arg(argp, int)));
+        setivalue(L->top++, va_arg(argp, int));
+        luaO_tostring(L, L->top - 1);
+        break;
+      }
+      case 'I': {
+        setivalue(L->top++, cast(lua_Integer, va_arg(argp, l_uacInt)));
+        luaO_tostring(L, L->top - 1);
         break;
       }
       case 'f': {
-        setnvalue(L->top++, cast_num(va_arg(argp, l_uacNumber)));
+        setfltvalue(L->top++, cast_num(va_arg(argp, l_uacNumber)));
+        luaO_tostring(L, L->top - 1);
         break;
       }
       case 'p': {
-        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
+        char buff[4*sizeof(void *) + 8]; /* should be enough space for a '%p' */
         int l = sprintf(buff, "%p", va_arg(argp, void *));
         pushstr(L, buff, l);
         break;
       }
+      case 'U': {
+        char buff[UTF8BUFFSZ];
+        int l = luaO_utf8esc(buff, cast(long, va_arg(argp, long)));
+        pushstr(L, buff + UTF8BUFFSZ - l, l);
+        break;
+      }
       case '%': {
         pushstr(L, "%", 1);
         break;
       }
       default: {
-        luaG_runerror(L,
-            "invalid option " LUA_QL("%%%c") " to " LUA_QL("lua_pushfstring"),
-            *(e + 1));
+        luaG_runerror(L, "invalid option '%%%c' to 'lua_pushfstring'",
+                         *(e + 1));
       }
     }
     n += 2;
diff -urN rpm-5.4.15/lua/lobject.h rpm-5.4-cvs/lua/lobject.h
--- rpm-5.4.15/lua/lobject.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lobject.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lobject.h,v 2.71 2012/09/11 18:21:44 roberto Exp $
+** $Id: lobject.h,v 2.106 2015/01/05 13:52:37 roberto Exp $
 ** Type definitions for Lua objects
 ** See Copyright Notice in lua.h
 */
@@ -20,13 +20,12 @@
 ** Extra tags for non-values
 */
 #define LUA_TPROTO	LUA_NUMTAGS
-#define LUA_TUPVAL	(LUA_NUMTAGS+1)
-#define LUA_TDEADKEY	(LUA_NUMTAGS+2)
+#define LUA_TDEADKEY	(LUA_NUMTAGS+1)
 
 /*
 ** number of all possible tags (including LUA_TNONE but excluding DEADKEY)
 */
-#define LUA_TOTALTAGS	(LUA_TUPVAL+2)
+#define LUA_TOTALTAGS	(LUA_TPROTO + 2)
 
 
 /*
@@ -57,6 +56,11 @@
 #define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */
 
 
+/* Variant tags for numbers */
+#define LUA_TNUMFLT	(LUA_TNUMBER | (0 << 4))  /* float numbers */
+#define LUA_TNUMINT	(LUA_TNUMBER | (1 << 4))  /* integer numbers */
+
+
 /* Bit mark for collectable types */
 #define BIT_ISCOLLECTABLE	(1 << 6)
 
@@ -65,9 +69,9 @@
 
 
 /*
-** Union of all collectable objects
+** Common type for all collectable objects
 */
-typedef union GCObject GCObject;
+typedef struct GCObject GCObject;
 
 
 /*
@@ -78,11 +82,11 @@
 
 
 /*
-** Common header in struct form
+** Common type has only the common header
 */
-typedef struct GCheader {
+struct GCObject {
   CommonHeader;
-} GCheader;
+};
 
 
 
@@ -92,8 +96,6 @@
 typedef union Value Value;
 
 
-#define numfield	lua_Number n;    /* numbers */
-
 
 
 /*
@@ -111,7 +113,6 @@
 
 
 #define val_(o)		((o)->value_)
-#define num_(o)		(val_(o).n)
 
 
 /* raw type tag of a TValue */
@@ -124,13 +125,15 @@
 #define ttype(o)	(rttype(o) & 0x3F)
 
 /* type tag of a TValue with no variants (bits 0-3) */
-#define ttypenv(o)	(novariant(rttype(o)))
+#define ttnov(o)	(novariant(rttype(o)))
 
 
 /* Macros to test type */
 #define checktag(o,t)		(rttype(o) == (t))
-#define checktype(o,t)		(ttypenv(o) == (t))
-#define ttisnumber(o)		checktag((o), LUA_TNUMBER)
+#define checktype(o,t)		(ttnov(o) == (t))
+#define ttisnumber(o)		checktype((o), LUA_TNUMBER)
+#define ttisfloat(o)		checktag((o), LUA_TNUMFLT)
+#define ttisinteger(o)		checktag((o), LUA_TNUMINT)
 #define ttisnil(o)		checktag((o), LUA_TNIL)
 #define ttisboolean(o)		checktag((o), LUA_TBOOLEAN)
 #define ttislightuserdata(o)	checktag((o), LUA_TLIGHTUSERDATA)
@@ -143,27 +146,27 @@
 #define ttisCclosure(o)		checktag((o), ctb(LUA_TCCL))
 #define ttisLclosure(o)		checktag((o), ctb(LUA_TLCL))
 #define ttislcf(o)		checktag((o), LUA_TLCF)
-#define ttisuserdata(o)		checktag((o), ctb(LUA_TUSERDATA))
+#define ttisfulluserdata(o)	checktag((o), ctb(LUA_TUSERDATA))
 #define ttisthread(o)		checktag((o), ctb(LUA_TTHREAD))
 #define ttisdeadkey(o)		checktag((o), LUA_TDEADKEY)
 
-#define ttisequal(o1,o2)	(rttype(o1) == rttype(o2))
 
 /* Macros to access values */
-#define nvalue(o)	check_exp(ttisnumber(o), num_(o))
+#define ivalue(o)	check_exp(ttisinteger(o), val_(o).i)
+#define fltvalue(o)	check_exp(ttisfloat(o), val_(o).n)
+#define nvalue(o)	check_exp(ttisnumber(o), \
+	(ttisinteger(o) ? cast_num(ivalue(o)) : fltvalue(o)))
 #define gcvalue(o)	check_exp(iscollectable(o), val_(o).gc)
 #define pvalue(o)	check_exp(ttislightuserdata(o), val_(o).p)
-#define rawtsvalue(o)	check_exp(ttisstring(o), &val_(o).gc->ts)
-#define tsvalue(o)	(&rawtsvalue(o)->tsv)
-#define rawuvalue(o)	check_exp(ttisuserdata(o), &val_(o).gc->u)
-#define uvalue(o)	(&rawuvalue(o)->uv)
-#define clvalue(o)	check_exp(ttisclosure(o), &val_(o).gc->cl)
-#define clLvalue(o)	check_exp(ttisLclosure(o), &val_(o).gc->cl.l)
-#define clCvalue(o)	check_exp(ttisCclosure(o), &val_(o).gc->cl.c)
+#define tsvalue(o)	check_exp(ttisstring(o), gco2ts(val_(o).gc))
+#define uvalue(o)	check_exp(ttisfulluserdata(o), gco2u(val_(o).gc))
+#define clvalue(o)	check_exp(ttisclosure(o), gco2cl(val_(o).gc))
+#define clLvalue(o)	check_exp(ttisLclosure(o), gco2lcl(val_(o).gc))
+#define clCvalue(o)	check_exp(ttisCclosure(o), gco2ccl(val_(o).gc))
 #define fvalue(o)	check_exp(ttislcf(o), val_(o).f)
-#define hvalue(o)	check_exp(ttistable(o), &val_(o).gc->h)
+#define hvalue(o)	check_exp(ttistable(o), gco2t(val_(o).gc))
 #define bvalue(o)	check_exp(ttisboolean(o), val_(o).b)
-#define thvalue(o)	check_exp(ttisthread(o), &val_(o).gc->th)
+#define thvalue(o)	check_exp(ttisthread(o), gco2th(val_(o).gc))
 /* a dead value may get the 'gc' field, but cannot access its contents */
 #define deadvalue(o)	check_exp(ttisdeadkey(o), cast(void *, val_(o).gc))
 
@@ -174,7 +177,7 @@
 
 
 /* Macros for internal tests */
-#define righttt(obj)		(ttype(obj) == gcvalue(obj)->gch.tt)
+#define righttt(obj)		(ttype(obj) == gcvalue(obj)->tt)
 
 #define checkliveness(g,obj) \
 	lua_longassert(!iscollectable(obj) || \
@@ -184,8 +187,11 @@
 /* Macros to set values */
 #define settt_(o,t)	((o)->tt_=(t))
 
-#define setnvalue(obj,x) \
-  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }
+#define setfltvalue(obj,x) \
+  { TValue *io=(obj); val_(io).n=(x); settt_(io, LUA_TNUMFLT); }
+
+#define setivalue(obj,x) \
+  { TValue *io=(obj); val_(io).i=(x); settt_(io, LUA_TNUMINT); }
 
 #define setnilvalue(obj) settt_(obj, LUA_TNIL)
 
@@ -199,38 +205,37 @@
   { TValue *io=(obj); val_(io).b=(x); settt_(io, LUA_TBOOLEAN); }
 
 #define setgcovalue(L,obj,x) \
-  { TValue *io=(obj); GCObject *i_g=(x); \
-    val_(io).gc=i_g; settt_(io, ctb(gch(i_g)->tt)); }
+  { TValue *io = (obj); GCObject *i_g=(x); \
+    val_(io).gc = i_g; settt_(io, ctb(i_g->tt)); }
 
 #define setsvalue(L,obj,x) \
-  { TValue *io=(obj); \
-    TString *x_ = (x); \
-    val_(io).gc=cast(GCObject *, x_); settt_(io, ctb(x_->tsv.tt)); \
+  { TValue *io = (obj); TString *x_ = (x); \
+    val_(io).gc = obj2gco(x_); settt_(io, ctb(x_->tt)); \
     checkliveness(G(L),io); }
 
 #define setuvalue(L,obj,x) \
-  { TValue *io=(obj); \
-    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TUSERDATA)); \
+  { TValue *io = (obj); Udata *x_ = (x); \
+    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TUSERDATA)); \
     checkliveness(G(L),io); }
 
 #define setthvalue(L,obj,x) \
-  { TValue *io=(obj); \
-    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTHREAD)); \
+  { TValue *io = (obj); lua_State *x_ = (x); \
+    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TTHREAD)); \
     checkliveness(G(L),io); }
 
 #define setclLvalue(L,obj,x) \
-  { TValue *io=(obj); \
-    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TLCL)); \
+  { TValue *io = (obj); LClosure *x_ = (x); \
+    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TLCL)); \
     checkliveness(G(L),io); }
 
 #define setclCvalue(L,obj,x) \
-  { TValue *io=(obj); \
-    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TCCL)); \
+  { TValue *io = (obj); CClosure *x_ = (x); \
+    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TCCL)); \
     checkliveness(G(L),io); }
 
 #define sethvalue(L,obj,x) \
-  { TValue *io=(obj); \
-    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTABLE)); \
+  { TValue *io = (obj); Table *x_ = (x); \
+    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TTABLE)); \
     checkliveness(G(L),io); }
 
 #define setdeadvalue(obj)	settt_(obj, LUA_TDEADKEY)
@@ -238,9 +243,8 @@
 
 
 #define setobj(L,obj1,obj2) \
-	{ const TValue *io2=(obj2); TValue *io1=(obj1); \
-	  io1->value_ = io2->value_; io1->tt_ = io2->tt_; \
-	  checkliveness(G(L),io1); }
+	{ TValue *io1=(obj1); *io1 = *(obj2); \
+	  (void)L; checkliveness(G(L),io1); }
 
 
 /*
@@ -263,119 +267,6 @@
 #define setsvalue2n	setsvalue
 
 
-/* check whether a number is valid (useful only for NaN trick) */
-#define luai_checknum(L,o,c)	{ /* empty */ }
-
-
-/*
-** {======================================================
-** NaN Trick
-** =======================================================
-*/
-#if defined(LUA_NANTRICK)
-
-/*
-** numbers are represented in the 'd_' field. All other values have the
-** value (NNMARK | tag) in 'tt__'. A number with such pattern would be
-** a "signaled NaN", which is never generated by regular operations by
-** the CPU (nor by 'strtod')
-*/
-
-/* allows for external implementation for part of the trick */
-#if !defined(NNMARK)	/* { */
-
-
-#if !defined(LUA_IEEEENDIAN)
-#error option 'LUA_NANTRICK' needs 'LUA_IEEEENDIAN'
-#endif
-
-
-#define NNMARK		0x7FF7A500
-#define NNMASK		0x7FFFFF00
-
-#undef TValuefields
-#undef NILCONSTANT
-
-#if (LUA_IEEEENDIAN == 0)	/* { */
-
-/* little endian */
-#define TValuefields  \
-	union { struct { Value v__; int tt__; } i; double d__; } u
-#define NILCONSTANT	{{{NULL}, tag2tt(LUA_TNIL)}}
-/* field-access macros */
-#define v_(o)		((o)->u.i.v__)
-#define d_(o)		((o)->u.d__)
-#define tt_(o)		((o)->u.i.tt__)
-
-#else				/* }{ */
-
-/* big endian */
-#define TValuefields  \
-	union { struct { int tt__; Value v__; } i; double d__; } u
-#define NILCONSTANT	{{tag2tt(LUA_TNIL), {NULL}}}
-/* field-access macros */
-#define v_(o)		((o)->u.i.v__)
-#define d_(o)		((o)->u.d__)
-#define tt_(o)		((o)->u.i.tt__)
-
-#endif				/* } */
-
-#endif			/* } */
-
-
-/* correspondence with standard representation */
-#undef val_
-#define val_(o)		v_(o)
-#undef num_
-#define num_(o)		d_(o)
-
-
-#undef numfield
-#define numfield	/* no such field; numbers are the entire struct */
-
-/* basic check to distinguish numbers from non-numbers */
-#undef ttisnumber
-#define ttisnumber(o)	((tt_(o) & NNMASK) != NNMARK)
-
-#define tag2tt(t)	(NNMARK | (t))
-
-#undef rttype
-#define rttype(o)	(ttisnumber(o) ? LUA_TNUMBER : tt_(o) & 0xff)
-
-#undef settt_
-#define settt_(o,t)	(tt_(o) = tag2tt(t))
-
-#undef setnvalue
-#define setnvalue(obj,x) \
-	{ TValue *io_=(obj); num_(io_)=(x); lua_assert(ttisnumber(io_)); }
-
-#undef setobj
-#define setobj(L,obj1,obj2) \
-	{ const TValue *o2_=(obj2); TValue *o1_=(obj1); \
-	  o1_->u = o2_->u; \
-	  checkliveness(G(L),o1_); }
-
-
-/*
-** these redefinitions are not mandatory, but these forms are more efficient
-*/
-
-#undef checktag
-#undef checktype
-#define checktag(o,t)	(tt_(o) == tag2tt(t))
-#define checktype(o,t)	(ctb(tt_(o) | VARBITS) == ctb(tag2tt(t) | VARBITS))
-
-#undef ttisequal
-#define ttisequal(o1,o2)  \
-	(ttisnumber(o1) ? ttisnumber(o2) : (tt_(o1) == tt_(o2)))
-
-
-#undef luai_checknum
-#define luai_checknum(L,o,c)	{ if (!ttisnumber(o)) c; }
-
-#endif
-/* }====================================================== */
-
 
 
 /*
@@ -390,7 +281,8 @@
   void *p;         /* light userdata */
   int b;           /* booleans */
   lua_CFunction f; /* light C functions */
-  numfield         /* numbers */
+  lua_Integer i;   /* integer numbers */
+  lua_Number n;    /* float numbers */
 };
 
 
@@ -406,39 +298,78 @@
 
 /*
 ** Header for string value; string bytes follow the end of this structure
+** (aligned according to 'UTString'; see next).
 */
-typedef union TString {
-  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
-  struct {
-    CommonHeader;
-    lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
-    unsigned int hash;
-    size_t len;  /* number of characters in string */
-  } tsv;
+typedef struct TString {
+  CommonHeader;
+  lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
+  unsigned int hash;
+  size_t len;  /* number of characters in string */
+  struct TString *hnext;  /* linked list for hash table */
 } TString;
 
 
-/* get the actual string (array of bytes) from a TString */
-#define getstr(ts)	cast(const char *, (ts) + 1)
+/*
+** Ensures that address after this type is always fully aligned.
+*/
+typedef union UTString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  TString tsv;
+} UTString;
+
+
+/*
+** Get the actual string (array of bytes) from a 'TString'.
+** (Access to 'extra' ensures that value is really a 'TString'.)
+*/
+#define getaddrstr(ts)	(cast(char *, (ts)) + sizeof(UTString))
+#define getstr(ts)  \
+  check_exp(sizeof((ts)->extra), cast(const char*, getaddrstr(ts)))
 
 /* get the actual string (array of bytes) from a Lua value */
-#define svalue(o)       getstr(rawtsvalue(o))
+#define svalue(o)       getstr(tsvalue(o))
 
 
 /*
 ** Header for userdata; memory area follows the end of this structure
+** (aligned according to 'UUdata'; see next).
 */
-typedef union Udata {
-  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
-  struct {
-    CommonHeader;
-    struct Table *metatable;
-    struct Table *env;
-    size_t len;  /* number of bytes */
-  } uv;
+typedef struct Udata {
+  CommonHeader;
+  lu_byte ttuv_;  /* user value's tag */
+  struct Table *metatable;
+  size_t len;  /* number of bytes */
+  union Value user_;  /* user value */
 } Udata;
 
 
+/*
+** Ensures that address after this type is always fully aligned.
+*/
+typedef union UUdata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for 'local' udata */
+  Udata uv;
+} UUdata;
+
+
+/*
+**  Get the address of memory block inside 'Udata'.
+** (Access to 'ttuv_' ensures that value is really a 'Udata'.)
+*/
+#define getudatamem(u)  \
+  check_exp(sizeof((u)->ttuv_), (cast(char*, (u)) + sizeof(UUdata)))
+
+#define setuservalue(L,u,o) \
+	{ const TValue *io=(o); Udata *iu = (u); \
+	  iu->user_ = io->value_; iu->ttuv_ = io->tt_; \
+	  checkliveness(G(L),io); }
+
+
+#define getuservalue(L,u,o) \
+	{ TValue *io=(o); const Udata *iu = (u); \
+	  io->value_ = iu->user_; io->tt_ = iu->ttuv_; \
+	  checkliveness(G(L),io); }
+
 
 /*
 ** Description of an upvalue for function prototypes
@@ -466,26 +397,26 @@
 */
 typedef struct Proto {
   CommonHeader;
+  lu_byte numparams;  /* number of fixed parameters */
+  lu_byte is_vararg;
+  lu_byte maxstacksize;  /* maximum stack used by this function */
+  int sizeupvalues;  /* size of 'upvalues' */
+  int sizek;  /* size of 'k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of 'p' */
+  int sizelocvars;
+  int linedefined;
+  int lastlinedefined;
   TValue *k;  /* constants used by the function */
   Instruction *code;
   struct Proto **p;  /* functions defined inside the function */
   int *lineinfo;  /* map from opcodes to source lines (debug information) */
   LocVar *locvars;  /* information about local variables (debug information) */
   Upvaldesc *upvalues;  /* upvalue information */
-  union Closure *cache;  /* last created closure with this prototype */
+  struct LClosure *cache;  /* last created closure with this prototype */
   TString  *source;  /* used for debug information */
-  int sizeupvalues;  /* size of 'upvalues' */
-  int sizek;  /* size of `k' */
-  int sizecode;
-  int sizelineinfo;
-  int sizep;  /* size of `p' */
-  int sizelocvars;
-  int linedefined;
-  int lastlinedefined;
   GCObject *gclist;
-  lu_byte numparams;  /* number of fixed parameters */
-  lu_byte is_vararg;
-  lu_byte maxstacksize;  /* maximum stack used by this function */
 } Proto;
 
 
@@ -493,17 +424,7 @@
 /*
 ** Lua Upvalues
 */
-typedef struct UpVal {
-  CommonHeader;
-  TValue *v;  /* points to stack or to its own value */
-  union {
-    TValue value;  /* the value (when closed) */
-    struct {  /* double linked list (when open) */
-      struct UpVal *prev;
-      struct UpVal *next;
-    } l;
-  } u;
-} UpVal;
+typedef struct UpVal UpVal;
 
 
 /*
@@ -545,12 +466,19 @@
 typedef union TKey {
   struct {
     TValuefields;
-    struct Node *next;  /* for chaining */
+    int next;  /* for chaining (offset for next node) */
   } nk;
   TValue tvk;
 } TKey;
 
 
+/* copy a value into a key without messing up field 'next' */
+#define setnodekey(L,key,obj) \
+	{ TKey *k_=(key); const TValue *io_=(obj); \
+	  k_->nk.value_ = io_->value_; k_->nk.tt_ = io_->tt_; \
+	  (void)L; checkliveness(G(L),io_); }
+
+
 typedef struct Node {
   TValue i_val;
   TKey i_key;
@@ -560,19 +488,19 @@
 typedef struct Table {
   CommonHeader;
   lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
-  lu_byte lsizenode;  /* log2 of size of `node' array */
-  struct Table *metatable;
+  lu_byte lsizenode;  /* log2 of size of 'node' array */
+  unsigned int sizearray;  /* size of 'array' array */
   TValue *array;  /* array part */
   Node *node;
   Node *lastfree;  /* any free position is before this position */
+  struct Table *metatable;
   GCObject *gclist;
-  int sizearray;  /* size of `array' array */
 } Table;
 
 
 
 /*
-** `module' operation for hashing (size is always a power of 2)
+** 'module' operation for hashing (size is always a power of 2)
 */
 #define lmod(s,size) \
 	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
@@ -590,13 +518,22 @@
 
 LUAI_DDEC const TValue luaO_nilobject_;
 
+/* size of buffer for 'luaO_utf8esc' function */
+#define UTF8BUFFSZ	8
 
-LUAI_FUNC int luaO_int2fb (unsigned int x);
-LUAI_FUNC int luaO_fb2int (int x);
-LUAI_FUNC int luaO_ceillog2 (unsigned int x);
-LUAI_FUNC lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2);
-LUAI_FUNC int luaO_str2d (const char *s, size_t len, lua_Number *result);
-LUAI_FUNC int luaO_hexavalue (int c);
+LUAI_FUNC int luaO_int2fb (unsigned int x)
+	LUA_GNUC_CONST;
+LUAI_FUNC int luaO_fb2int (int x)
+	LUA_GNUC_CONST;
+LUAI_FUNC int luaO_utf8esc (char *buff, unsigned long x);
+LUAI_FUNC int luaO_ceillog2 (unsigned int x)
+	LUA_GNUC_CONST;
+LUAI_FUNC void luaO_arith (lua_State *L, int op, const TValue *p1,
+                           const TValue *p2, TValue *res);
+LUAI_FUNC size_t luaO_str2num (const char *s, TValue *o);
+LUAI_FUNC int luaO_hexavalue (int c)
+	LUA_GNUC_CONST;
+LUAI_FUNC void luaO_tostring (lua_State *L, StkId obj);
 LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
                                                        va_list argp);
 LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
diff -urN rpm-5.4.15/lua/local/lposix.c rpm-5.4-cvs/lua/local/lposix.c
--- rpm-5.4.15/lua/local/lposix.c	2013-07-31 14:43:26.000000000 -0500
+++ rpm-5.4-cvs/lua/local/lposix.c	2014-09-27 10:48:46.000000000 -0500
@@ -1,3 +1,8 @@
+#if __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdocumentation"
+#endif
+
 /***
 @module lposix
 */
@@ -1680,7 +1685,7 @@
 {
 	const char *path = luaL_checkstring(L, 1);
 	int flags = luaL_checkint(L, 2);
-	mode_t mode;
+	mode_t mode = 0000;
 	if (flags & O_CREAT) {
 		const char *modestr = luaL_checkstring(L, 3);
 		if (mode_munch(&mode, modestr))
@@ -4308,4 +4313,8 @@
 	return 1;
 }
 
+#if __clang__
+#pragma clang diagnostic pop
+#endif
+
 /*EOF*/
diff -urN rpm-5.4.15/lua/local/lrexlib_common.c rpm-5.4-cvs/lua/local/lrexlib_common.c
--- rpm-5.4.15/lua/local/lrexlib_common.c	2013-06-29 16:03:27.000000000 -0500
+++ rpm-5.4-cvs/lua/local/lrexlib_common.c	2014-09-24 05:57:31.000000000 -0500
@@ -255,9 +255,13 @@
 }
 
 #if LUA_VERSION_NUM > 501
+LUA_GNUC_NORETURN
 int luaL_typerror (lua_State *L, int narg, const char *tname) {
   const char *msg = lua_pushfstring(L, "%s expected, got %s",
                                     tname, luaL_typename(L, narg));
-  return luaL_argerror(L, narg, msg);
+#if     !(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
+  return
+#endif
+  luaL_argerror(L, narg, msg);
 }
 #endif
diff -urN rpm-5.4.15/lua/local/lrexlib_common.h rpm-5.4-cvs/lua/local/lrexlib_common.h
--- rpm-5.4.15/lua/local/lrexlib_common.h	2013-06-29 16:03:27.000000000 -0500
+++ rpm-5.4-cvs/lua/local/lrexlib_common.h	2014-09-24 06:19:20.000000000 -0500
@@ -90,7 +90,8 @@
 int  get_int_field (lua_State *L, const char* field);
 void set_int_field (lua_State *L, const char* field, int val);
 int  get_flags (lua_State *L, const flag_pair **arr);
-const char *get_flag_key (const flag_pair *fp, int val);
+const char *get_flag_key (const flag_pair *fp, int val)
+	LUA_GNUC_PURE;
 void *Lmalloc (lua_State *L, size_t size);
 
 #endif
diff -urN rpm-5.4.15/lua/local/lua52compat.h rpm-5.4-cvs/lua/local/lua52compat.h
--- rpm-5.4.15/lua/local/lua52compat.h	2013-06-29 16:03:27.000000000 -0500
+++ rpm-5.4-cvs/lua/local/lua52compat.h	2015-04-18 23:34:20.000000000 -0500
@@ -6,15 +6,23 @@
  * Include this file after Lua headers
 */
 
-#if LUA_VERSION_NUM == 502
+#if LUA_VERSION_NUM == 502 || defined(LUA_COMPAT_5_2)
+LUA_GNUC_NORETURN
 static int luaL_typerror(lua_State *L, int narg, const char *tname)
 {
         const char *msg = lua_pushfstring(L, "%s expected, got %s",
                                           tname, luaL_typename(L, narg));
-        return luaL_argerror(L, narg, msg);
+#if     !(__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
+        return
+#endif
+	luaL_argerror(L, narg, msg);
 }
+
+#if !defined(LUA_COMPAT_5_2)
 #define lua_objlen lua_rawlen
 #define lua_strlen lua_rawlen
 #define luaL_openlib(L,n,l,nup) luaL_setfuncs((L),(l),(nup))
 #define luaL_register(L,n,l) (luaL_newlib(L,l))
 #endif
+
+#endif
diff -urN rpm-5.4.15/lua/lopcodes.c rpm-5.4-cvs/lua/lopcodes.c
--- rpm-5.4.15/lua/lopcodes.c	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lopcodes.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,13 +1,16 @@
 /*
-** $Id: lopcodes.c,v 1.49 2012/05/14 13:34:18 roberto Exp $
+** $Id: lopcodes.c,v 1.55 2015/01/05 13:48:33 roberto Exp $
 ** Opcodes for Lua virtual machine
 ** See Copyright Notice in lua.h
 */
 
-
 #define lopcodes_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <stddef.h>
 
 #include "lopcodes.h"
 
@@ -31,10 +34,17 @@
   "ADD",
   "SUB",
   "MUL",
-  "DIV",
   "MOD",
   "POW",
+  "DIV",
+  "IDIV",
+  "BAND",
+  "BOR",
+  "BXOR",
+  "SHL",
+  "SHR",
   "UNM",
+  "BNOT",
   "NOT",
   "LEN",
   "CONCAT",
@@ -79,10 +89,17 @@
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
- ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_IDIV */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BAND */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BOR */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BXOR */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SHL */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SHR */
  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_BNOT */
  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
  ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
diff -urN rpm-5.4.15/lua/lopcodes.h rpm-5.4-cvs/lua/lopcodes.h
--- rpm-5.4.15/lua/lopcodes.h	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/lopcodes.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lopcodes.h,v 1.142 2011/07/15 12:50:29 roberto Exp $
+** $Id: lopcodes.h,v 1.148 2014/10/25 11:50:46 roberto Exp $
 ** Opcodes for Lua virtual machine
 ** See Copyright Notice in lua.h
 */
@@ -14,12 +14,12 @@
   We assume that instructions are unsigned numbers.
   All instructions have an opcode in the first 6 bits.
   Instructions can have the following fields:
-	`A' : 8 bits
-	`B' : 9 bits
-	`C' : 9 bits
+	'A' : 8 bits
+	'B' : 9 bits
+	'C' : 9 bits
 	'Ax' : 26 bits ('A', 'B', and 'C' together)
-	`Bx' : 18 bits (`B' and `C' together)
-	`sBx' : signed Bx
+	'Bx' : 18 bits ('B' and 'C' together)
+	'sBx' : signed Bx
 
   A signed argument is represented in excess K; that is, the number
   value is the unsigned value minus K. K is exactly the maximum value
@@ -58,7 +58,7 @@
 */
 #if SIZE_Bx < LUAI_BITSINT-1
 #define MAXARG_Bx        ((1<<SIZE_Bx)-1)
-#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
+#define MAXARG_sBx        (MAXARG_Bx>>1)         /* 'sBx' is signed */
 #else
 #define MAXARG_Bx        MAX_INT
 #define MAXARG_sBx        MAX_INT
@@ -76,10 +76,10 @@
 #define MAXARG_C        ((1<<SIZE_C)-1)
 
 
-/* creates a mask with `n' 1 bits at position `p' */
+/* creates a mask with 'n' 1 bits at position 'p' */
 #define MASK1(n,p)	((~((~(Instruction)0)<<(n)))<<(p))
 
-/* creates a mask with `n' 0 bits at position `p' */
+/* creates a mask with 'n' 0 bits at position 'p' */
 #define MASK0(n,p)	(~MASK1(n,p))
 
 /*
@@ -187,16 +187,23 @@
 OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
 OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
 OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
-OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
 OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
 OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_IDIV,/*	A B C	R(A) := RK(B) // RK(C)				*/
+OP_BAND,/*	A B C	R(A) := RK(B) & RK(C)				*/
+OP_BOR,/*	A B C	R(A) := RK(B) | RK(C)				*/
+OP_BXOR,/*	A B C	R(A) := RK(B) ~ RK(C)				*/
+OP_SHL,/*	A B C	R(A) := RK(B) << RK(C)				*/
+OP_SHR,/*	A B C	R(A) := RK(B) >> RK(C)				*/
 OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_BNOT,/*	A B	R(A) := ~R(B)					*/
 OP_NOT,/*	A B	R(A) := not R(B)				*/
 OP_LEN,/*	A B	R(A) := length of R(B)				*/
 
 OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
 
-OP_JMP,/*	A sBx	pc+=sBx; if (A) close all upvalues >= R(A) + 1	*/
+OP_JMP,/*	A sBx	pc+=sBx; if (A) close all upvalues >= R(A - 1)	*/
 OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
 OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++		*/
 OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++		*/
@@ -231,16 +238,16 @@
 
 /*===========================================================================
   Notes:
-  (*) In OP_CALL, if (B == 0) then B = top. If (C == 0), then `top' is
+  (*) In OP_CALL, if (B == 0) then B = top. If (C == 0), then 'top' is
   set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
-  OP_SETLIST) may use `top'.
+  OP_SETLIST) may use 'top'.
 
   (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
   set top (like in OP_CALL with C == 0).
 
-  (*) In OP_RETURN, if (B == 0) then return up to `top'.
+  (*) In OP_RETURN, if (B == 0) then return up to 'top'.
 
-  (*) In OP_SETLIST, if (B == 0) then B = `top'; if (C == 0) then next
+  (*) In OP_SETLIST, if (B == 0) then B = 'top'; if (C == 0) then next
   'instruction' is EXTRAARG(real C).
 
   (*) In OP_LOADKX, the next 'instruction' is always EXTRAARG.
@@ -248,7 +255,7 @@
   (*) For comparisons, A specifies what condition the test should accept
   (true or false).
 
-  (*) All `skips' (pc++) assume that next instruction is a jump.
+  (*) All 'skips' (pc++) assume that next instruction is a jump.
 
 ===========================================================================*/
 
diff -urN rpm-5.4.15/lua/loslib.c rpm-5.4-cvs/lua/loslib.c
--- rpm-5.4.15/lua/loslib.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/loslib.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,9 +1,14 @@
 /*
-** $Id: loslib.c,v 1.40 2012/10/19 15:54:02 roberto Exp $
+** $Id: loslib.c,v 1.54 2014/12/26 14:46:07 roberto Exp $
 ** Standard Operating System library
 ** See Copyright Notice in lua.h
 */
 
+#define loslib_c
+#define LUA_LIB
+
+#include "lprefix.h"
+
 
 #include <errno.h>
 #include <locale.h>
@@ -11,69 +16,96 @@
 #include <string.h>
 #include <time.h>
 
-#define loslib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
 #include "lualib.h"
 
 
+#if !defined(LUA_STRFTIMEOPTIONS)	/* { */
 /*
 ** list of valid conversion specifiers for the 'strftime' function
 */
-#if !defined(LUA_STRFTIMEOPTIONS)
 
-#if !defined(LUA_USE_POSIX)
+#if defined(LUA_USE_C89)
 #define LUA_STRFTIMEOPTIONS	{ "aAbBcdHIjmMpSUwWxXyYz%", "" }
-#else
+#else  /* C99 specification */
 #define LUA_STRFTIMEOPTIONS \
-	{ "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%", "" \
-	  "", "E", "cCxXyY",  \
+	{ "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%", "", \
+	  "E", "cCxXyY",  \
 	  "O", "deHImMSuUVwWy" }
 #endif
 
-#endif
+#endif					/* } */
+
+
+
+#if !defined(l_time_t)		/* { */
+/*
+** type to represent time_t in Lua
+*/
+#define l_timet			lua_Integer
+#define l_pushtime(L,t)		lua_pushinteger(L,(lua_Integer)(t))
+#define l_checktime(L,a)	((time_t)luaL_checkinteger(L,a))
+
+#endif				/* } */
 
 
 
+#if !defined(lua_tmpnam)	/* { */
 /*
 ** By default, Lua uses tmpnam except when POSIX is available, where it
 ** uses mkstemp.
 */
-#if defined(LUA_USE_MKSTEMP)
+
+#if defined(LUA_USE_POSIX)	/* { */
+
 #include <unistd.h>
+
 #define LUA_TMPNAMBUFSIZE	32
+
+#if !defined(LUA_TMPNAMTEMPLATE)
+#define LUA_TMPNAMTEMPLATE	"/tmp/lua_XXXXXX"
+#endif
+
 #define lua_tmpnam(b,e) { \
-        strcpy(b, "/tmp/lua_XXXXXX"); \
+        strcpy(b, LUA_TMPNAMTEMPLATE); \
         e = mkstemp(b); \
         if (e != -1) close(e); \
         e = (e == -1); }
 
-#elif !defined(lua_tmpnam)
+#else				/* }{ */
 
+/* ISO C definitions */
 #define LUA_TMPNAMBUFSIZE	L_tmpnam
 #define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
 
-#endif
+#endif				/* } */
 
+#endif				/* } */
 
+
+
+#if !defined(l_gmtime)		/* { */
 /*
 ** By default, Lua uses gmtime/localtime, except when POSIX is available,
 ** where it uses gmtime_r/localtime_r
 */
-#if defined(LUA_USE_GMTIME_R)
+
+#if defined(LUA_USE_POSIX)	/* { */
 
 #define l_gmtime(t,r)		gmtime_r(t,r)
 #define l_localtime(t,r)	localtime_r(t,r)
 
-#elif !defined(l_gmtime)
+#else				/* }{ */
 
-#define l_gmtime(t,r)		((void)r, gmtime(t))
-#define l_localtime(t,r)  	((void)r, localtime(t))
+/* ISO C definitions */
+#define l_gmtime(t,r)		((void)(r)->tm_sec, gmtime(t))
+#define l_localtime(t,r)  	((void)(r)->tm_sec, localtime(t))
 
-#endif
+#endif				/* } */
+
+#endif				/* } */
 
 
 
@@ -147,8 +179,7 @@
 
 static int getboolfield (lua_State *L, const char *key) {
   int res;
-  lua_getfield(L, -1, key);
-  res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
+  res = (lua_getfield(L, -1, key) == LUA_TNIL) ? -1 : lua_toboolean(L, -1);
   lua_pop(L, 1);
   return res;
 }
@@ -160,7 +191,7 @@
   res = (int)lua_tointegerx(L, -1, &isnum);
   if (!isnum) {
     if (d < 0)
-      return luaL_error(L, "field " LUA_QS " missing in date table", key);
+      return luaL_error(L, "field '%s' missing in date table", key);
     res = d;
   }
   lua_pop(L, 1);
@@ -194,11 +225,11 @@
 
 static int os_date (lua_State *L) {
   const char *s = luaL_optstring(L, 1, "%c");
-  time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
+  time_t t = luaL_opt(L, l_checktime, 2, time(NULL));
   struct tm tmr, *stm;
   if (*s == '!') {  /* UTC? */
     stm = l_gmtime(&t, &tmr);
-    s++;  /* skip `!' */
+    s++;  /* skip '!' */
   }
   else
     stm = l_localtime(&t, &tmr);
@@ -255,17 +286,19 @@
     ts.tm_isdst = getboolfield(L, "isdst");
     t = mktime(&ts);
   }
-  if (t == (time_t)(-1))
+  if (t != (time_t)(l_timet)t)
+    luaL_error(L, "time result cannot be represented in this Lua instalation");
+  else if (t == (time_t)(-1))
     lua_pushnil(L);
   else
-    lua_pushnumber(L, (lua_Number)t);
+    l_pushtime(L, t);
   return 1;
 }
 
 
 static int os_difftime (lua_State *L) {
-  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
-                             (time_t)(luaL_optnumber(L, 2, 0))));
+  double res = difftime((l_checktime(L, 1)), (l_checktime(L, 2)));
+  lua_pushnumber(L, (lua_Number)res);
   return 1;
 }
 
@@ -289,7 +322,7 @@
   if (lua_isboolean(L, 1))
     status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);
   else
-    status = luaL_optint(L, 1, EXIT_SUCCESS);
+    status = (int)luaL_optinteger(L, 1, EXIT_SUCCESS);
   if (lua_toboolean(L, 2))
     lua_close(L);
   if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */
diff -urN rpm-5.4.15/lua/lparser.c rpm-5.4-cvs/lua/lparser.c
--- rpm-5.4.15/lua/lparser.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lparser.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,15 +1,17 @@
 /*
-** $Id: lparser.c,v 2.130 2013/02/06 13:37:39 roberto Exp $
+** $Id: lparser.c,v 2.147 2014/12/27 20:31:43 roberto Exp $
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */
 
-
-#include <string.h>
-
 #define lparser_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <string.h>
+
 #include "lua.h"
 
 #include "lcode.h"
@@ -35,17 +37,21 @@
 #define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
 
 
+/* because all strings are unified by the scanner, the parser
+   can use pointer equality for string equality */
+#define eqstr(a,b)	((a) == (b))
+
 
 /*
 ** nodes for block list (list of active blocks)
 */
 typedef struct BlockCnt {
   struct BlockCnt *previous;  /* chain */
-  short firstlabel;  /* index of first label in this block */
-  short firstgoto;  /* index of first pending goto in this block */
+  int firstlabel;  /* index of first label in this block */
+  int firstgoto;  /* index of first pending goto in this block */
   lu_byte nactvar;  /* # active locals outside the block */
   lu_byte upval;  /* true if some variable in the block is an upvalue */
-  lu_byte isloop;  /* true if `block' is a loop */
+  lu_byte isloop;  /* true if 'block' is a loop */
 } BlockCnt;
 
 
@@ -57,19 +63,9 @@
 static void expr (LexState *ls, expdesc *v);
 
 
-static void anchor_token (LexState *ls) {
-  /* last token from outer function must be EOS */
-  lua_assert(ls->fs != NULL || ls->t.token == TK_EOS);
-  if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
-    TString *ts = ls->t.seminfo.ts;
-    luaX_newstring(ls, getstr(ts), ts->tsv.len);
-  }
-}
-
-
 /* semantic error */
 static l_noret semerror (LexState *ls, const char *msg) {
-  ls->t.token = 0;  /* remove 'near to' from final message */
+  ls->t.token = 0;  /* remove "near <token>" from final message */
   luaX_syntaxerror(ls, msg);
 }
 
@@ -222,7 +218,7 @@
   int i;
   Upvaldesc *up = fs->f->upvalues;
   for (i = 0; i < fs->nups; i++) {
-    if (luaS_eqstr(up[i].name, name)) return i;
+    if (eqstr(up[i].name, name)) return i;
   }
   return -1;  /* not found */
 }
@@ -246,7 +242,7 @@
 static int searchvar (FuncState *fs, TString *n) {
   int i;
   for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {
-    if (luaS_eqstr(n, getlocvar(fs, i)->varname))
+    if (eqstr(n, getlocvar(fs, i)->varname))
       return i;
   }
   return -1;  /* not found */
@@ -342,11 +338,11 @@
   FuncState *fs = ls->fs;
   Labellist *gl = &ls->dyd->gt;
   Labeldesc *gt = &gl->arr[g];
-  lua_assert(luaS_eqstr(gt->name, label->name));
+  lua_assert(eqstr(gt->name, label->name));
   if (gt->nactvar < label->nactvar) {
     TString *vname = getlocvar(fs, gt->nactvar)->varname;
     const char *msg = luaO_pushfstring(ls->L,
-      "<goto %s> at line %d jumps into the scope of local " LUA_QS,
+      "<goto %s> at line %d jumps into the scope of local '%s'",
       getstr(gt->name), gt->line, getstr(vname));
     semerror(ls, msg);
   }
@@ -369,7 +365,7 @@
   /* check labels in current block for a match */
   for (i = bl->firstlabel; i < dyd->label.n; i++) {
     Labeldesc *lb = &dyd->label.arr[i];
-    if (luaS_eqstr(lb->name, gt->name)) {  /* correct label? */
+    if (eqstr(lb->name, gt->name)) {  /* correct label? */
       if (gt->nactvar > lb->nactvar &&
           (bl->upval || dyd->label.n > bl->firstlabel))
         luaK_patchclose(ls->fs, gt->pc, lb->nactvar);
@@ -390,7 +386,7 @@
   l->arr[n].line = line;
   l->arr[n].nactvar = ls->fs->nactvar;
   l->arr[n].pc = pc;
-  l->n++;
+  l->n = n + 1;
   return n;
 }
 
@@ -403,7 +399,7 @@
   Labellist *gl = &ls->dyd->gt;
   int i = ls->fs->bl->firstgoto;
   while (i < gl->n) {
-    if (luaS_eqstr(gl->arr[i].name, lb->name))
+    if (eqstr(gl->arr[i].name, lb->name))
       closegoto(ls, i, lb);
     else
       i++;
@@ -412,7 +408,7 @@
 
 
 /*
-** "export" pending gotos to outer level, to check them against
+** export pending gotos to outer level, to check them against
 ** outer labels; if the block being exited has upvalues, and
 ** the goto exits the scope of any variable (which can be the
 ** upvalue), close those variables being exited.
@@ -448,7 +444,7 @@
 
 
 /*
-** create a label named "break" to resolve break statements
+** create a label named 'break' to resolve break statements
 */
 static void breaklabel (LexState *ls) {
   TString *n = luaS_new(ls->L, "break");
@@ -463,7 +459,7 @@
 static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
   const char *msg = isreserved(gt->name)
                     ? "<%s> at line %d not inside a loop"
-                    : "no visible label " LUA_QS " for <goto> at line %d";
+                    : "no visible label '%s' for <goto> at line %d";
   msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
   semerror(ls, msg);
 }
@@ -525,7 +521,6 @@
 
 
 static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
-  lua_State *L = ls->L;
   Proto *f;
   fs->prev = ls->fs;  /* linked list of funcstates */
   fs->ls = ls;
@@ -544,10 +539,6 @@
   f = fs->f;
   f->source = ls->source;
   f->maxstacksize = 2;  /* registers 0/1 are always valid */
-  fs->h = luaH_new(L);
-  /* anchor table of constants (to avoid being collected) */
-  sethvalue2s(L, L->top, fs->h);
-  incr_top(L);
   enterblock(fs, bl, 0);
 }
 
@@ -572,9 +563,6 @@
   f->sizeupvalues = fs->nups;
   lua_assert(fs->bl == NULL);
   ls->fs = fs->prev;
-  /* last token read was anchored in defunct function; must re-anchor it */
-  anchor_token(ls);
-  L->top--;  /* pop table of constants */
   luaC_checkGC(L);
 }
 
@@ -588,7 +576,7 @@
 /*
 ** check whether current token is in the follow set of a block.
 ** 'until' closes syntactical blocks, but do not close scope,
-** so it handled in separate.
+** so it is handled in separate.
 */
 static int block_follow (LexState *ls, int withuntil) {
   switch (ls->t.token) {
@@ -602,7 +590,7 @@
 
 
 static void statlist (LexState *ls) {
-  /* statlist -> { stat [`;'] } */
+  /* statlist -> { stat [';'] } */
   while (!block_follow(ls, 1)) {
     if (ls->t.token == TK_RETURN) {
       statement(ls);
@@ -643,14 +631,14 @@
 struct ConsControl {
   expdesc v;  /* last list item read */
   expdesc *t;  /* table descriptor */
-  int nh;  /* total number of `record' elements */
+  int nh;  /* total number of 'record' elements */
   int na;  /* total number of array elements */
   int tostore;  /* number of array elements pending to be stored */
 };
 
 
 static void recfield (LexState *ls, struct ConsControl *cc) {
-  /* recfield -> (NAME | `['exp1`]') = exp1 */
+  /* recfield -> (NAME | '['exp1']') = exp1 */
   FuncState *fs = ls->fs;
   int reg = ls->fs->freereg;
   expdesc key, val;
@@ -757,12 +745,12 @@
 
 
 static void parlist (LexState *ls) {
-  /* parlist -> [ param { `,' param } ] */
+  /* parlist -> [ param { ',' param } ] */
   FuncState *fs = ls->fs;
   Proto *f = fs->f;
   int nparams = 0;
   f->is_vararg = 0;
-  if (ls->t.token != ')') {  /* is `parlist' not empty? */
+  if (ls->t.token != ')') {  /* is 'parlist' not empty? */
     do {
       switch (ls->t.token) {
         case TK_NAME: {  /* param -> NAME */
@@ -770,12 +758,12 @@
           nparams++;
           break;
         }
-        case TK_DOTS: {  /* param -> `...' */
+        case TK_DOTS: {  /* param -> '...' */
           luaX_next(ls);
           f->is_vararg = 1;
           break;
         }
-        default: luaX_syntaxerror(ls, "<name> or " LUA_QL("...") " expected");
+        default: luaX_syntaxerror(ls, "<name> or '...' expected");
       }
     } while (!f->is_vararg && testnext(ls, ','));
   }
@@ -786,7 +774,7 @@
 
 
 static void body (LexState *ls, expdesc *e, int ismethod, int line) {
-  /* body ->  `(' parlist `)' block END */
+  /* body ->  '(' parlist ')' block END */
   FuncState new_fs;
   BlockCnt bl;
   new_fs.f = addprototype(ls);
@@ -808,7 +796,7 @@
 
 
 static int explist (LexState *ls, expdesc *v) {
-  /* explist -> expr { `,' expr } */
+  /* explist -> expr { ',' expr } */
   int n = 1;  /* at least one expression */
   expr(ls, v);
   while (testnext(ls, ',')) {
@@ -825,7 +813,7 @@
   expdesc args;
   int base, nparams;
   switch (ls->t.token) {
-    case '(': {  /* funcargs -> `(' [ explist ] `)' */
+    case '(': {  /* funcargs -> '(' [ explist ] ')' */
       luaX_next(ls);
       if (ls->t.token == ')')  /* arg list is empty? */
         args.k = VVOID;
@@ -842,7 +830,7 @@
     }
     case TK_STRING: {  /* funcargs -> STRING */
       codestring(ls, &args, ls->t.seminfo.ts);
-      luaX_next(ls);  /* must use `seminfo' before `next' */
+      luaX_next(ls);  /* must use 'seminfo' before 'next' */
       break;
     }
     default: {
@@ -908,14 +896,14 @@
         fieldsel(ls, v);
         break;
       }
-      case '[': {  /* `[' exp1 `]' */
+      case '[': {  /* '[' exp1 ']' */
         expdesc key;
         luaK_exp2anyregup(fs, v);
         yindex(ls, &key);
         luaK_indexed(fs, v, &key);
         break;
       }
-      case ':': {  /* `:' NAME funcargs */
+      case ':': {  /* ':' NAME funcargs */
         expdesc key;
         luaX_next(ls);
         checkname(ls, &key);
@@ -935,14 +923,19 @@
 
 
 static void simpleexp (LexState *ls, expdesc *v) {
-  /* simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
+  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
                   constructor | FUNCTION body | suffixedexp */
   switch (ls->t.token) {
-    case TK_NUMBER: {
-      init_exp(v, VKNUM, 0);
+    case TK_FLT: {
+      init_exp(v, VKFLT, 0);
       v->u.nval = ls->t.seminfo.r;
       break;
     }
+    case TK_INT: {
+      init_exp(v, VKINT, 0);
+      v->u.ival = ls->t.seminfo.i;
+      break;
+    }
     case TK_STRING: {
       codestring(ls, v, ls->t.seminfo.ts);
       break;
@@ -962,7 +955,7 @@
     case TK_DOTS: {  /* vararg */
       FuncState *fs = ls->fs;
       check_condition(ls, fs->f->is_vararg,
-                      "cannot use " LUA_QL("...") " outside a vararg function");
+                      "cannot use '...' outside a vararg function");
       init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
       break;
     }
@@ -988,6 +981,7 @@
   switch (op) {
     case TK_NOT: return OPR_NOT;
     case '-': return OPR_MINUS;
+    case '~': return OPR_BNOT;
     case '#': return OPR_LEN;
     default: return OPR_NOUNOPR;
   }
@@ -999,9 +993,15 @@
     case '+': return OPR_ADD;
     case '-': return OPR_SUB;
     case '*': return OPR_MUL;
-    case '/': return OPR_DIV;
     case '%': return OPR_MOD;
     case '^': return OPR_POW;
+    case '/': return OPR_DIV;
+    case TK_IDIV: return OPR_IDIV;
+    case '&': return OPR_BAND;
+    case '|': return OPR_BOR;
+    case '~': return OPR_BXOR;
+    case TK_SHL: return OPR_SHL;
+    case TK_SHR: return OPR_SHR;
     case TK_CONCAT: return OPR_CONCAT;
     case TK_NE: return OPR_NE;
     case TK_EQ: return OPR_EQ;
@@ -1020,19 +1020,24 @@
   lu_byte left;  /* left priority for each binary operator */
   lu_byte right; /* right priority */
 } priority[] = {  /* ORDER OPR */
-   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `*' `/' `%' */
-   {10, 9}, {5, 4},                 /* ^, .. (right associative) */
-   {3, 3}, {3, 3}, {3, 3},          /* ==, <, <= */
-   {3, 3}, {3, 3}, {3, 3},          /* ~=, >, >= */
-   {2, 2}, {1, 1}                   /* and, or */
+   {10, 10}, {10, 10},           /* '+' '-' */
+   {11, 11}, {11, 11},           /* '*' '%' */
+   {14, 13},                  /* '^' (right associative) */
+   {11, 11}, {11, 11},           /* '/' '//' */
+   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */
+   {7, 7}, {7, 7},           /* '<<' '>>' */
+   {9, 8},                   /* '..' (right associative) */
+   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */
+   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */
+   {2, 2}, {1, 1}            /* and, or */
 };
 
-#define UNARY_PRIORITY	8  /* priority for unary operators */
+#define UNARY_PRIORITY	12  /* priority for unary operators */
 
 
 /*
 ** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
-** where `binop' is any binary operator with a priority higher than `limit'
+** where 'binop' is any binary operator with a priority higher than 'limit'
 */
 static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
   BinOpr op;
@@ -1046,7 +1051,7 @@
     luaK_prefix(ls->fs, uop, v, line);
   }
   else simpleexp(ls, v);
-  /* expand while operators have priorities higher than `limit' */
+  /* expand while operators have priorities higher than 'limit' */
   op = getbinopr(ls->t.token);
   while (op != OPR_NOBINOPR && priority[op].left > limit) {
     expdesc v2;
@@ -1146,7 +1151,7 @@
                     "C levels");
     assignment(ls, &nv, nvars+1);
   }
-  else {  /* assignment -> `=' explist */
+  else {  /* assignment -> '=' explist */
     int nexps;
     checknext(ls, '=');
     nexps = explist(ls, &e);
@@ -1170,7 +1175,7 @@
   /* cond -> exp */
   expdesc v;
   expr(ls, &v);  /* read condition */
-  if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
+  if (v.k == VNIL) v.k = VFALSE;  /* 'falses' are all equal here */
   luaK_goiftrue(ls->fs, &v);
   return v.f;
 }
@@ -1195,9 +1200,9 @@
 static void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {
   int i;
   for (i = fs->bl->firstlabel; i < ll->n; i++) {
-    if (luaS_eqstr(label, ll->arr[i].name)) {
+    if (eqstr(label, ll->arr[i].name)) {
       const char *msg = luaO_pushfstring(fs->ls->L,
-                          "label " LUA_QS " already defined on line %d",
+                          "label '%s' already defined on line %d",
                           getstr(label), ll->arr[i].line);
       semerror(fs->ls, msg);
     }
@@ -1321,7 +1326,7 @@
   if (testnext(ls, ','))
     exp1(ls);  /* optional step */
   else {  /* default step = 1 */
-    luaK_codek(fs, fs->freereg, luaK_numberK(fs, 1));
+    luaK_codek(fs, fs->freereg, luaK_intK(fs, 1));
     luaK_reserveregs(fs, 1);
   }
   forbody(ls, base, line, 1, 1);
@@ -1359,15 +1364,15 @@
   TString *varname;
   BlockCnt bl;
   enterblock(fs, &bl, 1);  /* scope for loop and control variables */
-  luaX_next(ls);  /* skip `for' */
+  luaX_next(ls);  /* skip 'for' */
   varname = str_checkname(ls);  /* first variable name */
   switch (ls->t.token) {
     case '=': fornum(ls, varname, line); break;
     case ',': case TK_IN: forlist(ls, varname); break;
-    default: luaX_syntaxerror(ls, LUA_QL("=") " or " LUA_QL("in") " expected");
+    default: luaX_syntaxerror(ls, "'=' or 'in' expected");
   }
   check_match(ls, TK_END, TK_FOR, line);
-  leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+  leaveblock(fs);  /* loop scope ('break' jumps to this point) */
 }
 
 
@@ -1397,7 +1402,7 @@
     enterblock(fs, &bl, 0);
     jf = v.f;
   }
-  statlist(ls);  /* `then' part */
+  statlist(ls);  /* 'then' part */
   leaveblock(fs);
   if (ls->t.token == TK_ELSE ||
       ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */
@@ -1414,7 +1419,7 @@
   while (ls->t.token == TK_ELSEIF)
     test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */
   if (testnext(ls, TK_ELSE))
-    block(ls);  /* `else' part */
+    block(ls);  /* 'else' part */
   check_match(ls, TK_END, TK_IF, line);
   luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */
 }
@@ -1432,7 +1437,7 @@
 
 
 static void localstat (LexState *ls) {
-  /* stat -> LOCAL NAME {`,' NAME} [`=' explist] */
+  /* stat -> LOCAL NAME {',' NAME} ['=' explist] */
   int nvars = 0;
   int nexps;
   expdesc e;
@@ -1452,7 +1457,7 @@
 
 
 static int funcname (LexState *ls, expdesc *v) {
-  /* funcname -> NAME {fieldsel} [`:' NAME] */
+  /* funcname -> NAME {fieldsel} [':' NAME] */
   int ismethod = 0;
   singlevar(ls, v);
   while (ls->t.token == '.')
@@ -1473,7 +1478,7 @@
   ismethod = funcname(ls, &v);
   body(ls, &b, ismethod, line);
   luaK_storevar(ls->fs, &v, &b);
-  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+  luaK_fixline(ls->fs, line);  /* definition "happens" in the first line */
 }
 
 
@@ -1515,8 +1520,8 @@
       if (nret == 1)  /* only one single value? */
         first = luaK_exp2anyreg(fs, &e);
       else {
-        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
-        first = fs->nactvar;  /* return all `active' values */
+        luaK_exp2nextreg(fs, &e);  /* values must go to the stack */
+        first = fs->nactvar;  /* return all active values */
         lua_assert(nret == fs->freereg - first);
       }
     }
@@ -1615,16 +1620,19 @@
 }
 
 
-Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
-                      Dyndata *dyd, const char *name, int firstchar) {
+LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                       Dyndata *dyd, const char *name, int firstchar) {
   LexState lexstate;
   FuncState funcstate;
-  Closure *cl = luaF_newLclosure(L, 1);  /* create main closure */
-  /* anchor closure (to avoid being collected) */
-  setclLvalue(L, L->top, cl);
+  LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */
+  setclLvalue(L, L->top, cl);  /* anchor it (to avoid being collected) */
+  incr_top(L);
+  lexstate.h = luaH_new(L);  /* create table for scanner */
+  sethvalue(L, L->top, lexstate.h);  /* anchor it */
   incr_top(L);
-  funcstate.f = cl->l.p = luaF_newproto(L);
+  funcstate.f = cl->p = luaF_newproto(L);
   funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
+  lua_assert(iswhite(funcstate.f));  /* do not need barrier here */
   lexstate.buff = buff;
   lexstate.dyd = dyd;
   dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
@@ -1633,6 +1641,7 @@
   lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
   /* all scopes should be correctly finished */
   lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
-  return cl;  /* it's on the stack too */
+  L->top--;  /* remove scanner's table */
+  return cl;  /* closure is on the stack, too */
 }
 
diff -urN rpm-5.4.15/lua/lparser.h rpm-5.4-cvs/lua/lparser.h
--- rpm-5.4.15/lua/lparser.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lparser.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lparser.h,v 1.70 2012/05/08 13:53:33 roberto Exp $
+** $Id: lparser.h,v 1.74 2014/10/25 11:50:46 roberto Exp $
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */
@@ -21,8 +21,9 @@
   VNIL,
   VTRUE,
   VFALSE,
-  VK,		/* info = index of constant in `k' */
-  VKNUM,	/* nval = numerical value */
+  VK,		/* info = index of constant in 'k' */
+  VKFLT,	/* nval = numerical float value */
+  VKINT,	/* nval = numerical integer value */
   VNONRELOC,	/* info = result register */
   VLOCAL,	/* info = local register */
   VUPVAL,       /* info = index of upvalue in 'upvalues' */
@@ -46,10 +47,11 @@
       lu_byte vt;  /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */
     } ind;
     int info;  /* for generic use */
-    lua_Number nval;  /* for VKNUM */
+    lua_Number nval;  /* for VKFLT */
+    lua_Integer ival;    /* for VKINT */
   } u;
-  int t;  /* patch list of `exit when true' */
-  int f;  /* patch list of `exit when false' */
+  int t;  /* patch list of 'exit when true' */
+  int f;  /* patch list of 'exit when false' */
 } expdesc;
 
 
@@ -95,15 +97,14 @@
 /* state needed to generate code for a given function */
 typedef struct FuncState {
   Proto *f;  /* current function header */
-  Table *h;  /* table to find (and reuse) elements in `k' */
   struct FuncState *prev;  /* enclosing function */
   struct LexState *ls;  /* lexical state */
   struct BlockCnt *bl;  /* chain of current blocks */
-  int pc;  /* next position to code (equivalent to `ncode') */
+  int pc;  /* next position to code (equivalent to 'ncode') */
   int lasttarget;   /* 'label' of last 'jump label' */
-  int jpc;  /* list of pending jumps to `pc' */
-  int nk;  /* number of elements in `k' */
-  int np;  /* number of elements in `p' */
+  int jpc;  /* list of pending jumps to 'pc' */
+  int nk;  /* number of elements in 'k' */
+  int np;  /* number of elements in 'p' */
   int firstlocal;  /* index of first local var (in Dyndata array) */
   short nlocvars;  /* number of elements in 'f->locvars' */
   lu_byte nactvar;  /* number of active local variables */
@@ -112,8 +113,8 @@
 } FuncState;
 
 
-LUAI_FUNC Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
-                                Dyndata *dyd, const char *name, int firstchar);
+LUAI_FUNC LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                                 Dyndata *dyd, const char *name, int firstchar);
 
 
 #endif
diff -urN rpm-5.4.15/lua/lprefix.h rpm-5.4-cvs/lua/lprefix.h
--- rpm-5.4.15/lua/lprefix.h	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/lprefix.h	2015-04-18 23:34:18.000000000 -0500
@@ -0,0 +1,45 @@
+/*
+** $Id: lprefix.h,v 1.1.2.1 2015/04/19 04:34:18 jbj Exp $
+** Definitions for Lua code that must come before any other header file
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lprefix_h
+#define lprefix_h
+
+
+/*
+** Allows POSIX/XSI stuff
+*/
+#if !defined(LUA_USE_C89)	/* { */
+
+#if !defined(_XOPEN_SOURCE)
+#define _XOPEN_SOURCE           600
+#elif _XOPEN_SOURCE == 0
+#undef _XOPEN_SOURCE  /* use -D_XOPEN_SOURCE=0 to undefine it */
+#endif
+
+/*
+** Allows manipulation of large files in gcc and some other compilers
+*/
+#if !defined(LUA_32BITS) && !defined(_FILE_OFFSET_BITS)
+#define _LARGEFILE_SOURCE       1
+#define _FILE_OFFSET_BITS       64
+#endif
+
+#endif				/* } */
+
+
+/*
+** Windows stuff
+*/
+#if defined(_WIN32) 	/* { */
+
+#if !defined(_CRT_SECURE_NO_WARNINGS)
+#define _CRT_SECURE_NO_WARNINGS  /* avoid warnings about ISO C functions */
+#endif
+
+#endif			/* } */
+
+#endif
+
diff -urN rpm-5.4.15/lua/lstate.c rpm-5.4-cvs/lua/lstate.c
--- rpm-5.4.15/lua/lstate.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lstate.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,16 +1,18 @@
 /*
-** $Id: lstate.c,v 2.99 2012/10/02 17:40:53 roberto Exp $
+** $Id: lstate.c,v 2.127 2014/11/02 19:33:33 roberto Exp $
 ** Global State
 ** See Copyright Notice in lua.h
 */
 
+#define lstate_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
 #include <stddef.h>
 #include <string.h>
 
-#define lstate_c
-#define LUA_CORE
-
 #include "lua.h"
 
 #include "lapi.h"
@@ -30,10 +32,6 @@
 #define LUAI_GCPAUSE	200  /* 200% */
 #endif
 
-#if !defined(LUAI_GCMAJOR)
-#define LUAI_GCMAJOR	200  /* 200% */
-#endif
-
 #if !defined(LUAI_GCMUL)
 #define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
 #endif
@@ -57,9 +55,7 @@
 ** thread state + extra space
 */
 typedef struct LX {
-#if defined(LUAI_EXTRASPACE)
-  char buff[LUAI_EXTRASPACE];
-#endif
+  lu_byte extra_[LUA_EXTRASPACE];
   lua_State l;
 } LX;
 
@@ -78,9 +74,8 @@
 
 
 /*
-** Compute an initial seed as random as possible. In ANSI, rely on
-** Address Space Layout Randomization (if present) to increase
-** randomness..
+** Compute an initial seed as random as possible. Rely on Address Space
+** Layout Randomization (if present) to increase randomness..
 */
 #define addbuff(b,p,e) \
   { size_t t = cast(size_t, e); \
@@ -119,6 +114,9 @@
 }
 
 
+/*
+** free all CallInfo structures not in use by a thread
+*/
 void luaE_freeCI (lua_State *L) {
   CallInfo *ci = L->ci;
   CallInfo *next = ci->next;
@@ -130,6 +128,22 @@
 }
 
 
+/*
+** free half of the CallInfo structures not in use by a thread
+*/
+void luaE_shrinkCI (lua_State *L) {
+  CallInfo *ci = L->ci;
+  while (ci->next != NULL) {  /* while there is 'next' */
+    CallInfo *next2 = ci->next->next;  /* next's next */
+    if (next2 == NULL) break;
+    luaM_free(L, ci->next);  /* remove next */
+    ci->next = next2;  /* remove 'next' from the list */
+    next2->previous = ci;
+    ci = next2;
+  }
+}
+
+
 static void stack_init (lua_State *L1, lua_State *L) {
   int i; CallInfo *ci;
   /* initialize stack array */
@@ -163,22 +177,23 @@
 ** Create registry table and its predefined values
 */
 static void init_registry (lua_State *L, global_State *g) {
-  TValue mt;
+  TValue temp;
   /* create registry */
   Table *registry = luaH_new(L);
   sethvalue(L, &g->l_registry, registry);
   luaH_resize(L, registry, LUA_RIDX_LAST, 0);
   /* registry[LUA_RIDX_MAINTHREAD] = L */
-  setthvalue(L, &mt, L);
-  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);
+  setthvalue(L, &temp, L);  /* temp = L */
+  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &temp);
   /* registry[LUA_RIDX_GLOBALS] = table of globals */
-  sethvalue(L, &mt, luaH_new(L));
-  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);
+  sethvalue(L, &temp, luaH_new(L));  /* temp = new table (global table) */
+  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &temp);
 }
 
 
 /*
-** open parts of the state that may cause memory-allocation errors
+** open parts of the state that may cause memory-allocation errors.
+** ('g->version' != NULL flags that the state was completely build)
 */
 static void f_luaopen (lua_State *L, void *ud) {
   global_State *g = G(L);
@@ -190,20 +205,23 @@
   luaX_init(L);
   /* pre-create memory-error message */
   g->memerrmsg = luaS_newliteral(L, MEMERRMSG);
-  luaS_fix(g->memerrmsg);  /* it should never be collected */
+  luaC_fix(L, obj2gco(g->memerrmsg));  /* it should never be collected */
   g->gcrunning = 1;  /* allow gc */
+  g->version = lua_version(NULL);
+  luai_userstateopen(L);
 }
 
 
 /*
-** preinitialize a state with consistent values without allocating
+** preinitialize a thread with consistent values without allocating
 ** any memory (to avoid errors)
 */
-static void preinit_state (lua_State *L, global_State *g) {
+static void preinit_thread (lua_State *L, global_State *g) {
   G(L) = g;
   L->stack = NULL;
   L->ci = NULL;
   L->stacksize = 0;
+  L->twups = L;  /* thread has no upvalues */
   L->errorJmp = NULL;
   L->nCcalls = 0;
   L->hook = NULL;
@@ -222,6 +240,8 @@
   global_State *g = G(L);
   luaF_close(L, L->stack);  /* close all upvalues for this thread */
   luaC_freeallobjects(L);  /* collect all objects */
+  if (g->version)  /* closing a fully built state? */
+    luai_userstateclose(L);
   luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
   luaZ_freebuffer(L, &g->buff);
   freestack(L);
@@ -231,17 +251,28 @@
 
 
 LUA_API lua_State *lua_newthread (lua_State *L) {
+  global_State *g = G(L);
   lua_State *L1;
   lua_lock(L);
   luaC_checkGC(L);
-  L1 = &luaC_newobj(L, LUA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;
+  /* create new thread */
+  L1 = &cast(LX *, luaM_newobject(L, LUA_TTHREAD, sizeof(LX)))->l;
+  L1->marked = luaC_white(g);
+  L1->tt = LUA_TTHREAD;
+  /* link it on list 'allgc' */
+  L1->next = g->allgc;
+  g->allgc = obj2gco(L1);
+  /* anchor it on L stack */
   setthvalue(L, L->top, L1);
   api_incr_top(L);
-  preinit_state(L1, G(L));
+  preinit_thread(L1, g);
   L1->hookmask = L->hookmask;
   L1->basehookcount = L->basehookcount;
   L1->hook = L->hook;
   resethookcount(L1);
+  /* initialize L1 extra space */
+  memcpy(lua_getextraspace(L1), lua_getextraspace(g->mainthread),
+         LUA_EXTRASPACE);
   luai_userstatethread(L, L1);
   stack_init(L1, L);  /* init stack */
   lua_unlock(L);
@@ -269,36 +300,32 @@
   g = &l->g;
   L->next = NULL;
   L->tt = LUA_TTHREAD;
-  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);
+  g->currentwhite = bitmask(WHITE0BIT);
   L->marked = luaC_white(g);
-  g->gckind = KGC_NORMAL;
-  preinit_state(L, g);
+  preinit_thread(L, g);
   g->frealloc = f;
   g->ud = ud;
   g->mainthread = L;
   g->seed = makeseed(L);
-  g->uvhead.u.l.prev = &g->uvhead;
-  g->uvhead.u.l.next = &g->uvhead;
   g->gcrunning = 0;  /* no GC while building state */
   g->GCestimate = 0;
-  g->strt.size = 0;
-  g->strt.nuse = 0;
+  g->strt.size = g->strt.nuse = 0;
   g->strt.hash = NULL;
   setnilvalue(&g->l_registry);
   luaZ_initbuffer(L, &g->buff);
   g->panic = NULL;
-  g->version = lua_version(NULL);
+  g->version = NULL;
   g->gcstate = GCSpause;
-  g->allgc = NULL;
-  g->finobj = NULL;
-  g->tobefnz = NULL;
-  g->sweepgc = g->sweepfin = NULL;
+  g->gckind = KGC_NORMAL;
+  g->allgc = g->finobj = g->tobefnz = g->fixedgc = NULL;
+  g->sweepgc = NULL;
   g->gray = g->grayagain = NULL;
   g->weak = g->ephemeron = g->allweak = NULL;
+  g->twups = NULL;
   g->totalbytes = sizeof(LG);
   g->GCdebt = 0;
+  g->gcfinnum = 0;
   g->gcpause = LUAI_GCPAUSE;
-  g->gcmajorinc = LUAI_GCMAJOR;
   g->gcstepmul = LUAI_GCMUL;
   for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
   if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
@@ -306,8 +333,6 @@
     close_state(L);
     L = NULL;
   }
-  else
-    luai_userstateopen(L);
   return L;
 }
 
@@ -315,7 +340,6 @@
 LUA_API void lua_close (lua_State *L) {
   L = G(L)->mainthread;  /* only the main thread can be closed */
   lua_lock(L);
-  luai_userstateclose(L);
   close_state(L);
 }
 
diff -urN rpm-5.4.15/lua/lstate.h rpm-5.4-cvs/lua/lstate.h
--- rpm-5.4.15/lua/lstate.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lstate.h	2015-04-19 13:24:57.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lstate.h,v 2.82 2012/07/02 13:37:04 roberto Exp $
+** $Id: lstate.h,v 2.119 2014/10/30 18:53:28 roberto Exp $
 ** Global State
 ** See Copyright Notice in lua.h
 */
@@ -16,25 +16,16 @@
 
 /*
 
-** Some notes about garbage-collected objects:  All objects in Lua must
-** be kept somehow accessible until being freed.
+** Some notes about garbage-collected objects: All objects in Lua must
+** be kept somehow accessible until being freed, so all objects always
+** belong to one (and only one) of these lists, using field 'next' of
+** the 'CommonHeader' for the link:
 **
-** Lua keeps most objects linked in list g->allgc. The link uses field
-** 'next' of the CommonHeader.
-**
-** Strings are kept in several lists headed by the array g->strt.hash.
-**
-** Open upvalues are not subject to independent garbage collection. They
-** are collected together with their respective threads. Lua keeps a
-** double-linked list with all open upvalues (g->uvhead) so that it can
-** mark objects referred by them. (They are always gray, so they must
-** be remarked in the atomic step. Usually their contents would be marked
-** when traversing the respective threads, but the thread may already be
-** dead, while the upvalue is still accessible through closures.)
-**
-** Objects with finalizers are kept in the list g->finobj.
-**
-** The list g->tobefnz links all objects being finalized.
+** 'allgc': all objects not marked for finalization;
+** 'finobj': all objects marked for finalization;
+** 'tobefnz': all objects ready to be finalized; 
+** 'fixedgc': all objects that are not to be collected (currently
+** only small strings, such as reserved words).
 
 */
 
@@ -53,65 +44,71 @@
 /* kinds of Garbage Collection */
 #define KGC_NORMAL	0
 #define KGC_EMERGENCY	1	/* gc was forced by an allocation failure */
-#define KGC_GEN		2	/* generational collection */
 
 
 typedef struct stringtable {
-  GCObject **hash;
-  lu_int32 nuse;  /* number of elements */
+  TString **hash;
+  int nuse;  /* number of elements */
   int size;
 } stringtable;
 
 
 /*
-** information about a call
+** Information about a call.
+** When a thread yields, 'func' is adjusted to pretend that the
+** top function has only the yielded values in its stack; in that
+** case, the actual 'func' value is saved in field 'extra'. 
+** When a function calls another with a continuation, 'extra' keeps
+** the function index so that, in case of errors, the continuation
+** function can be called with the correct top.
 */
 typedef struct CallInfo {
   StkId func;  /* function index in the stack */
   StkId	top;  /* top for this function */
   struct CallInfo *previous, *next;  /* dynamic call link */
-  short nresults;  /* expected number of results from this function */
-  lu_byte callstatus;
-  ptrdiff_t extra;
   union {
     struct {  /* only for Lua functions */
       StkId base;  /* base for this function */
       const Instruction *savedpc;
     } l;
     struct {  /* only for C functions */
-      int ctx;  /* context info. in case of yields */
-      lua_CFunction k;  /* continuation in case of yields */
+      lua_KFunction k;  /* continuation in case of yields */
       ptrdiff_t old_errfunc;
-      lu_byte old_allowhook;
-      lu_byte status;
+      lua_KContext ctx;  /* context info. in case of yields */
     } c;
   } u;
+  ptrdiff_t extra;
+  short nresults;  /* expected number of results from this function */
+  lu_byte callstatus;
 } CallInfo;
 
 
 /*
 ** Bits in CallInfo status
 */
-#define CIST_LUA	(1<<0)	/* call is running a Lua function */
-#define CIST_HOOKED	(1<<1)	/* call is running a debug hook */
-#define CIST_REENTRY	(1<<2)	/* call is running on same invocation of
+#define CIST_OAH	(1<<0)	/* original value of 'allowhook' */
+#define CIST_LUA	(1<<1)	/* call is running a Lua function */
+#define CIST_HOOKED	(1<<2)	/* call is running a debug hook */
+#define CIST_REENTRY	(1<<3)	/* call is running on same invocation of
                                    luaV_execute of previous call */
-#define CIST_YIELDED	(1<<3)	/* call reentered after suspension */
 #define CIST_YPCALL	(1<<4)	/* call is a yieldable protected call */
-#define CIST_STAT	(1<<5)	/* call has an error status (pcall) */
-#define CIST_TAIL	(1<<6)	/* call was tail called */
-#define CIST_HOOKYIELD	(1<<7)	/* last hook called yielded */
-
+#define CIST_TAIL	(1<<5)	/* call was tail called */
+#define CIST_HOOKYIELD	(1<<6)	/* last hook called yielded */
+#define CIST_LEQ	(1<<7)	/* using __lt for __le */
 
 #define isLua(ci)	((ci)->callstatus & CIST_LUA)
 
+/* assume that CIST_OAH has offset 0 and that 'v' is strictly 0/1 */
+#define setoah(st,v)	((st) = ((st) & ~CIST_OAH) | (v))
+#define getoah(st)	((st) & CIST_OAH)
+
 
 /*
-** `global state', shared by all threads of this state
+** 'global state', shared by all threads of this state
 */
 typedef struct global_State {
   lua_Alloc frealloc;  /* function to reallocate memory */
-  void *ud;         /* auxiliary data to `frealloc' */
+  void *ud;         /* auxiliary data to 'frealloc' */
   lu_mem totalbytes;  /* number of bytes currently allocated - GCdebt */
   l_mem GCdebt;  /* bytes allocated not yet compensated by the collector */
   lu_mem GCmemtrav;  /* memory traversed by the GC */
@@ -123,22 +120,21 @@
   lu_byte gcstate;  /* state of garbage collector */
   lu_byte gckind;  /* kind of GC running */
   lu_byte gcrunning;  /* true if GC is running */
-  int sweepstrgc;  /* position of sweep in `strt' */
   GCObject *allgc;  /* list of all collectable objects */
+  GCObject **sweepgc;  /* current position of sweep in list */
   GCObject *finobj;  /* list of collectable objects with finalizers */
-  GCObject **sweepgc;  /* current position of sweep in list 'allgc' */
-  GCObject **sweepfin;  /* current position of sweep in list 'finobj' */
   GCObject *gray;  /* list of gray objects */
   GCObject *grayagain;  /* list of objects to be traversed atomically */
   GCObject *weak;  /* list of tables with weak values */
   GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */
   GCObject *allweak;  /* list of all-weak tables */
   GCObject *tobefnz;  /* list of userdata to be GC */
-  UpVal uvhead;  /* head of double-linked list of all open upvalues */
+  GCObject *fixedgc;  /* list of objects not to be collected */
+  struct lua_State *twups;  /* list of threads with open upvalues */
   Mbuffer buff;  /* temporary buffer for string concatenation */
+  unsigned int gcfinnum;  /* number of finalizers to call in each GC step */
   int gcpause;  /* size of pause between successive GCs */
-  int gcmajorinc;  /* pause between major collections (only in gen. mode) */
-  int gcstepmul;  /* GC `granularity' */
+  int gcstepmul;  /* GC 'granularity' */
   lua_CFunction panic;  /* to be called in unprotected errors */
   struct lua_State *mainthread;
   const lua_Number *version;  /* pointer to version number */
@@ -149,7 +145,7 @@
 
 
 /*
-** `per thread' state
+** 'per thread' state
 */
 struct lua_State {
   CommonHeader;
@@ -160,19 +156,20 @@
   const Instruction *oldpc;  /* last pc traced */
   StkId stack_last;  /* last free slot in the stack */
   StkId stack;  /* stack base */
+  UpVal *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_State *twups;  /* list of threads with open upvalues */
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
+  lua_Hook hook;
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
   int stacksize;
+  int basehookcount;
+  int hookcount;
   unsigned short nny;  /* number of non-yieldable calls in stack */
   unsigned short nCcalls;  /* number of nested C calls */
   lu_byte hookmask;
   lu_byte allowhook;
-  int basehookcount;
-  int hookcount;
-  lua_Hook hook;
-  GCObject *openupval;  /* list of open upvalues in this stack */
-  GCObject *gclist;
-  struct lua_longjmp *errorJmp;  /* current error recover point */
-  ptrdiff_t errfunc;  /* current error handling function (stack index) */
-  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
 };
 
 
@@ -180,39 +177,37 @@
 
 
 /*
-** Union of all collectable objects
+** Union of all collectable objects (only for conversions)
 */
-union GCObject {
-  GCheader gch;  /* common header */
-  union TString ts;
-  union Udata u;
+union GCUnion {
+  GCObject gc;  /* common header */
+  struct TString ts;
+  struct Udata u;
   union Closure cl;
   struct Table h;
   struct Proto p;
-  struct UpVal uv;
   struct lua_State th;  /* thread */
 };
 
 
-#define gch(o)		(&(o)->gch)
+#define cast_u(o)	cast(union GCUnion *, (o))
 
 /* macros to convert a GCObject into a specific value */
-#define rawgco2ts(o)  \
-	check_exp(novariant((o)->gch.tt) == LUA_TSTRING, &((o)->ts))
-#define gco2ts(o)	(&rawgco2ts(o)->tsv)
-#define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
-#define gco2u(o)	(&rawgco2u(o)->uv)
-#define gco2lcl(o)	check_exp((o)->gch.tt == LUA_TLCL, &((o)->cl.l))
-#define gco2ccl(o)	check_exp((o)->gch.tt == LUA_TCCL, &((o)->cl.c))
+#define gco2ts(o)  \
+	check_exp(novariant((o)->tt) == LUA_TSTRING, &((cast_u(o))->ts))
+#define gco2u(o)  check_exp((o)->tt == LUA_TUSERDATA, &((cast_u(o))->u))
+#define gco2lcl(o)  check_exp((o)->tt == LUA_TLCL, &((cast_u(o))->cl.l))
+#define gco2ccl(o)  check_exp((o)->tt == LUA_TCCL, &((cast_u(o))->cl.c))
 #define gco2cl(o)  \
-	check_exp(novariant((o)->gch.tt) == LUA_TFUNCTION, &((o)->cl))
-#define gco2t(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
-#define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
-#define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
-#define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
+	check_exp(novariant((o)->tt) == LUA_TFUNCTION, &((cast_u(o))->cl))
+#define gco2t(o)  check_exp((o)->tt == LUA_TTABLE, &((cast_u(o))->h))
+#define gco2p(o)  check_exp((o)->tt == LUA_TPROTO, &((cast_u(o))->p))
+#define gco2th(o)  check_exp((o)->tt == LUA_TTHREAD, &((cast_u(o))->th))
+
 
-/* macro to convert any Lua object into a GCObject */
-#define obj2gco(v)	(cast(GCObject *, (v)))
+/* macro to convert a Lua object into a GCObject */
+#define obj2gco(v) \
+	check_exp(novariant((v)->tt) < LUA_TDEADKEY, (&(cast_u(v)->gc)))
 
 
 /* actual number of total bytes allocated */
@@ -222,6 +217,7 @@
 LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
 LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);
 LUAI_FUNC void luaE_freeCI (lua_State *L);
+LUAI_FUNC void luaE_shrinkCI (lua_State *L);
 
 
 #endif
diff -urN rpm-5.4.15/lua/lstring.c rpm-5.4-cvs/lua/lstring.c
--- rpm-5.4.15/lua/lstring.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lstring.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,23 +1,28 @@
 /*
-** $Id: lstring.c,v 2.26 2013/01/08 13:50:10 roberto Exp $
+** $Id: lstring.c,v 2.45 2014/11/02 19:19:04 roberto Exp $
 ** String table (keeps all strings handled by Lua)
 ** See Copyright Notice in lua.h
 */
 
-
-#include <string.h>
-
 #define lstring_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <string.h>
+
 #include "lua.h"
 
+#include "ldebug.h"
+#include "ldo.h"
 #include "lmem.h"
 #include "lobject.h"
 #include "lstate.h"
 #include "lstring.h"
 
 
+
 /*
 ** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to
 ** compute its hash
@@ -31,23 +36,14 @@
 ** equality for long strings
 */
 int luaS_eqlngstr (TString *a, TString *b) {
-  size_t len = a->tsv.len;
-  lua_assert(a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR);
+  size_t len = a->len;
+  lua_assert(a->tt == LUA_TLNGSTR && b->tt == LUA_TLNGSTR);
   return (a == b) ||  /* same instance or... */
-    ((len == b->tsv.len) &&  /* equal length and ... */
+    ((len == b->len) &&  /* equal length and ... */
      (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */
 }
 
 
-/*
-** equality for strings
-*/
-int luaS_eqstr (TString *a, TString *b) {
-  return (a->tsv.tt == b->tsv.tt) &&
-         (a->tsv.tt == LUA_TSHRSTR ? eqshrstr(a, b) : luaS_eqlngstr(a, b));
-}
-
-
 unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
   unsigned int h = seed ^ cast(unsigned int, l);
   size_t l1;
@@ -64,66 +60,59 @@
 void luaS_resize (lua_State *L, int newsize) {
   int i;
   stringtable *tb = &G(L)->strt;
-  /* cannot resize while GC is traversing strings */
-  luaC_runtilstate(L, ~bitmask(GCSsweepstring));
-  if (newsize > tb->size) {
-    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
-    for (i = tb->size; i < newsize; i++) tb->hash[i] = NULL;
-  }
-  /* rehash */
-  for (i=0; i<tb->size; i++) {
-    GCObject *p = tb->hash[i];
+  if (newsize > tb->size) {  /* grow table if needed */
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString *);
+    for (i = tb->size; i < newsize; i++)
+      tb->hash[i] = NULL;
+  }
+  for (i = 0; i < tb->size; i++) {  /* rehash */
+    TString *p = tb->hash[i];
     tb->hash[i] = NULL;
     while (p) {  /* for each node in the list */
-      GCObject *next = gch(p)->next;  /* save next */
-      unsigned int h = lmod(gco2ts(p)->hash, newsize);  /* new position */
-      gch(p)->next = tb->hash[h];  /* chain it */
+      TString *hnext = p->hnext;  /* save next */
+      unsigned int h = lmod(p->hash, newsize);  /* new position */
+      p->hnext = tb->hash[h];  /* chain it */
       tb->hash[h] = p;
-      resetoldbit(p);  /* see MOVE OLD rule */
-      p = next;
+      p = hnext;
     }
   }
-  if (newsize < tb->size) {
-    /* shrinking slice must be empty */
+  if (newsize < tb->size) {  /* shrink table if needed */
+    /* vanishing slice should be empty */
     lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);
-    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString *);
   }
   tb->size = newsize;
 }
 
 
+
 /*
 ** creates a new string object
 */
 static TString *createstrobj (lua_State *L, const char *str, size_t l,
-                              int tag, unsigned int h, GCObject **list) {
+                              int tag, unsigned int h) {
   TString *ts;
+  GCObject *o;
   size_t totalsize;  /* total size of TString object */
-  totalsize = sizeof(TString) + ((l + 1) * sizeof(char));
-  ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;
-  ts->tsv.len = l;
-  ts->tsv.hash = h;
-  ts->tsv.extra = 0;
-  memcpy(ts+1, str, l*sizeof(char));
-  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  totalsize = sizelstring(l);
+  o = luaC_newobj(L, tag, totalsize);
+  ts = gco2ts(o);
+  ts->len = l;
+  ts->hash = h;
+  ts->extra = 0;
+  memcpy(getaddrstr(ts), str, l * sizeof(char));
+  getaddrstr(ts)[l] = '\0';  /* ending 0 */
   return ts;
 }
 
 
-/*
-** creates a new short string, inserting it into string table
-*/
-static TString *newshrstr (lua_State *L, const char *str, size_t l,
-                                       unsigned int h) {
-  GCObject **list;  /* (pointer to) list where it will be inserted */
+void luaS_remove (lua_State *L, TString *ts) {
   stringtable *tb = &G(L)->strt;
-  TString *s;
-  if (tb->nuse >= cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
-    luaS_resize(L, tb->size*2);  /* too crowded */
-  list = &tb->hash[lmod(h, tb->size)];
-  s = createstrobj(L, str, l, LUA_TSHRSTR, h, list);
-  tb->nuse++;
-  return s;
+  TString **p = &tb->hash[lmod(ts->hash, tb->size)];
+  while (*p != ts)  /* find previous element */
+    p = &(*p)->hnext;
+  *p = (*p)->hnext;  /* remove element from its list */
+  tb->nuse--;
 }
 
 
@@ -131,22 +120,28 @@
 ** checks whether short string exists and reuses it or creates a new one
 */
 static TString *internshrstr (lua_State *L, const char *str, size_t l) {
-  GCObject *o;
+  TString *ts;
   global_State *g = G(L);
   unsigned int h = luaS_hash(str, l, g->seed);
-  for (o = g->strt.hash[lmod(h, g->strt.size)];
-       o != NULL;
-       o = gch(o)->next) {
-    TString *ts = rawgco2ts(o);
-    if (h == ts->tsv.hash &&
-        l == ts->tsv.len &&
+  TString **list = &g->strt.hash[lmod(h, g->strt.size)];
+  for (ts = *list; ts != NULL; ts = ts->hnext) {
+    if (l == ts->len &&
         (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
-      if (isdead(G(L), o))  /* string is dead (but was not collected yet)? */
-        changewhite(o);  /* resurrect it */
+      /* found! */
+      if (isdead(g, ts))  /* dead (but not collected yet)? */
+        changewhite(ts);  /* resurrect it */
       return ts;
     }
   }
-  return newshrstr(L, str, l, h);  /* not found; create a new string */
+  if (g->strt.nuse >= g->strt.size && g->strt.size <= MAX_INT/2) {
+    luaS_resize(L, g->strt.size * 2);
+    list = &g->strt.hash[lmod(h, g->strt.size)];  /* recompute with new size */
+  }
+  ts = createstrobj(L, str, l, LUA_TSHRSTR, h);
+  ts->hnext = *list;
+  *list = ts;
+  g->strt.nuse++;
+  return ts;
 }
 
 
@@ -157,9 +152,9 @@
   if (l <= LUAI_MAXSHORTLEN)  /* short string? */
     return internshrstr(L, str, l);
   else {
-    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
+    if (l + 1 > (MAX_SIZE - sizeof(TString))/sizeof(char))
       luaM_toobig(L);
-    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);
+    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed);
   }
 }
 
@@ -172,14 +167,16 @@
 }
 
 
-Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
+Udata *luaS_newudata (lua_State *L, size_t s) {
   Udata *u;
-  if (s > MAX_SIZET - sizeof(Udata))
+  GCObject *o;
+  if (s > MAX_SIZE - sizeof(Udata))
     luaM_toobig(L);
-  u = &luaC_newobj(L, LUA_TUSERDATA, sizeof(Udata) + s, NULL, 0)->u;
-  u->uv.len = s;
-  u->uv.metatable = NULL;
-  u->uv.env = e;
+  o = luaC_newobj(L, LUA_TUSERDATA, sizeludata(s));
+  u = gco2u(o);
+  u->len = s;
+  u->metatable = NULL;
+  setuservalue(L, u, luaO_nilobject);
   return u;
 }
 
diff -urN rpm-5.4.15/lua/lstring.h rpm-5.4-cvs/lua/lstring.h
--- rpm-5.4.15/lua/lstring.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lstring.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lstring.h,v 1.49 2012/02/01 21:57:15 roberto Exp $
+** $Id: lstring.h,v 1.56 2014/07/18 14:46:47 roberto Exp $
 ** String table (keep all strings handled by Lua)
 ** See Copyright Notice in lua.h
 */
@@ -12,33 +12,35 @@
 #include "lstate.h"
 
 
-#define sizestring(s)	(sizeof(union TString)+((s)->len+1)*sizeof(char))
+#define sizelstring(l)  (sizeof(union UTString) + ((l) + 1) * sizeof(char))
+#define sizestring(s)	sizelstring((s)->len)
 
-#define sizeudata(u)	(sizeof(union Udata)+(u)->len)
+#define sizeludata(l)	(sizeof(union UUdata) + (l))
+#define sizeudata(u)	sizeludata((u)->len)
 
 #define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
                                  (sizeof(s)/sizeof(char))-1))
 
-#define luaS_fix(s)	l_setbit((s)->tsv.marked, FIXEDBIT)
-
 
 /*
 ** test whether a string is a reserved word
 */
-#define isreserved(s)	((s)->tsv.tt == LUA_TSHRSTR && (s)->tsv.extra > 0)
+#define isreserved(s)	((s)->tt == LUA_TSHRSTR && (s)->extra > 0)
 
 
 /*
 ** equality for short strings, which are always internalized
 */
-#define eqshrstr(a,b)	check_exp((a)->tsv.tt == LUA_TSHRSTR, (a) == (b))
+#define eqshrstr(a,b)	check_exp((a)->tt == LUA_TSHRSTR, (a) == (b))
 
 
-LUAI_FUNC unsigned int luaS_hash (const char *str, size_t l, unsigned int seed);
-LUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);
-LUAI_FUNC int luaS_eqstr (TString *a, TString *b);
+LUAI_FUNC unsigned int luaS_hash (const char *str, size_t l, unsigned int seed)
+	LUA_GNUC_PURE;
+LUAI_FUNC int luaS_eqlngstr (TString *a, TString *b)
+	LUA_GNUC_PURE;
 LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
-LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
+LUAI_FUNC void luaS_remove (lua_State *L, TString *ts);
+LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s);
 LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
 LUAI_FUNC TString *luaS_new (lua_State *L, const char *str);
 
diff -urN rpm-5.4.15/lua/lstrlib.c rpm-5.4-cvs/lua/lstrlib.c
--- rpm-5.4.15/lua/lstrlib.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lstrlib.c	2015-04-19 13:24:57.000000000 -0500
@@ -1,19 +1,22 @@
 /*
-** $Id: lstrlib.c,v 1.178 2012/08/14 18:12:34 roberto Exp $
+** $Id: lstrlib.c,v 1.221 2014/12/11 14:03:07 roberto Exp $
 ** Standard library for string operations and pattern-matching
 ** See Copyright Notice in lua.h
 */
 
+#define lstrlib_c
+#define LUA_LIB
+
+#include "lprefix.h"
+
 
 #include <ctype.h>
+#include <limits.h>
 #include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define lstrlib_c
-#define LUA_LIB
-
 #include "lua.h"
 
 #include "lauxlib.h"
@@ -29,10 +32,19 @@
 #endif
 
 
-/* macro to `unsign' a character */
+/* macro to 'unsign' a character */
 #define uchar(c)	((unsigned char)(c))
 
 
+/*
+** Some sizes are better limited to fit in 'int', but must also fit in
+** 'size_t'. (We assume that 'lua_Integer' cannot be smaller than 'int'.)
+*/
+#define MAXSIZE  \
+	(sizeof(size_t) < sizeof(int) ? (~(size_t)0) : (size_t)(INT_MAX))
+
+
+
 
 static int str_len (lua_State *L) {
   size_t l;
@@ -43,22 +55,22 @@
 
 
 /* translate a relative string position: negative means back from end */
-static size_t posrelat (ptrdiff_t pos, size_t len) {
-  if (pos >= 0) return (size_t)pos;
+static lua_Integer posrelat (lua_Integer pos, size_t len) {
+  if (pos >= 0) return pos;
   else if (0u - (size_t)pos > len) return 0;
-  else return len - ((size_t)-pos) + 1;
+  else return (lua_Integer)len + pos + 1;
 }
 
 
 static int str_sub (lua_State *L) {
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
-  size_t start = posrelat(luaL_checkinteger(L, 2), l);
-  size_t end = posrelat(luaL_optinteger(L, 3, -1), l);
+  lua_Integer start = posrelat(luaL_checkinteger(L, 2), l);
+  lua_Integer end = posrelat(luaL_optinteger(L, 3, -1), l);
   if (start < 1) start = 1;
-  if (end > l) end = l;
+  if (end > (lua_Integer)l) end = l;
   if (start <= end)
-    lua_pushlstring(L, s + start - 1, end - start + 1);
+    lua_pushlstring(L, s + start - 1, (size_t)(end - start + 1));
   else lua_pushliteral(L, "");
   return 1;
 }
@@ -102,25 +114,23 @@
 }
 
 
-/* reasonable limit to avoid arithmetic overflow */
-#define MAXSIZE		((~(size_t)0) >> 1)
-
 static int str_rep (lua_State *L) {
   size_t l, lsep;
   const char *s = luaL_checklstring(L, 1, &l);
-  int n = luaL_checkint(L, 2);
+  lua_Integer n = luaL_checkinteger(L, 2);
   const char *sep = luaL_optlstring(L, 3, "", &lsep);
   if (n <= 0) lua_pushliteral(L, "");
-  else if (l + lsep < l || l + lsep >= MAXSIZE / n)  /* may overflow? */
+  else if (l + lsep < l || l + lsep > MAXSIZE / n)  /* may overflow? */
     return luaL_error(L, "resulting string too large");
   else {
-    size_t totallen = n * l + (n - 1) * lsep;
+    size_t totallen = (size_t)n * l + (size_t)(n - 1) * lsep;
     luaL_Buffer b;
     char *p = luaL_buffinitsize(L, &b, totallen);
     while (n-- > 1) {  /* first n-1 copies (followed by separator) */
       memcpy(p, s, l * sizeof(char)); p += l;
-      if (lsep > 0) {  /* avoid empty 'memcpy' (may be expensive) */
-        memcpy(p, sep, lsep * sizeof(char)); p += lsep;
+      if (lsep > 0) {  /* empty 'memcpy' is not that cheap */
+        memcpy(p, sep, lsep * sizeof(char));
+        p += lsep;
       }
     }
     memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
@@ -133,14 +143,14 @@
 static int str_byte (lua_State *L) {
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
-  size_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
-  size_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
+  lua_Integer posi = posrelat(luaL_optinteger(L, 2, 1), l);
+  lua_Integer pose = posrelat(luaL_optinteger(L, 3, posi), l);
   int n, i;
   if (posi < 1) posi = 1;
-  if (pose > l) pose = l;
+  if (pose > (lua_Integer)l) pose = l;
   if (posi > pose) return 0;  /* empty interval; return no values */
   n = (int)(pose -  posi + 1);
-  if (posi + n <= pose)  /* (size_t -> int) overflow? */
+  if (posi + n <= pose)  /* arithmetic overflow? */
     return luaL_error(L, "string slice too long");
   luaL_checkstack(L, n, "string slice too long");
   for (i=0; i<n; i++)
@@ -155,7 +165,7 @@
   luaL_Buffer b;
   char *p = luaL_buffinitsize(L, &b, n);
   for (i=1; i<=n; i++) {
-    int c = luaL_checkint(L, i);
+    lua_Integer c = luaL_checkinteger(L, i);
     luaL_argcheck(L, uchar(c) == c, i, "value out of range");
     p[i - 1] = uchar(c);
   }
@@ -164,19 +174,20 @@
 }
 
 
-static int writer (lua_State *L, const void* b, size_t size, void* B) {
+static int writer (lua_State *L, const void *b, size_t size, void *B) {
   (void)L;
-  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  luaL_addlstring((luaL_Buffer *) B, (const char *)b, size);
   return 0;
 }
 
 
 static int str_dump (lua_State *L) {
   luaL_Buffer b;
+  int strip = lua_toboolean(L, 2);
   luaL_checktype(L, 1, LUA_TFUNCTION);
   lua_settop(L, 1);
   luaL_buffinit(L,&b);
-  if (lua_dump(L, writer, &b) != 0)
+  if (lua_dump(L, writer, &b, strip) != 0)
     return luaL_error(L, "unable to dump given function");
   luaL_pushresult(&b);
   return 1;
@@ -243,16 +254,16 @@
   switch (*p++) {
     case L_ESC: {
       if (p == ms->p_end)
-        luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
+        luaL_error(ms->L, "malformed pattern (ends with '%%')");
       return p+1;
     }
     case '[': {
       if (*p == '^') p++;
-      do {  /* look for a `]' */
+      do {  /* look for a ']' */
         if (p == ms->p_end)
-          luaL_error(ms->L, "malformed pattern (missing " LUA_QL("]") ")");
+          luaL_error(ms->L, "malformed pattern (missing ']')");
         if (*(p++) == L_ESC && p < ms->p_end)
-          p++;  /* skip escapes (e.g. `%]') */
+          p++;  /* skip escapes (e.g. '%]') */
       } while (*p != ']');
       return p+1;
     }
@@ -283,11 +294,12 @@
 }
 
 
+LUA_GNUC_PURE
 static int matchbracketclass (int c, const char *p, const char *ec) {
   int sig = 1;
   if (*(p+1) == '^') {
     sig = 0;
-    p++;  /* skip the `^' */
+    p++;  /* skip the '^' */
   }
   while (++p < ec) {
     if (*p == L_ESC) {
@@ -306,6 +318,7 @@
 }
 
 
+LUA_GNUC_PURE
 static int singlematch (MatchState *ms, const char *s, const char *p,
                         const char *ep) {
   if (s >= ms->src_end)
@@ -325,8 +338,7 @@
 static const char *matchbalance (MatchState *ms, const char *s,
                                    const char *p) {
   if (p >= ms->p_end - 1)
-    luaL_error(ms->L, "malformed pattern "
-                      "(missing arguments to " LUA_QL("%%b") ")");
+    luaL_error(ms->L, "malformed pattern (missing arguments to '%%b')");
   if (*s != *p) return NULL;
   else {
     int b = *p;
@@ -425,7 +437,7 @@
         break;
       }
       case '$': {
-        if ((p + 1) != ms->p_end)  /* is the `$' the last char in pattern? */
+        if ((p + 1) != ms->p_end)  /* is the '$' the last char in pattern? */
           goto dflt;  /* no; go to default */
         s = (s == ms->src_end) ? s : NULL;  /* check end of string */
         break;
@@ -443,8 +455,7 @@
             const char *ep; char previous;
             p += 2;
             if (*p != '[')
-              luaL_error(ms->L, "missing " LUA_QL("[") " after "
-                                 LUA_QL("%%f") " in pattern");
+              luaL_error(ms->L, "missing '[' after '%%f' in pattern");
             ep = classend(ms, p);  /* points to what is next */
             previous = (s == ms->src_init) ? '\0' : *(s - 1);
             if (!matchbracketclass(uchar(previous), p, ep - 1) &&
@@ -511,19 +522,20 @@
 
 
 
+LUA_GNUC_PURE
 static const char *lmemfind (const char *s1, size_t l1,
                                const char *s2, size_t l2) {
   if (l2 == 0) return s1;  /* empty strings are everywhere */
-  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */
+  else if (l2 > l1) return NULL;  /* avoids a negative 'l1' */
   else {
-    const char *init;  /* to search for a `*s2' inside `s1' */
-    l2--;  /* 1st char will be checked by `memchr' */
-    l1 = l1-l2;  /* `s2' cannot be found after that */
+    const char *init;  /* to search for a '*s2' inside 's1' */
+    l2--;  /* 1st char will be checked by 'memchr' */
+    l1 = l1-l2;  /* 's2' cannot be found after that */
     while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
       init++;   /* 1st char is already checked */
       if (memcmp(init, s2+1, l2) == 0)
         return init-1;
-      else {  /* correct `l1' and `s1' to try again */
+      else {  /* correct 'l1' and 's1' to try again */
         l1 -= init-s1;
         s1 = init;
       }
@@ -539,7 +551,7 @@
     if (i == 0)  /* ms->level == 0, too */
       lua_pushlstring(ms->L, s, e - s);  /* add whole match */
     else
-      luaL_error(ms->L, "invalid capture index");
+      luaL_error(ms->L, "invalid capture index %%%d", i + 1);
   }
   else {
     ptrdiff_t l = ms->capture[i].len;
@@ -563,6 +575,7 @@
 
 
 /* check whether pattern has no special characters */
+LUA_GNUC_PURE
 static int nospecials (const char *p, size_t l) {
   size_t upto = 0;
   do {
@@ -578,16 +591,16 @@
   size_t ls, lp;
   const char *s = luaL_checklstring(L, 1, &ls);
   const char *p = luaL_checklstring(L, 2, &lp);
-  size_t init = posrelat(luaL_optinteger(L, 3, 1), ls);
+  lua_Integer init = posrelat(luaL_optinteger(L, 3, 1), ls);
   if (init < 1) init = 1;
-  else if (init > ls + 1) {  /* start after string's end? */
+  else if (init > (lua_Integer)ls + 1) {  /* start after string's end? */
     lua_pushnil(L);  /* cannot find anything */
     return 1;
   }
   /* explicit request or no special characters? */
   if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
     /* do a plain search */
-    const char *s2 = lmemfind(s + init - 1, ls - init + 1, p, lp);
+    const char *s2 = lmemfind(s + init - 1, ls - (size_t)init + 1, p, lp);
     if (s2) {
       lua_pushinteger(L, s2 - s + 1);
       lua_pushinteger(L, s2 - s + lp);
@@ -678,7 +691,8 @@
 static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
                                                    const char *e) {
   size_t l, i;
-  const char *news = lua_tolstring(ms->L, 3, &l);
+  lua_State *L = ms->L;
+  const char *news = lua_tolstring(L, 3, &l);
   for (i = 0; i < l; i++) {
     if (news[i] != L_ESC)
       luaL_addchar(b, news[i]);
@@ -686,14 +700,15 @@
       i++;  /* skip ESC */
       if (!isdigit(uchar(news[i]))) {
         if (news[i] != L_ESC)
-          luaL_error(ms->L, "invalid use of " LUA_QL("%c")
-                           " in replacement string", L_ESC);
+          luaL_error(L, "invalid use of '%c' in replacement string", L_ESC);
         luaL_addchar(b, news[i]);
       }
       else if (news[i] == '0')
           luaL_addlstring(b, s, e - s);
       else {
         push_onecapture(ms, news[i] - '1', s, e);
+        luaL_tolstring(L, -1, NULL);  /* if number, convert it to string */
+        lua_remove(L, -2);  /* remove original value */
         luaL_addvalue(b);  /* add capture to accumulated result */
       }
     }
@@ -737,9 +752,9 @@
   const char *src = luaL_checklstring(L, 1, &srcl);
   const char *p = luaL_checklstring(L, 2, &lp);
   int tr = lua_type(L, 3);
-  size_t max_s = luaL_optinteger(L, 4, srcl+1);
+  lua_Integer max_s = luaL_optinteger(L, 4, srcl + 1);
   int anchor = (*p == '^');
-  size_t n = 0;
+  lua_Integer n = 0;
   MatchState ms;
   luaL_Buffer b;
   luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
@@ -786,48 +801,18 @@
 ** =======================================================
 */
 
-/*
-** LUA_INTFRMLEN is the length modifier for integer conversions in
-** 'string.format'; LUA_INTFRM_T is the integer type corresponding to
-** the previous length
-*/
-#if !defined(LUA_INTFRMLEN)	/* { */
-#if defined(LUA_USE_LONGLONG)
-
-#define LUA_INTFRMLEN		"ll"
-#define LUA_INTFRM_T		long long
-
-#else
-
-#define LUA_INTFRMLEN		"l"
-#define LUA_INTFRM_T		long
-
-#endif
-#endif				/* } */
-
-
-/*
-** LUA_FLTFRMLEN is the length modifier for float conversions in
-** 'string.format'; LUA_FLTFRM_T is the float type corresponding to
-** the previous length
-*/
-#if !defined(LUA_FLTFRMLEN)
-
-#define LUA_FLTFRMLEN		""
-#define LUA_FLTFRM_T		double
-
-#endif
-
-
 /* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
-#define MAX_ITEM	512
+#define MAX_ITEM	\
+  (sizeof(lua_Number) <= 4 ? 150 : sizeof(lua_Number) <= 8 ? 450 : 5050)
+
 /* valid flags in a format specification */
 #define FLAGS	"-+ #0"
+
 /*
-** maximum size of each format specification (such as '%-099.99d')
-** (+10 accounts for %99.99x plus margin of error)
+** maximum size of each format specification (such as "%-099.99d")
+** (+2 for length modifiers; +10 accounts for %99.99x plus margin of error)
 */
-#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
+#define MAX_FORMAT	(sizeof(FLAGS) + 2 + 10)
 
 
 static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
@@ -903,7 +888,7 @@
     else if (*++strfrmt == L_ESC)
       luaL_addchar(&b, *strfrmt++);  /* %% */
     else { /* format item */
-      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char form[MAX_FORMAT];  /* to store the format ('%...') */
       char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */
       int nb = 0;  /* number of bytes in added item */
       if (++arg > top)
@@ -911,36 +896,23 @@
       strfrmt = scanformat(L, strfrmt, form);
       switch (*strfrmt++) {
         case 'c': {
-          nb = sprintf(buff, form, luaL_checkint(L, arg));
-          break;
-        }
-        case 'd': case 'i': {
-          lua_Number n = luaL_checknumber(L, arg);
-          LUA_INTFRM_T ni = (LUA_INTFRM_T)n;
-          lua_Number diff = n - (lua_Number)ni;
-          luaL_argcheck(L, -1 < diff && diff < 1, arg,
-                        "not a number in proper range");
-          addlenmod(form, LUA_INTFRMLEN);
-          nb = sprintf(buff, form, ni);
+          nb = sprintf(buff, form, (int)luaL_checkinteger(L, arg));
           break;
         }
+        case 'd': case 'i':
         case 'o': case 'u': case 'x': case 'X': {
-          lua_Number n = luaL_checknumber(L, arg);
-          unsigned LUA_INTFRM_T ni = (unsigned LUA_INTFRM_T)n;
-          lua_Number diff = n - (lua_Number)ni;
-          luaL_argcheck(L, -1 < diff && diff < 1, arg,
-                        "not a non-negative number in proper range");
-          addlenmod(form, LUA_INTFRMLEN);
-          nb = sprintf(buff, form, ni);
+          lua_Integer n = luaL_checkinteger(L, arg);
+          addlenmod(form, LUA_INTEGER_FRMLEN);
+          nb = sprintf(buff, form, n);
           break;
         }
-        case 'e': case 'E': case 'f':
 #if defined(LUA_USE_AFORMAT)
         case 'a': case 'A':
 #endif
+        case 'e': case 'E': case 'f':
         case 'g': case 'G': {
-          addlenmod(form, LUA_FLTFRMLEN);
-          nb = sprintf(buff, form, (LUA_FLTFRM_T)luaL_checknumber(L, arg));
+          addlenmod(form, LUA_NUMBER_FRMLEN);
+          nb = sprintf(buff, form, luaL_checknumber(L, arg));
           break;
         }
         case 'q': {
@@ -962,9 +934,9 @@
             break;
           }
         }
-        default: {  /* also treat cases `pnLlh' */
-          return luaL_error(L, "invalid option " LUA_QL("%%%c") " to "
-                               LUA_QL("format"), *(strfrmt - 1));
+        default: {  /* also treat cases 'pnLlh' */
+          return luaL_error(L, "invalid option '%%%c' to 'format'",
+                               *(strfrmt - 1));
         }
       }
       luaL_addsize(&b, nb);
@@ -977,6 +949,447 @@
 /* }====================================================== */
 
 
+/*
+** {======================================================
+** PACK/UNPACK
+** =======================================================
+*/
+
+
+/* value used for padding */
+#if !defined(LUA_PACKPADBYTE)
+#define LUA_PACKPADBYTE		0x00
+#endif
+
+/* maximum size for the binary representation of an integer */
+#define MAXINTSIZE	16
+
+/* number of bits in a character */
+#define NB	CHAR_BIT
+
+/* mask for one character (NB 1's) */
+#define MC	((1 << NB) - 1)
+
+/* size of a lua_Integer */
+#define SZINT	((int)sizeof(lua_Integer))
+
+
+/* dummy union to get native endianness */
+static const union {
+  int dummy;
+  char little;  /* true iff machine is little endian */
+} nativeendian = {1};
+
+
+/* dummy structure to get native alignment requirements */
+struct cD {
+  char c;
+  union { double d; void *p; lua_Integer i; lua_Number n; } u;
+};
+
+#define MAXALIGN	(offsetof(struct cD, u))
+
+
+/*
+** Union for serializing floats
+*/
+typedef union Ftypes {
+  float f;
+  double d;
+  lua_Number n;
+  char buff[5 * sizeof(lua_Number)];  /* enough for any float type */
+} Ftypes;
+
+
+/*
+** information to pack/unpack stuff
+*/
+typedef struct Header {
+  lua_State *L;
+  int islittle;
+  int maxalign;
+} Header;
+
+
+/*
+** options for pack/unpack
+*/
+typedef enum KOption {
+  Kint,		/* signed integers */
+  Kuint,	/* unsigned integers */
+  Kfloat,	/* floating-point numbers */
+  Kchar,	/* fixed-length strings */
+  Kstring,	/* strings with prefixed length */
+  Kzstr,	/* zero-terminated strings */
+  Kpadding,	/* padding */
+  Kpaddalign,	/* padding for alignment */
+  Knop		/* no-op (configuration or spaces) */
+} KOption;
+
+
+/*
+** Read an integer numeral from string 'fmt' or return 'df' if
+** there is no numeral
+*/
+static int digit (int c) { return '0' <= c && c <= '9'; }
+
+static int getnum (const char **fmt, int df) {
+  if (!digit(**fmt))  /* no number? */
+    return df;  /* return default value */
+  else {
+    int a = 0;
+    do {
+      a = a*10 + (*((*fmt)++) - '0');
+    } while (digit(**fmt) && a <= ((int)MAXSIZE - 9)/10);
+    return a;
+  }
+}
+
+
+/*
+** Read an integer numeral and raises an error if it is larger
+** than the maximum size for integers.
+*/
+static int getnumlimit (Header *h, const char **fmt, int df) {
+  int sz = getnum(fmt, df);
+  if (sz > MAXINTSIZE || sz <= 0)
+    luaL_error(h->L, "integral size (%d) out of limits [1,%d]",
+                     sz, MAXINTSIZE);
+  return sz;
+}
+
+
+/*
+** Initialize Header
+*/
+static void initheader (lua_State *L, Header *h) {
+  h->L = L;
+  h->islittle = nativeendian.little;
+  h->maxalign = 1;
+}
+
+
+/*
+** Read and classify next option. 'size' is filled with option's size.
+*/
+static KOption getoption (Header *h, const char **fmt, int *size) {
+  int opt = *((*fmt)++);
+  *size = 0;  /* default */
+  switch (opt) {
+    case 'b': *size = sizeof(char); return Kint;
+    case 'B': *size = sizeof(char); return Kuint;
+    case 'h': *size = sizeof(short); return Kint;
+    case 'H': *size = sizeof(short); return Kuint;
+    case 'l': *size = sizeof(long); return Kint;
+    case 'L': *size = sizeof(long); return Kuint;
+    case 'j': *size = sizeof(lua_Integer); return Kint;
+    case 'J': *size = sizeof(lua_Integer); return Kuint;
+    case 'T': *size = sizeof(size_t); return Kuint;
+    case 'f': *size = sizeof(float); return Kfloat;
+    case 'd': *size = sizeof(double); return Kfloat;
+    case 'n': *size = sizeof(lua_Number); return Kfloat;
+    case 'i': *size = getnumlimit(h, fmt, sizeof(int)); return Kint;
+    case 'I': *size = getnumlimit(h, fmt, sizeof(int)); return Kuint;
+    case 's': *size = getnumlimit(h, fmt, sizeof(size_t)); return Kstring;
+    case 'c':
+      *size = getnum(fmt, -1);
+      if (*size == -1)
+        luaL_error(h->L, "missing size for format option 'c'");
+      return Kchar;
+    case 'z': return Kzstr;
+    case 'x': *size = 1; return Kpadding;
+    case 'X': return Kpaddalign;
+    case ' ': break;
+    case '<': h->islittle = 1; break;
+    case '>': h->islittle = 0; break;
+    case '=': h->islittle = nativeendian.little; break;
+    case '!': h->maxalign = getnumlimit(h, fmt, MAXALIGN); break;
+    default: luaL_error(h->L, "invalid format option '%c'", opt);
+  }
+  return Knop;
+}
+
+
+/*
+** Read, classify, and fill other details about the next option.
+** 'psize' is filled with option's size, 'notoalign' with its
+** alignment requirements.
+** Local variable 'size' gets the size to be aligned. (Kpadal option
+** always gets its full alignment, other options are limited by 
+** the maximum alignment ('maxalign'). Kchar option needs no alignment
+** despite its size.
+*/
+static KOption getdetails (Header *h, size_t totalsize,
+                           const char **fmt, int *psize, int *ntoalign) {
+  KOption opt = getoption(h, fmt, psize);
+  int align = *psize;  /* usually, alignment follows size */
+  if (opt == Kpaddalign) {  /* 'X' gets alignment from following option */
+    if (**fmt == '\0' || getoption(h, fmt, &align) == Kchar || align == 0)
+      luaL_argerror(h->L, 1, "invalid next option for option 'X'");
+  }
+  if (align <= 1 || opt == Kchar)  /* need no alignment? */
+    *ntoalign = 0;
+  else {
+    if (align > h->maxalign)  /* enforce maximum alignment */
+      align = h->maxalign;
+    if ((align & (align - 1)) != 0)  /* is 'align' not a power of 2? */
+      luaL_argerror(h->L, 1, "format asks for alignment not power of 2");
+    *ntoalign = (align - (int)(totalsize & (align - 1))) & (align - 1);
+  }
+  return opt;
+}
+
+
+/*
+** Pack integer 'n' with 'size' bytes and 'islittle' endianness.
+** The final 'if' handles the case when 'size' is larger than
+** the size of a Lua integer, correcting the extra sign-extension
+** bytes if necessary (by default they would be zeros).
+*/
+static void packint (luaL_Buffer *b, lua_Unsigned n,
+                     int islittle, int size, int neg) {
+  char *buff = luaL_prepbuffsize(b, size);
+  int i;
+  buff[islittle ? 0 : size - 1] = (char)(n & MC);  /* first byte */
+  for (i = 1; i < size; i++) {
+    n >>= NB;
+    buff[islittle ? i : size - 1 - i] = (char)(n & MC);
+  }
+  if (neg && size > SZINT) {  /* negative number need sign extension? */
+    for (i = SZINT; i < size; i++)  /* correct extra bytes */
+      buff[islittle ? i : size - 1 - i] = (char)MC;
+  }
+  luaL_addsize(b, size);  /* add result to buffer */
+}
+
+
+/*
+** Copy 'size' bytes from 'src' to 'dest', correcting endianness if
+** given 'islittle' is different from native endianness.
+*/
+static void copywithendian (volatile char *dest, volatile const char *src,
+                            int size, int islittle) {
+  if (islittle == nativeendian.little) {
+    while (size-- != 0)
+      *(dest++) = *(src++);
+  }
+  else {
+    dest += size - 1;
+    while (size-- != 0)
+      *(dest--) = *(src++);
+  }
+}
+
+
+static int str_pack (lua_State *L) {
+  luaL_Buffer b;
+  Header h;
+  const char *fmt = luaL_checkstring(L, 1);  /* format string */
+  int arg = 1;  /* current argument to pack */
+  size_t totalsize = 0;  /* accumulate total size of result */
+  initheader(L, &h);
+  lua_pushnil(L);  /* mark to separate arguments from string buffer */
+  luaL_buffinit(L, &b);
+  while (*fmt != '\0') {
+    int size, ntoalign;
+    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
+    totalsize += ntoalign + size;
+    while (ntoalign-- > 0)
+     luaL_addchar(&b, LUA_PACKPADBYTE);  /* fill alignment */
+    arg++;
+    switch (opt) {
+      case Kint: {  /* signed integers */
+        lua_Integer n = luaL_checkinteger(L, arg);
+        if (size < SZINT) {  /* need overflow check? */
+          lua_Integer lim = (lua_Integer)1 << ((size * NB) - 1);
+          luaL_argcheck(L, -lim <= n && n < lim, arg, "integer overflow");
+        }
+        packint(&b, (lua_Unsigned)n, h.islittle, size, (n < 0));
+        break;
+      }
+      case Kuint: {  /* unsigned integers */
+        lua_Integer n = luaL_checkinteger(L, arg);
+        if (size < SZINT)  /* need overflow check? */
+          luaL_argcheck(L, (lua_Unsigned)n < ((lua_Unsigned)1 << (size * NB)),
+                           arg, "unsigned overflow");
+        packint(&b, (lua_Unsigned)n, h.islittle, size, 0);
+        break;
+      }
+      case Kfloat: {  /* floating-point options */
+        volatile Ftypes u;
+        char *buff = luaL_prepbuffsize(&b, size);
+        lua_Number n = luaL_checknumber(L, arg);  /* get argument */
+        if (size == sizeof(u.f)) u.f = (float)n;  /* copy it into 'u' */
+        else if (size == sizeof(u.d)) u.d = (double)n;
+        else u.n = n;
+        /* move 'u' to final result, correcting endianness if needed */
+        copywithendian(buff, u.buff, size, h.islittle);
+        luaL_addsize(&b, size);
+        break;
+      }
+      case Kchar: {  /* fixed-size string */
+        size_t len;
+        const char *s = luaL_checklstring(L, arg, &len);
+        luaL_argcheck(L, len == (size_t)size, arg, "wrong length");
+        luaL_addlstring(&b, s, size);
+        break;
+      }
+      case Kstring: {  /* strings with length count */
+        size_t len;
+        const char *s = luaL_checklstring(L, arg, &len);
+        luaL_argcheck(L, size >= (int)sizeof(size_t) ||
+                         len < ((size_t)1 << (size * NB)),
+                         arg, "string length does not fit in given size");
+        packint(&b, (lua_Unsigned)len, h.islittle, size, 0);  /* pack length */
+        luaL_addlstring(&b, s, len);
+        totalsize += len;
+        break;
+      }
+      case Kzstr: {  /* zero-terminated string */
+        size_t len;
+        const char *s = luaL_checklstring(L, arg, &len);
+        luaL_argcheck(L, strlen(s) == len, arg, "string contains zeros");
+        luaL_addlstring(&b, s, len);
+        luaL_addchar(&b, '\0');  /* add zero at the end */
+        totalsize += len + 1;
+        break;
+      }
+      case Kpadding: luaL_addchar(&b, LUA_PACKPADBYTE);  /* go through */
+      case Kpaddalign: case Knop:
+        arg--;  /* undo increment */
+        break;
+    }
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static int str_packsize (lua_State *L) {
+  Header h;
+  const char *fmt = luaL_checkstring(L, 1);  /* format string */
+  size_t totalsize = 0;  /* accumulate total size of result */
+  initheader(L, &h);
+  while (*fmt != '\0') {
+    int size, ntoalign;
+    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
+    size += ntoalign;  /* total space used by option */
+    luaL_argcheck(L, totalsize <= MAXSIZE - size, 1,
+                     "format result too large");
+    totalsize += size;
+    switch (opt) {
+      case Kstring:  /* strings with length count */
+      case Kzstr:    /* zero-terminated string */
+        luaL_argerror(L, 1, "variable-length format");
+        break;
+      default:  break;
+    }
+  }
+  lua_pushinteger(L, (lua_Integer)totalsize);
+  return 1;
+}
+
+
+/*
+** Unpack an integer with 'size' bytes and 'islittle' endianness.
+** If size is smaller than the size of a Lua integer and integer
+** is signed, must do sign extension (propagating the sign to the
+** higher bits); if size is larger than the size of a Lua integer,
+** it must check the unread bytes to see whether they do not cause an
+** overflow.
+*/
+static lua_Integer unpackint (lua_State *L, const char *str,
+                              int islittle, int size, int issigned) {
+  lua_Unsigned res = 0;
+  int i;
+  int limit = (size  <= SZINT) ? size : SZINT;
+  for (i = limit - 1; i >= 0; i--) {
+    res <<= NB;
+    res |= (lua_Unsigned)(unsigned char)str[islittle ? i : size - 1 - i];
+  }
+  if (size < SZINT) {  /* real size smaller than lua_Integer? */
+    if (issigned) {  /* needs sign extension? */
+      lua_Unsigned mask = (lua_Unsigned)1 << (size*NB - 1);
+      res = ((res ^ mask) - mask);  /* do sign extension */
+    }
+  }
+  else if (size > SZINT) {  /* must check unread bytes */
+    int mask = (!issigned || (lua_Integer)res >= 0) ? 0 : MC;
+    for (i = limit; i < size; i++) {
+      if ((unsigned char)str[islittle ? i : size - 1 - i] != mask)
+        luaL_error(L, "%d-byte integer does not fit into Lua Integer", size);
+    }
+  }
+  return (lua_Integer)res;
+}
+
+
+static int str_unpack (lua_State *L) {
+  Header h;
+  const char *fmt = luaL_checkstring(L, 1);
+  size_t ld;
+  const char *data = luaL_checklstring(L, 2, &ld);
+  size_t pos = (size_t)posrelat(luaL_optinteger(L, 3, 1), ld) - 1;
+  int n = 0;  /* number of results */
+  luaL_argcheck(L, pos <= ld, 3, "initial position out of string");
+  initheader(L, &h);
+  while (*fmt != '\0') {
+    int size, ntoalign;
+    KOption opt = getdetails(&h, pos, &fmt, &size, &ntoalign);
+    if ((size_t)ntoalign + size > ~pos || pos + ntoalign + size > ld)
+      luaL_argerror(L, 2, "data string too short");
+    pos += ntoalign;  /* skip alignment */
+    /* stack space for item + next position */
+    luaL_checkstack(L, 2, "too many results");
+    n++;
+    switch (opt) {
+      case Kint:
+      case Kuint: {
+        lua_Integer res = unpackint(L, data + pos, h.islittle, size,
+                                       (opt == Kint));
+        lua_pushinteger(L, res);
+        break;
+      }
+      case Kfloat: {
+        volatile Ftypes u;
+        lua_Number num;
+        copywithendian(u.buff, data + pos, size, h.islittle);
+        if (size == sizeof(u.f)) num = (lua_Number)u.f;
+        else if (size == sizeof(u.d)) num = (lua_Number)u.d;
+        else num = u.n;
+        lua_pushnumber(L, num);
+        break;
+      }
+      case Kchar: {
+        lua_pushlstring(L, data + pos, size);
+        break;
+      }
+      case Kstring: {
+        size_t len = (size_t)unpackint(L, data + pos, h.islittle, size, 0);
+        luaL_argcheck(L, pos + len + size <= ld, 2, "data string too short");
+        lua_pushlstring(L, data + pos + size, len);
+        pos += len;  /* skip string */
+        break;
+      }
+      case Kzstr: {
+        size_t len = (int)strlen(data + pos);
+        lua_pushlstring(L, data + pos, len);
+        pos += len + 1;  /* skip string plus final '\0' */
+        break;
+      }
+      case Kpaddalign: case Kpadding: case Knop:
+        n--;  /* undo increment */
+        break;
+    }
+    pos += size;
+  }
+  lua_pushinteger(L, pos + 1);  /* next position */
+  return n + 1;
+}
+
+/* }====================================================== */
+
+
 static const luaL_Reg strlib[] = {
   {"byte", str_byte},
   {"char", str_char},
@@ -992,6 +1405,9 @@
   {"reverse", str_reverse},
   {"sub", str_sub},
   {"upper", str_upper},
+  {"pack", str_pack},
+  {"packsize", str_packsize},
+  {"unpack", str_unpack},
   {NULL, NULL}
 };
 
diff -urN rpm-5.4.15/lua/ltable.c rpm-5.4-cvs/lua/ltable.c
--- rpm-5.4.15/lua/ltable.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/ltable.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,27 +1,32 @@
 /*
-** $Id: ltable.c,v 2.72 2012/09/11 19:37:16 roberto Exp $
+** $Id: ltable.c,v 2.100 2015/01/05 13:52:37 roberto Exp $
 ** Lua tables (hash)
 ** See Copyright Notice in lua.h
 */
 
+#define ltable_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
 /*
 ** Implementation of tables (aka arrays, objects, or hash tables).
 ** Tables keep its elements in two parts: an array part and a hash part.
 ** Non-negative integer keys are all candidates to be kept in the array
-** part. The actual size of the array is the largest `n' such that at
+** part. The actual size of the array is the largest 'n' such that at
 ** least half the slots between 0 and n are in use.
 ** Hash uses a mix of chained scatter table with Brent's variation.
 ** A main invariant of these tables is that, if an element is not
-** in its main position (i.e. the `original' position that its hash gives
+** in its main position (i.e. the 'original' position that its hash gives
 ** to it), then the colliding element is in its own main position.
 ** Hence even when the load factor reaches 100%, performance remains good.
 */
 
+#include <float.h>
+#include <math.h>
 #include <string.h>
-
-#define ltable_c
-#define LUA_CORE
+#include <limits.h>
 
 #include "lua.h"
 
@@ -37,21 +42,26 @@
 
 
 /*
-** max size of array part is 2^MAXBITS
+** Maximum size of array part (MAXASIZE) is 2^MAXABITS. MAXABITS is
+** the largest integer such that MAXASIZE fits in an unsigned int.
 */
-#if LUAI_BITSINT >= 32
-#define MAXBITS		30
-#else
-#define MAXBITS		(LUAI_BITSINT-2)
-#endif
+#define MAXABITS	cast_int(sizeof(int) * CHAR_BIT - 1)
+#define MAXASIZE	(1u << MAXABITS)
 
-#define MAXASIZE	(1 << MAXBITS)
+/*
+** Maximum size of hash part is 2^MAXHBITS. MAXHBITS is the largest
+** integer such that 2^MAXHBITS fits in a signed int. (Note that the
+** maximum number of elements in a table, 2^MAXABITS + 2^MAXHBITS, still
+** fits comfortably in an unsigned int.)
+*/
+#define MAXHBITS	(MAXABITS - 1)
 
 
 #define hashpow2(t,n)		(gnode(t, lmod((n), sizenode(t))))
 
-#define hashstr(t,str)		hashpow2(t, (str)->tsv.hash)
+#define hashstr(t,str)		hashpow2(t, (str)->hash)
 #define hashboolean(t,p)	hashpow2(t, p)
+#define hashint(t,i)		hashpow2(t, i)
 
 
 /*
@@ -61,7 +71,7 @@
 #define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
 
 
-#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+#define hashpointer(t,p)	hashmod(t, point2int(p))
 
 
 #define dummynode		(&dummynode_)
@@ -70,16 +80,28 @@
 
 static const Node dummynode_ = {
   {NILCONSTANT},  /* value */
-  {{NILCONSTANT, NULL}}  /* key */
+  {{NILCONSTANT, 0}}  /* key */
 };
 
 
 /*
-** hash for lua_Numbers
+** Checks whether a float has a value representable as a lua_Integer
+** (and does the conversion if so)
+*/
+static int numisinteger (lua_Number x, lua_Integer *p) {
+  if ((x) == l_floor(x))  /* integral value? */
+    return lua_numbertointeger(x, p);  /* try as an integer */
+  else return 0;
+}
+
+
+/*
+** hash for floating-point numbers
 */
-static Node *hashnum (const Table *t, lua_Number n) {
+static Node *hashfloat (const Table *t, lua_Number n) {
   int i;
-  luai_hashnum(i, n);
+  n = l_mathop(frexp)(n, &i) * cast_num(INT_MAX - DBL_MAX_EXP);
+  i += cast_int(n);
   if (i < 0) {
     if (cast(unsigned int, i) == 0u - i)  /* use unsigned to avoid overflows */
       i = 0;  /* handle INT_MIN */
@@ -91,23 +113,25 @@
 
 
 /*
-** returns the `main' position of an element in a table (that is, the index
+** returns the 'main' position of an element in a table (that is, the index
 ** of its hash value)
 */
 static Node *mainposition (const Table *t, const TValue *key) {
   switch (ttype(key)) {
-    case LUA_TNUMBER:
-      return hashnum(t, nvalue(key));
+    case LUA_TNUMINT:
+      return hashint(t, ivalue(key));
+    case LUA_TNUMFLT:
+      return hashfloat(t, fltvalue(key));
+    case LUA_TSHRSTR:
+      return hashstr(t, tsvalue(key));
     case LUA_TLNGSTR: {
-      TString *s = rawtsvalue(key);
-      if (s->tsv.extra == 0) {  /* no hash? */
-        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);
-        s->tsv.extra = 1;  /* now it has its hash */
+      TString *s = tsvalue(key);
+      if (s->extra == 0) {  /* no hash? */
+        s->hash = luaS_hash(getstr(s), s->len, s->hash);
+        s->extra = 1;  /* now it has its hash */
       }
-      return hashstr(t, rawtsvalue(key));
+      return hashstr(t, tsvalue(key));
     }
-    case LUA_TSHRSTR:
-      return hashstr(t, rawtsvalue(key));
     case LUA_TBOOLEAN:
       return hashboolean(t, bvalue(key));
     case LUA_TLIGHTUSERDATA:
@@ -121,61 +145,61 @@
 
 
 /*
-** returns the index for `key' if `key' is an appropriate key to live in
-** the array part of the table, -1 otherwise.
+** returns the index for 'key' if 'key' is an appropriate key to live in
+** the array part of the table, 0 otherwise.
 */
-static int arrayindex (const TValue *key) {
-  if (ttisnumber(key)) {
-    lua_Number n = nvalue(key);
-    int k;
-    lua_number2int(k, n);
-    if (luai_numeq(cast_num(k), n))
-      return k;
+static unsigned int arrayindex (const TValue *key) {
+  if (ttisinteger(key)) {
+    lua_Integer k = ivalue(key);
+    if (0 < k && (lua_Unsigned)k <= MAXASIZE)
+      return cast(unsigned int, k);  /* 'key' is an appropriate array index */
   }
-  return -1;  /* `key' did not match some condition */
+  return 0;  /* 'key' did not match some condition */
 }
 
 
 /*
-** returns the index of a `key' for table traversals. First goes all
+** returns the index of a 'key' for table traversals. First goes all
 ** elements in the array part, then elements in the hash part. The
-** beginning of a traversal is signaled by -1.
+** beginning of a traversal is signaled by 0.
 */
-static int findindex (lua_State *L, Table *t, StkId key) {
-  int i;
-  if (ttisnil(key)) return -1;  /* first iteration */
+static unsigned int findindex (lua_State *L, Table *t, StkId key) {
+  unsigned int i;
+  if (ttisnil(key)) return 0;  /* first iteration */
   i = arrayindex(key);
-  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */
-    return i-1;  /* yes; that's the index (corrected to C) */
+  if (i != 0 && i <= t->sizearray)  /* is 'key' inside array part? */
+    return i;  /* yes; that's the index */
   else {
+    int nx;
     Node *n = mainposition(t, key);
-    for (;;) {  /* check whether `key' is somewhere in the chain */
-      /* key may be dead already, but it is ok to use it in `next' */
+    for (;;) {  /* check whether 'key' is somewhere in the chain */
+      /* key may be dead already, but it is ok to use it in 'next' */
       if (luaV_rawequalobj(gkey(n), key) ||
             (ttisdeadkey(gkey(n)) && iscollectable(key) &&
              deadvalue(gkey(n)) == gcvalue(key))) {
         i = cast_int(n - gnode(t, 0));  /* key index in hash table */
         /* hash elements are numbered after array ones */
-        return i + t->sizearray;
+        return (i + 1) + t->sizearray;
       }
-      else n = gnext(n);
-      if (n == NULL)
-        luaG_runerror(L, "invalid key to " LUA_QL("next"));  /* key not found */
+      nx = gnext(n);
+      if (nx == 0)
+        luaG_runerror(L, "invalid key to 'next'");  /* key not found */
+      else n += nx;
     }
   }
 }
 
 
 int luaH_next (lua_State *L, Table *t, StkId key) {
-  int i = findindex(L, t, key);  /* find original element */
-  for (i++; i < t->sizearray; i++) {  /* try first array part */
+  unsigned int i = findindex(L, t, key);  /* find original element */
+  for (; i < t->sizearray; i++) {  /* try first array part */
     if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
-      setnvalue(key, cast_num(i+1));
+      setivalue(key, i + 1);
       setobj2s(L, key+1, &t->array[i]);
       return 1;
     }
   }
-  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
+  for (i -= t->sizearray; cast_int(i) < sizenode(t); i++) {  /* hash part */
     if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
       setobj2s(L, key, gkey(gnode(t, i)));
       setobj2s(L, key+1, gval(gnode(t, i)));
@@ -192,19 +216,24 @@
 ** ==============================================================
 */
 
-
-static int computesizes (int nums[], int *narray) {
+/*
+** Compute the optimal size for the array part of table 't'. 'nums' is a
+** "count array" where 'nums[i]' is the number of integers in the table
+** between 2^(i - 1) + 1 and 2^i. Put in '*narray' the optimal size, and
+** return the number of elements that will go to that part.
+*/
+static unsigned int computesizes (unsigned int nums[], unsigned int *narray) {
   int i;
-  int twotoi;  /* 2^i */
-  int a = 0;  /* number of elements smaller than 2^i */
-  int na = 0;  /* number of elements to go to array part */
-  int n = 0;  /* optimal size for array part */
+  unsigned int twotoi;  /* 2^i */
+  unsigned int a = 0;  /* number of elements smaller than 2^i */
+  unsigned int na = 0;  /* number of elements to go to array part */
+  unsigned int n = 0;  /* optimal size for array part */
   for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
     if (nums[i] > 0) {
       a += nums[i];
       if (a > twotoi/2) {  /* more than half elements present? */
         n = twotoi;  /* optimal size (till now) */
-        na = a;  /* all elements smaller than n will go to array part */
+        na = a;  /* all elements up to 'n' will go to array part */
       }
     }
     if (a == *narray) break;  /* all elements already counted */
@@ -215,9 +244,9 @@
 }
 
 
-static int countint (const TValue *key, int *nums) {
-  int k = arrayindex(key);
-  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */
+static int countint (const TValue *key, unsigned int *nums) {
+  unsigned int k = arrayindex(key);
+  if (k != 0) {  /* is 'key' an appropriate array index? */
     nums[luaO_ceillog2(k)]++;  /* count as such */
     return 1;
   }
@@ -226,20 +255,21 @@
 }
 
 
-static int numusearray (const Table *t, int *nums) {
+static unsigned int numusearray (const Table *t, unsigned int *nums) {
   int lg;
-  int ttlg;  /* 2^lg */
-  int ause = 0;  /* summation of `nums' */
-  int i = 1;  /* count to traverse all array keys */
-  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  /* for each slice */
-    int lc = 0;  /* counter */
-    int lim = ttlg;
+  unsigned int ttlg;  /* 2^lg */
+  unsigned int ause = 0;  /* summation of 'nums' */
+  unsigned int i = 1;  /* count to traverse all array keys */
+  /* traverse each slice */
+  for (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {
+    unsigned int lc = 0;  /* counter */
+    unsigned int lim = ttlg;
     if (lim > t->sizearray) {
       lim = t->sizearray;  /* adjust upper limit */
       if (i > lim)
         break;  /* no more elements to count */
     }
-    /* count elements in range (2^(lg-1), 2^lg] */
+    /* count elements in range (2^(lg - 1), 2^lg] */
     for (; i <= lim; i++) {
       if (!ttisnil(&t->array[i-1]))
         lc++;
@@ -251,9 +281,10 @@
 }
 
 
-static int numusehash (const Table *t, int *nums, int *pnasize) {
+static int numusehash (const Table *t, unsigned int *nums,
+                       unsigned int *pnasize) {
   int totaluse = 0;  /* total number of elements */
-  int ause = 0;  /* summation of `nums' */
+  int ause = 0;  /* elements added to 'nums' (can go to array part) */
   int i = sizenode(t);
   while (i--) {
     Node *n = &t->node[i];
@@ -267,8 +298,8 @@
 }
 
 
-static void setarrayvector (lua_State *L, Table *t, int size) {
-  int i;
+static void setarrayvector (lua_State *L, Table *t, unsigned int size) {
+  unsigned int i;
   luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
   for (i=t->sizearray; i<size; i++)
      setnilvalue(&t->array[i]);
@@ -276,23 +307,23 @@
 }
 
 
-static void setnodevector (lua_State *L, Table *t, int size) {
+static void setnodevector (lua_State *L, Table *t, unsigned int size) {
   int lsize;
   if (size == 0) {  /* no elements to hash part? */
-    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
+    t->node = cast(Node *, dummynode);  /* use common 'dummynode' */
     lsize = 0;
   }
   else {
     int i;
     lsize = luaO_ceillog2(size);
-    if (lsize > MAXBITS)
+    if (lsize > MAXHBITS)
       luaG_runerror(L, "table overflow");
     size = twoto(lsize);
     t->node = luaM_newvector(L, size, Node);
-    for (i=0; i<size; i++) {
+    for (i = 0; i < (int)size; i++) {
       Node *n = gnode(t, i);
-      gnext(n) = NULL;
-      setnilvalue(gkey(n));
+      gnext(n) = 0;
+      setnilvalue(wgkey(n));
       setnilvalue(gval(n));
     }
   }
@@ -301,9 +332,11 @@
 }
 
 
-void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize) {
-  int i;
-  int oldasize = t->sizearray;
+void luaH_resize (lua_State *L, Table *t, unsigned int nasize,
+                                          unsigned int nhsize) {
+  unsigned int i;
+  int j;
+  unsigned int oldasize = t->sizearray;
   int oldhsize = t->lsizenode;
   Node *nold = t->node;  /* save old hash ... */
   if (nasize > oldasize)  /* array part must grow? */
@@ -321,8 +354,8 @@
     luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
   }
   /* re-insert elements from hash part */
-  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
-    Node *old = nold+i;
+  for (j = twoto(oldhsize) - 1; j >= 0; j--) {
+    Node *old = nold + j;
     if (!ttisnil(gval(old))) {
       /* doesn't need barrier/invalidate cache, as entry was
          already present in the table */
@@ -334,18 +367,20 @@
 }
 
 
-void luaH_resizearray (lua_State *L, Table *t, int nasize) {
+void luaH_resizearray (lua_State *L, Table *t, unsigned int nasize) {
   int nsize = isdummy(t->node) ? 0 : sizenode(t);
   luaH_resize(L, t, nasize, nsize);
 }
 
-
+/*
+** nums[i] = number of keys 'k' where 2^(i - 1) < k <= 2^i
+*/
 static void rehash (lua_State *L, Table *t, const TValue *ek) {
-  int nasize, na;
-  int nums[MAXBITS+1];  /* nums[i] = number of keys with 2^(i-1) < k <= 2^i */
+  unsigned int nasize, na;
+  unsigned int nums[MAXABITS + 1];
   int i;
   int totaluse;
-  for (i=0; i<=MAXBITS; i++) nums[i] = 0;  /* reset counts */
+  for (i = 0; i <= MAXABITS; i++) nums[i] = 0;  /* reset counts */
   nasize = numusearray(t, nums);  /* count keys in array part */
   totaluse = nasize;  /* all those keys are integer keys */
   totaluse += numusehash(t, nums, &nasize);  /* count keys in hash part */
@@ -366,7 +401,8 @@
 
 
 Table *luaH_new (lua_State *L) {
-  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
+  GCObject *o = luaC_newobj(L, LUA_TTABLE, sizeof(Table));
+  Table *t = gco2t(o);
   t->metatable = NULL;
   t->flags = cast_byte(~0);
   t->array = NULL;
@@ -404,37 +440,52 @@
 */
 TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
   Node *mp;
+  TValue aux;
   if (ttisnil(key)) luaG_runerror(L, "table index is nil");
-  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))
-    luaG_runerror(L, "table index is NaN");
+  else if (ttisfloat(key)) {
+    lua_Number n = fltvalue(key);
+    lua_Integer k;
+    if (luai_numisnan(n))
+      luaG_runerror(L, "table index is NaN");
+    if (numisinteger(n, &k)) {  /* index is int? */
+      setivalue(&aux, k);
+      key = &aux;  /* insert it as an integer */
+    }
+  }
   mp = mainposition(t, key);
   if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
     Node *othern;
-    Node *n = getfreepos(t);  /* get a free place */
-    if (n == NULL) {  /* cannot find a free place? */
+    Node *f = getfreepos(t);  /* get a free place */
+    if (f == NULL) {  /* cannot find a free place? */
       rehash(L, t, key);  /* grow table */
-      /* whatever called 'newkey' take care of TM cache and GC barrier */
+      /* whatever called 'newkey' takes care of TM cache and GC barrier */
       return luaH_set(L, t, key);  /* insert key into grown table */
     }
-    lua_assert(!isdummy(n));
+    lua_assert(!isdummy(f));
     othern = mainposition(t, gkey(mp));
     if (othern != mp) {  /* is colliding node out of its main position? */
       /* yes; move colliding node into free position */
-      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
-      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
-      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
-      gnext(mp) = NULL;  /* now `mp' is free */
+      while (othern + gnext(othern) != mp)  /* find previous */
+        othern += gnext(othern);
+      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */
+      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      if (gnext(mp) != 0) {
+        gnext(f) += cast_int(mp - f);  /* correct 'next' */
+        gnext(mp) = 0;  /* now 'mp' is free */
+      }
       setnilvalue(gval(mp));
     }
     else {  /* colliding node is in its own main position */
       /* new node will go into free position */
-      gnext(n) = gnext(mp);  /* chain new position */
-      gnext(mp) = n;
-      mp = n;
+      if (gnext(mp) != 0)
+        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */
+      else lua_assert(gnext(f) == 0);
+      gnext(mp) = cast_int(f - mp);
+      mp = f;
     }
   }
-  setobj2t(L, gkey(mp), key);
-  luaC_barrierback(L, obj2gco(t), key);
+  setnodekey(L, &mp->i_key, key);
+  luaC_barrierback(L, t, key);
   lua_assert(ttisnil(gval(mp)));
   return gval(mp);
 }
@@ -443,18 +494,21 @@
 /*
 ** search function for integers
 */
-const TValue *luaH_getint (Table *t, int key) {
+const TValue *luaH_getint (Table *t, lua_Integer key) {
   /* (1 <= key && key <= t->sizearray) */
-  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
-    return &t->array[key-1];
+  if (l_castS2U(key - 1) < t->sizearray)
+    return &t->array[key - 1];
   else {
-    lua_Number nk = cast_num(key);
-    Node *n = hashnum(t, nk);
-    do {  /* check whether `key' is somewhere in the chain */
-      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
+    Node *n = hashint(t, key);
+    for (;;) {  /* check whether 'key' is somewhere in the chain */
+      if (ttisinteger(gkey(n)) && ivalue(gkey(n)) == key)
         return gval(n);  /* that's it */
-      else n = gnext(n);
-    } while (n);
+      else {
+        int nx = gnext(n);
+        if (nx == 0) break;
+        n += nx;
+      }
+    };
     return luaO_nilobject;
   }
 }
@@ -465,12 +519,17 @@
 */
 const TValue *luaH_getstr (Table *t, TString *key) {
   Node *n = hashstr(t, key);
-  lua_assert(key->tsv.tt == LUA_TSHRSTR);
-  do {  /* check whether `key' is somewhere in the chain */
-    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))
+  lua_assert(key->tt == LUA_TSHRSTR);
+  for (;;) {  /* check whether 'key' is somewhere in the chain */
+    const TValue *k = gkey(n);
+    if (ttisshrstring(k) && eqshrstr(tsvalue(k), key))
       return gval(n);  /* that's it */
-    else n = gnext(n);
-  } while (n);
+    else {
+      int nx = gnext(n);
+      if (nx == 0) break;
+      n += nx;
+    }
+  };
   return luaO_nilobject;
 }
 
@@ -480,23 +539,26 @@
 */
 const TValue *luaH_get (Table *t, const TValue *key) {
   switch (ttype(key)) {
-    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));
+    case LUA_TSHRSTR: return luaH_getstr(t, tsvalue(key));
+    case LUA_TNUMINT: return luaH_getint(t, ivalue(key));
     case LUA_TNIL: return luaO_nilobject;
-    case LUA_TNUMBER: {
-      int k;
-      lua_Number n = nvalue(key);
-      lua_number2int(k, n);
-      if (luai_numeq(cast_num(k), n)) /* index is int? */
+    case LUA_TNUMFLT: {
+      lua_Integer k;
+      if (numisinteger(fltvalue(key), &k)) /* index is int? */
         return luaH_getint(t, k);  /* use specialized version */
       /* else go through */
     }
     default: {
       Node *n = mainposition(t, key);
-      do {  /* check whether `key' is somewhere in the chain */
+      for (;;) {  /* check whether 'key' is somewhere in the chain */
         if (luaV_rawequalobj(gkey(n), key))
           return gval(n);  /* that's it */
-        else n = gnext(n);
-      } while (n);
+        else {
+          int nx = gnext(n);
+          if (nx == 0) break;
+          n += nx;
+        }
+      };
       return luaO_nilobject;
     }
   }
@@ -515,33 +577,34 @@
 }
 
 
-void luaH_setint (lua_State *L, Table *t, int key, TValue *value) {
+void luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) {
   const TValue *p = luaH_getint(t, key);
   TValue *cell;
   if (p != luaO_nilobject)
     cell = cast(TValue *, p);
   else {
     TValue k;
-    setnvalue(&k, cast_num(key));
+    setivalue(&k, key);
     cell = luaH_newkey(L, t, &k);
   }
   setobj2t(L, cell, value);
 }
 
 
+LUA_GNUC_PURE
 static int unbound_search (Table *t, unsigned int j) {
   unsigned int i = j;  /* i is zero or a present index */
   j++;
-  /* find `i' and `j' such that i is present and j is not */
+  /* find 'i' and 'j' such that i is present and j is not */
   while (!ttisnil(luaH_getint(t, j))) {
     i = j;
-    j *= 2;
-    if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */
+    if (j > cast(unsigned int, MAX_INT)/2) {  /* overflow? */
       /* table was built with bad purposes: resort to linear search */
       i = 1;
       while (!ttisnil(luaH_getint(t, i))) i++;
       return i - 1;
     }
+    j *= 2;
   }
   /* now do a binary search between them */
   while (j - i > 1) {
@@ -554,7 +617,7 @@
 
 
 /*
-** Try to find a boundary in table `t'. A `boundary' is an integer index
+** Try to find a boundary in table 't'. A 'boundary' is an integer index
 ** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
 */
 int luaH_getn (Table *t) {
diff -urN rpm-5.4.15/lua/ltable.h rpm-5.4-cvs/lua/ltable.h
--- rpm-5.4.15/lua/ltable.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/ltable.h	2015-04-18 23:34:18.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: ltable.h,v 2.16 2011/08/17 20:26:47 roberto Exp $
+** $Id: ltable.h,v 2.20 2014/09/04 18:15:29 roberto Exp $
 ** Lua tables (hash)
 ** See Copyright Notice in lua.h
 */
@@ -11,25 +11,40 @@
 
 
 #define gnode(t,i)	(&(t)->node[i])
-#define gkey(n)		(&(n)->i_key.tvk)
 #define gval(n)		(&(n)->i_val)
 #define gnext(n)	((n)->i_key.nk.next)
 
+
+/* 'const' to avoid wrong writings that can mess up field 'next' */ 
+#define gkey(n)		cast(const TValue*, (&(n)->i_key.tvk))
+
+#define wgkey(n)		(&(n)->i_key.nk)
+
 #define invalidateTMcache(t)	((t)->flags = 0)
 
 
-LUAI_FUNC const TValue *luaH_getint (Table *t, int key);
-LUAI_FUNC void luaH_setint (lua_State *L, Table *t, int key, TValue *value);
-LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
+/* returns the key, given the value of a table entry */
+#define keyfromval(v) \
+  (gkey(cast(Node *, cast(char *, (v)) - offsetof(Node, i_val))))
+
+
+LUAI_FUNC const TValue *luaH_getint (Table *t, lua_Integer key)
+	LUA_GNUC_PURE;
+LUAI_FUNC void luaH_setint (lua_State *L, Table *t, lua_Integer key,
+                                                    TValue *value);
+LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key)
+	LUA_GNUC_PURE;
 LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
 LUAI_FUNC TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key);
 LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
 LUAI_FUNC Table *luaH_new (lua_State *L);
-LUAI_FUNC void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize);
-LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);
+LUAI_FUNC void luaH_resize (lua_State *L, Table *t, unsigned int nasize,
+                                                    unsigned int nhsize);
+LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, unsigned int nasize);
 LUAI_FUNC void luaH_free (lua_State *L, Table *t);
 LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
-LUAI_FUNC int luaH_getn (Table *t);
+LUAI_FUNC int luaH_getn (Table *t)
+	LUA_GNUC_PURE;
 
 
 #if defined(LUA_DEBUG)
diff -urN rpm-5.4.15/lua/ltablib.c rpm-5.4-cvs/lua/ltablib.c
--- rpm-5.4.15/lua/ltablib.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/ltablib.c	2015-04-18 23:34:18.000000000 -0500
@@ -1,23 +1,58 @@
 /*
-** $Id: ltablib.c,v 1.65 2013/03/07 18:17:24 roberto Exp $
+** $Id: ltablib.c,v 1.79 2014/11/02 19:19:04 roberto Exp $
 ** Library for Table Manipulation
 ** See Copyright Notice in lua.h
 */
 
-
-#include <stddef.h>
-
 #define ltablib_c
 #define LUA_LIB
 
+#include "lprefix.h"
+
+
+#include <limits.h>
+#include <stddef.h>
+
 #include "lua.h"
 
 #include "lauxlib.h"
 #include "lualib.h"
 
 
-#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))
 
+/*
+** Structure with table-access functions
+*/
+typedef struct {
+  int (*geti) (lua_State *L, int idx, lua_Integer n);
+  void (*seti) (lua_State *L, int idx, lua_Integer n);
+} TabA;
+
+
+/*
+** Check that 'arg' has a table and set access functions in 'ta' to raw
+** or non-raw according to the presence of corresponding metamethods.
+*/
+static void checktab (lua_State *L, int arg, TabA *ta) {
+  ta->geti = NULL; ta->seti = NULL;
+  if (lua_getmetatable(L, arg)) {
+    lua_pushliteral(L, "__index");  /* 'index' metamethod */
+    if (lua_rawget(L, -2) != LUA_TNIL)
+      ta->geti = lua_geti;
+    lua_pushliteral(L, "__newindex");  /* 'newindex' metamethod */
+    if (lua_rawget(L, -3) != LUA_TNIL)
+      ta->seti = lua_seti;
+    lua_pop(L, 3);  /* pop metatable plus both metamethods */
+  }
+  if (ta->geti == NULL || ta->seti == NULL) {
+    luaL_checktype(L, arg, LUA_TTABLE);  /* must be table for raw methods */
+    if (ta->geti == NULL) ta->geti = lua_rawgeti;
+    if (ta->seti == NULL) ta->seti = lua_rawseti;
+  }
+}
+
+
+#define aux_getn(L,n,ta)	(checktab(L, n, ta), luaL_len(L, n))
 
 
 #if defined(LUA_COMPAT_MAXN)
@@ -39,72 +74,110 @@
 
 
 static int tinsert (lua_State *L) {
-  int e = aux_getn(L, 1) + 1;  /* first empty element */
-  int pos;  /* where to insert new element */
+  TabA ta;
+  lua_Integer e = aux_getn(L, 1, &ta) + 1;  /* first empty element */
+  lua_Integer pos;  /* where to insert new element */
   switch (lua_gettop(L)) {
     case 2: {  /* called with only 2 arguments */
       pos = e;  /* insert new element at the end */
       break;
     }
     case 3: {
-      int i;
-      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+      lua_Integer i;
+      pos = luaL_checkinteger(L, 2);  /* 2nd argument is the position */
       luaL_argcheck(L, 1 <= pos && pos <= e, 2, "position out of bounds");
       for (i = e; i > pos; i--) {  /* move up elements */
-        lua_rawgeti(L, 1, i-1);
-        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */
+        (*ta.geti)(L, 1, i - 1);
+        (*ta.seti)(L, 1, i);  /* t[i] = t[i - 1] */
       }
       break;
     }
     default: {
-      return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
+      return luaL_error(L, "wrong number of arguments to 'insert'");
     }
   }
-  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  (*ta.seti)(L, 1, pos);  /* t[pos] = v */
   return 0;
 }
 
 
 static int tremove (lua_State *L) {
-  int size = aux_getn(L, 1);
-  int pos = luaL_optint(L, 2, size);
+  TabA ta;
+  lua_Integer size = aux_getn(L, 1, &ta);
+  lua_Integer pos = luaL_optinteger(L, 2, size);
   if (pos != size)  /* validate 'pos' if given */
     luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, "position out of bounds");
-  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  (*ta.geti)(L, 1, pos);  /* result = t[pos] */
   for ( ; pos < size; pos++) {
-    lua_rawgeti(L, 1, pos+1);
-    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+    (*ta.geti)(L, 1, pos + 1);
+    (*ta.seti)(L, 1, pos);  /* t[pos] = t[pos + 1] */
   }
   lua_pushnil(L);
-  lua_rawseti(L, 1, pos);  /* t[pos] = nil */
+  (*ta.seti)(L, 1, pos);  /* t[pos] = nil */
+  return 1;
+}
+
+
+static int tmove (lua_State *L) {
+  TabA ta;
+  lua_Integer f = luaL_checkinteger(L, 2);
+  lua_Integer e = luaL_checkinteger(L, 3);
+  lua_Integer t = luaL_checkinteger(L, 4);
+  int tt = !lua_isnoneornil(L, 5) ? 5 : 1;  /* destination table */
+  /* the following restriction avoids several problems with overflows */
+  luaL_argcheck(L, f > 0, 2, "initial position must be positive");
+  if (e >= f) {  /* otherwise, nothing to move */
+    lua_Integer n, i;
+    ta.geti = (luaL_getmetafield(L, 1, "__index") == LUA_TNIL)
+      ? (luaL_checktype(L, 1, LUA_TTABLE), lua_rawgeti)
+      : lua_geti;
+    ta.seti = (luaL_getmetafield(L, tt, "__newindex") == LUA_TNIL)
+      ? (luaL_checktype(L, tt, LUA_TTABLE), lua_rawseti)
+      : lua_seti;
+    n = e - f + 1;  /* number of elements to move */
+    if (t > f) {
+      for (i = n - 1; i >= 0; i--) {
+        (*ta.geti)(L, 1, f + i);
+        (*ta.seti)(L, tt, t + i);
+      }
+    }
+    else {
+      for (i = 0; i < n; i++) {
+        (*ta.geti)(L, 1, f + i);
+        (*ta.seti)(L, tt, t + i);
+      }
+    }
+  }
+  lua_pushvalue(L, tt);  /* return "to table" */
   return 1;
 }
 
 
-static void addfield (lua_State *L, luaL_Buffer *b, int i) {
-  lua_rawgeti(L, 1, i);
+static void addfield (lua_State *L, luaL_Buffer *b, TabA *ta, lua_Integer i) {
+  (*ta->geti)(L, 1, i);
   if (!lua_isstring(L, -1))
-    luaL_error(L, "invalid value (%s) at index %d in table for "
-                  LUA_QL("concat"), luaL_typename(L, -1), i);
+    luaL_error(L, "invalid value (%s) at index %d in table for 'concat'",
+                  luaL_typename(L, -1), i);
   luaL_addvalue(b);
 }
 
 
 static int tconcat (lua_State *L) {
+  TabA ta;
   luaL_Buffer b;
   size_t lsep;
-  int i, last;
+  lua_Integer i, last;
   const char *sep = luaL_optlstring(L, 2, "", &lsep);
-  luaL_checktype(L, 1, LUA_TTABLE);
-  i = luaL_optint(L, 3, 1);
-  last = luaL_opt(L, luaL_checkint, 4, luaL_len(L, 1));
+  checktab(L, 1, &ta);
+  i = luaL_optinteger(L, 3, 1);
+  last = luaL_opt(L, luaL_checkinteger, 4, luaL_len(L, 1));
   luaL_buffinit(L, &b);
   for (; i < last; i++) {
-    addfield(L, &b, i);
+    addfield(L, &b, &ta, i);
     luaL_addlstring(&b, sep, lsep);
   }
   if (i == last)  /* add last value (if interval was not empty) */
-    addfield(L, &b, i);
+    addfield(L, &b, &ta, i);
   luaL_pushresult(&b);
   return 1;
 }
@@ -117,35 +190,34 @@
 */
 
 static int pack (lua_State *L) {
+  int i;
   int n = lua_gettop(L);  /* number of elements to pack */
   lua_createtable(L, n, 1);  /* create result table */
+  lua_insert(L, 1);  /* put it at index 1 */
+  for (i = n; i >= 1; i--)  /* assign elements */
+    lua_rawseti(L, 1, i);
   lua_pushinteger(L, n);
-  lua_setfield(L, -2, "n");  /* t.n = number of elements */
-  if (n > 0) {  /* at least one element? */
-    int i;
-    lua_pushvalue(L, 1);
-    lua_rawseti(L, -2, 1);  /* insert first element */
-    lua_replace(L, 1);  /* move table into index 1 */
-    for (i = n; i >= 2; i--)  /* assign other elements */
-      lua_rawseti(L, 1, i);
-  }
+  lua_setfield(L, 1, "n");  /* t.n = number of elements */
   return 1;  /* return table */
 }
 
 
 static int unpack (lua_State *L) {
-  int i, e, n;
-  luaL_checktype(L, 1, LUA_TTABLE);
-  i = luaL_optint(L, 2, 1);
-  e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));
+  TabA ta;
+  lua_Integer i, e;
+  lua_Unsigned n;
+  checktab(L, 1, &ta);
+  i = luaL_optinteger(L, 2, 1);
+  e = luaL_opt(L, luaL_checkinteger, 3, luaL_len(L, 1));
   if (i > e) return 0;  /* empty range */
-  n = e - i + 1;  /* number of elements */
-  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
+  n = (lua_Unsigned)e - i;  /* number of elements minus 1 (avoid overflows) */
+  if (n >= (unsigned int)INT_MAX  || !lua_checkstack(L, (int)(++n)))
     return luaL_error(L, "too many results to unpack");
-  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
-  while (i++ < e)  /* push arg[i + 1...e] */
-    lua_rawgeti(L, 1, i);
-  return n;
+  do {  /* must have at least one element */
+    (*ta.geti)(L, 1, i);  /* push arg[i..e] */
+  } while (i++ < e); 
+
+  return (int)n;
 }
 
 /* }====================================================== */
@@ -155,15 +227,15 @@
 /*
 ** {======================================================
 ** Quicksort
-** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+** (based on 'Algorithms in MODULA-3', Robert Sedgewick;
 **  Addison-Wesley, 1993.)
 ** =======================================================
 */
 
 
-static void set2 (lua_State *L, int i, int j) {
-  lua_rawseti(L, 1, i);
-  lua_rawseti(L, 1, j);
+static void set2 (lua_State *L, TabA *ta, int i, int j) {
+  (*ta->seti)(L, 1, i);
+  (*ta->seti)(L, 1, j);
 }
 
 static int sort_comp (lua_State *L, int a, int b) {
@@ -171,7 +243,7 @@
     int res;
     lua_pushvalue(L, 2);
     lua_pushvalue(L, a-1);  /* -1 to compensate function */
-    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and 'a' */
     lua_call(L, 2, 1);
     res = lua_toboolean(L, -1);
     lua_pop(L, 1);
@@ -181,45 +253,45 @@
     return lua_compare(L, a, b, LUA_OPLT);
 }
 
-static void auxsort (lua_State *L, int l, int u) {
+static void auxsort (lua_State *L, TabA *ta, int l, int u) {
   while (l < u) {  /* for tail recursion */
     int i, j;
     /* sort elements a[l], a[(l+u)/2] and a[u] */
-    lua_rawgeti(L, 1, l);
-    lua_rawgeti(L, 1, u);
+    (*ta->geti)(L, 1, l);
+    (*ta->geti)(L, 1, u);
     if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
-      set2(L, l, u);  /* swap a[l] - a[u] */
+      set2(L, ta, l, u);  /* swap a[l] - a[u] */
     else
       lua_pop(L, 2);
     if (u-l == 1) break;  /* only 2 elements */
     i = (l+u)/2;
-    lua_rawgeti(L, 1, i);
-    lua_rawgeti(L, 1, l);
+    (*ta->geti)(L, 1, i);
+    (*ta->geti)(L, 1, l);
     if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
-      set2(L, i, l);
+      set2(L, ta, i, l);
     else {
       lua_pop(L, 1);  /* remove a[l] */
-      lua_rawgeti(L, 1, u);
+      (*ta->geti)(L, 1, u);
       if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
-        set2(L, i, u);
+        set2(L, ta, i, u);
       else
         lua_pop(L, 2);
     }
     if (u-l == 2) break;  /* only 3 elements */
-    lua_rawgeti(L, 1, i);  /* Pivot */
+    (*ta->geti)(L, 1, i);  /* Pivot */
     lua_pushvalue(L, -1);
-    lua_rawgeti(L, 1, u-1);
-    set2(L, i, u-1);
+    (*ta->geti)(L, 1, u-1);
+    set2(L, ta, i, u-1);
     /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
     i = l; j = u-1;
     for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
       /* repeat ++i until a[i] >= P */
-      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+      while ((*ta->geti)(L, 1, ++i), sort_comp(L, -1, -2)) {
         if (i>=u) luaL_error(L, "invalid order function for sorting");
         lua_pop(L, 1);  /* remove a[i] */
       }
       /* repeat --j until a[j] <= P */
-      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+      while ((*ta->geti)(L, 1, --j), sort_comp(L, -3, -1)) {
         if (j<=l) luaL_error(L, "invalid order function for sorting");
         lua_pop(L, 1);  /* remove a[j] */
       }
@@ -227,11 +299,11 @@
         lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
         break;
       }
-      set2(L, i, j);
+      set2(L, ta, i, j);
     }
-    lua_rawgeti(L, 1, u-1);
-    lua_rawgeti(L, 1, i);
-    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    (*ta->geti)(L, 1, u-1);
+    (*ta->geti)(L, 1, i);
+    set2(L, ta, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
     /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
     /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
     if (i-l < u-i) {
@@ -240,17 +312,18 @@
     else {
       j=i+1; i=u; u=j-2;
     }
-    auxsort(L, j, i);  /* call recursively the smaller one */
+    auxsort(L, ta, j, i);  /* call recursively the smaller one */
   }  /* repeat the routine for the larger one */
 }
 
 static int sort (lua_State *L) {
-  int n = aux_getn(L, 1);
-  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
+  TabA ta;
+  int n = (int)aux_getn(L, 1, &ta);
+  luaL_checkstack(L, 50, "");  /* assume array is smaller than 2^50 */
   if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
     luaL_checktype(L, 2, LUA_TFUNCTION);
-  lua_settop(L, 2);  /* make sure there is two arguments */
-  auxsort(L, 1, n);
+  lua_settop(L, 2);  /* make sure there are two arguments */
+  auxsort(L, &ta, 1, n);
   return 0;
 }
 
@@ -266,6 +339,7 @@
   {"pack", pack},
   {"unpack", unpack},
   {"remove", tremove},
+  {"move", tmove},
   {"sort", sort},
   {NULL, NULL}
 };
diff -urN rpm-5.4.15/lua/ltests.c rpm-5.4-cvs/lua/ltests.c
--- rpm-5.4.15/lua/ltests.c	2004-03-22 23:09:14.000000000 -0600
+++ rpm-5.4-cvs/lua/ltests.c	2015-04-19 13:24:57.000000000 -0500
@@ -1,23 +1,27 @@
 /*
-** $Id: ltests.c,v 1.1 2004/03/16 21:58:30 niemeyer Exp $
+** $Id: ltests.c,v 2.201 2014/12/18 12:13:42 roberto Exp $
 ** Internal Module for Debugging of the Lua Implementation
 ** See Copyright Notice in lua.h
 */
 
+#define ltests_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
-#include <ctype.h>
 #include <limits.h>
+#include <setjmp.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define ltests_c
-
 #include "lua.h"
 
 #include "lapi.h"
 #include "lauxlib.h"
 #include "lcode.h"
+#include "lctype.h"
 #include "ldebug.h"
 #include "ldo.h"
 #include "lfunc.h"
@@ -33,29 +37,41 @@
 /*
 ** The whole module only makes sense with LUA_DEBUG on
 */
-#ifdef LUA_DEBUG
-
+#if defined(LUA_DEBUG)
 
-#define lua_pushintegral(L,i)	lua_pushnumber(L, cast(lua_Number, (i)))
 
+void *l_Trick = 0;
 
-static lua_State *lua_state = NULL;
 
 int islocked = 0;
 
 
-#define func_at(L,k)	(L->ci->base+(k) - 1)
+#define obj_at(L,k)	(L->ci->func + (k))
 
 
-static void setnameval (lua_State *L, const char *name, int val)
-	/*@*/
-{
+static int runC (lua_State *L, lua_State *L1, const char *pc);
+
+
+static void setnameval (lua_State *L, const char *name, int val) {
   lua_pushstring(L, name);
-  lua_pushintegral(L, val);
+  lua_pushinteger(L, val);
   lua_settable(L, -3);
 }
 
 
+static void pushobject (lua_State *L, const TValue *o) {
+  setobj2s(L, L->top, o);
+  api_incr_top(L);
+}
+
+
+static int tpanic (lua_State *L) {
+  fprintf(stderr, "PANIC: unprotected error in call to Lua API (%s)\n",
+                   lua_tostring(L, -1));
+  return (exit(EXIT_FAILURE), 0);  /* do not return to Lua */
+}
+
+
 /*
 ** {======================================================================
 ** Controlled version for realloc.
@@ -64,87 +80,97 @@
 
 #define MARK		0x55  /* 01010101 (a nice pattern) */
 
-#ifndef EXTERNMEMCHECK
+typedef union Header {
+  L_Umaxalign a;  /* ensures maximum alignment for Header */
+  struct {
+    size_t size;
+    int type;
+  } d;
+} Header;
+
+
+#if !defined(EXTERNMEMCHECK)
+
 /* full memory check */
-#define HEADER	(sizeof(L_Umaxalign)) /* ensures maximum alignment for HEADER */
 #define MARKSIZE	16  /* size of marks after each block */
-#define blockhead(b)	(cast(char *, b) - HEADER)
-#define setsize(newblock, size)	(*cast(size_t *, newblock) = size)
-#define checkblocksize(b, size) (size == (*cast(size_t *, blockhead(b))))
 #define fillmem(mem,size)	memset(mem, -MARK, size)
+
 #else
+
 /* external memory check: don't do it twice */
-#define HEADER		0
 #define MARKSIZE	0
-#define blockhead(b)	(b)
-#define setsize(newblock, size)	/* empty */
-#define checkblocksize(b,size)	(1)
 #define fillmem(mem,size)	/* empty */
-#endif
 
-unsigned long memdebug_numblocks = 0;
-unsigned long memdebug_total = 0;
-unsigned long memdebug_maxmem = 0;
-unsigned long memdebug_memlimit = ULONG_MAX;
+#endif
 
 
-static void *checkblock (void *block, size_t size)
-	/*@*/
-{
-  void *b = blockhead(block);
-  int i;
-  for (i=0;i<MARKSIZE;i++)
-    lua_assert(*(cast(char *, b)+HEADER+size+i) == MARK+i); /* corrupted block? */
-  return b;
-}
+Memcontrol l_memcontrol =
+  {0L, 0L, 0L, 0L, {0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L}};
 
 
-static void freeblock (void *block, size_t size)
-	/*@*/
-{
+static void freeblock (Memcontrol *mc, Header *block) {
   if (block) {
-    lua_assert(checkblocksize(block, size));
-    block = checkblock(block, size);
-    fillmem(block, size+HEADER+MARKSIZE);  /* erase block */
-    free(block);  /* free original block */
-    memdebug_numblocks--;
-    memdebug_total -= size;
+    size_t size = block->d.size;
+    int i;
+    for (i = 0; i < MARKSIZE; i++)  /* check marks after block */
+      lua_assert(*(cast(char *, block + 1) + size + i) == MARK);
+    mc->objcount[block->d.type]--;
+    fillmem(block, sizeof(Header) + size + MARKSIZE);  /* erase block */
+    free(block);  /* actually free block */
+    mc->numblocks--;  /* update counts */
+    mc->total -= size;
   }
 }
 
 
-void *debug_realloc (void *block, size_t oldsize, size_t size) {
-  lua_assert(oldsize == 0 || checkblocksize(block, oldsize));
-  /* ISO does not specify what realloc(NULL, 0) does */
-  lua_assert(block != NULL || size > 0);
+void *debug_realloc (void *ud, void *b, size_t oldsize, size_t size) {
+  Memcontrol *mc = cast(Memcontrol *, ud);
+  Header *block = cast(Header *, b);
+  int type;
+  if (mc->memlimit == 0) {  /* first time? */
+    char *limit = getenv("MEMLIMIT");  /* initialize memory limit */
+    mc->memlimit = limit ? strtoul(limit, NULL, 10) : ULONG_MAX;
+  }
+  if (block == NULL) {
+    type = (oldsize < LUA_NUMTAGS) ? oldsize : 0;
+    oldsize = 0;
+  }
+  else {
+    block--;  /* go to real header */
+    type = block->d.type;
+    lua_assert(oldsize == block->d.size);
+  }
   if (size == 0) {
-    freeblock(block, oldsize);
+    freeblock(mc, block);
     return NULL;
   }
-  else if (size > oldsize && memdebug_total+size-oldsize > memdebug_memlimit)
-    return NULL;  /* to test memory allocation errors */
+  else if (size > oldsize && mc->total+size-oldsize > mc->memlimit)
+    return NULL;  /* fake a memory allocation error */
   else {
-    void *newblock;
+    Header *newblock;
     int i;
-    size_t realsize = HEADER+size+MARKSIZE;
     size_t commonsize = (oldsize < size) ? oldsize : size;
-    if (realsize < size) return NULL;  /* overflow! */
-    newblock = malloc(realsize);  /* alloc a new block */
-    if (newblock == NULL) return NULL;
+    size_t realsize = sizeof(Header) + size + MARKSIZE;
+    if (realsize < size) return NULL;  /* arithmetic overflow! */
+    newblock = cast(Header *, malloc(realsize));  /* alloc a new block */
+    if (newblock == NULL) return NULL;  /* really out of memory? */
     if (block) {
-      memcpy(cast(char *, newblock)+HEADER, block, commonsize);
-      freeblock(block, oldsize);  /* erase (and check) old copy */
+      memcpy(newblock + 1, block + 1, commonsize);  /* copy old contents */
+      freeblock(mc, block);  /* erase (and check) old copy */
     }
-    /* initialize new part of the block with something `weird' */
-    fillmem(cast(char *, newblock)+HEADER+commonsize, size-commonsize);
-    memdebug_total += size;
-    if (memdebug_total > memdebug_maxmem)
-      memdebug_maxmem = memdebug_total;
-    memdebug_numblocks++;
-    setsize(newblock, size);
-    for (i=0;i<MARKSIZE;i++)
-      *(cast(char *, newblock)+HEADER+size+i) = cast(char, MARK+i);
-    return cast(char *, newblock)+HEADER;
+    /* initialize new part of the block with something weird */
+    fillmem(cast(char *, newblock + 1) + commonsize, size - commonsize);
+    /* initialize marks after block */
+    for (i = 0; i < MARKSIZE; i++)
+      *(cast(char *, newblock + 1) + size + i) = MARK;
+    newblock->d.size = size;
+    newblock->d.type = type;
+    mc->total += size;
+    if (mc->total > mc->maxmem)
+      mc->maxmem = mc->total;
+    mc->numblocks++;
+    mc->objcount[type]++;
+    return newblock + 1;
   }
 }
 
@@ -155,20 +181,293 @@
 
 /*
 ** {======================================================
+** Functions to check memory consistency
+** =======================================================
+*/
+
+
+static int testobjref1 (global_State *g, GCObject *f, GCObject *t) {
+  if (isdead(g,t)) return 0;
+  if (!issweepphase(g))
+    return !(isblack(f) && iswhite(t));
+  else return 1;
+}
+
+
+static void printobj (global_State *g, GCObject *o) {
+  printf("||%s(%p)-%c(%02X)||",
+           ttypename(novariant(o->tt)), (void *)o,
+           isdead(g,o)?'d':isblack(o)?'b':iswhite(o)?'w':'g', o->marked);
+}
+
+
+static int testobjref (global_State *g, GCObject *f, GCObject *t) {
+  int r1 = testobjref1(g, f, t);
+  if (!r1) {
+    printf("%d(%02X) - ", g->gcstate, g->currentwhite);
+    printobj(g, f);
+    printf("  ->  ");
+    printobj(g, t);
+    printf("\n");
+  }
+  return r1;
+}
+
+#define checkobjref(g,f,t)  \
+	{ if (t) lua_longassert(testobjref(g,f,obj2gco(t))); }
+
+
+static void checkvalref (global_State *g, GCObject *f, const TValue *t) {
+  lua_assert(!iscollectable(t) ||
+    (righttt(t) && testobjref(g, f, gcvalue(t))));
+}
+
+
+static void checktable (global_State *g, Table *h) {
+  unsigned int i;
+  Node *n, *limit = gnode(h, sizenode(h));
+  GCObject *hgc = obj2gco(h);
+  checkobjref(g, hgc, h->metatable);
+  for (i = 0; i < h->sizearray; i++)
+    checkvalref(g, hgc, &h->array[i]);
+  for (n = gnode(h, 0); n < limit; n++) {
+    if (!ttisnil(gval(n))) {
+      lua_assert(!ttisnil(gkey(n)));
+      checkvalref(g, hgc, gkey(n));
+      checkvalref(g, hgc, gval(n));
+    }
+  }
+}
+
+
+/*
+** All marks are conditional because a GC may happen while the
+** prototype is still being created
+*/
+static void checkproto (global_State *g, Proto *f) {
+  int i;
+  GCObject *fgc = obj2gco(f);
+  checkobjref(g, fgc, f->cache);
+  checkobjref(g, fgc, f->source);
+  for (i=0; i<f->sizek; i++) {
+    if (ttisstring(f->k + i))
+      checkobjref(g, fgc, tsvalue(f->k + i));
+  }
+  for (i=0; i<f->sizeupvalues; i++)
+    checkobjref(g, fgc, f->upvalues[i].name);
+  for (i=0; i<f->sizep; i++)
+    checkobjref(g, fgc, f->p[i]);
+  for (i=0; i<f->sizelocvars; i++)
+    checkobjref(g, fgc, f->locvars[i].varname);
+}
+
+
+
+static void checkCclosure (global_State *g, CClosure *cl) {
+  GCObject *clgc = obj2gco(cl);
+  int i;
+  for (i = 0; i < cl->nupvalues; i++)
+    checkvalref(g, clgc, &cl->upvalue[i]);
+}
+
+
+static void checkLclosure (global_State *g, LClosure *cl) {
+  GCObject *clgc = obj2gco(cl);
+  int i;
+  checkobjref(g, clgc, cl->p);
+  for (i=0; i<cl->nupvalues; i++) {
+    UpVal *uv = cl->upvals[i];
+    if (uv) {
+      if (!upisopen(uv))  /* only closed upvalues matter to invariant */
+        checkvalref(g, clgc, uv->v);
+      lua_assert(uv->refcount > 0);
+    }
+  }
+}
+
+
+static int lua_checkpc (lua_State *L, CallInfo *ci) {
+  if (!isLua(ci)) return 1;
+  else {
+    Proto *p;
+    if (L->status != LUA_YIELD || ci != L->ci)
+      p = ci_func(ci)->p;
+    else  /* real 'func' was saved in 'extra' field */
+      p = clLvalue(restorestack(L, ci->extra))->p;
+    return p->code <= ci->u.l.savedpc &&
+           ci->u.l.savedpc <= p->code + p->sizecode;
+  }
+}
+
+
+static void checkstack (global_State *g, lua_State *L1) {
+  StkId o;
+  CallInfo *ci;
+  UpVal *uv;
+  lua_assert(!isdead(g, L1));
+  for (uv = L1->openupval; uv != NULL; uv = uv->u.open.next)
+    lua_assert(upisopen(uv));  /* must be open */
+  for (ci = L1->ci; ci != NULL; ci = ci->previous) {
+    lua_assert(ci->top <= L1->stack_last);
+    lua_assert(lua_checkpc(L1, ci));
+  }
+  if (L1->stack) {  /* complete thread? */
+    for (o = L1->stack; o < L1->stack_last + EXTRA_STACK; o++)
+      checkliveness(g, o);  /* entire stack must have valid values */
+  }
+  else lua_assert(L1->stacksize == 0);
+}
+
+
+static void checkobject (global_State *g, GCObject *o, int maybedead) {
+  if (isdead(g, o))
+    lua_assert(maybedead);
+  else {
+    lua_assert(g->gcstate != GCSpause || iswhite(o));
+    switch (o->tt) {
+      case LUA_TUSERDATA: {
+        TValue uservalue;
+        Table *mt = gco2u(o)->metatable;
+        checkobjref(g, o, mt);
+        getuservalue(g->mainthread, gco2u(o), &uservalue);
+        checkvalref(g, o, &uservalue);
+        break;
+      }
+      case LUA_TTABLE: {
+        checktable(g, gco2t(o));
+        break;
+      }
+      case LUA_TTHREAD: {
+        checkstack(g, gco2th(o));
+        break;
+      }
+      case LUA_TLCL: {
+        checkLclosure(g, gco2lcl(o));
+        break;
+      }
+      case LUA_TCCL: {
+        checkCclosure(g, gco2ccl(o));
+        break;
+      }
+      case LUA_TPROTO: {
+        checkproto(g, gco2p(o));
+        break;
+      }
+      case LUA_TSHRSTR:
+      case LUA_TLNGSTR: {
+        lua_assert(!isgray(o));  /* strings are never gray */
+        break;
+      }
+      default: lua_assert(0);
+    }
+  }
+}
+
+
+#define TESTGRAYBIT		7
+
+static void checkgraylist (global_State *g, GCObject *o) {
+  ((void)g);  /* better to keep it available if we need to print an object */
+  while (o) {
+    lua_assert(isgray(o));
+    lua_assert(!testbit(o->marked, TESTGRAYBIT));
+    l_setbit(o->marked, TESTGRAYBIT);
+    switch (o->tt) {
+      case LUA_TTABLE: o = gco2t(o)->gclist; break;
+      case LUA_TLCL: o = gco2lcl(o)->gclist; break;
+      case LUA_TCCL: o = gco2ccl(o)->gclist; break;
+      case LUA_TTHREAD: o = gco2th(o)->gclist; break;
+      case LUA_TPROTO: o = gco2p(o)->gclist; break;
+      default: lua_assert(0);  /* other objects cannot be gray */
+    }
+  }
+}
+
+
+/*
+** mark all objects in gray lists with the TESTGRAYBIT, so that
+** 'checkmemory' can check that all gray objects are in a gray list
+*/
+static void markgrays (global_State *g) {
+  if (!keepinvariant(g)) return;
+  checkgraylist(g, g->gray);
+  checkgraylist(g, g->grayagain);
+  checkgraylist(g, g->weak);
+  checkgraylist(g, g->ephemeron);
+  checkgraylist(g, g->allweak);
+}
+
+
+static void checkgray (global_State *g, GCObject *o) {
+  for (; o != NULL; o = o->next) {
+    if (isgray(o)) {
+      lua_assert(!keepinvariant(g) || testbit(o->marked, TESTGRAYBIT));
+      resetbit(o->marked, TESTGRAYBIT);
+    }
+    lua_assert(!testbit(o->marked, TESTGRAYBIT));
+  }
+}
+
+
+int lua_checkmemory (lua_State *L) {
+  global_State *g = G(L);
+  GCObject *o;
+  int maybedead;
+  if (keepinvariant(g)) {
+    lua_assert(!iswhite(g->mainthread));
+    lua_assert(!iswhite(gcvalue(&g->l_registry)));
+  }
+  lua_assert(!isdead(g, gcvalue(&g->l_registry)));
+  checkstack(g, g->mainthread);
+  resetbit(g->mainthread->marked, TESTGRAYBIT);
+  lua_assert(g->sweepgc == NULL || issweepphase(g));
+  markgrays(g);
+  /* check 'fixedgc' list */
+  for (o = g->fixedgc; o != NULL; o = o->next) {
+    lua_assert(o->tt == LUA_TSHRSTR && isgray(o));
+  }
+  /* check 'allgc' list */
+  checkgray(g, g->allgc);
+  maybedead = (GCSatomic < g->gcstate && g->gcstate <= GCSswpallgc);
+  for (o = g->allgc; o != NULL; o = o->next) {
+    checkobject(g, o, maybedead);
+    lua_assert(!tofinalize(o));
+  }
+  /* check 'finobj' list */
+  checkgray(g, g->finobj);
+  for (o = g->finobj; o != NULL; o = o->next) {
+    checkobject(g, o, 0);
+    lua_assert(tofinalize(o));
+    lua_assert(o->tt == LUA_TUSERDATA || o->tt == LUA_TTABLE);
+  }
+  /* check 'tobefnz' list */
+  checkgray(g, g->tobefnz);
+  for (o = g->tobefnz; o != NULL; o = o->next) {
+    checkobject(g, o, 0);
+    lua_assert(tofinalize(o));
+    lua_assert(o->tt == LUA_TUSERDATA || o->tt == LUA_TTABLE);
+  }
+  return 0;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
 ** Disassembler
 ** =======================================================
 */
 
 
-static char *buildop (Proto *p, int pc, char *buff)
-	/*@*/
-{
+static char *buildop (Proto *p, int pc, char *buff) {
   Instruction i = p->code[pc];
   OpCode o = GET_OPCODE(i);
   const char *name = luaP_opnames[o];
-  int line = getline(p, pc);
+  int line = getfuncline(p, pc);
   sprintf(buff, "(%4d) %4d - ", line, pc);
-  switch (getOpMode(o)) {  
+  switch (getOpMode(o)) {
     case iABC:
       sprintf(buff+strlen(buff), "%-12s%4d %4d %4d", name,
               GETARG_A(i), GETARG_B(i), GETARG_C(i));
@@ -179,6 +478,9 @@
     case iAsBx:
       sprintf(buff+strlen(buff), "%-12s%4d %4d", name, GETARG_A(i), GETARG_sBx(i));
       break;
+    case iAx:
+      sprintf(buff+strlen(buff), "%-12s%4d", name, GETARG_Ax(i));
+      break;
   }
   return buff;
 }
@@ -193,23 +495,27 @@
   }
   printf("-------\n");
 }
+
+
+void luaI_printinst (Proto *pt, int pc) {
+  char buff[100];
+  printf("%s\n", buildop(pt, pc, buff));
+}
 #endif
 
 
-static int listcode (lua_State *L)
-	/*@*/
-{
+static int listcode (lua_State *L) {
   int pc;
   Proto *p;
   luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
                  1, "Lua function expected");
-  p = clvalue(func_at(L, 1))->l.p;
+  p = getproto(obj_at(L, 1));
   lua_newtable(L);
   setnameval(L, "maxstack", p->maxstacksize);
   setnameval(L, "numparams", p->numparams);
   for (pc=0; pc<p->sizecode; pc++) {
     char buff[100];
-    lua_pushintegral(L, pc+1);
+    lua_pushinteger(L, pc+1);
     lua_pushstring(L, buildop(p, pc, buff));
     lua_settable(L, -3);
   }
@@ -217,34 +523,29 @@
 }
 
 
-static int listk (lua_State *L)
-	/*@*/
-{
+static int listk (lua_State *L) {
   Proto *p;
   int i;
   luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
                  1, "Lua function expected");
-  p = clvalue(func_at(L, 1))->l.p;
-  lua_newtable(L);
+  p = getproto(obj_at(L, 1));
+  lua_createtable(L, p->sizek, 0);
   for (i=0; i<p->sizek; i++) {
-    lua_pushintegral(L, i+1);
-    luaA_pushobject(L, p->k+i);
-    lua_settable(L, -3);
+    pushobject(L, p->k+i);
+    lua_rawseti(L, -2, i+1);
   }
   return 1;
 }
 
 
-static int listlocals (lua_State *L)
-	/*@*/
-{
+static int listlocals (lua_State *L) {
   Proto *p;
-  int pc = luaL_checkint(L, 2) - 1;
+  int pc = cast_int(luaL_checkinteger(L, 2)) - 1;
   int i = 0;
   const char *name;
   luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
                  1, "Lua function expected");
-  p = clvalue(func_at(L, 1))->l.p;
+  p = getproto(obj_at(L, 1));
   while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)
     lua_pushstring(L, name);
   return i-1;
@@ -254,96 +555,157 @@
 
 
 
+static void printstack (lua_State *L) {
+  int i;
+  int n = lua_gettop(L);
+  for (i = 1; i <= n; i++) {
+    printf("%3d: %s\n", i, luaL_tolstring(L, i, NULL));
+    lua_pop(L, 1);
+  }
+  printf("\n");
+}
 
-static int get_limits (lua_State *L)
-	/*@*/
-{
-  lua_newtable(L);
-  setnameval(L, "BITS_INT", BITS_INT);
+
+static int get_limits (lua_State *L) {
+  lua_createtable(L, 0, 5);
+  setnameval(L, "BITS_INT", LUAI_BITSINT);
+  setnameval(L, "MAXARG_Ax", MAXARG_Ax);
+  setnameval(L, "MAXARG_Bx", MAXARG_Bx);
+  setnameval(L, "MAXARG_sBx", MAXARG_sBx);
+  setnameval(L, "BITS_INT", LUAI_BITSINT);
   setnameval(L, "LFPF", LFIELDS_PER_FLUSH);
-  setnameval(L, "MAXVARS", MAXVARS);
-  setnameval(L, "MAXPARAMS", MAXPARAMS);
-  setnameval(L, "MAXSTACK", MAXSTACK);
-  setnameval(L, "MAXUPVALUES", MAXUPVALUES);
+  setnameval(L, "NUM_OPCODES", NUM_OPCODES);
   return 1;
 }
 
 
-static int mem_query (lua_State *L)
-	/*@*/
-{
+static int mem_query (lua_State *L) {
   if (lua_isnone(L, 1)) {
-    lua_pushintegral(L, memdebug_total);
-    lua_pushintegral(L, memdebug_numblocks);
-    lua_pushintegral(L, memdebug_maxmem);
+    lua_pushinteger(L, l_memcontrol.total);
+    lua_pushinteger(L, l_memcontrol.numblocks);
+    lua_pushinteger(L, l_memcontrol.maxmem);
     return 3;
   }
+  else if (lua_isnumber(L, 1)) {
+    unsigned long limit = cast(unsigned long, luaL_checkinteger(L, 1));
+    if (limit == 0) limit = ULONG_MAX;
+    l_memcontrol.memlimit = limit;
+    return 0;
+  }
   else {
-    memdebug_memlimit = luaL_checkint(L, 1);
+    const char *t = luaL_checkstring(L, 1);
+    int i;
+    for (i = LUA_NUMTAGS - 1; i >= 0; i--) {
+      if (strcmp(t, ttypename(i)) == 0) {
+        lua_pushinteger(L, l_memcontrol.objcount[i]);
+        return 1;
+      }
+    }
+    return luaL_error(L, "unkown type '%s'", t);
+  }
+}
+
+
+static int settrick (lua_State *L) {
+  if (ttisnil(obj_at(L, 1)))
+    l_Trick = NULL;
+  else
+    l_Trick = gcvalue(obj_at(L, 1));
+  return 0;
+}
+
+
+static int gc_color (lua_State *L) {
+  TValue *o;
+  luaL_checkany(L, 1);
+  o = obj_at(L, 1);
+  if (!iscollectable(o))
+    lua_pushstring(L, "no collectable");
+  else {
+    GCObject *obj = gcvalue(o);
+    lua_pushstring(L, isdead(G(L), obj) ? "dead" :
+                      iswhite(obj) ? "white" :
+                      isblack(obj) ? "black" : "grey");
+  }
+  return 1;
+}
+
+
+static int gc_state (lua_State *L) {
+  static const char *statenames[] = {"propagate", "atomic", "sweepallgc",
+      "sweepfinobj", "sweeptobefnz", "sweepend", "pause", ""};
+  static const int states[] = {GCSpropagate, GCSatomic, GCSswpallgc,
+      GCSswpfinobj, GCSswptobefnz, GCSswpend, GCSpause, -1};
+  int option = states[luaL_checkoption(L, 1, "", statenames)];
+  if (option == -1) {
+    lua_pushstring(L, statenames[G(L)->gcstate]);
+    return 1;
+  }
+  else {
+    global_State *g = G(L);
+    lua_lock(L);
+    if (option < g->gcstate) {  /* must cross 'pause'? */
+      luaC_runtilstate(L, bitmask(GCSpause));  /* run until pause */
+    }
+    luaC_runtilstate(L, bitmask(option));
+    lua_assert(G(L)->gcstate == option);
+    lua_unlock(L);
     return 0;
   }
 }
 
 
-static int hash_query (lua_State *L)
-	/*@*/
-{
+static int hash_query (lua_State *L) {
   if (lua_isnone(L, 2)) {
     luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, "string expected");
-    lua_pushintegral(L, tsvalue(func_at(L, 1))->tsv.hash);
+    lua_pushinteger(L, tsvalue(obj_at(L, 1))->hash);
   }
   else {
-    TObject *o = func_at(L, 1);
+    TValue *o = obj_at(L, 1);
     Table *t;
     luaL_checktype(L, 2, LUA_TTABLE);
-    t = hvalue(func_at(L, 2));
-    lua_pushintegral(L, luaH_mainposition(t, o) - t->node);
+    t = hvalue(obj_at(L, 2));
+    lua_pushinteger(L, luaH_mainposition(t, o) - t->node);
   }
   return 1;
 }
 
 
-static int stacklevel (lua_State *L)
-	/*@*/
-{
+static int stacklevel (lua_State *L) {
   unsigned long a = 0;
-  lua_pushintegral(L, (int)(L->top - L->stack));
-  lua_pushintegral(L, (int)(L->stack_last - L->stack));
-  lua_pushintegral(L, (int)(L->ci - L->base_ci));
-  lua_pushintegral(L, (int)(L->end_ci - L->base_ci));
-  lua_pushintegral(L, (unsigned long)&a);
-  return 5;
+  lua_pushinteger(L, (L->top - L->stack));
+  lua_pushinteger(L, (L->stack_last - L->stack));
+  lua_pushinteger(L, (unsigned long)&a);
+  return 3;
 }
 
 
-static int table_query (lua_State *L)
-	/*@*/
-{
+static int table_query (lua_State *L) {
   const Table *t;
-  int i = luaL_optint(L, 2, -1);
+  int i = cast_int(luaL_optinteger(L, 2, -1));
   luaL_checktype(L, 1, LUA_TTABLE);
-  t = hvalue(func_at(L, 1));
+  t = hvalue(obj_at(L, 1));
   if (i == -1) {
-    lua_pushintegral(L, t->sizearray);
-    lua_pushintegral(L, sizenode(t));
-    lua_pushintegral(L, t->firstfree - t->node);
-  }
-  else if (i < t->sizearray) {
-    lua_pushintegral(L, i);
-    luaA_pushobject(L, &t->array[i]);
-    lua_pushnil(L); 
+    lua_pushinteger(L, t->sizearray);
+    lua_pushinteger(L, luaH_isdummy(t->node) ? 0 : sizenode(t));
+    lua_pushinteger(L, t->lastfree - t->node);
+  }
+  else if ((unsigned int)i < t->sizearray) {
+    lua_pushinteger(L, i);
+    pushobject(L, &t->array[i]);
+    lua_pushnil(L);
   }
   else if ((i -= t->sizearray) < sizenode(t)) {
     if (!ttisnil(gval(gnode(t, i))) ||
         ttisnil(gkey(gnode(t, i))) ||
         ttisnumber(gkey(gnode(t, i)))) {
-      luaA_pushobject(L, gkey(gnode(t, i)));
+      pushobject(L, gkey(gnode(t, i)));
     }
     else
-      lua_pushstring(L, "<undef>");
-    luaA_pushobject(L, gval(gnode(t, i)));
-    if (t->node[i].next)
-      lua_pushintegral(L, t->node[i].next - t->node);
+      lua_pushliteral(L, "<undef>");
+    pushobject(L, gval(gnode(t, i)));
+    if (gnext(&t->node[i]) != 0)
+      lua_pushinteger(L, gnext(&t->node[i]));
     else
       lua_pushnil(L);
   }
@@ -351,81 +713,54 @@
 }
 
 
-static int string_query (lua_State *L)
-	/*@*/
-{
+static int string_query (lua_State *L) {
   stringtable *tb = &G(L)->strt;
-  int s = luaL_optint(L, 2, 0) - 1;
-  if (s==-1) {
-    lua_pushintegral(L ,tb->nuse);
-    lua_pushintegral(L ,tb->size);
+  int s = cast_int(luaL_optinteger(L, 1, 0)) - 1;
+  if (s == -1) {
+    lua_pushinteger(L ,tb->size);
+    lua_pushinteger(L ,tb->nuse);
     return 2;
   }
   else if (s < tb->size) {
-    GCObject *ts;
+    TString *ts;
     int n = 0;
-    for (ts = tb->hash[s]; ts; ts = ts->gch.next) {
-      setsvalue2s(L->top, gcotots(ts));
-      incr_top(L);
+    for (ts = tb->hash[s]; ts != NULL; ts = ts->hnext) {
+      setsvalue2s(L, L->top, ts);
+      api_incr_top(L);
       n++;
     }
     return n;
   }
-  return 0;
+  else return 0;
 }
 
 
-static int tref (lua_State *L)
-	/*@*/
-{
+static int tref (lua_State *L) {
   int level = lua_gettop(L);
-  int lock = luaL_optint(L, 2, 1);
   luaL_checkany(L, 1);
   lua_pushvalue(L, 1);
-  lua_pushintegral(L, lua_ref(L, lock));
-  assert(lua_gettop(L) == level+1);  /* +1 for result */
+  lua_pushinteger(L, luaL_ref(L, LUA_REGISTRYINDEX));
+  lua_assert(lua_gettop(L) == level+1);  /* +1 for result */
   return 1;
 }
 
-static int getref (lua_State *L)
-	/*@*/
-{
+static int getref (lua_State *L) {
   int level = lua_gettop(L);
-  lua_getref(L, luaL_checkint(L, 1));
-  assert(lua_gettop(L) == level+1);
+  lua_rawgeti(L, LUA_REGISTRYINDEX, luaL_checkinteger(L, 1));
+  lua_assert(lua_gettop(L) == level+1);
   return 1;
 }
 
-static int unref (lua_State *L)
-	/*@*/
-{
+static int unref (lua_State *L) {
   int level = lua_gettop(L);
-  lua_unref(L, luaL_checkint(L, 1));
-  assert(lua_gettop(L) == level);
+  luaL_unref(L, LUA_REGISTRYINDEX, cast_int(luaL_checkinteger(L, 1)));
+  lua_assert(lua_gettop(L) == level);
   return 0;
 }
 
-static int metatable (lua_State *L)
-	/*@*/
-{
-  luaL_checkany(L, 1);
-  if (lua_isnone(L, 2)) {
-    if (lua_getmetatable(L, 1) == 0)
-      lua_pushnil(L);
-  }
-  else {
-    lua_settop(L, 2);
-    luaL_checktype(L, 2, LUA_TTABLE);
-    lua_setmetatable(L, 1);
-  }
-  return 1;
-}
 
-
-static int upvalue (lua_State *L)
-	/*@*/
-{
-  int n = luaL_checkint(L, 2);
+static int upvalue (lua_State *L) {
+  int n = cast_int(luaL_checkinteger(L, 2));
   luaL_checktype(L, 1, LUA_TFUNCTION);
   if (lua_isnone(L, 3)) {
     const char *name = lua_getupvalue(L, 1, n);
@@ -441,69 +776,65 @@
 }
 
 
-static int newuserdata (lua_State *L)
-	/*@*/
-{
-  size_t size = luaL_checkint(L, 1);
+static int newuserdata (lua_State *L) {
+  size_t size = cast(size_t, luaL_checkinteger(L, 1));
   char *p = cast(char *, lua_newuserdata(L, size));
   while (size--) *p++ = '\0';
   return 1;
 }
 
 
-static int pushuserdata (lua_State *L)
-	/*@*/
-{
-  lua_pushlightuserdata(L, cast(void *, luaL_checkint(L, 1)));
+static int pushuserdata (lua_State *L) {
+  lua_Integer u = luaL_checkinteger(L, 1);
+  lua_pushlightuserdata(L, cast(void *, cast(size_t, u)));
   return 1;
 }
 
 
-static int udataval (lua_State *L)
-	/*@*/
-{
-  lua_pushintegral(L, cast(int, lua_touserdata(L, 1)));
+static int udataval (lua_State *L) {
+  lua_pushinteger(L, cast(long, lua_touserdata(L, 1)));
   return 1;
 }
 
 
-static int doonnewstack (lua_State *L)
-	/*@*/
-{
+static int doonnewstack (lua_State *L) {
   lua_State *L1 = lua_newthread(L);
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
   int status = luaL_loadbuffer(L1, s, l, s);
-  if (status == 0)
+  if (status == LUA_OK)
     status = lua_pcall(L1, 0, 0, 0);
-  lua_pushintegral(L, status);
+  lua_pushinteger(L, status);
   return 1;
 }
 
 
-static int s2d (lua_State *L)
-	/*@*/
-{
+static int s2d (lua_State *L) {
   lua_pushnumber(L, *cast(const double *, luaL_checkstring(L, 1)));
   return 1;
 }
 
-static int d2s (lua_State *L)
-	/*@*/
-{
+
+static int d2s (lua_State *L) {
   double d = luaL_checknumber(L, 1);
   lua_pushlstring(L, cast(char *, &d), sizeof(d));
   return 1;
 }
 
 
-static int newstate (lua_State *L)
-	/*@*/
-{
-  lua_State *L1 = lua_open();
+static int num2int (lua_State *L) {
+  lua_pushinteger(L, lua_tointeger(L, 1));
+  return 1;
+}
+
+
+static int newstate (lua_State *L) {
+  void *ud;
+  lua_Alloc f = lua_getallocf(L, &ud);
+  lua_State *L1 = lua_newstate(f, ud);
   if (L1) {
-    lua_userstateopen(L1);  /* init lock */
-    lua_pushintegral(L, (unsigned long)L1);
+    lua_atpanic(L1, tpanic);
+    lua_pushlightuserdata(L, L1);
   }
   else
     lua_pushnil(L);
@@ -511,49 +842,60 @@
 }
 
 
-static int loadlib (lua_State *L)
-	/*@*/
-{
-  static const luaL_reg libs[] = {
-    {"mathlibopen", luaopen_math},
-    {"strlibopen", luaopen_string},
-    {"iolibopen", luaopen_io},
-    {"tablibopen", luaopen_table},
-    {"dblibopen", luaopen_debug},
-    {"baselibopen", luaopen_base},
+static lua_State *getstate (lua_State *L) {
+  lua_State *L1 = cast(lua_State *, lua_touserdata(L, 1));
+  luaL_argcheck(L, L1 != NULL, 1, "state expected");
+  return L1;
+}
+
+
+static int loadlib (lua_State *L) {
+  static const luaL_Reg libs[] = {
+    {"_G", luaopen_base},
+    {"coroutine", luaopen_coroutine},
+    {"debug", luaopen_debug},
+    {"io", luaopen_io},
+    {"os", luaopen_os},
+    {"math", luaopen_math},
+    {"string", luaopen_string},
+    {"table", luaopen_table},
     {NULL, NULL}
   };
-  lua_State *L1 = cast(lua_State *,
-                       cast(unsigned long, luaL_checknumber(L, 1)));
-  lua_pushvalue(L1, LUA_GLOBALSINDEX);
-  luaL_openlib(L1, NULL, libs, 0);
+  lua_State *L1 = getstate(L);
+  int i;
+  luaL_requiref(L1, "package", luaopen_package, 0);
+  lua_assert(lua_type(L1, -1) == LUA_TTABLE);
+  /* 'requiref' should not reload module already loaded... */
+  luaL_requiref(L1, "package", NULL, 1);  /* seg. fault if it reloads */
+  /* ...but should return the same module */
+  lua_assert(lua_compare(L1, -1, -2, LUA_OPEQ));
+  luaL_getsubtable(L1, LUA_REGISTRYINDEX, "_PRELOAD");
+  for (i = 0; libs[i].name; i++) {
+    lua_pushcfunction(L1, libs[i].func);
+    lua_setfield(L1, -2, libs[i].name);
+  }
   return 0;
 }
 
-static int closestate (lua_State *L)
-	/*@*/
-{
-  lua_State *L1 = cast(lua_State *, cast(unsigned long, luaL_checknumber(L, 1)));
+static int closestate (lua_State *L) {
+  lua_State *L1 = getstate(L);
   lua_close(L1);
-  lua_unlock(L);  /* close cannot unlock that */
   return 0;
 }
 
-static int doremote (lua_State *L)
-	/*@*/
-{
-  lua_State *L1 = cast(lua_State *,cast(unsigned long,luaL_checknumber(L, 1)));
+static int doremote (lua_State *L) {
+  lua_State *L1 = getstate(L);
   size_t lcode;
   const char *code = luaL_checklstring(L, 2, &lcode);
   int status;
   lua_settop(L1, 0);
   status = luaL_loadbuffer(L1, code, lcode, code);
-  if (status == 0)
+  if (status == LUA_OK)
     status = lua_pcall(L1, 0, LUA_MULTRET, 0);
-  if (status != 0) {
+  if (status != LUA_OK) {
     lua_pushnil(L);
-    lua_pushintegral(L, status);
     lua_pushstring(L, lua_tostring(L1, -1));
+    lua_pushinteger(L, status);
     return 3;
   }
   else {
@@ -566,60 +908,89 @@
 }
 
 
-static int log2_aux (lua_State *L)
-	/*@*/
-{
-  lua_pushintegral(L, luaO_log2(luaL_checkint(L, 1)));
-  return 1;
-}
-
-static int int2fb_aux (lua_State *L)
-	/*@*/
-{
-  int b = luaO_int2fb(luaL_checkint(L, 1));
-  lua_pushintegral(L, b);
-  lua_pushintegral(L, fb2int(b));
+static int int2fb_aux (lua_State *L) {
+  int b = luaO_int2fb((unsigned int)luaL_checkinteger(L, 1));
+  lua_pushinteger(L, b);
+  lua_pushinteger(L, luaO_fb2int(b));
   return 2;
 }
 
 
-static int test_do (lua_State *L)
-	/*@*/
-{
-  const char *p = luaL_checkstring(L, 1);
-  if (*p == '@')
-    lua_dofile(L, p+1);
-  else
-    lua_dostring(L, p);
-  return lua_gettop(L);
+struct Aux { jmp_buf jb; const char *paniccode; lua_State *L; };
+
+/*
+** does a long-jump back to "main program".
+*/
+static int panicback (lua_State *L) {
+  struct Aux *b;
+  lua_checkstack(L, 1);  /* open space for 'Aux' struct */
+  lua_getfield(L, LUA_REGISTRYINDEX, "_jmpbuf");  /* get 'Aux' struct */
+  b = (struct Aux *)lua_touserdata(L, -1);
+  lua_pop(L, 1);  /* remove 'Aux' struct */
+  runC(b->L, L, b->paniccode);  /* run optional panic code */
+  longjmp(b->jb, 1);
+  return 1;  /* to avoid warnings */
+}
+
+static int checkpanic (lua_State *L) {
+  struct Aux b;
+  void *ud;
+  lua_State *L1;
+  const char *code = luaL_checkstring(L, 1);
+  lua_Alloc f = lua_getallocf(L, &ud);
+  b.paniccode = luaL_optstring(L, 2, "");
+  b.L = L;
+  L1 = lua_newstate(f, ud);  /* create new state */
+  if (L1 == NULL) {  /* error? */
+    lua_pushnil(L);
+    return 1;
+  }
+  lua_atpanic(L1, panicback);  /* set its panic function */
+  lua_pushlightuserdata(L1, &b);
+  lua_setfield(L1, LUA_REGISTRYINDEX, "_jmpbuf");  /* store 'Aux' struct */
+  if (setjmp(b.jb) == 0) {  /* set jump buffer */
+    runC(L, L1, code);  /* run code unprotected */
+    lua_pushliteral(L, "no errors");
+  }
+  else {  /* error handling */
+    /* move error message to original state */
+    lua_pushstring(L, lua_tostring(L1, -1));
+  }
+  lua_close(L1);
+  return 1;
 }
 
 
 
 /*
-** {======================================================
+** {====================================================================
 ** function to test the API with C. It interprets a kind of assembler
 ** language with calls to the API, so the test can be driven by Lua code
-** =======================================================
+** =====================================================================
 */
 
+
+static void sethookaux (lua_State *L, int mask, int count, const char *code);
+
 static const char *const delimits = " \t\n,;";
 
-static void skip (const char **pc)
-	/*@*/
-{
-  while (**pc != '\0' && strchr(delimits, **pc)) (*pc)++;
+static void skip (const char **pc) {
+  for (;;) {
+    if (**pc != '\0' && strchr(delimits, **pc)) (*pc)++;
+    else if (**pc == '#') {
+      while (**pc != '\n' && **pc != '\0') (*pc)++;
+    }
+    else break;
+  }
 }
 
-static int getnum_aux (lua_State *L, const char **pc)
-	/*@*/
-{
+static int getnum_aux (lua_State *L, lua_State *L1, const char **pc) {
   int res = 0;
   int sig = 1;
   skip(pc);
   if (**pc == '.') {
-    res = cast(int, lua_tonumber(L, -1));
-    lua_pop(L, 1);
+    res = cast_int(lua_tointeger(L1, -1));
+    lua_pop(L1, 1);
     (*pc)++;
     return res;
   }
@@ -627,221 +998,491 @@
     sig = -1;
     (*pc)++;
   }
-  while (isdigit(cast(int, **pc))) res = res*10 + (*(*pc)++) - '0';
+  if (!lisdigit(cast_uchar(**pc)))
+    luaL_error(L, "number expected (%s)", *pc);
+  while (lisdigit(cast_uchar(**pc))) res = res*10 + (*(*pc)++) - '0';
   return sig*res;
 }
-  
-static const char *getname_aux (char *buff, const char **pc)
-	/*@*/
-{
+
+static const char *getstring_aux (lua_State *L, char *buff, const char **pc) {
   int i = 0;
   skip(pc);
-  while (**pc != '\0' && !strchr(delimits, **pc))
-    buff[i++] = *(*pc)++;
+  if (**pc == '"' || **pc == '\'') {  /* quoted string? */
+    int quote = *(*pc)++;
+    while (**pc != quote) {
+      if (**pc == '\0') luaL_error(L, "unfinished string in C script");
+      buff[i++] = *(*pc)++;
+    }
+    (*pc)++;
+  }
+  else {
+    while (**pc != '\0' && !strchr(delimits, **pc))
+      buff[i++] = *(*pc)++;
+  }
   buff[i] = '\0';
   return buff;
 }
 
 
+static int getindex_aux (lua_State *L, lua_State *L1, const char **pc) {
+  skip(pc);
+  switch (*(*pc)++) {
+    case 'R': return LUA_REGISTRYINDEX;
+    case 'G': return luaL_error(L, "deprecated index 'G'");
+    case 'U': return lua_upvalueindex(getnum_aux(L, L1, pc));
+    default: (*pc)--; return getnum_aux(L, L1, pc);
+  }
+}
+
+
+static void pushcode (lua_State *L, int code) {
+  static const char *const codes[] = {"OK", "YIELD", "ERRRUN",
+                   "ERRSYNTAX", "ERRMEM", "ERRGCMM", "ERRERR"};
+  lua_pushstring(L, codes[code]);
+}
+
+
 #define EQ(s1)	(strcmp(s1, inst) == 0)
 
-#define getnum	(getnum_aux(L, &pc))
-#define getname	(getname_aux(buff, &pc))
+#define getnum		(getnum_aux(L, L1, &pc))
+#define getstring	(getstring_aux(L, buff, &pc))
+#define getindex	(getindex_aux(L, L1, &pc))
+
 
+static int testC (lua_State *L);
+static int Cfunck (lua_State *L, int status, lua_KContext ctx);
 
-static int testC (lua_State *L)
-	/*@*/
-{
-  char buff[30];
-  const char *pc = luaL_checkstring(L, 1);
+/*
+** arithmetic operation encoding for 'arith' instruction
+** LUA_OPIDIV  -> \
+** LUA_OPSHL   -> <
+** LUA_OPSHR   -> >
+** LUA_OPUNM   -> _
+** LUA_OPBNOT  -> !
+*/
+static const char ops[] = "+-*%^/\\&|~<>_!";
+
+static int runC (lua_State *L, lua_State *L1, const char *pc) {
+  char buff[300];
+  int status = 0;
+  if (pc == NULL) return luaL_error(L, "attempt to runC null script");
   for (;;) {
-    const char *inst = getname;
+    const char *inst = getstring;
     if EQ("") return 0;
-    else if EQ("isnumber") {
-      lua_pushintegral(L, lua_isnumber(L, getnum));
+    else if EQ("absindex") {
+      lua_pushnumber(L1, lua_absindex(L1, getindex));
     }
-    else if EQ("isstring") {
-      lua_pushintegral(L, lua_isstring(L, getnum));
+    else if EQ("append") {
+      int t = getindex;
+      int i = lua_rawlen(L1, t);
+      lua_rawseti(L1, t, i + 1);
+    }
+    else if EQ("arith") {
+      int op;
+      skip(&pc);
+      op = strchr(ops, *pc++) - ops;
+      lua_arith(L1, op);
     }
-    else if EQ("istable") {
-      lua_pushintegral(L, lua_istable(L, getnum));
+    else if EQ("call") {
+      int narg = getnum;
+      int nres = getnum;
+      lua_call(L1, narg, nres);
+    }
+    else if EQ("callk") {
+      int narg = getnum;
+      int nres = getnum;
+      int i = getindex;
+      lua_callk(L1, narg, nres, i, Cfunck);
+    }
+    else if EQ("checkstack") {
+      int sz = getnum;
+      const char *msg = getstring;
+      if (*msg == '\0')
+        msg = NULL;  /* to test 'luaL_checkstack' with no message */
+      luaL_checkstack(L1, sz, msg);
+    }
+    else if EQ("compare") {
+      const char *opt = getstring;  /* EQ, LT, or LE */
+      int op = (opt[0] == 'E') ? LUA_OPEQ
+                               : (opt[1] == 'T') ? LUA_OPLT : LUA_OPLE;
+      int a = getindex;
+      int b = getindex;
+      lua_pushboolean(L1, lua_compare(L1, a, b, op));
+    }
+    else if EQ("concat") {
+      lua_concat(L1, getnum);
+    }
+    else if EQ("copy") {
+      int f = getindex;
+      lua_copy(L1, f, getindex);
+    }
+    else if EQ("func2num") {
+      lua_CFunction func = lua_tocfunction(L1, getindex);
+      lua_pushnumber(L1, cast(size_t, func));
+    }
+    else if EQ("getfield") {
+      int t = getindex;
+      lua_getfield(L1, t, getstring);
+    }
+    else if EQ("getglobal") {
+      lua_getglobal(L1, getstring);
+    }
+    else if EQ("getmetatable") {
+      if (lua_getmetatable(L1, getindex) == 0)
+        lua_pushnil(L1);
+    }
+    else if EQ("gettable") {
+      lua_gettable(L1, getindex);
+    }
+    else if EQ("gettop") {
+      lua_pushinteger(L1, lua_gettop(L1));
+    }
+    else if EQ("gsub") {
+      int a = getnum; int b = getnum; int c = getnum;
+      luaL_gsub(L1, lua_tostring(L1, a),
+                    lua_tostring(L1, b),
+                    lua_tostring(L1, c));
+    }
+    else if EQ("insert") {
+      lua_insert(L1, getnum);
     }
     else if EQ("iscfunction") {
-      lua_pushintegral(L, lua_iscfunction(L, getnum));
+      lua_pushboolean(L1, lua_iscfunction(L1, getindex));
     }
     else if EQ("isfunction") {
-      lua_pushintegral(L, lua_isfunction(L, getnum));
+      lua_pushboolean(L1, lua_isfunction(L1, getindex));
     }
-    else if EQ("isuserdata") {
-      lua_pushintegral(L, lua_isuserdata(L, getnum));
+    else if EQ("isnil") {
+      lua_pushboolean(L1, lua_isnil(L1, getindex));
+    }
+    else if EQ("isnull") {
+      lua_pushboolean(L1, lua_isnone(L1, getindex));
+    }
+    else if EQ("isnumber") {
+      lua_pushboolean(L1, lua_isnumber(L1, getindex));
+    }
+    else if EQ("isstring") {
+      lua_pushboolean(L1, lua_isstring(L1, getindex));
+    }
+    else if EQ("istable") {
+      lua_pushboolean(L1, lua_istable(L1, getindex));
     }
     else if EQ("isudataval") {
-      lua_pushintegral(L, lua_islightuserdata(L, getnum));
+      lua_pushboolean(L1, lua_islightuserdata(L1, getindex));
     }
-    else if EQ("isnil") {
-      lua_pushintegral(L, lua_isnil(L, getnum));
+    else if EQ("isuserdata") {
+      lua_pushboolean(L1, lua_isuserdata(L1, getindex));
     }
-    else if EQ("isnull") {
-      lua_pushintegral(L, lua_isnone(L, getnum));
+    else if EQ("len") {
+      lua_len(L1, getindex);
     }
-    else if EQ("tonumber") {
-      lua_pushnumber(L, lua_tonumber(L, getnum));
+    else if EQ("Llen") {
+      lua_pushinteger(L1, luaL_len(L1, getindex));
     }
-    else if EQ("tostring") {
-      const char *s = lua_tostring(L, getnum);
-      lua_pushstring(L, s);
+    else if EQ("loadfile") {
+      luaL_loadfile(L1, luaL_checkstring(L1, getnum));
     }
-    else if EQ("strlen") {
-      lua_pushintegral(L, lua_strlen(L, getnum));
+    else if EQ("loadstring") {
+      const char *s = luaL_checkstring(L1, getnum);
+      luaL_loadstring(L1, s);
     }
-    else if EQ("tocfunction") {
-      lua_pushcfunction(L, lua_tocfunction(L, getnum));
+    else if EQ("newmetatable") {
+      lua_pushboolean(L1, luaL_newmetatable(L1, getstring));
     }
-    else if EQ("return") {
-      return getnum;
+    else if EQ("newtable") {
+      lua_newtable(L1);
     }
-    else if EQ("gettop") {
-      lua_pushintegral(L, lua_gettop(L));
+    else if EQ("newthread") {
+      lua_newthread(L1);
     }
-    else if EQ("settop") {
-      lua_settop(L, getnum);
+    else if EQ("newuserdata") {
+      lua_newuserdata(L1, getnum);
+    }
+    else if EQ("next") {
+      lua_next(L1, -2);
+    }
+    else if EQ("objsize") {
+      lua_pushinteger(L1, lua_rawlen(L1, getindex));
+    }
+    else if EQ("pcall") {
+      int narg = getnum;
+      int nres = getnum;
+      status = lua_pcall(L1, narg, nres, getnum);
+    }
+    else if EQ("pcallk") {
+      int narg = getnum;
+      int nres = getnum;
+      int i = getindex;
+      status = lua_pcallk(L1, narg, nres, 0, i, Cfunck);
     }
     else if EQ("pop") {
-      lua_pop(L, getnum);
+      lua_pop(L1, getnum);
     }
-    else if EQ("pushnum") {
-      lua_pushintegral(L, getnum);
+    else if EQ("print") {
+      int n = getnum;
+      if (n != 0) {
+        printf("%s\n", luaL_tolstring(L1, n, NULL));
+        lua_pop(L1, 1);
+      }
+      else printstack(L1);
+    }
+    else if EQ("pushbool") {
+      lua_pushboolean(L1, getnum);
+    }
+    else if EQ("pushcclosure") {
+      lua_pushcclosure(L1, testC, getnum);
+    }
+    else if EQ("pushint") {
+      lua_pushinteger(L1, getnum);
     }
     else if EQ("pushnil") {
-      lua_pushnil(L);
+      lua_pushnil(L1);
     }
-    else if EQ("pushbool") {
-      lua_pushboolean(L, getnum);
+    else if EQ("pushnum") {
+      lua_pushnumber(L1, (lua_Number)getnum);
     }
-    else if EQ("tobool") {
-      lua_pushintegral(L, lua_toboolean(L, getnum));
+    else if EQ("pushstatus") {
+      pushcode(L1, status);
     }
-    else if EQ("pushvalue") {
-      lua_pushvalue(L, getnum);
+    else if EQ("pushstring") {
+      lua_pushstring(L1, getstring);
     }
-    else if EQ("pushcclosure") {
-      lua_pushcclosure(L, testC, getnum);
+    else if EQ("pushupvalueindex") {
+      lua_pushinteger(L1, lua_upvalueindex(getnum));
     }
-    else if EQ("pushupvalues") {
-      lua_pushupvalues(L);
+    else if EQ("pushvalue") {
+      lua_pushvalue(L1, getindex);
     }
-    else if EQ("remove") {
-      lua_remove(L, getnum);
+    else if EQ("rawgeti") {
+      int t = getindex;
+      lua_rawgeti(L1, t, getnum);
+    }
+    else if EQ("rawgetp") {
+      int t = getindex;
+      lua_rawgetp(L1, t, cast(void *, cast(size_t, getnum)));
+    }
+    else if EQ("rawsetp") {
+      int t = getindex;
+      lua_rawsetp(L1, t, cast(void *, cast(size_t, getnum)));
     }
-    else if EQ("insert") {
-      lua_insert(L, getnum);
+    else if EQ("remove") {
+      lua_remove(L1, getnum);
     }
     else if EQ("replace") {
-      lua_replace(L, getnum);
+      lua_replace(L1, getindex);
     }
-    else if EQ("gettable") {
-      lua_gettable(L, getnum);
+    else if EQ("resume") {
+      int i = getindex;
+      status = lua_resume(lua_tothread(L1, i), L, getnum);
     }
-    else if EQ("settable") {
-      lua_settable(L, getnum);
+    else if EQ("return") {
+      int n = getnum;
+      if (L1 != L) {
+        int i;
+        for (i = 0; i < n; i++)
+          lua_pushstring(L, lua_tostring(L1, -(n - i)));
+      }
+      return n;
+    }
+    else if EQ("rotate") {
+      int i = getindex;
+      lua_rotate(L1, i, getnum);
+    }
+    else if EQ("setfield") {
+      int t = getindex;
+      lua_setfield(L1, t, getstring);
+    }
+    else if EQ("setglobal") {
+      lua_setglobal(L1, getstring);
+    }
+    else if EQ("sethook") {
+      int mask = getnum;
+      int count = getnum;
+      sethookaux(L1, mask, count, getstring);
     }
-    else if EQ("next") {
-      lua_next(L, -2);
+    else if EQ("setmetatable") {
+      lua_setmetatable(L1, getindex);
     }
-    else if EQ("concat") {
-      lua_concat(L, getnum);
+    else if EQ("settable") {
+      lua_settable(L1, getindex);
     }
-    else if EQ("lessthan") {
-      int a = getnum;
-      lua_pushboolean(L, lua_lessthan(L, a, getnum));
+    else if EQ("settop") {
+      lua_settop(L1, getnum);
     }
-    else if EQ("equal") {
-      int a = getnum;
-      lua_pushboolean(L, lua_equal(L, a, getnum));
+    else if EQ("testudata") {
+      int i = getindex;
+      lua_pushboolean(L1, luaL_testudata(L1, i, getstring) != NULL);
+    }
+    else if EQ("error") {
+      lua_error(L1);
+    }
+    else if EQ("throw") {
+#if defined(__cplusplus)
+static struct X { int x; } x;
+      throw x;
+#else
+      luaL_error(L1, "C++");
+#endif
+      break;
     }
-    else if EQ("rawcall") {
-      int narg = getnum;
-      int nres = getnum;
-      lua_call(L, narg, nres);
+    else if EQ("tobool") {
+      lua_pushboolean(L1, lua_toboolean(L1, getindex));
     }
-    else if EQ("call") {
-      int narg = getnum;
-      int nres = getnum;
-      lua_pcall(L, narg, nres, 0);
+    else if EQ("tocfunction") {
+      lua_pushcfunction(L1, lua_tocfunction(L1, getindex));
     }
-    else if EQ("loadstring") {
-      size_t sl;
-      const char *s = luaL_checklstring(L, getnum, &sl);
-      luaL_loadbuffer(L, s, sl, s);
+    else if EQ("tointeger") {
+      lua_pushinteger(L1, lua_tointeger(L1, getindex));
     }
-    else if EQ("loadfile") {
-      luaL_loadfile(L, luaL_checkstring(L, getnum));
+    else if EQ("tonumber") {
+      lua_pushnumber(L1, lua_tonumber(L1, getindex));
     }
-    else if EQ("setmetatable") {
-      lua_setmetatable(L, getnum);
+    else if EQ("topointer") {
+      lua_pushnumber(L1, cast(size_t, lua_topointer(L1, getindex)));
     }
-    else if EQ("getmetatable") {
-      if (lua_getmetatable(L, getnum) == 0)
-        lua_pushnil(L);
+    else if EQ("tostring") {
+      const char *s = lua_tostring(L1, getindex);
+      const char *s1 = lua_pushstring(L1, s);
+      lua_assert((s == NULL && s1 == NULL) || strcmp(s, s1) == 0);
     }
     else if EQ("type") {
-      lua_pushstring(L, lua_typename(L, lua_type(L, getnum)));
+      lua_pushstring(L1, luaL_typename(L1, getnum));
     }
-    else if EQ("getn") {
-      int i = getnum;
-      lua_pushintegral(L, luaL_getn(L, i));
-    }
-    else if EQ("setn") {
-      int i = getnum;
-      int n = cast(int, lua_tonumber(L, -1));
-      luaL_setn(L, i, n);
-      lua_pop(L, 1);
+    else if EQ("xmove") {
+      int f = getindex;
+      int t = getindex;
+      lua_State *fs = (f == 0) ? L1 : lua_tothread(L1, f);
+      lua_State *ts = (t == 0) ? L1 : lua_tothread(L1, t);
+      int n = getnum;
+      if (n == 0) n = lua_gettop(fs);
+      lua_xmove(fs, ts, n);
+    }
+    else if EQ("yield") {
+      return lua_yield(L1, getnum);
+    }
+    else if EQ("yieldk") {
+      int nres = getnum;
+      int i = getindex;
+      return lua_yieldk(L1, nres, i, Cfunck);
     }
     else luaL_error(L, "unknown instruction %s", buff);
   }
   return 0;
 }
 
+
+static int testC (lua_State *L) {
+  lua_State *L1;
+  const char *pc;
+  if (lua_isuserdata(L, 1)) {
+    L1 = getstate(L);
+    pc = luaL_checkstring(L, 2);
+  }
+  else if (lua_isthread(L, 1)) {
+    L1 = lua_tothread(L, 1);
+    pc = luaL_checkstring(L, 2);
+  }
+  else {
+    L1 = L;
+    pc = luaL_checkstring(L, 1);
+  }
+  return runC(L, L1, pc);
+}
+
+
+static int Cfunc (lua_State *L) {
+  return runC(L, L, lua_tostring(L, lua_upvalueindex(1)));
+}
+
+
+static int Cfunck (lua_State *L, int status, lua_KContext ctx) {
+  pushcode(L, status);
+  lua_setglobal(L, "status");
+  lua_pushinteger(L, ctx);
+  lua_setglobal(L, "ctx");
+  return runC(L, L, lua_tostring(L, ctx));
+}
+
+
+static int makeCfunc (lua_State *L) {
+  luaL_checkstring(L, 1);
+  lua_pushcclosure(L, Cfunc, lua_gettop(L));
+  return 1;
+}
+
+
 /* }====================================================== */
 
 
 /*
 ** {======================================================
-** tests for yield inside hooks
+** tests for C hooks
 ** =======================================================
 */
 
-static void yieldf (lua_State *L, lua_Debug *ar)
-	/*@*/
-{
-  lua_yield(L, 0);
+/*
+** C hook that runs the C script stored in registry.C_HOOK[L]
+*/
+static void Chook (lua_State *L, lua_Debug *ar) {
+  const char *scpt;
+  const char *const events [] = {"call", "ret", "line", "count", "tailcall"};
+  lua_getfield(L, LUA_REGISTRYINDEX, "C_HOOK");
+  lua_pushlightuserdata(L, L);
+  lua_gettable(L, -2);  /* get C_HOOK[L] (script saved by sethookaux) */
+  scpt = lua_tostring(L, -1);  /* not very religious (string will be popped) */
+  lua_pop(L, 2);  /* remove C_HOOK and script */
+  lua_pushstring(L, events[ar->event]);  /* may be used by script */
+  lua_pushinteger(L, ar->currentline);  /* may be used by script */
+  runC(L, L, scpt);  /* run script from C_HOOK[L] */
 }
 
-static int setyhook (lua_State *L)
-	/*@*/
-{
+
+/*
+** sets 'registry.C_HOOK[L] = scpt' and sets 'Chook' as a hook
+*/
+static void sethookaux (lua_State *L, int mask, int count, const char *scpt) {
+  if (*scpt == '\0') {  /* no script? */
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+    return;
+  }
+  lua_getfield(L, LUA_REGISTRYINDEX, "C_HOOK");  /* get C_HOOK table */
+  if (!lua_istable(L, -1)) {  /* no hook table? */
+    lua_pop(L, 1);  /* remove previous value */
+    lua_newtable(L);  /* create new C_HOOK table */
+    lua_pushvalue(L, -1);
+    lua_setfield(L, LUA_REGISTRYINDEX, "C_HOOK");  /* register it */
+  }
+  lua_pushlightuserdata(L, L);
+  lua_pushstring(L, scpt);
+  lua_settable(L, -3);  /* C_HOOK[L] = script */
+  lua_sethook(L, Chook, mask, count);
+}
+
+
+static int sethook (lua_State *L) {
   if (lua_isnoneornil(L, 1))
     lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
   else {
-    const char *smask = luaL_checkstring(L, 1);
-    int count = luaL_optint(L, 2, 0);
+    const char *scpt = luaL_checkstring(L, 1);
+    const char *smask = luaL_checkstring(L, 2);
+    int count = cast_int(luaL_optinteger(L, 3, 0));
     int mask = 0;
+    if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+    if (strchr(smask, 'r')) mask |= LUA_MASKRET;
     if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
     if (count > 0) mask |= LUA_MASKCOUNT;
-    lua_sethook(L, yieldf, mask, count);
+    sethookaux(L, mask, count, scpt);
   }
   return 0;
 }
 
 
-static int coresume (lua_State *L)
-	/*@*/
-{
+static int coresume (lua_State *L) {
   int status;
   lua_State *co = lua_tothread(L, 1);
   luaL_argcheck(L, co, 1, "coroutine expected");
-  status = lua_resume(co, 0);
-  if (status != 0) {
+  status = lua_resume(co, L, 0);
+  if (status != LUA_OK && status != LUA_YIELD) {
     lua_pushboolean(L, 0);
     lua_insert(L, -2);
     return 2;  /* return false + error message */
@@ -856,77 +1497,61 @@
 
 
 
-static const struct luaL_reg tests_funcs[] = {
+static const struct luaL_Reg tests_funcs[] = {
+  {"checkmemory", lua_checkmemory},
+  {"closestate", closestate},
+  {"d2s", d2s},
+  {"doonnewstack", doonnewstack},
+  {"doremote", doremote},
+  {"gccolor", gc_color},
+  {"gcstate", gc_state},
+  {"getref", getref},
   {"hash", hash_query},
+  {"int2fb", int2fb_aux},
   {"limits", get_limits},
   {"listcode", listcode},
   {"listk", listk},
   {"listlocals", listlocals},
   {"loadlib", loadlib},
-  {"stacklevel", stacklevel},
+  {"checkpanic", checkpanic},
+  {"newstate", newstate},
+  {"newuserdata", newuserdata},
+  {"num2int", num2int},
+  {"pushuserdata", pushuserdata},
   {"querystr", string_query},
   {"querytab", table_query},
-  {"doit", test_do},
-  {"testC", testC},
   {"ref", tref},
-  {"getref", getref},
-  {"unref", unref},
-  {"d2s", d2s},
+  {"resume", coresume},
   {"s2d", s2d},
-  {"metatable", metatable},
-  {"upvalue", upvalue},
-  {"newuserdata", newuserdata},
-  {"pushuserdata", pushuserdata},
-  {"udataval", udataval},
-  {"doonnewstack", doonnewstack},
-  {"newstate", newstate},
-  {"closestate", closestate},
-  {"doremote", doremote},
-  {"log2", log2_aux},
-  {"int2fb", int2fb_aux},
+  {"sethook", sethook},
+  {"stacklevel", stacklevel},
+  {"testC", testC},
+  {"makeCfunc", makeCfunc},
   {"totalmem", mem_query},
-  {"resume", coresume},
-  {"setyhook", setyhook},
+  {"trick", settrick},
+  {"udataval", udataval},
+  {"unref", unref},
+  {"upvalue", upvalue},
   {NULL, NULL}
 };
 
 
-static void fim (void)
-	/*@*/
-{
-  if (!islocked)
-    lua_close(lua_state);
-  lua_assert(memdebug_numblocks == 0);
-  lua_assert(memdebug_total == 0);
-}
-
-
-static int l_panic (lua_State *L)
-	/*@*/
-{
-  UNUSED(L);
-  fprintf(stderr, "unable to recover; exiting\n");
-  return 0;
+static void checkfinalmem (void) {
+  lua_assert(l_memcontrol.numblocks == 0);
+  lua_assert(l_memcontrol.total == 0);
 }
 
 
 int luaB_opentests (lua_State *L) {
-  lua_atpanic(L, l_panic);
-  lua_userstateopen(L);  /* init lock */
-  lua_state = L;  /* keep first state to be opened */
-  luaL_openlib(L, "T", tests_funcs, 0);
-  atexit(fim);
-  return 0;
-}
-
-
-#undef main
-int main (int argc, char *argv[]) {
-  char *limit = getenv("MEMLIMIT");
-  if (limit)
-    memdebug_memlimit = strtoul(limit, NULL, 10);
-  l_main(argc, argv);
-  return 0;
+  void *ud;
+  lua_atpanic(L, &tpanic);
+  atexit(checkfinalmem);
+  lua_assert(lua_getallocf(L, &ud) == debug_realloc);
+  lua_assert(ud == cast(void *, &l_memcontrol));
+  lua_setallocf(L, lua_getallocf(L, NULL), ud);
+  luaL_newlib(L, tests_funcs);
+  return 1;
 }
 
 #endif
+
diff -urN rpm-5.4.15/lua/ltests.h rpm-5.4-cvs/lua/ltests.h
--- rpm-5.4.15/lua/ltests.h	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/ltests.h	2015-04-19 13:24:57.000000000 -0500
@@ -0,0 +1,113 @@
+/*
+** $Id: ltests.h,v 1.1.2.1 2015/04/19 18:24:57 jbj Exp $
+** Internal Header for Debugging of the Lua Implementation
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltests_h
+#define ltests_h
+
+
+#include <stdlib.h>
+
+/* test Lua with no compatibility code */
+#undef LUA_COMPAT_MATHLIB
+#undef LUA_COMPAT_IPAIRS
+#undef LUA_COMPAT_BITLIB
+#undef LUA_COMPAT_APIINTCASTS
+#undef LUA_COMPAT_FLOATSTRING
+#undef LUA_COMPAT_UNPACK
+#undef LUA_COMPAT_LOADERS
+#undef LUA_COMPAT_LOG10
+#undef LUA_COMPAT_LOADSTRING
+#undef LUA_COMPAT_MAXN
+#undef LUA_COMPAT_MODULE
+
+
+#define LUA_DEBUG
+
+
+/* turn on assertions */
+#undef NDEBUG
+#include <assert.h>
+#define lua_assert(c)           assert(c)
+
+
+/* to avoid warnings, and to make sure value is really unused */
+#define UNUSED(x)       (x=0, (void)(x))
+
+
+/* memory-allocator control variables */
+typedef struct Memcontrol {
+  unsigned long numblocks;
+  unsigned long total;
+  unsigned long maxmem;
+  unsigned long memlimit;
+  unsigned long objcount[LUA_NUMTAGS];
+} Memcontrol;
+
+LUA_API Memcontrol l_memcontrol;
+
+
+/*
+** generic variable for debug tricks
+*/
+extern void *l_Trick;
+
+
+
+/*
+** Function to traverse and check all memory used by Lua
+*/
+int lua_checkmemory (lua_State *L);
+
+
+/* test for lock/unlock */
+
+struct L_EXTRA { int lock; int *plock; };
+#undef LUA_EXTRASPACE
+#define LUA_EXTRASPACE	sizeof(struct L_EXTRA)
+#define getlock(l)	cast(struct L_EXTRA*, lua_getextraspace(l))
+#define luai_userstateopen(l)  \
+	(getlock(l)->lock = 0, getlock(l)->plock = &(getlock(l)->lock))
+#define luai_userstateclose(l)  \
+  lua_assert(getlock(l)->lock == 1 && getlock(l)->plock == &(getlock(l)->lock))
+#define luai_userstatethread(l,l1) \
+  lua_assert(getlock(l1)->plock == getlock(l)->plock)
+#define luai_userstatefree(l,l1) \
+  lua_assert(getlock(l)->plock == getlock(l1)->plock)
+#define lua_lock(l)     lua_assert((*getlock(l)->plock)++ == 0)
+#define lua_unlock(l)   lua_assert(--(*getlock(l)->plock) == 0)
+
+
+
+LUA_API int luaB_opentests (lua_State *L);
+
+LUA_API void *debug_realloc (void *ud, void *block,
+                             size_t osize, size_t nsize);
+
+#if defined(lua_c)
+#define luaL_newstate()		lua_newstate(debug_realloc, &l_memcontrol)
+#define luaL_openlibs(L)  \
+  { (luaL_openlibs)(L); luaL_requiref(L, "T", luaB_opentests, 1); }
+#endif
+
+
+
+/* change some sizes to give some bugs a chance */
+
+#undef LUAL_BUFFERSIZE
+#define LUAL_BUFFERSIZE		23
+#define MINSTRTABSIZE		2
+
+
+/* make stack-overflow tests run faster */
+#undef LUAI_MAXSTACK
+#define LUAI_MAXSTACK   50000
+
+
+#undef LUAI_USER_ALIGNMENT_T
+#define LUAI_USER_ALIGNMENT_T   union { char b[sizeof(void*) * 8]; }
+
+#endif
+
diff -urN rpm-5.4.15/lua/ltm.c rpm-5.4-cvs/lua/ltm.c
--- rpm-5.4.15/lua/ltm.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/ltm.c	2015-04-18 23:34:19.000000000 -0500
@@ -1,22 +1,27 @@
 /*
-** $Id: ltm.c,v 2.14 2011/06/02 19:31:40 roberto Exp $
+** $Id: ltm.c,v 2.33 2014/11/21 12:15:57 roberto Exp $
 ** Tag methods
 ** See Copyright Notice in lua.h
 */
 
-
-#include <string.h>
-
 #define ltm_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <string.h>
+
 #include "lua.h"
 
+#include "ldebug.h"
+#include "ldo.h" 
 #include "lobject.h"
 #include "lstate.h"
 #include "lstring.h"
 #include "ltable.h"
 #include "ltm.h"
+#include "lvm.h"
 
 
 static const char udatatypename[] = "userdata";
@@ -25,7 +30,7 @@
   "no value",
   "nil", "boolean", udatatypename, "number",
   "string", "table", "function", udatatypename, "thread",
-  "proto", "upval"  /* these last two cases are used for tests only */
+  "proto" /* this last case is used for tests only */
 };
 
 
@@ -33,14 +38,16 @@
   static const char *const luaT_eventname[] = {  /* ORDER TM */
     "__index", "__newindex",
     "__gc", "__mode", "__len", "__eq",
-    "__add", "__sub", "__mul", "__div", "__mod",
-    "__pow", "__unm", "__lt", "__le",
+    "__add", "__sub", "__mul", "__mod", "__pow",
+    "__div", "__idiv",
+    "__band", "__bor", "__bxor", "__shl", "__shr",
+    "__unm", "__bnot", "__lt", "__le",
     "__concat", "__call"
   };
   int i;
   for (i=0; i<TM_N; i++) {
     G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
-    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
+    luaC_fix(L, obj2gco(G(L)->tmname[i]));  /* never collect these names */
   }
 }
 
@@ -62,7 +69,7 @@
 
 const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
   Table *mt;
-  switch (ttypenv(o)) {
+  switch (ttnov(o)) {
     case LUA_TTABLE:
       mt = hvalue(o)->metatable;
       break;
@@ -70,8 +77,67 @@
       mt = uvalue(o)->metatable;
       break;
     default:
-      mt = G(L)->mt[ttypenv(o)];
+      mt = G(L)->mt[ttnov(o)];
   }
   return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
 }
 
+
+void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,
+                  const TValue *p2, TValue *p3, int hasres) {
+  ptrdiff_t result = savestack(L, p3);
+  setobj2s(L, L->top++, f);  /* push function (assume EXTRA_STACK) */
+  setobj2s(L, L->top++, p1);  /* 1st argument */
+  setobj2s(L, L->top++, p2);  /* 2nd argument */
+  if (!hasres)  /* no result? 'p3' is third argument */
+    setobj2s(L, L->top++, p3);  /* 3rd argument */
+  /* metamethod may yield only when called from Lua code */
+  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));
+  if (hasres) {  /* if has result, move it to its place */
+    p3 = restorestack(L, result);
+    setobjs2s(L, p3, --L->top);
+  }
+}
+
+
+int luaT_callbinTM (lua_State *L, const TValue *p1, const TValue *p2,
+                    StkId res, TMS event) {
+  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (ttisnil(tm)) return 0;
+  luaT_callTM(L, tm, p1, p2, res, 1);
+  return 1;
+}
+
+
+void luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,
+                    StkId res, TMS event) {
+  if (!luaT_callbinTM(L, p1, p2, res, event)) {
+    switch (event) {
+      case TM_CONCAT:
+        luaG_concaterror(L, p1, p2);
+      case TM_BAND: case TM_BOR: case TM_BXOR:
+      case TM_SHL: case TM_SHR: case TM_BNOT: {
+        lua_Number dummy;
+        if (tonumber(p1, &dummy) && tonumber(p2, &dummy))
+          luaG_tointerror(L, p1, p2);
+        else
+          luaG_opinterror(L, p1, p2, "perform bitwise operation on");
+        /* else go through */
+      }
+      default:
+        luaG_opinterror(L, p1, p2, "perform arithmetic on");
+    }
+  }
+}
+
+
+int luaT_callorderTM (lua_State *L, const TValue *p1, const TValue *p2,
+                      TMS event) {
+  if (!luaT_callbinTM(L, p1, p2, L->top, event))
+    return -1;  /* no metamethod */
+  else
+    return !l_isfalse(L->top);
+}
+
diff -urN rpm-5.4.15/lua/ltm.h rpm-5.4-cvs/lua/ltm.h
--- rpm-5.4.15/lua/ltm.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/ltm.h	2015-04-18 23:34:19.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: ltm.h,v 2.11 2011/02/28 17:32:10 roberto Exp $
+** $Id: ltm.h,v 2.21 2014/10/25 11:50:46 roberto Exp $
 ** Tag methods
 ** See Copyright Notice in lua.h
 */
@@ -13,7 +13,7 @@
 
 /*
 * WARNING: if you change the order of this enumeration,
-* grep "ORDER TM"
+* grep "ORDER TM" and "ORDER OP"
 */
 typedef enum {
   TM_INDEX,
@@ -21,14 +21,21 @@
   TM_GC,
   TM_MODE,
   TM_LEN,
-  TM_EQ,  /* last tag method with `fast' access */
+  TM_EQ,  /* last tag method with fast access */
   TM_ADD,
   TM_SUB,
   TM_MUL,
-  TM_DIV,
   TM_MOD,
   TM_POW,
+  TM_DIV,
+  TM_IDIV,
+  TM_BAND,
+  TM_BOR,
+  TM_BXOR,
+  TM_SHL,
+  TM_SHR,
   TM_UNM,
+  TM_BNOT,
   TM_LT,
   TM_LE,
   TM_CONCAT,
@@ -44,14 +51,26 @@
 #define fasttm(l,et,e)	gfasttm(G(l), et, e)
 
 #define ttypename(x)	luaT_typenames_[(x) + 1]
-#define objtypename(x)	ttypename(ttypenv(x))
+#define objtypename(x)	ttypename(ttnov(x))
 
 LUAI_DDEC const char *const luaT_typenames_[LUA_TOTALTAGS];
 
 
 LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
 LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
-                                                       TMS event);
+                                                       TMS event)
+				LUA_GNUC_PURE;
 LUAI_FUNC void luaT_init (lua_State *L);
 
+LUAI_FUNC void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,
+                            const TValue *p2, TValue *p3, int hasres);
+LUAI_FUNC int luaT_callbinTM (lua_State *L, const TValue *p1, const TValue *p2,
+                              StkId res, TMS event);
+LUAI_FUNC void luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,
+                              StkId res, TMS event);
+LUAI_FUNC int luaT_callorderTM (lua_State *L, const TValue *p1,
+                                const TValue *p2, TMS event);
+
+
+
 #endif
diff -urN rpm-5.4.15/lua/lua.c rpm-5.4-cvs/lua/lua.c
--- rpm-5.4.15/lua/lua.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lua.c	2015-04-18 23:34:19.000000000 -0500
@@ -1,17 +1,19 @@
 /*
-** $Id: lua.c,v 1.206 2012/09/29 20:07:06 roberto Exp $
+** $Id: lua.c,v 1.222 2014/11/11 19:41:27 roberto Exp $
 ** Lua stand-alone interpreter
 ** See Copyright Notice in lua.h
 */
 
+#define lua_c
+
+#include "lprefix.h"
+
 
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define lua_c
-
 #include "lua.h"
 
 #include "lauxlib.h"
@@ -31,28 +33,38 @@
 #define LUA_MAXINPUT		512
 #endif
 
-#if !defined(LUA_INIT)
-#define LUA_INIT		"LUA_INIT"
+#if !defined(LUA_INIT_VAR)
+#define LUA_INIT_VAR		"LUA_INIT"
 #endif
 
-#define LUA_INITVERSION  \
-	LUA_INIT "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+#define LUA_INITVARVERSION  \
+	LUA_INIT_VAR "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
 
 
 /*
 ** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
 ** is, whether we're running lua interactively).
 */
-#if defined(LUA_USE_ISATTY)
+#if !defined(lua_stdin_is_tty)	/* { */
+
+#if defined(LUA_USE_POSIX)	/* { */
+
 #include <unistd.h>
 #define lua_stdin_is_tty()	isatty(0)
-#elif defined(LUA_WIN)
+
+#elif defined(LUA_USE_WINDOWS)	/* }{ */
+
 #include <io.h>
-#include <stdio.h>
 #define lua_stdin_is_tty()	_isatty(_fileno(stdin))
-#else
+
+#else				/* }{ */
+
+/* ISO C definition */
 #define lua_stdin_is_tty()	1  /* assume stdin is a tty */
-#endif
+
+#endif				/* } */
+
+#endif				/* } */
 
 
 /*
@@ -61,9 +73,10 @@
 ** lua_saveline defines how to "save" a read line in a "history".
 ** lua_freeline defines how to free a line read by lua_readline.
 */
-#if defined(LUA_USE_READLINE)
+#if !defined(lua_readline)	/* { */
+
+#if defined(LUA_USE_READLINE)	/* { */
 
-#include <stdio.h>
 #include <readline/readline.h>
 #include <readline/history.h>
 #define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
@@ -72,7 +85,7 @@
           add_history(lua_tostring(L, idx));  /* add it to history */
 #define lua_freeline(L,b)	((void)L, free(b))
 
-#elif !defined(lua_readline)
+#else				/* }{ */
 
 #define lua_readline(L,b,p) \
         ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
@@ -80,7 +93,9 @@
 #define lua_saveline(L,idx)	{ (void)L; (void)idx; }
 #define lua_freeline(L,b)	{ (void)L; (void)b; }
 
-#endif
+#endif				/* } */
+
+#endif				/* } */
 
 
 
@@ -90,33 +105,40 @@
 static const char *progname = LUA_PROGNAME;
 
 
-
+/*
+** Hook set by signal function to stop the interpreter.
+*/
 static void lstop (lua_State *L, lua_Debug *ar) {
   (void)ar;  /* unused arg. */
-  lua_sethook(L, NULL, 0, 0);
+  lua_sethook(L, NULL, 0, 0);  /* reset hook */
   luaL_error(L, "interrupted!");
 }
 
 
+/*
+** Function to be called at a C signal. Because a C signal cannot
+** just change a Lua state (as there is no proper synchronization),
+** this function only sets a hook that, when called, will stop the
+** interpreter.
+*/
 static void laction (int i) {
-  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
-                              terminate process (default action) */
+  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
   lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
 }
 
 
 static void print_usage (const char *badoption) {
-  luai_writestringerror("%s: ", progname);
+  lua_writestringerror("%s: ", progname);
   if (badoption[1] == 'e' || badoption[1] == 'l')
-    luai_writestringerror("'%s' needs argument\n", badoption);
+    lua_writestringerror("'%s' needs argument\n", badoption);
   else
-    luai_writestringerror("unrecognized option '%s'\n", badoption);
-  luai_writestringerror(
+    lua_writestringerror("unrecognized option '%s'\n", badoption);
+  lua_writestringerror(
   "usage: %s [options] [script [args]]\n"
   "Available options are:\n"
-  "  -e stat  execute string " LUA_QL("stat") "\n"
-  "  -i       enter interactive mode after executing " LUA_QL("script") "\n"
-  "  -l name  require library " LUA_QL("name") "\n"
+  "  -e stat  execute string 'stat'\n"
+  "  -i       enter interactive mode after executing 'script'\n"
+  "  -l name  require library 'name'\n"
   "  -v       show version information\n"
   "  -E       ignore environment variables\n"
   "  --       stop handling options\n"
@@ -126,101 +148,114 @@
 }
 
 
+/*
+** Prints an error message, adding the program name in front of it
+** (if present)
+*/
 static void l_message (const char *pname, const char *msg) {
-  if (pname) luai_writestringerror("%s: ", pname);
-  luai_writestringerror("%s\n", msg);
+  if (pname) lua_writestringerror("%s: ", pname);
+  lua_writestringerror("%s\n", msg);
 }
 
 
+/*
+** Check whether 'status' is not OK and, if so, prints the error
+** message on the top of the stack. It assumes that the error object
+** is a string, as it was either generated by Lua or by 'msghandler'.
+*/
 static int report (lua_State *L, int status) {
-  if (status != LUA_OK && !lua_isnil(L, -1)) {
+  if (status != LUA_OK) {
     const char *msg = lua_tostring(L, -1);
-    if (msg == NULL) msg = "(error object is not a string)";
     l_message(progname, msg);
-    lua_pop(L, 1);
-    /* force a complete garbage collection in case of errors */
-    lua_gc(L, LUA_GCCOLLECT, 0);
+    lua_pop(L, 1);  /* remove message */
   }
   return status;
 }
 
 
-/* the next function is called unprotected, so it must avoid errors */
-static void finalreport (lua_State *L, int status) {
-  if (status != LUA_OK) {
-    const char *msg = (lua_type(L, -1) == LUA_TSTRING) ? lua_tostring(L, -1)
-                                                       : NULL;
-    if (msg == NULL) msg = "(error object is not a string)";
-    l_message(progname, msg);
-    lua_pop(L, 1);
-  }
-}
-
-
-static int traceback (lua_State *L) {
+/*
+** Message handler used to run all chunks
+*/
+static int msghandler (lua_State *L) {
   const char *msg = lua_tostring(L, 1);
-  if (msg)
-    luaL_traceback(L, L, msg, 1);
-  else if (!lua_isnoneornil(L, 1)) {  /* is there an error object? */
-    if (!luaL_callmeta(L, 1, "__tostring"))  /* try its 'tostring' metamethod */
-      lua_pushliteral(L, "(no error message)");
+  if (msg == NULL) {  /* is error object not a string? */
+    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
+        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
+      return 1;  /* that is the message */
+    else
+      msg = lua_pushfstring(L, "(error object is a %s value)",
+                               luaL_typename(L, 1));
   }
-  return 1;
+  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
+  return 1;  /* return the traceback */
 }
 
 
+/*
+** Interface to 'lua_pcall', which sets appropriate message function
+** and C-signal handler. Used to run all chunks.
+*/
 static int docall (lua_State *L, int narg, int nres) {
   int status;
   int base = lua_gettop(L) - narg;  /* function index */
-  lua_pushcfunction(L, traceback);  /* push traceback function */
-  lua_insert(L, base);  /* put it under chunk and args */
+  lua_pushcfunction(L, msghandler);  /* push message handler */
+  lua_insert(L, base);  /* put it under function and args */
   globalL = L;  /* to be available to 'laction' */
-  signal(SIGINT, laction);
+  signal(SIGINT, laction);  /* set C-signal handler */
   status = lua_pcall(L, narg, nres, base);
-  signal(SIGINT, SIG_DFL);
-  lua_remove(L, base);  /* remove traceback function */
+  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
+  lua_remove(L, base);  /* remove message handler from the stack */
   return status;
 }
 
 
 static void print_version (void) {
-  luai_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
-  luai_writeline();
+  lua_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
+  lua_writeline();
 }
 
 
-static int getargs (lua_State *L, char **argv, int n) {
-  int narg;
-  int i;
-  int argc = 0;
-  while (argv[argc]) argc++;  /* count total number of arguments */
-  narg = argc - (n + 1);  /* number of arguments to the script */
-  luaL_checkstack(L, narg + 3, "too many arguments to script");
-  for (i=n+1; i < argc; i++)
-    lua_pushstring(L, argv[i]);
-  lua_createtable(L, narg, n + 1);
-  for (i=0; i < argc; i++) {
+/*
+** Create the 'arg' table, which stores all arguments from the
+** command line ('argv'). It should be aligned so that, at index 0,
+** it has 'argv[script]', which is the script name. The arguments
+** to the script (everything after 'script') go to positive indices;
+** other arguments (before the script name) go to negative indices.
+** If there is no script name, assume interpreter's name as base.
+*/
+static void createargtable (lua_State *L, char **argv, int argc, int script) {
+  int i, narg;
+  if (script == argc) script = 0;  /* no script name? */
+  narg = argc - (script + 1);  /* number of positive indices */
+  lua_createtable(L, narg, script + 1);
+  for (i = 0; i < argc; i++) {
     lua_pushstring(L, argv[i]);
-    lua_rawseti(L, -2, i - n);
+    lua_rawseti(L, -2, i - script);
   }
-  return narg;
+  lua_setglobal(L, "arg");
 }
 
 
-static int dofile (lua_State *L, const char *name) {
-  int status = luaL_loadfile(L, name);
+static int dochunk (lua_State *L, int status) {
   if (status == LUA_OK) status = docall(L, 0, 0);
   return report(L, status);
 }
 
 
+static int dofile (lua_State *L, const char *name) {
+  return dochunk(L, luaL_loadfile(L, name));
+}
+
+
 static int dostring (lua_State *L, const char *s, const char *name) {
-  int status = luaL_loadbuffer(L, s, strlen(s), name);
-  if (status == LUA_OK) status = docall(L, 0, 0);
-  return report(L, status);
+  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
 }
 
 
+/*
+** Calls 'require(name)' and stores the result in a global variable
+** with the given name.
+*/
 static int dolibrary (lua_State *L, const char *name) {
   int status;
   lua_getglobal(L, "require");
@@ -232,6 +267,9 @@
 }
 
 
+/*
+** Returns the string to be used as a prompt by the interpreter.
+*/
 static const char *get_prompt (lua_State *L, int firstline) {
   const char *p;
   lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
@@ -244,6 +282,12 @@
 #define EOFMARK		"<eof>"
 #define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)
 
+
+/*
+** Check whether 'status' signals a syntax error and the error
+** message at the top of the stack ends with the above mark for
+** incomplete statements.
+*/
 static int incomplete (lua_State *L, int status) {
   if (status == LUA_ERRSYNTAX) {
     size_t lmsg;
@@ -257,20 +301,23 @@
 }
 
 
+/*
+** Prompt the user, read a line, and push it into the Lua stack.
+*/
 static int pushline (lua_State *L, int firstline) {
   char buffer[LUA_MAXINPUT];
   char *b = buffer;
   size_t l;
   const char *prmt = get_prompt(L, firstline);
   int readstatus = lua_readline(L, b, prmt);
-  lua_pop(L, 1);  /* remove result from 'get_prompt' */
   if (readstatus == 0)
-    return 0;  /* no input */
+    return 0;  /* no input (prompt will be popped by caller) */
+  lua_pop(L, 1);  /* remove prompt */
   l = strlen(b);
   if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
     b[l-1] = '\0';  /* remove it */
-  if (firstline && b[0] == '=')  /* first line starts with `=' ? */
-    lua_pushfstring(L, "return %s", b+1);  /* change it to `return' */
+  if (firstline && b[0] == '=')  /* for compatibility with 5.2, ... */
+    lua_pushfstring(L, "return %s", b + 1);  /* change '=' to 'return' */
   else
     lua_pushstring(L, b);
   lua_freeline(L, b);
@@ -278,142 +325,206 @@
 }
 
 
+/*
+** Try to compile line on the stack as 'return <line>'; on return, stack
+** has either compiled chunk or original line (if compilation failed).
+*/
+static int addreturn (lua_State *L) {
+  int status;
+  size_t len; const char *line;
+  lua_pushliteral(L, "return ");
+  lua_pushvalue(L, -2);  /* duplicate line */
+  lua_concat(L, 2);  /* new line is "return ..." */
+  line = lua_tolstring(L, -1, &len);
+  if ((status = luaL_loadbuffer(L, line, len, "=stdin")) == LUA_OK)
+    lua_remove(L, -3);  /* remove original line */
+  else
+    lua_pop(L, 2);  /* remove result from 'luaL_loadbuffer' and new line */
+  return status;
+}
+
+
+/*
+** Read multiple lines until a complete Lua statement
+*/
+static int multiline (lua_State *L) {
+  for (;;) {  /* repeat until gets a complete statement */
+    size_t len;
+    const char *line = lua_tolstring(L, 1, &len);  /* get what it has */
+    int status = luaL_loadbuffer(L, line, len, "=stdin");  /* try it */
+    if (!incomplete(L, status) || !pushline(L, 0))
+      return status;  /* cannot or should not try to add continuation line */
+    lua_pushliteral(L, "\n");  /* add newline... */
+    lua_insert(L, -2);  /* ...between the two lines */
+    lua_concat(L, 3);  /* join them */
+  }
+}
+
+
+/*
+** Read a line and try to load (compile) it first as an expression (by
+** adding "return " in front of it) and second as a statement. Return
+** the final status of load/call with the resulting function (if any)
+** in the top of the stack.
+*/
 static int loadline (lua_State *L) {
   int status;
   lua_settop(L, 0);
   if (!pushline(L, 1))
     return -1;  /* no input */
-  for (;;) {  /* repeat until gets a complete line */
-    size_t l;
-    const char *line = lua_tolstring(L, 1, &l);
-    status = luaL_loadbuffer(L, line, l, "=stdin");
-    if (!incomplete(L, status)) break;  /* cannot try to add lines? */
-    if (!pushline(L, 0))  /* no more input? */
-      return -1;
-    lua_pushliteral(L, "\n");  /* add a new line... */
-    lua_insert(L, -2);  /* ...between the two lines */
-    lua_concat(L, 3);  /* join them */
-  }
-  lua_saveline(L, 1);
-  lua_remove(L, 1);  /* remove line */
+  if ((status = addreturn(L)) != LUA_OK)  /* 'return ...' did not work? */
+    status = multiline(L);  /* try as command, maybe with continuation lines */
+  lua_saveline(L, 1);  /* keep history */
+  lua_remove(L, 1);  /* remove line from the stack */
+  lua_assert(lua_gettop(L) == 1);
   return status;
 }
 
 
-static void dotty (lua_State *L) {
+/*
+** Prints (calling the Lua 'print' function) any values on the stack
+*/
+static void l_print (lua_State *L) {
+  int n = lua_gettop(L);
+  if (n > 0) {  /* any result to be printed? */
+    luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
+    lua_getglobal(L, "print");
+    lua_insert(L, 1);
+    if (lua_pcall(L, n, 0, 0) != LUA_OK)
+      l_message(progname, lua_pushfstring(L, "error calling 'print' (%s)",
+                                             lua_tostring(L, -1)));
+  }
+}
+
+
+/*
+** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and
+** print any results.
+*/
+static void doREPL (lua_State *L) {
   int status;
   const char *oldprogname = progname;
-  progname = NULL;
+  progname = NULL;  /* no 'progname' on errors in interactive mode */
   while ((status = loadline(L)) != -1) {
-    if (status == LUA_OK) status = docall(L, 0, LUA_MULTRET);
-    report(L, status);
-    if (status == LUA_OK && lua_gettop(L) > 0) {  /* any result to print? */
-      luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
-      lua_getglobal(L, "print");
-      lua_insert(L, 1);
-      if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != LUA_OK)
-        l_message(progname, lua_pushfstring(L,
-                               "error calling " LUA_QL("print") " (%s)",
-                               lua_tostring(L, -1)));
-    }
+    if (status == LUA_OK)
+      status = docall(L, 0, LUA_MULTRET);
+    if (status == LUA_OK) l_print(L);
+    else report(L, status);
   }
   lua_settop(L, 0);  /* clear stack */
-  luai_writeline();
+  lua_writeline();
   progname = oldprogname;
 }
 
 
-static int handle_script (lua_State *L, char **argv, int n) {
+/*
+** Push on the stack the contents of table 'arg' from 1 to #arg
+*/
+static int pushargs (lua_State *L) {
+  int i, n;
+  if (lua_getglobal(L, "arg") != LUA_TTABLE)
+    luaL_error(L, "'arg' is not a table");
+  n = (int)luaL_len(L, -1);
+  luaL_checkstack(L, n + 3, "too many arguments to script");
+  for (i = 1; i <= n; i++)
+    lua_rawgeti(L, -i, i);
+  lua_remove(L, -i);  /* remove table from the stack */
+  return n;
+}
+
+
+static int handle_script (lua_State *L, char **argv) {
   int status;
-  const char *fname;
-  int narg = getargs(L, argv, n);  /* collect arguments */
-  lua_setglobal(L, "arg");
-  fname = argv[n];
-  if (strcmp(fname, "-") == 0 && strcmp(argv[n-1], "--") != 0)
+  const char *fname = argv[0];
+  if (strcmp(fname, "-") == 0 && strcmp(argv[-1], "--") != 0)
     fname = NULL;  /* stdin */
   status = luaL_loadfile(L, fname);
-  lua_insert(L, -(narg+1));
-  if (status == LUA_OK)
-    status = docall(L, narg, LUA_MULTRET);
-  else
-    lua_pop(L, narg);
+  if (status == LUA_OK) {
+    int n = pushargs(L);  /* push arguments to script */
+    status = docall(L, n, LUA_MULTRET);
+  }
   return report(L, status);
 }
 
 
-/* check that argument has no extra characters at the end */
-#define noextrachars(x)		{if ((x)[2] != '\0') return -1;}
-
-
-/* indices of various argument indicators in array args */
-#define has_i		0	/* -i */
-#define has_v		1	/* -v */
-#define has_e		2	/* -e */
-#define has_E		3	/* -E */
 
-#define num_has		4	/* number of 'has_*' */
+/* bits of various argument indicators in 'args' */
+#define has_error	1	/* bad option */
+#define has_i		2	/* -i */
+#define has_v		4	/* -v */
+#define has_e		8	/* -e */
+#define has_E		16	/* -E */
 
-
-static int collectargs (char **argv, int *args) {
+/*
+** Traverses all arguments from 'argv', returning a mask with those
+** needed before running any Lua code (or an error code if it finds
+** any invalid argument). 'first' returns the first not-handled argument 
+** (either the script name or a bad argument in case of error).
+*/
+static int collectargs (char **argv, int *first) {
+  int args = 0;
   int i;
   for (i = 1; argv[i] != NULL; i++) {
+    *first = i;
     if (argv[i][0] != '-')  /* not an option? */
-        return i;
-    switch (argv[i][1]) {  /* option */
-      case '-':
-        noextrachars(argv[i]);
-        return (argv[i+1] != NULL ? i+1 : 0);
-      case '\0':
-        return i;
+        return args;  /* stop handling options */
+    switch (argv[i][1]) {  /* else check option */
+      case '-':  /* '--' */
+        if (argv[i][2] != '\0')  /* extra characters after '--'? */
+          return has_error;  /* invalid option */
+        *first = i + 1;
+        return args;
+      case '\0':  /* '-' */
+        return args;  /* script "name" is '-' */
       case 'E':
-        args[has_E] = 1;
+        if (argv[i][2] != '\0')  /* extra characters after 1st? */
+          return has_error;  /* invalid option */
+        args |= has_E;
         break;
       case 'i':
-        noextrachars(argv[i]);
-        args[has_i] = 1;  /* go through */
+        args |= has_i;  /* goes through  (-i implies -v) */
       case 'v':
-        noextrachars(argv[i]);
-        args[has_v] = 1;
+        if (argv[i][2] != '\0')  /* extra characters after 1st? */
+          return has_error;  /* invalid option */
+        args |= has_v;
         break;
       case 'e':
-        args[has_e] = 1;  /* go through */
+        args |= has_e;  /* go through */
       case 'l':  /* both options need an argument */
         if (argv[i][2] == '\0') {  /* no concatenated argument? */
           i++;  /* try next 'argv' */
           if (argv[i] == NULL || argv[i][0] == '-')
-            return -(i - 1);  /* no next argument or it is another option */
+            return has_error;  /* no next argument or it is another option */
         }
         break;
-      default:  /* invalid option; return its index... */
-        return -i;  /* ...as a negative value */
+      default:  /* invalid option */
+        return has_error;
     }
   }
-  return 0;
+  *first = i;  /* no script name */
+  return args;
 }
 
 
+/*
+** Processes options 'e' and 'l', which involve running Lua code.
+** Returns 0 if some code raises an error.
+*/
 static int runargs (lua_State *L, char **argv, int n) {
   int i;
   for (i = 1; i < n; i++) {
-    lua_assert(argv[i][0] == '-');
-    switch (argv[i][1]) {  /* option */
-      case 'e': {
-        const char *chunk = argv[i] + 2;
-        if (*chunk == '\0') chunk = argv[++i];
-        lua_assert(chunk != NULL);
-        if (dostring(L, chunk, "=(command line)") != LUA_OK)
-          return 0;
-        break;
-      }
-      case 'l': {
-        const char *filename = argv[i] + 2;
-        if (*filename == '\0') filename = argv[++i];
-        lua_assert(filename != NULL);
-        if (dolibrary(L, filename) != LUA_OK)
-          return 0;  /* stop if file fails */
-        break;
-      }
-      default: break;
+    int status;
+    int option = argv[i][1];
+    lua_assert(argv[i][0] == '-');  /* already checked */
+    if (option == 'e' || option == 'l') {
+      const char *extra = argv[i] + 2;  /* both options need an argument */
+      if (*extra == '\0') extra = argv[++i];
+      lua_assert(extra != NULL);
+      if (option == 'e')
+        status = dostring(L, extra, "=(command line)");
+      else
+        status = dolibrary(L, extra);
+      if (status != LUA_OK) return 0;
     }
   }
   return 1;
@@ -421,10 +532,10 @@
 
 
 static int handle_luainit (lua_State *L) {
-  const char *name = "=" LUA_INITVERSION;
+  const char *name = "=" LUA_INITVARVERSION;
   const char *init = getenv(name + 1);
   if (init == NULL) {
-    name = "=" LUA_INIT;
+    name = "=" LUA_INIT_VAR;
     init = getenv(name + 1);  /* try alternative name */
   }
   if (init == NULL) return LUA_OK;
@@ -435,40 +546,44 @@
 }
 
 
+/*
+** Main body of stand-alone interpreter (to be called in protected mode).
+** Reads the options and handles them all.
+*/
 static int pmain (lua_State *L) {
   int argc = (int)lua_tointeger(L, 1);
   char **argv = (char **)lua_touserdata(L, 2);
   int script;
-  int args[num_has];
-  args[has_i] = args[has_v] = args[has_e] = args[has_E] = 0;
+  int args = collectargs(argv, &script);
+  luaL_checkversion(L);  /* check that interpreter has correct version */
   if (argv[0] && argv[0][0]) progname = argv[0];
-  script = collectargs(argv, args);
-  if (script < 0) {  /* invalid arg? */
-    print_usage(argv[-script]);
+  if (args == has_error) {  /* bad arg? */
+    print_usage(argv[script]);  /* 'script' has index of bad arg. */
     return 0;
   }
-  if (args[has_v]) print_version();
-  if (args[has_E]) {  /* option '-E'? */
+  if (args & has_v)  /* option '-v'? */
+    print_version();
+  if (args & has_E) {  /* option '-E'? */
     lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
     lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
   }
-  /* open standard libraries */
-  luaL_checkversion(L);
-  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */
-  luaL_openlibs(L);  /* open libraries */
-  lua_gc(L, LUA_GCRESTART, 0);
-  if (!args[has_E] && handle_luainit(L) != LUA_OK)
-    return 0;  /* error running LUA_INIT */
-  /* execute arguments -e and -l */
-  if (!runargs(L, argv, (script > 0) ? script : argc)) return 0;
-  /* execute main script (if there is one) */
-  if (script && handle_script(L, argv, script) != LUA_OK) return 0;
-  if (args[has_i])  /* -i option? */
-    dotty(L);
-  else if (script == 0 && !args[has_e] && !args[has_v]) {  /* no arguments? */
-    if (lua_stdin_is_tty()) {
+  luaL_openlibs(L);  /* open standard libraries */
+  createargtable(L, argv, argc, script);  /* create table 'arg' */
+  if (!(args & has_E)) {  /* no option '-E'? */
+    if (handle_luainit(L) != LUA_OK)  /* run LUA_INIT */
+      return 0;  /* error running LUA_INIT */
+  }
+  if (!runargs(L, argv, script))  /* execute arguments -e and -l */
+    return 0;  /* something failed */
+  if (script < argc &&  /* execute main script (if there is one) */
+      handle_script(L, argv + script) != LUA_OK)
+    return 0;
+  if (args & has_i)  /* -i option? */
+    doREPL(L);  /* do read-eval-print loop */
+  else if (script == argc && !(args & (has_e | has_v))) {  /* no arguments? */
+    if (lua_stdin_is_tty()) {  /* running in interactive mode? */
       print_version();
-      dotty(L);
+      doREPL(L);  /* do read-eval-print loop */
     }
     else dofile(L, NULL);  /* executes stdin as a file */
   }
@@ -484,13 +599,12 @@
     l_message(argv[0], "cannot create state: not enough memory");
     return EXIT_FAILURE;
   }
-  /* call 'pmain' in protected mode */
-  lua_pushcfunction(L, &pmain);
+  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
   lua_pushinteger(L, argc);  /* 1st argument */
   lua_pushlightuserdata(L, argv); /* 2nd argument */
-  status = lua_pcall(L, 2, 1, 0);
+  status = lua_pcall(L, 2, 1, 0);  /* do the call */
   result = lua_toboolean(L, -1);  /* get result */
-  finalreport(L, status);
+  report(L, status);
   lua_close(L);
   return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
 }
diff -urN rpm-5.4.15/lua/luac.c rpm-5.4-cvs/lua/luac.c
--- rpm-5.4.15/lua/luac.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/luac.c	2015-04-18 23:34:19.000000000 -0500
@@ -1,17 +1,20 @@
 /*
-** $Id: luac.c,v 1.69 2011/11/29 17:46:33 lhf Exp $
-** Lua compiler (saves bytecodes to files; also list bytecodes)
+** $Id: luac.c,v 1.72 2015/01/06 03:09:13 lhf Exp $
+** Lua compiler (saves bytecodes to files; also lists bytecodes)
 ** See Copyright Notice in lua.h
 */
 
+#define luac_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
+#include <ctype.h>
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define luac_c
-#define LUA_CORE
-
 #include "lua.h"
 #include "lauxlib.h"
 
@@ -47,14 +50,14 @@
 static void usage(const char* message)
 {
  if (*message=='-')
-  fprintf(stderr,"%s: unrecognized option " LUA_QS "\n",progname,message);
+  fprintf(stderr,"%s: unrecognized option '%s'\n",progname,message);
  else
   fprintf(stderr,"%s: %s\n",progname,message);
  fprintf(stderr,
   "usage: %s [options] [filenames]\n"
   "Available options are:\n"
   "  -l       list (use -l -l for full listing)\n"
-  "  -o name  output to file " LUA_QL("name") " (default is \"%s\")\n"
+  "  -o name  output to file 'name' (default is \"%s\")\n"
   "  -p       parse only\n"
   "  -s       strip debug information\n"
   "  -v       show version information\n"
@@ -89,7 +92,7 @@
   {
    output=argv[++i];
    if (output==NULL || *output==0 || (*output=='-' && output[1]!=0))
-    usage(LUA_QL("-o") " needs argument");
+    usage("'-o' needs argument");
    if (IS("-")) output=NULL;
   }
   else if (IS("-p"))			/* parse only */
@@ -203,7 +206,7 @@
 }
 
 /*
-** $Id: print.c,v 1.68 2011/09/30 10:21:20 lhf Exp $
+** $Id: print.c,v 1.76 2015/01/05 16:12:50 lhf Exp $
 ** print bytecodes
 ** See Copyright Notice in lua.h
 */
@@ -223,7 +226,7 @@
 static void PrintString(const TString* ts)
 {
  const char* s=getstr(ts);
- size_t i,n=ts->tsv.len;
+ size_t i,n=ts->len;
  printf("%c",'"');
  for (i=0; i<n; i++)
  {
@@ -259,11 +262,19 @@
   case LUA_TBOOLEAN:
 	printf(bvalue(o) ? "true" : "false");
 	break;
-  case LUA_TNUMBER:
-	printf(LUA_NUMBER_FMT,nvalue(o));
+  case LUA_TNUMFLT:
+	{
+	char buff[100];
+	sprintf(buff,LUA_NUMBER_FMT,fltvalue(o));
+	printf("%s",buff);
+	if (buff[strspn(buff,"-0123456789")]=='\0') printf(".0");
+	break;
+	}
+  case LUA_TNUMINT:
+	printf(LUA_INTEGER_FMT,ivalue(o));
 	break;
-  case LUA_TSTRING:
-	PrintString(rawtsvalue(o));
+  case LUA_TSHRSTR: case LUA_TLNGSTR:
+	PrintString(tsvalue(o));
 	break;
   default:				/* cannot happen */
 	printf("? type=%d",ttype(o));
@@ -337,8 +348,14 @@
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
-   case OP_DIV:
    case OP_POW:
+   case OP_DIV:
+   case OP_IDIV:
+   case OP_BAND:
+   case OP_BOR:
+   case OP_BXOR:
+   case OP_SHL:
+   case OP_SHR:
    case OP_EQ:
    case OP_LT:
    case OP_LE:
diff -urN rpm-5.4.15/lua/luaconf.h rpm-5.4-cvs/lua/luaconf.h
--- rpm-5.4.15/lua/luaconf.h	2014-08-17 07:45:35.000000000 -0500
+++ rpm-5.4-cvs/lua/luaconf.h	2015-04-18 23:34:19.000000000 -0500
@@ -1,112 +1,187 @@
 /*
-** $Id: luaconf.h,v 1.176 2013/03/16 21:10:18 roberto Exp $
+** $Id: luaconf.h,v 1.238 2014/12/29 13:27:55 roberto Exp $
 ** Configuration file for Lua
 ** See Copyright Notice in lua.h
 */
 
 
-#ifndef lconfig_h
-#define lconfig_h
+#ifndef luaconf_h
+#define luaconf_h
 
 #include <limits.h>
 #include <stddef.h>
-#include <assert.h>
 
 
 /*
-** ==================================================================
+** ===================================================================
 ** Search for "@@" to find all configurable definitions.
 ** ===================================================================
 */
 
 
 /*
-@@ LUA_ANSI controls the use of non-ansi features.
-** CHANGE it (define it) if you want Lua to avoid the use of any
-** non-ansi feature or library.
+** {====================================================================
+** System Configuration: macros to adapt (if needed) Lua to some
+** particular platform, for instance compiling it with 32-bit numbers or
+** restricting it to C89.
+** =====================================================================
 */
-#if !defined(LUA_ANSI) && defined(__STRICT_ANSI__)
-#define LUA_ANSI
-#endif
 
+/*
+@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You
+** can also define LUA_32BITS in the make file, but changing here you
+** ensure that all software connected to Lua will be compiled with the
+** same configuration.
+*/
+/* #define LUA_32BITS */
+
+
+/*
+@@ LUA_USE_C89 controls the use of non-ISO-C89 features.
+** Define it if you want Lua to avoid the use of a few C99 features
+** or Windows-specific features on Windows.
+*/
+/* #define LUA_USE_C89 */
 
-#if !defined(LUA_ANSI) && defined(_WIN32) && !defined(_WIN32_WCE)
-#define LUA_WIN		/* enable goodies for regular Windows platforms */
-#endif
 
-#if defined(LUA_WIN)
-#define LUA_DL_DLL
-#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+/*
+** By default, Lua on Windows use (some) specific Windows features
+*/
+#if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)
+#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */
 #endif
 
 
+#if defined(LUA_USE_WINDOWS)
+#define LUA_DL_DLL	/* enable support for DLL */
+#define LUA_USE_C89	/* broadly, Windows is C89 */
+#endif
+
 
 #if defined(LUA_USE_LINUX)
 #define LUA_USE_POSIX
 #define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
 #define LUA_USE_READLINE	/* needs some extra libraries */
-#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
-#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
-#define LUA_USE_LONGLONG	/* assume support for long long */
 #endif
 
+
 #if defined(LUA_USE_MACOSX)
 #define LUA_USE_POSIX
-#define LUA_USE_DLOPEN		/* does not need -ldl */
+#define LUA_USE_DLOPEN		/* MacOS does not need -ldl */
 #define LUA_USE_READLINE	/* needs an extra library: -lreadline */
-#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
-#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
-#define LUA_USE_LONGLONG	/* assume support for long long */
 #endif
 
 
+/*
+@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for
+** C89 ('long' and 'double'); Windows always has '__int64', so it does
+** not need to use this case.
+*/
+#if defined(LUA_USE_C89) && !defined(LUA_USE_WINDOWS)
+#define LUA_C89_NUMBERS
+#endif
+
+
+
+/*
+@@ LUAI_BITSINT defines the (minimum) number of bits in an 'int'.
+*/
+/* avoid undefined shifts */
+#if ((INT_MAX >> 15) >> 15) >= 1
+#define LUAI_BITSINT	32
+#else
+/* 'int' always must have at least 16 bits */
+#define LUAI_BITSINT	16
+#endif
+
+
+/*
+@@ LUA_INT_INT / LUA_INT_LONG / LUA_INT_LONGLONG defines the type for
+** Lua integers.
+@@ LUA_REAL_FLOAT / LUA_REAL_DOUBLE / LUA_REAL_LONGDOUBLE defines
+** the type for Lua floats.
+** Lua should work fine with any mix of these options (if supported
+** by your C compiler). The usual configurations are 64-bit integers
+** and 'double' (the default), 32-bit integers and 'float' (for
+** restricted platforms), and 'long'/'double' (for C compilers not
+** compliant with C99, which may not have support for 'long long').
+*/
 
+#if defined(LUA_32BITS)		/* { */
 /*
-@@ LUA_USE_POSIX includes all functionality listed as X/Open System
-@* Interfaces Extension (XSI).
-** CHANGE it (define it) if your system is XSI compatible.
+** 32-bit integers and 'float'
 */
-#if defined(LUA_USE_POSIX)
-#define LUA_USE_MKSTEMP
-#define LUA_USE_ISATTY
-#define LUA_USE_POPEN
-#define LUA_USE_ULONGJMP
-#define LUA_USE_GMTIME_R
+#if LUAI_BITSINT >= 32  /* use 'int' if big enough */
+#define LUA_INT_INT
+#else  /* otherwise use 'long' */
+#define LUA_INT_LONG
 #endif
+#define LUA_REAL_FLOAT
+
+#elif defined(LUA_C89_NUMBERS)	/* }{ */
+/*
+** largest types available for C89 ('long' and 'double')
+*/
+#define LUA_INT_LONG
+#define LUA_REAL_DOUBLE
+
+#else				/* }{ */
+/*
+** default configuration for 64-bit Lua ('long long' and 'double')
+*/
+#define LUA_INT_LONGLONG
+#define LUA_REAL_DOUBLE
+
+#endif								/* } */
+
+/* }================================================================== */
 
 
 
+
+/*
+** {==================================================================
+** Configuration for Paths.
+** ===================================================================
+*/
+
 /*
 @@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
-@* Lua libraries.
+** Lua libraries.
 @@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
-@* C libraries.
+** C libraries.
 ** CHANGE them if your machine has a non-conventional directory
 ** hierarchy or if you want to install your libraries in
 ** non-conventional directories.
 */
-#if defined(_WIN32)	/* { */
+#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
+#if defined(_WIN32) 	/* { */
 /*
 ** In Windows, any exclamation mark ('!') in the path is replaced by the
 ** path of the directory of the executable file of the current process.
 */
 #define LUA_LDIR	"!\\lua\\"
 #define LUA_CDIR	"!\\"
+#define LUA_SHRDIR	"!\\..\\share\\lua\\" LUA_VDIR "\\"
 #define LUA_PATH_DEFAULT  \
 		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
-		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" ".\\?.lua"
+		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" \
+		LUA_SHRDIR"?.lua;" LUA_SHRDIR"?\\init.lua;" \
+		".\\?.lua;" ".\\?\\init.lua"
 #define LUA_CPATH_DEFAULT \
-		LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll;" ".\\?.dll"
+		LUA_CDIR"?.dll;" \
+		LUA_CDIR"..\\lib\\lua\\" LUA_VDIR "\\?.dll;" \
+		LUA_CDIR"loadall.dll;" ".\\?.dll"
 
 #else			/* }{ */
 
-#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR "/"
 #define LUA_ROOT	"/usr/local/"
-#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR
-#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR
+#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR "/"
+#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR "/"
 #define LUA_PATH_DEFAULT  \
 		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
-		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" "./?.lua"
+		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" \
+		"./?.lua;" "./?/init.lua"
 #define LUA_CPATH_DEFAULT \
 		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
 #endif			/* } */
@@ -123,14 +198,14 @@
 #define LUA_DIRSEP	"/"
 #endif
 
+/* }================================================================== */
+
 
 /*
-@@ LUA_ENV is the name of the variable that holds the current
-@@ environment, used to access global names.
-** CHANGE it if you do not like this name.
+** {==================================================================
+** Marks for exported symbols in the C code
+** ===================================================================
 */
-#define LUA_ENV		"_ENV"
-
 
 /*
 @@ LUA_API is a mark for all core API functions.
@@ -163,10 +238,10 @@
 
 /*
 @@ LUAI_FUNC is a mark for all extern functions that are not to be
-@* exported to outside modules.
+** exported to outside modules.
 @@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
-@* that are not to be exported to outside modules (LUAI_DDEF for
-@* definitions and LUAI_DDEC for declarations).
+** that are not to be exported to outside modules (LUAI_DDEF for
+** definitions and LUAI_DDEC for declarations).
 ** CHANGE them if you need to mark them in some special way. Elf/gcc
 ** (versions 3.2 and later) mark them as "hidden" to optimize access
 ** when Lua is compiled as a shared library. Not all elf targets support
@@ -178,75 +253,68 @@
 #if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
     defined(__ELF__)		/* { */
 #define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
-#define LUAI_DDEC	LUAI_FUNC
-#define LUAI_DDEF	/* empty */
-
 #else				/* }{ */
 #define LUAI_FUNC	extern
-#define LUAI_DDEC	extern
-#define LUAI_DDEF	/* empty */
 #endif				/* } */
 
+#define LUAI_DDEC	LUAI_FUNC
+#define LUAI_DDEF	/* empty */
+
+/* }================================================================== */
 
 
 /*
-@@ LUA_QL describes how error messages quote program elements.
-** CHANGE it if you want a different appearance.
+** {==================================================================
+** Compatibility with previous versions
+** ===================================================================
 */
-#define LUA_QL(x)	"'" x "'"
-#define LUA_QS		LUA_QL("%s")
-
 
 /*
-@@ LUA_IDSIZE gives the maximum size for the description of the source
-@* of a function in debug information.
-** CHANGE it if you want a different size.
+@@ LUA_COMPAT_5_2 controls other macros for compatibility with Lua 5.2.
+@@ LUA_COMPAT_5_1 controls other macros for compatibility with Lua 5.1.
+** You can define it to get all options, or change specific options
+** to fit your specific needs.
 */
-#define LUA_IDSIZE	60
-
+#define	LUA_COMPAT_5_2	1
+#if defined(LUA_COMPAT_5_2)	/* { */
 
 /*
-@@ luai_writestring/luai_writeline define how 'print' prints its results.
-** They are only used in libraries and the stand-alone program. (The #if
-** avoids including 'stdio.h' everywhere.)
+@@ LUA_COMPAT_MATHLIB controls the presence of several deprecated
+** functions in the mathematical library.
 */
-#if defined(LUA_LIB) || defined(lua_c)
-#include <stdio.h>
-#define luai_writestring(s,l) \
-	assert(fwrite((s), sizeof(char), (l), stdout) == (l))
-#define luai_writeline()	(luai_writestring("\n", 1), fflush(stdout))
-#endif
+#define LUA_COMPAT_MATHLIB
 
 /*
-@@ luai_writestringerror defines how to print error messages.
-** (A format string with one argument is enough for Lua...)
+@@ LUA_COMPAT_BITLIB controls the presence of library 'bit32'.
 */
-#define luai_writestringerror(s,p) \
-	(fprintf(stderr, (s), (p)), fflush(stderr))
-
+#define LUA_COMPAT_BITLIB
 
 /*
-@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
-** strings that are internalized. (Cannot be smaller than reserved words
-** or tags for metamethods, as these strings must be internalized;
-** #("function") = 8, #("__newindex") = 10.)
+@@ LUA_COMPAT_IPAIRS controls the effectiveness of the __ipairs metamethod.
 */
-#define LUAI_MAXSHORTLEN        40
-
-
+#define LUA_COMPAT_IPAIRS
 
 /*
-** {==================================================================
-** Compatibility with previous versions
-** ===================================================================
+@@ LUA_COMPAT_APIINTCASTS controls the presence of macros for
+** manipulating other integer types (lua_pushunsigned, lua_tounsigned,
+** luaL_checkint, luaL_checklong, etc.)
 */
+#define LUA_COMPAT_APIINTCASTS
+
 
 /*
-@@ LUA_COMPAT_ALL controls all compatibility options.
-** You can define it to get all options, or change specific options
-** to fit your specific needs.
+@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a
+@@ a float mark ('.0').
+** This macro is not on by default even in compatibility mode,
+** because this is not really an incompatibility.
 */
-#if defined(LUA_COMPAT_ALL)	/* { */
+/* #define LUA_COMPAT_FLOATSTRING */
+
+#endif				/* } */
+
+
+#define	LUA_COMPAT_5_1	1
+#if defined(LUA_COMPAT_5_1)	/* { */
 
 /*
 @@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
@@ -312,131 +380,119 @@
 
 
 /*
-@@ LUAI_BITSINT defines the number of bits in an int.
-** CHANGE here if Lua cannot automatically detect the number of bits of
-** your machine. Probably you do not need to change this.
+** {==================================================================
+** Configuration for Numbers.
+** Change these definitions if no predefined LUA_REAL_* / LUA_INT_*
+** satisfy your needs.
+** ===================================================================
 */
-/* avoid overflows in comparison */
-#if INT_MAX-20 < 32760		/* { */
-#define LUAI_BITSINT	16
-#elif INT_MAX > 2147483640L	/* }{ */
-/* int has at least 32 bits */
-#define LUAI_BITSINT	32
-#else				/* }{ */
-#error "you must define LUA_BITSINT with number of bits in an integer"
-#endif				/* } */
-
 
 /*
-@@ LUA_INT32 is an signed integer with exactly 32 bits.
-@@ LUAI_UMEM is an unsigned integer big enough to count the total
-@* memory used by Lua.
-@@ LUAI_MEM is a signed integer big enough to count the total memory
-@* used by Lua.
-** CHANGE here if for some weird reason the default definitions are not
-** good enough for your machine. Probably you do not need to change
-** this.
-*/
-#if LUAI_BITSINT >= 32		/* { */
-#define LUA_INT32	int
-#define LUAI_UMEM	size_t
-#define LUAI_MEM	ptrdiff_t
-#else				/* }{ */
-/* 16-bit ints */
-#define LUA_INT32	long
-#define LUAI_UMEM	unsigned long
-#define LUAI_MEM	long
-#endif				/* } */
+@@ LUA_NUMBER is the floating-point type used by Lua.
+**
+@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
+@@ over a floating number.
+**
+@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.
+@@ LUA_NUMBER_FMT is the format for writing floats.
+@@ lua_number2str converts a float to a string.
+**
+@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.
+**
+@@ lua_str2number converts a decimal numeric string to a number.
+*/
 
+#if defined(LUA_REAL_FLOAT)		/* { single float */
 
-/*
-@@ LUAI_MAXSTACK limits the size of the Lua stack.
-** CHANGE it if you need a different limit. This limit is arbitrary;
-** its only purpose is to stop Lua to consume unlimited stack
-** space (and to reserve some numbers for pseudo-indices).
-*/
-#if LUAI_BITSINT >= 32
-#define LUAI_MAXSTACK		1000000
-#else
-#define LUAI_MAXSTACK		15000
-#endif
+#define LUA_NUMBER	float
 
-/* reserve some space for error handling */
-#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)
+#define LUAI_UACNUMBER	double
 
+#define LUA_NUMBER_FRMLEN	""
+#define LUA_NUMBER_FMT		"%.7g"
 
+#define l_mathop(op)		op##f
 
+#define lua_str2number(s,p)	strtof((s), (p))
 
-/*
-@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
-** CHANGE it if it uses too much C-stack space.
-*/
-#define LUAL_BUFFERSIZE		BUFSIZ
 
+#elif defined(LUA_REAL_LONGDOUBLE)	/* }{ long double */
 
+#define LUA_NUMBER	long double
 
+#define LUAI_UACNUMBER	long double
 
-/*
-** {==================================================================
-@@ LUA_NUMBER is the type of numbers in Lua.
-** CHANGE the following definitions only if you want to build Lua
-** with a number type different from double. You may also need to
-** change lua_number2int & lua_number2integer.
-** ===================================================================
-*/
+#define LUA_NUMBER_FRMLEN	"L"
+#define LUA_NUMBER_FMT		"%.19Lg"
+
+#define l_mathop(op)		op##l
+
+#define lua_str2number(s,p)	strtold((s), (p))
+
+#elif defined(LUA_REAL_DOUBLE)		/* }{ double */
 
-#define LUA_NUMBER_DOUBLE
 #define LUA_NUMBER	double
 
-/*
-@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
-@* over a number.
-*/
 #define LUAI_UACNUMBER	double
 
-
-/*
-@@ LUA_NUMBER_SCAN is the format for reading numbers.
-@@ LUA_NUMBER_FMT is the format for writing numbers.
-@@ lua_number2str converts a number to a string.
-@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
-*/
-#define LUA_NUMBER_SCAN		"%lf"
+#define LUA_NUMBER_FRMLEN	""
 #define LUA_NUMBER_FMT		"%.14g"
-#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
-#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
 
+#define l_mathop(op)		op
 
-/*
-@@ l_mathop allows the addition of an 'l' or 'f' to all math operations
-*/
-#define l_mathop(x)		(x)
+#define lua_str2number(s,p)	strtod((s), (p))
 
+#else					/* }{ */
 
-/*
-@@ lua_str2number converts a decimal numeric string to a number.
-@@ lua_strx2number converts an hexadecimal numeric string to a number.
-** In C99, 'strtod' does both conversions. C89, however, has no function
-** to convert floating hexadecimal strings to numbers. For these
-** systems, you can leave 'lua_strx2number' undefined and Lua will
-** provide its own implementation.
-*/
-#define lua_str2number(s,p)	strtod((s), (p))
+#error "numeric real type not defined"
+
+#endif					/* } */
+
+
+#define l_floor(x)		(l_mathop(floor)(x))
+
+#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
 
-#if defined(LUA_USE_STRTODHEX)
-#define lua_strx2number(s,p)	strtod((s), (p))
-#endif
+
+/*
+@@ lua_numbertointeger converts a float number to an integer, or
+** returns 0 if float is not within the range of a lua_Integer.
+** (The range comparisons are tricky because of rounding. The tests
+** here assume a two-complement representation, where MININTEGER always
+** has an exact representation as a float; MAXINTEGER may not have one,
+** and therefore its conversion to float may have an ill-defined value.)
+*/
+#define lua_numbertointeger(n,p) \
+  ((n) >= (LUA_NUMBER)(LUA_MININTEGER) && \
+   (n) < -(LUA_NUMBER)(LUA_MININTEGER) && \
+      (*(p) = (LUA_INTEGER)(n), 1))
 
 
 /*
 @@ The luai_num* macros define the primitive operations over numbers.
+** They should work for any size of floating numbers.
 */
 
 /* the following operations need the math library */
 #if defined(lobject_c) || defined(lvm_c)
 #include <math.h>
-#define luai_nummod(L,a,b)	((a) - l_mathop(floor)((a)/(b))*(b))
-#define luai_numpow(L,a,b)	(l_mathop(pow)(a,b))
+
+/* floor division (defined as 'floor(a/b)') */
+#define luai_numidiv(L,a,b)	((void)L, l_mathop(floor)(luai_numdiv(L,a,b)))
+
+/*
+** module: defined as 'a - floor(a/b)*b'; the previous definition gives
+** NaN when 'b' is huge, but the result should be 'a'. 'fmod' gives the
+** result of 'a - trunc(a/b)*b', and therefore must be corrected when
+** 'trunc(a/b) ~= floor(a/b)'. That happens when the division has a
+** non-integer negative result, which is equivalent to the test below
+*/
+#define luai_nummod(L,a,b,m)  \
+  { (m) = l_mathop(fmod)(a,b); if ((m)*(b) < 0) (m) += (b); }
+
+/* exponentiation */
+#define luai_numpow(L,a,b)	((void)L, l_mathop(pow)(a,b))
+
 #endif
 
 /* these are quite standard operations */
@@ -447,97 +503,223 @@
 #define luai_numdiv(L,a,b)	((a)/(b))
 #define luai_numunm(L,a)	(-(a))
 #define luai_numeq(a,b)		((a)==(b))
-#define luai_numlt(L,a,b)	((a)<(b))
-#define luai_numle(L,a,b)	((a)<=(b))
-#define luai_numisnan(L,a)	(!luai_numeq((a), (a)))
+#define luai_numlt(a,b)		((a)<(b))
+#define luai_numle(a,b)		((a)<=(b))
+#define luai_numisnan(a)	(!luai_numeq((a), (a)))
 #endif
 
 
+/*
+@@ LUA_INTEGER is the integer type used by Lua.
+**
+@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.
+**
+@@ LUAI_UACINT is the result of an 'usual argument conversion'
+@@ over a lUA_INTEGER.
+@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.
+@@ LUA_INTEGER_FMT is the format for writing integers.
+@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.
+@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.
+@@ lua_integer2str converts an integer to a string.
+*/
+
+
+/* The following definitions are good for most cases here */
+
+#define LUA_INTEGER_FMT		"%" LUA_INTEGER_FRMLEN "d"
+#define lua_integer2str(s,n)	sprintf((s), LUA_INTEGER_FMT, (n))
+
+#define LUAI_UACINT		LUA_INTEGER
 
 /*
-@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
-** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
-** machines, ptrdiff_t gives a good choice between int or long.)
+** use LUAI_UACINT here to avoid problems with promotions (which
+** can turn a comparison between unsigneds into a signed comparison)
 */
-#define LUA_INTEGER	ptrdiff_t
+#define LUA_UNSIGNED		unsigned LUAI_UACINT
+
+
+/* now the variable definitions */
+
+#if defined(LUA_INT_INT)		/* { int */
+
+#define LUA_INTEGER		int
+#define LUA_INTEGER_FRMLEN	""
+
+#define LUA_MAXINTEGER		INT_MAX
+#define LUA_MININTEGER		INT_MIN
+
+#elif defined(LUA_INT_LONG)	/* }{ long */
+
+#define LUA_INTEGER		long
+#define LUA_INTEGER_FRMLEN	"l"
+
+#define LUA_MAXINTEGER		LONG_MAX
+#define LUA_MININTEGER		LONG_MIN
+
+#elif defined(LUA_INT_LONGLONG)	/* }{ long long */
+
+#if defined(LLONG_MAX)		/* { */
+/* use ISO C99 stuff */
+
+#define LUA_INTEGER		long long
+#define LUA_INTEGER_FRMLEN	"ll"
+
+#define LUA_MAXINTEGER		LLONG_MAX
+#define LUA_MININTEGER		LLONG_MIN
+
+#elif defined(LUA_USE_WINDOWS) /* }{ */
+/* in Windows, can use specific Windows types */
+
+#define LUA_INTEGER		__int64
+#define LUA_INTEGER_FRMLEN	"I64"
+
+#define LUA_MAXINTEGER		_I64_MAX
+#define LUA_MININTEGER		_I64_MIN
+
+#else				/* }{ */
+
+#error "Compiler does not support 'long long'. Use option '-DLUA_32BITS' \
+  or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)"
+
+#endif				/* } */
+
+#else				/* }{ */
+
+#error "numeric integer type not defined"
+
+#endif				/* } */
+
+/* }================================================================== */
+
 
 /*
-@@ LUA_UNSIGNED is the integral type used by lua_pushunsigned/lua_tounsigned.
-** It must have at least 32 bits.
+** {==================================================================
+** Dependencies with C99
+** ===================================================================
 */
-#define LUA_UNSIGNED	unsigned LUA_INT32
 
+/*
+@@ lua_strx2number converts an hexadecimal numeric string to a number.
+** In C99, 'strtod' does both conversions. Otherwise, you can
+** leave 'lua_strx2number' undefined and Lua will provide its own
+** implementation.
+*/
+#if !defined(LUA_USE_C89)
+#define lua_strx2number(s,p)	lua_str2number(s,p)
+#endif
 
 
 /*
-** Some tricks with doubles
+@@ LUA_USE_AFORMAT allows '%a'/'%A' specifiers in 'string.format'
+** Enable it if the C function 'printf' supports these specifiers.
+** (C99 demands it and Windows also supports it.)
 */
+#if !defined(LUA_USE_C89) || defined(LUA_USE_WINDOWS)
+#define LUA_USE_AFORMAT
+#endif
+
 
-#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI)	/* { */
 /*
-** The next definitions activate some tricks to speed up the
-** conversion from doubles to integer types, mainly to LUA_UNSIGNED.
-**
-@@ LUA_MSASMTRICK uses Microsoft assembler to avoid clashes with a
-** DirectX idiosyncrasy.
-**
-@@ LUA_IEEE754TRICK uses a trick that should work on any machine
-** using IEEE754 with a 32-bit integer type.
-**
-@@ LUA_IEEELL extends the trick to LUA_INTEGER; should only be
-** defined when LUA_INTEGER is a 32-bit integer.
-**
-@@ LUA_IEEEENDIAN is the endianness of doubles in your machine
-** (0 for little endian, 1 for big endian); if not defined, Lua will
-** check it dynamically for LUA_IEEE754TRICK (but not for LUA_NANTRICK).
-**
-@@ LUA_NANTRICK controls the use of a trick to pack all types into
-** a single double value, using NaN values to represent non-number
-** values. The trick only works on 32-bit machines (ints and pointers
-** are 32-bit values) with numbers represented as IEEE 754-2008 doubles
-** with conventional endianess (12345678 or 87654321), in CPUs that do
-** not produce signaling NaN values (all NaNs are quiet).
+** 'strtof' and 'opf' variants for math functions are not valid in
+** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the
+** availability of these variants. ('math.h' is already included in
+** all files that use these macros.)
 */
+#if defined(LUA_USE_C89) || (defined(HUGE_VAL) && !defined(HUGE_VALF))
+#undef l_mathop  /* variants not available */
+#undef lua_str2number
+#define l_mathop(op)		(lua_Number)op  /* no variant */
+#define lua_str2number(s,p)	((lua_Number)strtod((s), (p)))
+#endif
 
-/* Microsoft compiler on a Pentium (32 bit) ? */
-#if defined(LUA_WIN) && defined(_MSC_VER) && defined(_M_IX86)	/* { */
 
-#define LUA_MSASMTRICK
-#define LUA_IEEEENDIAN		0
-#define LUA_NANTRICK
+/*
+@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation
+** functions.  It must be a numerical type; Lua will use 'intptr_t' if
+** available, otherwise it will use 'ptrdiff_t' (the nearest thing to
+** 'intptr_t' in C89)
+*/
+#define LUA_KCONTEXT	ptrdiff_t
 
+#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \
+    __STDC_VERSION__ >= 199901L
+#include <stdint.h>
+#if defined (INTPTR_MAX)  /* even in C99 this type is optional */
+#undef LUA_KCONTEXT
+#define LUA_KCONTEXT	intptr_t
+#endif
+#endif
 
-/* pentium 32 bits? */
-#elif defined(__i386__) || defined(__i386) || defined(__X86__) /* }{ */
+/* }================================================================== */
 
-#define LUA_IEEE754TRICK
-#define LUA_IEEELL
-#define LUA_IEEEENDIAN		0
-#define LUA_NANTRICK
 
-/* pentium 64 bits? */
-#elif defined(__x86_64)						/* }{ */
+/*
+** {==================================================================
+** Macros that affect the API and must be stable (that is, must be the
+** same when you compile Lua and when you compile code that links to
+** Lua). You probably do not want/need to change them.
+** =====================================================================
+*/
 
-#define LUA_IEEE754TRICK
-#define LUA_IEEEENDIAN		0
+/*
+@@ LUAI_MAXSTACK limits the size of the Lua stack.
+** CHANGE it if you need a different limit. This limit is arbitrary;
+** its only purpose is to stop Lua from consuming unlimited stack
+** space (and to reserve some numbers for pseudo-indices).
+*/
+#if LUAI_BITSINT >= 32
+#define LUAI_MAXSTACK		1000000
+#else
+#define LUAI_MAXSTACK		15000
+#endif
 
-#elif defined(__POWERPC__) || defined(__ppc__)			/* }{ */
+/* reserve some space for error handling */
+#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)
 
-#define LUA_IEEE754TRICK
-#define LUA_IEEEENDIAN		1
 
-#else								/* }{ */
+/*
+@@ LUA_EXTRASPACE defines the size of a raw memory area associated with
+** a Lua state with very fast access.
+** CHANGE it if you need a different size.
+*/
+#define LUA_EXTRASPACE		(sizeof(void *))
 
-/* assume IEEE754 and a 32-bit integer type */
-#define LUA_IEEE754TRICK
 
-#endif								/* } */
+/*
+@@ LUA_IDSIZE gives the maximum size for the description of the source
+@@ of a function in debug information.
+** CHANGE it if you want a different size.
+*/
+#define LUA_IDSIZE	60
+
+
+/*
+@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
+** strings that are internalized. (Cannot be smaller than reserved words
+** or tags for metamethods, as these strings must be internalized;
+** #("function") = 8, #("__newindex") = 10.)
+*/
+#define LUAI_MAXSHORTLEN        40
 
-#endif							/* } */
+
+/*
+@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
+** CHANGE it if it uses too much C-stack space.
+*/
+#define LUAL_BUFFERSIZE	((int)(0x80 * sizeof(void*) * sizeof(lua_Integer)))
 
 /* }================================================================== */
 
 
+/*
+@@ LUA_QL describes how error messages quote program elements.
+** Lua does not use these macros anymore; they are here for
+** compatibility only.
+*/
+#define LUA_QL(x)	"'" x "'"
+#define LUA_QS		LUA_QL("%s")
+
+
 
 
 /* =================================================================== */
@@ -548,6 +730,115 @@
 */
 
 
+/*
+ * Miscellaneous utility macros:
+ * - portability wrappers for various gcc extensions like __attribute__()
+ * - ...
+ *
+ * Copied from glib, names replaced to avoid clashing with glib.
+ *
+ */
+
+/* Here we provide LUA_GNUC_EXTENSION as an alias for __extension__,
+ * where this is valid. This allows for warningless compilation of
+ * "long long" types even in the presence of '-ansi -pedantic'. 
+ */
+#if     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)
+#  define LUA_GNUC_EXTENSION __extension__
+#else
+#  define LUA_GNUC_EXTENSION
+#endif
+
+/* Provide macros to feature the GCC function attribute.
+ */
+#if    __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+#define LUA_GNUC_PURE                            \
+  __attribute__((__pure__))
+#define LUA_GNUC_MALLOC    			\
+  __attribute__((__malloc__))
+#else
+#define LUA_GNUC_PURE
+#define LUA_GNUC_MALLOC
+#endif
+
+#if     (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
+#define LUA_GNUC_ALLOC_SIZE(x) __attribute__((__alloc_size__(x)))
+#define LUA_GNUC_ALLOC_SIZE2(x,y) __attribute__((__alloc_size__(x,y)))
+#else
+#define LUA_GNUC_ALLOC_SIZE(x)
+#define LUA_GNUC_ALLOC_SIZE2(x,y)
+#endif
+
+#if     __GNUC__ >= 4
+#define LUA_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
+#else
+#define LUA_GNUC_NULL_TERMINATED
+#endif
+
+#if     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define LUA_GNUC_PRINTF( format_idx, arg_idx )    \
+  __attribute__((__format__ (__printf__, format_idx, arg_idx)))
+#define LUA_GNUC_SCANF( format_idx, arg_idx )     \
+  __attribute__((__format__ (__scanf__, format_idx, arg_idx)))
+#define LUA_GNUC_FORMAT( arg_idx )                \
+  __attribute__((__format_arg__ (arg_idx)))
+#define LUA_GNUC_NORETURN                         \
+  __attribute__((__noreturn__))
+#define LUA_GNUC_CONST                            \
+  __attribute__((__const__))
+#define LUA_GNUC_UNUSED                           \
+  __attribute__((__unused__))
+#define LUA_GNUC_NO_INSTRUMENT			\
+  __attribute__((__no_instrument_function__))
+#else   /* !__GNUC__ */
+#define LUA_GNUC_PRINTF( format_idx, arg_idx )
+#define LUA_GNUC_SCANF( format_idx, arg_idx )
+#define LUA_GNUC_FORMAT( arg_idx )
+#define LUA_GNUC_NORETURN
+#define LUA_GNUC_CONST
+#define LUA_GNUC_UNUSED
+#define LUA_GNUC_NO_INSTRUMENT
+#endif  /* !__GNUC__ */
+
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
+#define LUA_GNUC_DEPRECATED                            \
+  __attribute__((__deprecated__))
+#else
+#define LUA_GNUC_DEPRECATED
+#endif /* __GNUC__ */
+
+#if     __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
+#define LUA_GNUC_MAY_ALIAS __attribute__((may_alias))
+#define LUA_GNUC_NONNULL( ... )	\
+  __attribute__((__nonnull__ (__VA_ARGS__)))
+#else
+#define LUA_GNUC_MAY_ALIAS
+#define LUA_GNUC_NONNULL( ... )
+#endif
+
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#define LUA_GNUC_WARN_UNUSED_RESULT 		\
+  __attribute__((warn_unused_result))
+#else
+#define LUA_GNUC_WARN_UNUSED_RESULT
+#endif /* __GNUC__ */
+
+#if    __GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
+#  define LUA_GNUC_INTERNAL __attribute__((visibility("hidden")))
+#else
+#  define LUA_GNUC_INTERNAL
+#endif
+
+
+/* Guard C code in headers, while including them from C++ */
+#ifdef  __cplusplus
+# define LUA_BEGIN_DECLS  extern "C" {
+# define LUA_END_DECLS    }
+#else
+# define LUA_BEGIN_DECLS
+# define LUA_END_DECLS
+#endif
+
 
 #endif
 
diff -urN rpm-5.4.15/lua/lua.h rpm-5.4-cvs/lua/lua.h
--- rpm-5.4.15/lua/lua.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lua.h	2015-04-18 23:34:19.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lua.h,v 1.285 2013/03/15 13:04:22 roberto Exp $
+** $Id: lua.h,v 1.325 2014/12/26 17:24:27 roberto Exp $
 ** Lua - A Scripting Language
 ** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
 ** See Copyright Notice at the end of this file
@@ -17,18 +17,18 @@
 
 
 #define LUA_VERSION_MAJOR	"5"
-#define LUA_VERSION_MINOR	"2"
-#define LUA_VERSION_NUM		502
-#define LUA_VERSION_RELEASE	"2"
+#define LUA_VERSION_MINOR	"3"
+#define LUA_VERSION_NUM		503
+#define LUA_VERSION_RELEASE	"0"
 
 #define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
 #define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
-#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2013 Lua.org, PUC-Rio"
+#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2015 Lua.org, PUC-Rio"
 #define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
 
 
 /* mark for precompiled code ('<esc>Lua') */
-#define LUA_SIGNATURE	"\033Lua"
+#define LUA_SIGNATURE	"\x1bLua"
 
 /* option for multiple returns in 'lua_pcall' and 'lua_call' */
 #define LUA_MULTRET	(-1)
@@ -53,22 +53,6 @@
 
 typedef struct lua_State lua_State;
 
-typedef int (*lua_CFunction) (lua_State *L);
-
-
-/*
-** functions that read/write blocks when loading/dumping Lua chunks
-*/
-typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
-
-typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);
-
-
-/*
-** prototype for memory-allocation functions
-*/
-typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
-
 
 /*
 ** basic types
@@ -109,6 +93,34 @@
 /* unsigned integer type */
 typedef LUA_UNSIGNED lua_Unsigned;
 
+/* type for continuation-function contexts */
+typedef LUA_KCONTEXT lua_KContext;
+
+
+/*
+** Type for C functions registered with Lua
+*/
+typedef int (*lua_CFunction) (lua_State *L);
+
+/*
+** Type for continuation functions
+*/
+typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);
+
+
+/*
+** Type for functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);
+
+
+/*
+** Type for memory-allocation functions
+*/
+typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
+
 
 
 /*
@@ -135,21 +147,22 @@
 LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);
 
 
-LUA_API const lua_Number *(lua_version) (lua_State *L);
+LUA_API const lua_Number *(lua_version) (lua_State *L)
+	LUA_GNUC_PURE;
 
 
 /*
 ** basic stack manipulation
 */
-LUA_API int   (lua_absindex) (lua_State *L, int idx);
-LUA_API int   (lua_gettop) (lua_State *L);
+LUA_API int   (lua_absindex) (lua_State *L, int idx)
+	LUA_GNUC_PURE;
+LUA_API int   (lua_gettop) (lua_State *L)
+	LUA_GNUC_PURE;
 LUA_API void  (lua_settop) (lua_State *L, int idx);
 LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
-LUA_API void  (lua_remove) (lua_State *L, int idx);
-LUA_API void  (lua_insert) (lua_State *L, int idx);
-LUA_API void  (lua_replace) (lua_State *L, int idx);
+LUA_API void  (lua_rotate) (lua_State *L, int idx, int n);
 LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
-LUA_API int   (lua_checkstack) (lua_State *L, int sz);
+LUA_API int   (lua_checkstack) (lua_State *L, int n);
 
 LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);
 
@@ -159,35 +172,54 @@
 */
 
 LUA_API int             (lua_isnumber) (lua_State *L, int idx);
-LUA_API int             (lua_isstring) (lua_State *L, int idx);
-LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
-LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
-LUA_API int             (lua_type) (lua_State *L, int idx);
-LUA_API const char     *(lua_typename) (lua_State *L, int tp);
+LUA_API int             (lua_isstring) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API int             (lua_iscfunction) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API int             (lua_isinteger) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API int             (lua_isuserdata) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API int             (lua_type) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API const char     *(lua_typename) (lua_State *L, int tp)
+				LUA_GNUC_CONST;
 
 LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
 LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
-LUA_API lua_Unsigned    (lua_tounsignedx) (lua_State *L, int idx, int *isnum);
-LUA_API int             (lua_toboolean) (lua_State *L, int idx);
+LUA_API int             (lua_toboolean) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
 LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
-LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
-LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
-LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
-LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
-LUA_API const void     *(lua_topointer) (lua_State *L, int idx);
+LUA_API size_t          (lua_rawlen) (lua_State *L, int idx)
+	LUA_GNUC_PURE;
+LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API void	       *(lua_touserdata) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
+LUA_API const void     *(lua_topointer) (lua_State *L, int idx)
+				LUA_GNUC_PURE;
 
 
 /*
 ** Comparison and arithmetic functions
 */
 
-#define LUA_OPADD	0	/* ORDER TM */
+#define LUA_OPADD	0	/* ORDER TM, ORDER OP */
 #define LUA_OPSUB	1
 #define LUA_OPMUL	2
-#define LUA_OPDIV	3
-#define LUA_OPMOD	4
-#define LUA_OPPOW	5
-#define LUA_OPUNM	6
+#define LUA_OPMOD	3
+#define LUA_OPPOW	4
+#define LUA_OPDIV	5
+#define LUA_OPIDIV	6
+#define LUA_OPBAND	7
+#define LUA_OPBOR	8
+#define LUA_OPBXOR	9
+#define LUA_OPSHL	10
+#define LUA_OPSHR	11
+#define LUA_OPUNM	12
+#define LUA_OPBNOT	13
 
 LUA_API void  (lua_arith) (lua_State *L, int op);
 
@@ -205,8 +237,7 @@
 LUA_API void        (lua_pushnil) (lua_State *L);
 LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
 LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
-LUA_API void        (lua_pushunsigned) (lua_State *L, lua_Unsigned n);
-LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t l);
+LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len);
 LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
 LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                       va_list argp);
@@ -220,26 +251,29 @@
 /*
 ** get functions (Lua -> stack)
 */
-LUA_API void  (lua_getglobal) (lua_State *L, const char *var);
-LUA_API void  (lua_gettable) (lua_State *L, int idx);
-LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
-LUA_API void  (lua_rawget) (lua_State *L, int idx);
-LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
-LUA_API void  (lua_rawgetp) (lua_State *L, int idx, const void *p);
+LUA_API int (lua_getglobal) (lua_State *L, const char *name);
+LUA_API int (lua_gettable) (lua_State *L, int idx);
+LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);
+LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);
+LUA_API int (lua_rawget) (lua_State *L, int idx);
+LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);
+LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);
+
 LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
 LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
 LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
-LUA_API void  (lua_getuservalue) (lua_State *L, int idx);
+LUA_API int  (lua_getuservalue) (lua_State *L, int idx);
 
 
 /*
 ** set functions (stack -> Lua)
 */
-LUA_API void  (lua_setglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_setglobal) (lua_State *L, const char *name);
 LUA_API void  (lua_settable) (lua_State *L, int idx);
 LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);
 LUA_API void  (lua_rawset) (lua_State *L, int idx);
-LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);
 LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
 LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
 LUA_API void  (lua_setuservalue) (lua_State *L, int idx);
@@ -248,31 +282,33 @@
 /*
 ** 'load' and 'call' functions (load and run Lua code)
 */
-LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults, int ctx,
-                           lua_CFunction k);
+LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults,
+                           lua_KContext ctx, lua_KFunction k);
 #define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)
 
-LUA_API int   (lua_getctx) (lua_State *L, int *ctx);
-
 LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
-                            int ctx, lua_CFunction k);
+                            lua_KContext ctx, lua_KFunction k);
 #define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)
 
 LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
-                                        const char *chunkname,
-                                        const char *mode);
+                          const char *chunkname, const char *mode);
 
-LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);
+LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip);
 
 
 /*
 ** coroutine functions
 */
-LUA_API int  (lua_yieldk) (lua_State *L, int nresults, int ctx,
-                           lua_CFunction k);
+LUA_API int  (lua_yieldk)     (lua_State *L, int nresults, lua_KContext ctx,
+                               lua_KFunction k);
+LUA_API int  (lua_resume)     (lua_State *L, lua_State *from, int narg);
+LUA_API int  (lua_status)     (lua_State *L)
+	LUA_GNUC_PURE;
+LUA_API int (lua_isyieldable) (lua_State *L)
+	LUA_GNUC_PURE;
+
 #define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)
-LUA_API int  (lua_resume) (lua_State *L, lua_State *from, int narg);
-LUA_API int  (lua_status) (lua_State *L);
+
 
 /*
 ** garbage-collection function and options
@@ -286,10 +322,7 @@
 #define LUA_GCSTEP		5
 #define LUA_GCSETPAUSE		6
 #define LUA_GCSETSTEPMUL	7
-#define LUA_GCSETMAJORINC	8
 #define LUA_GCISRUNNING		9
-#define LUA_GCGEN		10
-#define LUA_GCINC		11
 
 LUA_API int (lua_gc) (lua_State *L, int what, int data);
 
@@ -298,27 +331,31 @@
 ** miscellaneous functions
 */
 
-LUA_API int   (lua_error) (lua_State *L);
+LUA_API int   (lua_error) (lua_State *L)
+	LUA_GNUC_NORETURN;
 
 LUA_API int   (lua_next) (lua_State *L, int idx);
 
 LUA_API void  (lua_concat) (lua_State *L, int n);
 LUA_API void  (lua_len)    (lua_State *L, int idx);
 
+LUA_API size_t   (lua_stringtonumber) (lua_State *L, const char *s);
+
 LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
 LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);
 
 
 
 /*
-** ===============================================================
+** {==============================================================
 ** some useful macros
 ** ===============================================================
 */
 
-#define lua_tonumber(L,i)	lua_tonumberx(L,i,NULL)
-#define lua_tointeger(L,i)	lua_tointegerx(L,i,NULL)
-#define lua_tounsigned(L,i)	lua_tounsignedx(L,i,NULL)
+#define lua_getextraspace(L)	((void *)((char *)(L) - LUA_EXTRASPACE))
+
+#define lua_tonumber(L,i)	lua_tonumberx(L,(i),NULL)
+#define lua_tointeger(L,i)	lua_tointegerx(L,(i),NULL)
 
 #define lua_pop(L,n)		lua_settop(L, -(n)-1)
 
@@ -346,6 +383,28 @@
 #define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)
 
 
+#define lua_insert(L,idx)	lua_rotate(L, (idx), 1)
+
+#define lua_remove(L,idx)	(lua_rotate(L, (idx), -1), lua_pop(L, 1))
+
+#define lua_replace(L,idx)	(lua_copy(L, -1, (idx)), lua_pop(L, 1))
+
+/* }============================================================== */
+
+
+/*
+** {==============================================================
+** compatibility macros for unsigned conversions
+** ===============================================================
+*/
+#if defined(LUA_COMPAT_APIINTCASTS)
+
+#define lua_pushunsigned(L,n)	lua_pushinteger(L, (lua_Integer)(n))
+#define lua_tounsignedx(L,i,is)	((lua_Unsigned)lua_tointegerx(L,i,is))
+#define lua_tounsigned(L,i)	lua_tounsignedx(L,(i),NULL)
+
+#endif
+/* }============================================================== */
 
 /*
 ** {======================================================================
@@ -386,14 +445,18 @@
 LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
 LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);
 
-LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
+LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n)
+	LUA_GNUC_PURE;
 LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
                                                int fidx2, int n2);
 
-LUA_API int (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
-LUA_API lua_Hook (lua_gethook) (lua_State *L);
-LUA_API int (lua_gethookmask) (lua_State *L);
-LUA_API int (lua_gethookcount) (lua_State *L);
+LUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook (lua_gethook) (lua_State *L)
+	LUA_GNUC_PURE;
+LUA_API int (lua_gethookmask) (lua_State *L)
+	LUA_GNUC_PURE;
+LUA_API int (lua_gethookcount) (lua_State *L)
+	LUA_GNUC_PURE;
 
 
 struct lua_Debug {
@@ -418,7 +481,7 @@
 
 
 /******************************************************************************
-* Copyright (C) 1994-2013 Lua.org, PUC-Rio.
+* Copyright (C) 1994-2015 Lua.org, PUC-Rio.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
diff -urN rpm-5.4.15/lua/lualib.h rpm-5.4-cvs/lua/lualib.h
--- rpm-5.4.15/lua/lualib.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lualib.h	2015-04-18 23:34:19.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lualib.h,v 1.43 2011/12/08 12:11:37 roberto Exp $
+** $Id: lualib.h,v 1.44 2014/02/06 17:32:33 roberto Exp $
 ** Lua standard libraries
 ** See Copyright Notice in lua.h
 */
@@ -29,8 +29,15 @@
 #define LUA_STRLIBNAME	"string"
 LUAMOD_API int (luaopen_string) (lua_State *L);
 
+#define LUA_UTF8LIBNAME	"utf8"
+LUAMOD_API int (luaopen_utf8) (lua_State *L);
+
 #define LUA_BITLIBNAME	"bit32"
-LUAMOD_API int (luaopen_bit32) (lua_State *L);
+LUAMOD_API int (luaopen_bit32) (lua_State *L)
+#if !defined(LUA_COMPAT_BITLIB)
+	LUA_GNUC_NORETURN
+#endif
+;
 
 #define LUA_MATHLIBNAME	"math"
 LUAMOD_API int (luaopen_math) (lua_State *L);
diff -urN rpm-5.4.15/lua/lundump.c rpm-5.4-cvs/lua/lundump.c
--- rpm-5.4.15/lua/lundump.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lundump.c	2015-04-18 23:34:19.000000000 -0500
@@ -1,14 +1,17 @@
 /*
-** $Id: lundump.c,v 2.22 2012/05/08 13:53:33 roberto Exp $
+** $Id: lundump.c,v 2.41 2014/11/02 19:19:04 roberto Exp $
 ** load precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
 
-#include <string.h>
-
 #define lundump_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <string.h>
+
 #include "lua.h"
 
 #include "ldebug.h"
@@ -20,239 +23,255 @@
 #include "lundump.h"
 #include "lzio.h"
 
+
+#if !defined(luai_verifycode)
+#define luai_verifycode(L,b,f)  /* empty */
+#endif
+
+
 typedef struct {
- lua_State* L;
- ZIO* Z;
- Mbuffer* b;
- const char* name;
+  lua_State *L;
+  ZIO *Z;
+  Mbuffer *b;
+  const char *name;
 } LoadState;
 
-static l_noret error(LoadState* S, const char* why)
-{
- luaO_pushfstring(S->L,"%s: %s precompiled chunk",S->name,why);
- luaD_throw(S->L,LUA_ERRSYNTAX);
+
+static l_noret error(LoadState *S, const char *why) {
+  luaO_pushfstring(S->L, "%s: %s precompiled chunk", S->name, why);
+  luaD_throw(S->L, LUA_ERRSYNTAX);
 }
 
-#define LoadMem(S,b,n,size)	LoadBlock(S,b,(n)*(size))
-#define LoadByte(S)		(lu_byte)LoadChar(S)
-#define LoadVar(S,x)		LoadMem(S,&x,1,sizeof(x))
-#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)
 
-#if !defined(luai_verifycode)
-#define luai_verifycode(L,b,f)	/* empty */
-#endif
+/*
+** All high-level loads go through LoadVector; you can change it to
+** adapt to the endianness of the input
+*/
+#define LoadVector(S,b,n)	LoadBlock(S,b,(n)*sizeof((b)[0]))
+
+static void LoadBlock (LoadState *S, void *b, size_t size) {
+  if (luaZ_read(S->Z, b, size) != 0)
+    error(S, "truncated");
+}
 
-static void LoadBlock(LoadState* S, void* b, size_t size)
-{
- if (luaZ_read(S->Z,b,size)!=0) error(S,"truncated");
-}
-
-static int LoadChar(LoadState* S)
-{
- char x;
- LoadVar(S,x);
- return x;
-}
-
-static int LoadInt(LoadState* S)
-{
- int x;
- LoadVar(S,x);
- if (x<0) error(S,"corrupted");
- return x;
-}
-
-static lua_Number LoadNumber(LoadState* S)
-{
- lua_Number x;
- LoadVar(S,x);
- return x;
-}
-
-static TString* LoadString(LoadState* S)
-{
- size_t size;
- LoadVar(S,size);
- if (size==0)
-  return NULL;
- else
- {
-  char* s=luaZ_openspace(S->L,S->b,size);
-  LoadBlock(S,s,size*sizeof(char));
-  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
- }
-}
-
-static void LoadCode(LoadState* S, Proto* f)
-{
- int n=LoadInt(S);
- f->code=luaM_newvector(S->L,n,Instruction);
- f->sizecode=n;
- LoadVector(S,f->code,n,sizeof(Instruction));
-}
-
-static void LoadFunction(LoadState* S, Proto* f);
-
-static void LoadConstants(LoadState* S, Proto* f)
-{
- int i,n;
- n=LoadInt(S);
- f->k=luaM_newvector(S->L,n,TValue);
- f->sizek=n;
- for (i=0; i<n; i++) setnilvalue(&f->k[i]);
- for (i=0; i<n; i++)
- {
-  TValue* o=&f->k[i];
-  int t=LoadChar(S);
-  switch (t)
-  {
-   case LUA_TNIL:
-	setnilvalue(o);
-	break;
-   case LUA_TBOOLEAN:
-	setbvalue(o,LoadChar(S));
-	break;
-   case LUA_TNUMBER:
-	setnvalue(o,LoadNumber(S));
-	break;
-   case LUA_TSTRING:
-	setsvalue2n(S->L,o,LoadString(S));
-	break;
-    default: lua_assert(0);
+
+#define LoadVar(S,x)		LoadVector(S,&x,1)
+
+
+static lu_byte LoadByte (LoadState *S) {
+  lu_byte x;
+  LoadVar(S, x);
+  return x;
+}
+
+
+static int LoadInt (LoadState *S) {
+  int x;
+  LoadVar(S, x);
+  return x;
+}
+
+
+static lua_Number LoadNumber (LoadState *S) {
+  lua_Number x;
+  LoadVar(S, x);
+  return x;
+}
+
+
+static lua_Integer LoadInteger (LoadState *S) {
+  lua_Integer x;
+  LoadVar(S, x);
+  return x;
+}
+
+
+static TString *LoadString (LoadState *S) {
+  size_t size = LoadByte(S);
+  if (size == 0xFF)
+    LoadVar(S, size);
+  if (size == 0)
+    return NULL;
+  else {
+    char *s = luaZ_openspace(S->L, S->b, --size);
+    LoadVector(S, s, size);
+    return luaS_newlstr(S->L, s, size);
   }
- }
- n=LoadInt(S);
- f->p=luaM_newvector(S->L,n,Proto*);
- f->sizep=n;
- for (i=0; i<n; i++) f->p[i]=NULL;
- for (i=0; i<n; i++)
- {
-  f->p[i]=luaF_newproto(S->L);
-  LoadFunction(S,f->p[i]);
- }
-}
-
-static void LoadUpvalues(LoadState* S, Proto* f)
-{
- int i,n;
- n=LoadInt(S);
- f->upvalues=luaM_newvector(S->L,n,Upvaldesc);
- f->sizeupvalues=n;
- for (i=0; i<n; i++) f->upvalues[i].name=NULL;
- for (i=0; i<n; i++)
- {
-  f->upvalues[i].instack=LoadByte(S);
-  f->upvalues[i].idx=LoadByte(S);
- }
-}
-
-static void LoadDebug(LoadState* S, Proto* f)
-{
- int i,n;
- f->source=LoadString(S);
- n=LoadInt(S);
- f->lineinfo=luaM_newvector(S->L,n,int);
- f->sizelineinfo=n;
- LoadVector(S,f->lineinfo,n,sizeof(int));
- n=LoadInt(S);
- f->locvars=luaM_newvector(S->L,n,LocVar);
- f->sizelocvars=n;
- for (i=0; i<n; i++) f->locvars[i].varname=NULL;
- for (i=0; i<n; i++)
- {
-  f->locvars[i].varname=LoadString(S);
-  f->locvars[i].startpc=LoadInt(S);
-  f->locvars[i].endpc=LoadInt(S);
- }
- n=LoadInt(S);
- for (i=0; i<n; i++) f->upvalues[i].name=LoadString(S);
-}
-
-static void LoadFunction(LoadState* S, Proto* f)
-{
- f->linedefined=LoadInt(S);
- f->lastlinedefined=LoadInt(S);
- f->numparams=LoadByte(S);
- f->is_vararg=LoadByte(S);
- f->maxstacksize=LoadByte(S);
- LoadCode(S,f);
- LoadConstants(S,f);
- LoadUpvalues(S,f);
- LoadDebug(S,f);
-}
-
-/* the code below must be consistent with the code in luaU_header */
-#define N0	LUAC_HEADERSIZE
-#define N1	(sizeof(LUA_SIGNATURE)-sizeof(char))
-#define N2	N1+2
-#define N3	N2+6
-
-static void LoadHeader(LoadState* S)
-{
- lu_byte h[LUAC_HEADERSIZE];
- lu_byte s[LUAC_HEADERSIZE];
- luaU_header(h);
- memcpy(s,h,sizeof(char));			/* first char already read */
- LoadBlock(S,s+sizeof(char),LUAC_HEADERSIZE-sizeof(char));
- if (memcmp(h,s,N0)==0) return;
- if (memcmp(h,s,N1)!=0) error(S,"not a");
- if (memcmp(h,s,N2)!=0) error(S,"version mismatch in");
- if (memcmp(h,s,N3)!=0) error(S,"incompatible"); else error(S,"corrupted");
 }
 
-/*
-** load precompiled chunk
-*/
-Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
-{
- LoadState S;
- Closure* cl;
- if (*name=='@' || *name=='=')
-  S.name=name+1;
- else if (*name==LUA_SIGNATURE[0])
-  S.name="binary string";
- else
-  S.name=name;
- S.L=L;
- S.Z=Z;
- S.b=buff;
- LoadHeader(&S);
- cl=luaF_newLclosure(L,1);
- setclLvalue(L,L->top,cl); incr_top(L);
- cl->l.p=luaF_newproto(L);
- LoadFunction(&S,cl->l.p);
- if (cl->l.p->sizeupvalues != 1)
- {
-  Proto* p=cl->l.p;
-  cl=luaF_newLclosure(L,cl->l.p->sizeupvalues);
-  cl->l.p=p;
-  setclLvalue(L,L->top-1,cl);
- }
- luai_verifycode(L,buff,cl->l.p);
- return cl;
-}
-
-#define MYINT(s)	(s[0]-'0')
-#define VERSION		MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR)
-#define FORMAT		0		/* this is the official format */
+
+static void LoadCode (LoadState *S, Proto *f) {
+  int n = LoadInt(S);
+  f->code = luaM_newvector(S->L, n, Instruction);
+  f->sizecode = n;
+  LoadVector(S, f->code, n);
+}
+
+
+static void LoadFunction(LoadState *S, Proto *f, TString *psource);
+
+
+static void LoadConstants (LoadState *S, Proto *f) {
+  int i;
+  int n = LoadInt(S);
+  f->k = luaM_newvector(S->L, n, TValue);
+  f->sizek = n;
+  for (i = 0; i < n; i++)
+    setnilvalue(&f->k[i]);
+  for (i = 0; i < n; i++) {
+    TValue *o = &f->k[i];
+    int t = LoadByte(S);
+    switch (t) {
+    case LUA_TNIL:
+      setnilvalue(o);
+      break;
+    case LUA_TBOOLEAN:
+      setbvalue(o, LoadByte(S));
+      break;
+    case LUA_TNUMFLT:
+      setfltvalue(o, LoadNumber(S));
+      break;
+    case LUA_TNUMINT:
+      setivalue(o, LoadInteger(S));
+      break;
+    case LUA_TSHRSTR:
+    case LUA_TLNGSTR:
+      setsvalue2n(S->L, o, LoadString(S));
+      break;
+    default:
+      lua_assert(0);
+    }
+  }
+}
+
+
+static void LoadProtos (LoadState *S, Proto *f) {
+  int i;
+  int n = LoadInt(S);
+  f->p = luaM_newvector(S->L, n, Proto *);
+  f->sizep = n;
+  for (i = 0; i < n; i++)
+    f->p[i] = NULL;
+  for (i = 0; i < n; i++) {
+    f->p[i] = luaF_newproto(S->L);
+    LoadFunction(S, f->p[i], f->source);
+  }
+}
+
+
+static void LoadUpvalues (LoadState *S, Proto *f) {
+  int i, n;
+  n = LoadInt(S);
+  f->upvalues = luaM_newvector(S->L, n, Upvaldesc);
+  f->sizeupvalues = n;
+  for (i = 0; i < n; i++)
+    f->upvalues[i].name = NULL;
+  for (i = 0; i < n; i++) {
+    f->upvalues[i].instack = LoadByte(S);
+    f->upvalues[i].idx = LoadByte(S);
+  }
+}
+
+
+static void LoadDebug (LoadState *S, Proto *f) {
+  int i, n;
+  n = LoadInt(S);
+  f->lineinfo = luaM_newvector(S->L, n, int);
+  f->sizelineinfo = n;
+  LoadVector(S, f->lineinfo, n);
+  n = LoadInt(S);
+  f->locvars = luaM_newvector(S->L, n, LocVar);
+  f->sizelocvars = n;
+  for (i = 0; i < n; i++)
+    f->locvars[i].varname = NULL;
+  for (i = 0; i < n; i++) {
+    f->locvars[i].varname = LoadString(S);
+    f->locvars[i].startpc = LoadInt(S);
+    f->locvars[i].endpc = LoadInt(S);
+  }
+  n = LoadInt(S);
+  for (i = 0; i < n; i++)
+    f->upvalues[i].name = LoadString(S);
+}
+
+
+static void LoadFunction (LoadState *S, Proto *f, TString *psource) {
+  f->source = LoadString(S);
+  if (f->source == NULL)  /* no source in dump? */
+    f->source = psource;  /* reuse parent's source */
+  f->linedefined = LoadInt(S);
+  f->lastlinedefined = LoadInt(S);
+  f->numparams = LoadByte(S);
+  f->is_vararg = LoadByte(S);
+  f->maxstacksize = LoadByte(S);
+  LoadCode(S, f);
+  LoadConstants(S, f);
+  LoadUpvalues(S, f);
+  LoadProtos(S, f);
+  LoadDebug(S, f);
+}
+
+
+static void checkliteral (LoadState *S, const char *s, const char *msg) {
+  char buff[sizeof(LUA_SIGNATURE) + sizeof(LUAC_DATA)]; /* larger than both */
+  size_t len = strlen(s);
+  LoadVector(S, buff, len);
+  if (memcmp(s, buff, len) != 0)
+    error(S, msg);
+}
+
+
+static void fchecksize (LoadState *S, size_t size, const char *tname) {
+  if (LoadByte(S) != size)
+    error(S, luaO_pushfstring(S->L, "%s size mismatch in", tname));
+}
+
+
+#define checksize(S,t)	fchecksize(S,sizeof(t),#t)
+
+static void checkHeader (LoadState *S) {
+  checkliteral(S, LUA_SIGNATURE + 1, "not a");  /* 1st char already checked */
+  if (LoadByte(S) != LUAC_VERSION)
+    error(S, "version mismatch in");
+  if (LoadByte(S) != LUAC_FORMAT)
+    error(S, "format mismatch in");
+  checkliteral(S, LUAC_DATA, "corrupted");
+  checksize(S, int);
+  checksize(S, size_t);
+  checksize(S, Instruction);
+  checksize(S, lua_Integer);
+  checksize(S, lua_Number);
+  if (LoadInteger(S) != LUAC_INT)
+    error(S, "endianness mismatch in");
+  if (LoadNumber(S) != LUAC_NUM)
+    error(S, "float format mismatch in");
+}
+
 
 /*
-* make header for precompiled chunks
-* if you change the code below be sure to update LoadHeader and FORMAT above
-* and LUAC_HEADERSIZE in lundump.h
+** load precompiled chunk
 */
-void luaU_header (lu_byte* h)
-{
- int x=1;
- memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-sizeof(char));
- h+=sizeof(LUA_SIGNATURE)-sizeof(char);
- *h++=cast_byte(VERSION);
- *h++=cast_byte(FORMAT);
- *h++=cast_byte(*(char*)&x);			/* endianness */
- *h++=cast_byte(sizeof(int));
- *h++=cast_byte(sizeof(size_t));
- *h++=cast_byte(sizeof(Instruction));
- *h++=cast_byte(sizeof(lua_Number));
- *h++=cast_byte(((lua_Number)0.5)==0);		/* is lua_Number integral? */
- memcpy(h,LUAC_TAIL,sizeof(LUAC_TAIL)-sizeof(char));
+LClosure *luaU_undump(lua_State *L, ZIO *Z, Mbuffer *buff,
+                      const char *name) {
+  LoadState S;
+  LClosure *cl;
+  if (*name == '@' || *name == '=')
+    S.name = name + 1;
+  else if (*name == LUA_SIGNATURE[0])
+    S.name = "binary string";
+  else
+    S.name = name;
+  S.L = L;
+  S.Z = Z;
+  S.b = buff;
+  checkHeader(&S);
+  cl = luaF_newLclosure(L, LoadByte(&S));
+  setclLvalue(L, L->top, cl);
+  incr_top(L);
+  cl->p = luaF_newproto(L);
+  LoadFunction(&S, cl->p, NULL);
+  lua_assert(cl->nupvalues == cl->p->sizeupvalues);
+  luai_verifycode(L, buff, cl->p);
+  return cl;
 }
+
diff -urN rpm-5.4.15/lua/lundump.h rpm-5.4-cvs/lua/lundump.h
--- rpm-5.4.15/lua/lundump.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lundump.h	2015-04-18 23:34:19.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lundump.h,v 1.39 2012/05/08 13:53:33 roberto Exp $
+** $Id: lundump.h,v 1.44 2014/06/19 18:27:20 roberto Exp $
 ** load precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
@@ -7,22 +7,27 @@
 #ifndef lundump_h
 #define lundump_h
 
+#include "llimits.h"
 #include "lobject.h"
 #include "lzio.h"
 
-/* load one chunk; from lundump.c */
-LUAI_FUNC Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);
 
-/* make header; from lundump.c */
-LUAI_FUNC void luaU_header (lu_byte* h);
+/* data to catch conversion errors */
+#define LUAC_DATA	"\x19\x93\r\n\x1a\n"
 
-/* dump one chunk; from ldump.c */
-LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);
+#define LUAC_INT	0x5678
+#define LUAC_NUM	cast_num(370.5)
 
-/* data to catch conversion errors */
-#define LUAC_TAIL		"\x19\x93\r\n\x1a\n"
+#define MYINT(s)	(s[0]-'0')
+#define LUAC_VERSION	(MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR))
+#define LUAC_FORMAT	0	/* this is the official format */
 
-/* size in bytes of header of binary files */
-#define LUAC_HEADERSIZE		(sizeof(LUA_SIGNATURE)-sizeof(char)+2+6+sizeof(LUAC_TAIL)-sizeof(char))
+/* load one chunk; from lundump.c */
+LUAI_FUNC LClosure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff,
+                                 const char* name);
+
+/* dump one chunk; from ldump.c */
+LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w,
+                         void* data, int strip);
 
 #endif
diff -urN rpm-5.4.15/lua/lutf8lib.c rpm-5.4-cvs/lua/lutf8lib.c
--- rpm-5.4.15/lua/lutf8lib.c	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/lutf8lib.c	2015-04-18 23:34:19.000000000 -0500
@@ -0,0 +1,255 @@
+/*
+** $Id: lutf8lib.c,v 1.1.2.1 2015/04/19 04:34:19 jbj Exp $
+** Standard library for UTF-8 manipulation
+** See Copyright Notice in lua.h
+*/
+
+#define lutf8lib_c
+#define LUA_LIB
+
+#include "lprefix.h"
+
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+#define MAXUNICODE	0x10FFFF
+
+#define iscont(p)	((*(p) & 0xC0) == 0x80)
+
+
+/* from strlib */
+/* translate a relative string position: negative means back from end */
+static lua_Integer u_posrelat (lua_Integer pos, size_t len) {
+  if (pos >= 0) return pos;
+  else if (0u - (size_t)pos > len) return 0;
+  else return (lua_Integer)len + pos + 1;
+}
+
+
+/*
+** Decode one UTF-8 sequence, returning NULL if byte sequence is invalid.
+*/
+static const char *utf8_decode (const char *o, int *val) {
+  static unsigned int limits[] = {0xFF, 0x7F, 0x7FF, 0xFFFF};
+  const unsigned char *s = (const unsigned char *)o;
+  unsigned int c = s[0];
+  unsigned int res = 0;  /* final result */
+  if (c < 0x80)  /* ascii? */
+    res = c;
+  else {
+    int count = 0;  /* to count number of continuation bytes */
+    while (c & 0x40) {  /* still have continuation bytes? */
+      int cc = s[++count];  /* read next byte */
+      if ((cc & 0xC0) != 0x80)  /* not a continuation byte? */
+        return NULL;  /* invalid byte sequence */
+      res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */
+      c <<= 1;  /* to test next bit */
+    }
+    res |= ((c & 0x7F) << (count * 5));  /* add first byte */
+    if (count > 3 || res > MAXUNICODE || res <= limits[count])
+      return NULL;  /* invalid byte sequence */
+    s += count;  /* skip continuation bytes read */
+  }
+  if (val) *val = res;
+  return (const char *)s + 1;  /* +1 to include first byte */
+}
+
+
+/*
+** utf8len(s [, i [, j]]) --> number of characters that start in the
+** range [i,j], or nil + current position if 's' is not well formed in
+** that interval
+*/
+static int utflen (lua_State *L) {
+  int n = 0;
+  size_t len;
+  const char *s = luaL_checklstring(L, 1, &len);
+  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);
+  lua_Integer posj = u_posrelat(luaL_optinteger(L, 3, -1), len);
+  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 2,
+                   "initial position out of string");
+  luaL_argcheck(L, --posj < (lua_Integer)len, 3,
+                   "final position out of string");
+  while (posi <= posj) {
+    const char *s1 = utf8_decode(s + posi, NULL);
+    if (s1 == NULL) {  /* conversion error? */
+      lua_pushnil(L);  /* return nil ... */
+      lua_pushinteger(L, posi + 1);  /* ... and current position */
+      return 2;
+    }
+    posi = s1 - s;
+    n++;
+  }
+  lua_pushinteger(L, n);
+  return 1;
+}
+
+
+/*
+** codepoint(s, [i, [j]])  -> returns codepoints for all characters
+** that start in the range [i,j]
+*/
+static int codepoint (lua_State *L) {
+  size_t len;
+  const char *s = luaL_checklstring(L, 1, &len);
+  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);
+  lua_Integer pose = u_posrelat(luaL_optinteger(L, 3, posi), len);
+  int n;
+  const char *se;
+  luaL_argcheck(L, posi >= 1, 2, "out of range");
+  luaL_argcheck(L, pose <= (lua_Integer)len, 3, "out of range");
+  if (posi > pose) return 0;  /* empty interval; return no values */
+  n = (int)(pose -  posi + 1);
+  if (posi + n <= pose)  /* (lua_Integer -> int) overflow? */
+    return luaL_error(L, "string slice too long");
+  luaL_checkstack(L, n, "string slice too long");
+  n = 0;
+  se = s + pose;
+  for (s += posi - 1; s < se;) {
+    int code;
+    s = utf8_decode(s, &code);
+    if (s == NULL)
+      return luaL_error(L, "invalid UTF-8 code");
+    lua_pushinteger(L, code);
+    n++;
+  }
+  return n;
+}
+
+
+static void pushutfchar (lua_State *L, int arg) {
+  lua_Integer code = luaL_checkinteger(L, arg);
+  luaL_argcheck(L, 0 <= code && code <= MAXUNICODE, arg, "value out of range");
+  lua_pushfstring(L, "%U", (long)code);
+}
+
+
+/*
+** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...
+*/
+static int utfchar (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  if (n == 1)  /* optimize common case of single char */
+    pushutfchar(L, 1);
+  else {
+    int i;
+    luaL_Buffer b;
+    luaL_buffinit(L, &b);
+    for (i = 1; i <= n; i++) {
+      pushutfchar(L, i);
+      luaL_addvalue(&b);
+    }
+    luaL_pushresult(&b);
+  }
+  return 1;
+}
+
+
+/*
+** offset(s, n, [i])  -> index where n-th character counting from
+**   position 'i' starts; 0 means character at 'i'.
+*/
+static int byteoffset (lua_State *L) {
+  size_t len;
+  const char *s = luaL_checklstring(L, 1, &len);
+  lua_Integer n  = luaL_checkinteger(L, 2);
+  lua_Integer posi = (n >= 0) ? 1 : len + 1;
+  posi = u_posrelat(luaL_optinteger(L, 3, posi), len);
+  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 3,
+                   "position out of range");
+  if (n == 0) {
+    /* find beginning of current byte sequence */
+    while (posi > 0 && iscont(s + posi)) posi--;
+  }
+  else {
+    if (iscont(s + posi))
+      luaL_error(L, "initial position is a continuation byte");
+    if (n < 0) {
+       while (n < 0 && posi > 0) {  /* move back */
+         do {  /* find beginning of previous character */
+           posi--;
+         } while (posi > 0 && iscont(s + posi));
+         n++;
+       }
+     }
+     else {
+       n--;  /* do not move for 1st character */
+       while (n > 0 && posi < (lua_Integer)len) {
+         do {  /* find beginning of next character */
+           posi++;
+         } while (iscont(s + posi));  /* (cannot pass final '\0') */
+         n--;
+       }
+     }
+  }
+  if (n == 0)  /* did it find given character? */
+    lua_pushinteger(L, posi + 1);
+  else  /* no such character */
+    lua_pushnil(L);
+  return 1;  
+}
+
+
+static int iter_aux (lua_State *L) {
+  size_t len;
+  const char *s = luaL_checklstring(L, 1, &len);
+  lua_Integer n = lua_tointeger(L, 2) - 1;
+  if (n < 0)  /* first iteration? */
+    n = 0;  /* start from here */
+  else if (n < (lua_Integer)len) {
+    n++;  /* skip current byte */
+    while (iscont(s + n)) n++;  /* and its continuations */
+  }
+  if (n >= (lua_Integer)len)
+    return 0;  /* no more codepoints */
+  else {
+    int code;
+    const char *next = utf8_decode(s + n, &code);
+    if (next == NULL || iscont(next))
+      return luaL_error(L, "invalid UTF-8 code");
+    lua_pushinteger(L, n + 1);
+    lua_pushinteger(L, code);
+    return 2;
+  }
+}
+
+
+static int iter_codes (lua_State *L) {
+  luaL_checkstring(L, 1);
+  lua_pushcfunction(L, iter_aux);
+  lua_pushvalue(L, 1);
+  lua_pushinteger(L, 0);
+  return 3;
+}
+
+
+/* pattern to match a single UTF-8 character */
+#define UTF8PATT	"[\0-\x7F\xC2-\xF4][\x80-\xBF]*"
+
+
+static struct luaL_Reg funcs[] = {
+  {"offset", byteoffset},
+  {"codepoint", codepoint},
+  {"char", utfchar},
+  {"len", utflen},
+  {"codes", iter_codes},
+  /* placeholders */
+  {"charpattern", NULL},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_utf8 (lua_State *L) {
+  luaL_newlib(L, funcs);
+  lua_pushliteral(L, UTF8PATT);
+  lua_setfield(L, -2, "charpattern");
+  return 1;
+}
+
diff -urN rpm-5.4.15/lua/lvm.c rpm-5.4-cvs/lua/lvm.c
--- rpm-5.4.15/lua/lvm.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lvm.c	2015-04-19 13:24:57.000000000 -0500
@@ -1,17 +1,20 @@
 /*
-** $Id: lvm.c,v 2.155 2013/03/16 21:10:18 roberto Exp $
+** $Id: lvm.c,v 2.232 2014/12/27 20:30:38 roberto Exp $
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */
 
+#define lvm_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
 
+#include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define lvm_c
-#define LUA_CORE
-
 #include "lua.h"
 
 #include "ldebug.h"
@@ -27,121 +30,176 @@
 #include "lvm.h"
 
 
+/*
+** You can define LUA_FLOORN2I if you want to convert floats to integers
+** by flooring them (instead of raising an error if they are not
+** integral values)
+*/
+#if !defined(LUA_FLOORN2I)
+#define LUA_FLOORN2I		0
+#endif
+
 
 /* limit for table tag-method chains (to avoid loops) */
-#define MAXTAGLOOP	100
+#define MAXTAGLOOP	2000
 
 
-const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
-  lua_Number num;
-  if (ttisnumber(obj)) return obj;
-  if (ttisstring(obj) && luaO_str2d(svalue(obj), tsvalue(obj)->len, &num)) {
-    setnvalue(n, num);
-    return n;
+/*
+** Similar to 'tonumber', but does not attempt to convert strings and
+** ensure correct precision (no extra bits). Used in comparisons.
+*/
+static int tofloat (const TValue *obj, lua_Number *n) {
+  if (ttisfloat(obj)) *n = fltvalue(obj);
+  else if (ttisinteger(obj)) {
+    volatile lua_Number x = cast_num(ivalue(obj));  /* avoid extra precision */
+    *n = x;
   }
-  else
-    return NULL;
+  else {
+    *n = 0;  /* to avoid warnings */
+    return 0;
+  }
+  return 1;
 }
 
 
-int luaV_tostring (lua_State *L, StkId obj) {
-  if (!ttisnumber(obj))
-    return 0;
-  else {
-    char s[LUAI_MAXNUMBER2STR];
-    lua_Number n = nvalue(obj);
-    int l = lua_number2str(s, n);
-    setsvalue2s(L, obj, luaS_newlstr(L, s, l));
+/*
+** Try to convert a value to a float. The float case is already handled
+** by the macro 'tonumber'.
+*/
+int luaV_tonumber_ (const TValue *obj, lua_Number *n) {
+  TValue v;
+  if (ttisinteger(obj)) {
+    *n = cast_num(ivalue(obj));
+    return 1;
+  }
+  else if (cvt2num(obj) &&  /* string convertible to number? */
+            luaO_str2num(svalue(obj), &v) == tsvalue(obj)->len + 1) {
+    *n = nvalue(&v);  /* convert result of 'luaO_str2num' to a float */
     return 1;
   }
+  else
+    return 0;  /* conversion failed */
 }
 
 
-static void traceexec (lua_State *L) {
-  CallInfo *ci = L->ci;
-  lu_byte mask = L->hookmask;
-  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);
-  if (counthook)
-    resethookcount(L);  /* reset count */
-  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
-    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
-    return;  /* do not call hook again (VM yielded, so it did not move) */
-  }
-  if (counthook)
-    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */
-  if (mask & LUA_MASKLINE) {
-    Proto *p = ci_func(ci)->p;
-    int npc = pcRel(ci->u.l.savedpc, p);
-    int newline = getfuncline(p, npc);
-    if (npc == 0 ||  /* call linehook when enter a new function, */
-        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */
-        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */
-      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */
-  }
-  L->oldpc = ci->u.l.savedpc;
-  if (L->status == LUA_YIELD) {  /* did hook yield? */
-    if (counthook)
-      L->hookcount = 1;  /* undo decrement to zero */
-    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
-    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */
-    ci->func = L->top - 1;  /* protect stack below results */
-    luaD_throw(L, LUA_YIELD);
+/*
+** try to convert a value to an integer, rounding according to 'mode':
+** mode == 0: accepts only integral values
+** mode == 1: takes the floor of the number
+** mode == 2: takes the ceil of the number
+*/
+static int tointeger_aux (const TValue *obj, lua_Integer *p, int mode) {
+  TValue v;
+ again:
+  if (ttisfloat(obj)) {
+    lua_Number n = fltvalue(obj);
+    lua_Number f = l_floor(n);
+    if (n != f) {  /* not an integral value? */
+      if (mode == 0) return 0;  /* fails if mode demands integral value */
+      else if (mode > 1)  /* needs ceil? */
+        f += 1;  /* convert floor to ceil (remember: n != f) */
+    }
+    return lua_numbertointeger(f, p);
   }
+  else if (ttisinteger(obj)) {
+    *p = ivalue(obj);
+    return 1;
+  }
+  else if (cvt2num(obj) &&
+            luaO_str2num(svalue(obj), &v) == tsvalue(obj)->len + 1) {
+    obj = &v;
+    goto again;  /* convert result from 'luaO_str2num' to an integer */
+  }
+  return 0;  /* conversion failed */
 }
 
 
-static void callTM (lua_State *L, const TValue *f, const TValue *p1,
-                    const TValue *p2, TValue *p3, int hasres) {
-  ptrdiff_t result = savestack(L, p3);
-  setobj2s(L, L->top++, f);  /* push function */
-  setobj2s(L, L->top++, p1);  /* 1st argument */
-  setobj2s(L, L->top++, p2);  /* 2nd argument */
-  if (!hasres)  /* no result? 'p3' is third argument */
-    setobj2s(L, L->top++, p3);  /* 3rd argument */
-  /* metamethod may yield only when called from Lua code */
-  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));
-  if (hasres) {  /* if has result, move it to its place */
-    p3 = restorestack(L, result);
-    setobjs2s(L, p3, --L->top);
+/*
+** try to convert a value to an integer
+*/
+int luaV_tointeger_ (const TValue *obj, lua_Integer *p) {
+  return tointeger_aux(obj, p, LUA_FLOORN2I);
+}
+
+
+/*
+** Try to convert a 'for' limit to an integer, preserving the
+** semantics of the loop.
+** (The following explanation assumes a non-negative step; it is valid
+** for negative steps mutatis mutandis.)
+** If the limit can be converted to an integer, rounding down, that is
+** it.
+** Otherwise, check whether the limit can be converted to a number.  If
+** the number is too large, it is OK to set the limit as LUA_MAXINTEGER,
+** which means no limit.  If the number is too negative, the loop
+** should not run, because any initial integer value is larger than the
+** limit. So, it sets the limit to LUA_MININTEGER. 'stopnow' corrects
+** the extreme case when the initial value is LUA_MININTEGER, in which
+** case the LUA_MININTEGER limit would still run the loop once.
+*/
+static int forlimit (const TValue *obj, lua_Integer *p, lua_Integer step,
+                     int *stopnow) {
+  *stopnow = 0;  /* usually, let loops run */
+  if (!tointeger_aux(obj, p, (step < 0 ? 2 : 1))) {  /* not fit in integer? */
+    lua_Number n;  /* try to convert to float */
+    if (!tonumber(obj, &n)) /* cannot convert to float? */
+      return 0;  /* not a number */
+    if (n > 0) {  /* if true, float is larger than max integer */
+      *p = LUA_MAXINTEGER;
+      if (step < 0) *stopnow = 1;
+    }
+    else {  /* float is smaller than min integer */
+      *p = LUA_MININTEGER;
+      if (step >= 0) *stopnow = 1;
+    }
   }
+  return 1;
 }
 
 
+/*
+** Main function for table access (invoking metamethods if needed).
+** Compute 'val = t[key]'
+*/
 void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
-  int loop;
+  int loop;  /* counter to avoid infinite loops */
   for (loop = 0; loop < MAXTAGLOOP; loop++) {
     const TValue *tm;
-    if (ttistable(t)) {  /* `t' is a table? */
+    if (ttistable(t)) {  /* 't' is a table? */
       Table *h = hvalue(t);
       const TValue *res = luaH_get(h, key); /* do a primitive get */
       if (!ttisnil(res) ||  /* result is not nil? */
           (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { /* or no TM? */
-        setobj2s(L, val, res);
+        setobj2s(L, val, res);  /* result is the raw get */
         return;
       }
-      /* else will try the tag method */
+      /* else will try metamethod */
     }
     else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
-      luaG_typeerror(L, t, "index");
-    if (ttisfunction(tm)) {
-      callTM(L, tm, t, key, val, 1);
+      luaG_typeerror(L, t, "index");  /* no metamethod */
+    if (ttisfunction(tm)) {  /* metamethod is a function */
+      luaT_callTM(L, tm, t, key, val, 1);
       return;
     }
-    t = tm;  /* else repeat with 'tm' */
+    t = tm;  /* else repeat access over 'tm' */
   }
-  luaG_runerror(L, "loop in gettable");
+  luaG_runerror(L, "gettable chain too long; possible loop");
 }
 
 
+/*
+** Main function for table assignment (invoking metamethods if needed).
+** Compute 't[key] = val'
+*/
 void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
-  int loop;
+  int loop;  /* counter to avoid infinite loops */
   for (loop = 0; loop < MAXTAGLOOP; loop++) {
     const TValue *tm;
-    if (ttistable(t)) {  /* `t' is a table? */
+    if (ttistable(t)) {  /* 't' is a table? */
       Table *h = hvalue(t);
       TValue *oldval = cast(TValue *, luaH_get(h, key));
       /* if previous value is not nil, there must be a previous entry
-         in the table; moreover, a metamethod has no relevance */
+         in the table; a metamethod has no relevance */
       if (!ttisnil(oldval) ||
          /* previous value is nil; must check the metamethod */
          ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&
@@ -153,7 +211,7 @@
         /* no metamethod and (now) there is an entry with given key */
         setobj2t(L, oldval, val);  /* assign new value to that entry */
         invalidateTMcache(h);
-        luaC_barrierback(L, obj2gco(h), val);
+        luaC_barrierback(L, h, val);
         return;
       }
       /* else will try the metamethod */
@@ -161,66 +219,41 @@
     else  /* not a table; check metamethod */
       if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
         luaG_typeerror(L, t, "index");
-    /* there is a metamethod */
+    /* try the metamethod */
     if (ttisfunction(tm)) {
-      callTM(L, tm, t, key, val, 0);
+      luaT_callTM(L, tm, t, key, val, 0);
       return;
     }
-    t = tm;  /* else repeat with 'tm' */
+    t = tm;  /* else repeat assignment over 'tm' */
   }
-  luaG_runerror(L, "loop in settable");
-}
-
-
-static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
-                       StkId res, TMS event) {
-  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
-  if (ttisnil(tm))
-    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
-  if (ttisnil(tm)) return 0;
-  callTM(L, tm, p1, p2, res, 1);
-  return 1;
-}
-
-
-static const TValue *get_equalTM (lua_State *L, Table *mt1, Table *mt2,
-                                  TMS event) {
-  const TValue *tm1 = fasttm(L, mt1, event);
-  const TValue *tm2;
-  if (tm1 == NULL) return NULL;  /* no metamethod */
-  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
-  tm2 = fasttm(L, mt2, event);
-  if (tm2 == NULL) return NULL;  /* no metamethod */
-  if (luaV_rawequalobj(tm1, tm2))  /* same metamethods? */
-    return tm1;
-  return NULL;
-}
-
-
-static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
-                         TMS event) {
-  if (!call_binTM(L, p1, p2, L->top, event))
-    return -1;  /* no metamethod */
-  else
-    return !l_isfalse(L->top);
+  luaG_runerror(L, "settable chain too long; possible loop");
 }
 
 
+/*
+** Compare two strings 'ls' x 'rs', returning an integer smaller-equal-
+** -larger than zero if 'ls' is smaller-equal-larger than 'rs'.
+** The code is a little tricky because it allows '\0' in the strings
+** and it uses 'strcoll' (to respect locales) for each segments
+** of the strings.
+*/
+LUA_GNUC_PURE
 static int l_strcmp (const TString *ls, const TString *rs) {
   const char *l = getstr(ls);
-  size_t ll = ls->tsv.len;
+  size_t ll = ls->len;
   const char *r = getstr(rs);
-  size_t lr = rs->tsv.len;
-  for (;;) {
+  size_t lr = rs->len;
+  for (;;) {  /* for each segment */
     int temp = strcoll(l, r);
-    if (temp != 0) return temp;
-    else {  /* strings are equal up to a `\0' */
-      size_t len = strlen(l);  /* index of first `\0' in both strings */
-      if (len == lr)  /* r is finished? */
-        return (len == ll) ? 0 : 1;
-      else if (len == ll)  /* l is finished? */
-        return -1;  /* l is smaller than r (because r is not finished) */
-      /* both strings longer than `len'; go on comparing (after the `\0') */
+    if (temp != 0)  /* not equal? */
+      return temp;  /* done */
+    else {  /* strings are equal up to a '\0' */
+      size_t len = strlen(l);  /* index of first '\0' in both strings */
+      if (len == lr)  /* 'rs' is finished? */
+        return (len == ll) ? 0 : 1;  /* check 'ls' */
+      else if (len == ll)  /* 'ls' is finished? */
+        return -1;  /* 'ls' is smaller than 'rs' ('rs' is not finished) */
+      /* both strings longer than 'len'; go on comparing after the '\0' */
       len++;
       l += len; ll -= len; r += len; lr -= len;
     }
@@ -228,79 +261,118 @@
 }
 
 
+/*
+** Main operation less than; return 'l < r'.
+*/
 int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
   int res;
-  if (ttisnumber(l) && ttisnumber(r))
-    return luai_numlt(L, nvalue(l), nvalue(r));
-  else if (ttisstring(l) && ttisstring(r))
-    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
-  else if ((res = call_orderTM(L, l, r, TM_LT)) < 0)
-    luaG_ordererror(L, l, r);
+  lua_Number nl, nr;
+  if (ttisinteger(l) && ttisinteger(r))  /* both operands are integers? */
+    return (ivalue(l) < ivalue(r));
+  else if (tofloat(l, &nl) && tofloat(r, &nr))  /* both are numbers? */
+    return luai_numlt(nl, nr);
+  else if (ttisstring(l) && ttisstring(r))  /* both are strings? */
+    return l_strcmp(tsvalue(l), tsvalue(r)) < 0;
+  else if ((res = luaT_callorderTM(L, l, r, TM_LT)) < 0)  /* no metamethod? */
+    luaG_ordererror(L, l, r);  /* error */
   return res;
 }
 
 
+/*
+** Main operation less than or equal to; return 'l <= r'.
+*/
 int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {
   int res;
-  if (ttisnumber(l) && ttisnumber(r))
-    return luai_numle(L, nvalue(l), nvalue(r));
-  else if (ttisstring(l) && ttisstring(r))
-    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
-  else if ((res = call_orderTM(L, l, r, TM_LE)) >= 0)  /* first try `le' */
+  lua_Number nl, nr;
+  if (ttisinteger(l) && ttisinteger(r))  /* both operands are integers? */
+    return (ivalue(l) <= ivalue(r));
+  else if (tofloat(l, &nl) && tofloat(r, &nr))  /* both are numbers? */
+    return luai_numle(nl, nr);
+  else if (ttisstring(l) && ttisstring(r))  /* both are strings? */
+    return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;
+  else if ((res = luaT_callorderTM(L, l, r, TM_LE)) >= 0)  /* first try 'le' */
     return res;
-  else if ((res = call_orderTM(L, r, l, TM_LT)) < 0)  /* else try `lt' */
-    luaG_ordererror(L, l, r);
-  return !res;
+  else {  /* try 'lt': */
+    L->ci->callstatus |= CIST_LEQ;  /* mark it is doing 'lt' for 'le' */
+    res = luaT_callorderTM(L, r, l, TM_LT);
+    L->ci->callstatus ^= CIST_LEQ;  /* clear mark */
+    if (res < 0)
+      luaG_ordererror(L, l, r);
+    return !res;  /* result is negated */
+  }
 }
 
 
 /*
-** equality of Lua values. L == NULL means raw equality (no metamethods)
+** Main operation for equality of Lua values; return 't1 == t2'. 
+** L == NULL means raw equality (no metamethods)
 */
-int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2) {
+int luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2) {
   const TValue *tm;
-  lua_assert(ttisequal(t1, t2));
+  if (ttype(t1) != ttype(t2)) {  /* not the same variant? */
+    if (ttnov(t1) != ttnov(t2) || ttnov(t1) != LUA_TNUMBER)
+      return 0;  /* only numbers can be equal with different variants */
+    else {  /* two numbers with different variants */
+      lua_Number n1, n2;  /* compare them as floats */
+      lua_assert(ttisnumber(t1) && ttisnumber(t2));
+      cast_void(tofloat(t1, &n1)); cast_void(tofloat(t2, &n2));
+      return luai_numeq(n1, n2);
+    }
+  }
+  /* values have same type and same variant */
   switch (ttype(t1)) {
     case LUA_TNIL: return 1;
-    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
+    case LUA_TNUMINT: return (ivalue(t1) == ivalue(t2));
+    case LUA_TNUMFLT: return luai_numeq(fltvalue(t1), fltvalue(t2));
     case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
     case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
     case LUA_TLCF: return fvalue(t1) == fvalue(t2);
-    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));
-    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TSHRSTR: return eqshrstr(tsvalue(t1), tsvalue(t2));
+    case LUA_TLNGSTR: return luaS_eqlngstr(tsvalue(t1), tsvalue(t2));
     case LUA_TUSERDATA: {
       if (uvalue(t1) == uvalue(t2)) return 1;
       else if (L == NULL) return 0;
-      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);
+      tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);
+      if (tm == NULL)
+        tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);
       break;  /* will try TM */
     }
     case LUA_TTABLE: {
       if (hvalue(t1) == hvalue(t2)) return 1;
       else if (L == NULL) return 0;
-      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      tm = fasttm(L, hvalue(t1)->metatable, TM_EQ);
+      if (tm == NULL)
+        tm = fasttm(L, hvalue(t2)->metatable, TM_EQ);
       break;  /* will try TM */
     }
     default:
-      lua_assert(iscollectable(t1));
       return gcvalue(t1) == gcvalue(t2);
   }
-  if (tm == NULL) return 0;  /* no TM? */
-  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */
+  if (tm == NULL)  /* no TM? */
+    return 0;  /* objects are different */
+  luaT_callTM(L, tm, t1, t2, L->top, 1);  /* call TM */
   return !l_isfalse(L->top);
 }
 
 
+/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */
+#define tostring(L,o)  \
+	(ttisstring(o) || (cvt2str(o) && (luaO_tostring(L, o), 1)))
+
+/*
+** Main operation for concatenation: concat 'total' values in the stack,
+** from 'L->top - total' up to 'L->top - 1'.
+*/
 void luaV_concat (lua_State *L, int total) {
   lua_assert(total >= 2);
   do {
     StkId top = L->top;
     int n = 2;  /* number of elements handled in this pass (at least 2) */
-    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
-      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
-        luaG_concaterror(L, top-2, top-1);
-    }
+    if (!(ttisstring(top-2) || cvt2str(top-2)) || !tostring(L, top-1))
+      luaT_trybinTM(L, top-2, top-1, top-2, TM_CONCAT);
     else if (tsvalue(top-1)->len == 0)  /* second operand is empty? */
-      (void)tostring(L, top - 2);  /* result is first operand */
+      cast_void(tostring(L, top - 2));  /* result is first operand */
     else if (ttisstring(top-2) && tsvalue(top-2)->len == 0) {
       setobjs2s(L, top - 2, top - 1);  /* result is second op. */
     }
@@ -312,19 +384,19 @@
       /* collect total length */
       for (i = 1; i < total && tostring(L, top-i-1); i++) {
         size_t l = tsvalue(top-i-1)->len;
-        if (l >= (MAX_SIZET/sizeof(char)) - tl)
+        if (l >= (MAX_SIZE/sizeof(char)) - tl)
           luaG_runerror(L, "string length overflow");
         tl += l;
       }
       buffer = luaZ_openspace(L, &G(L)->buff, tl);
       tl = 0;
       n = i;
-      do {  /* concat all strings */
+      do {  /* copy all strings to buffer */
         size_t l = tsvalue(top-i)->len;
         memcpy(buffer+tl, svalue(top-i), l * sizeof(char));
         tl += l;
       } while (--i > 0);
-      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
+      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));  /* create result */
     }
     total -= n-1;  /* got 'n' strings to create 1 new */
     L->top -= n-1;  /* popped 'n' strings and pushed one */
@@ -332,18 +404,21 @@
 }
 
 
+/*
+** Main operation 'ra' = #rb'.
+*/
 void luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {
   const TValue *tm;
-  switch (ttypenv(rb)) {
+  switch (ttnov(rb)) {
     case LUA_TTABLE: {
       Table *h = hvalue(rb);
       tm = fasttm(L, h->metatable, TM_LEN);
       if (tm) break;  /* metamethod? break switch to call it */
-      setnvalue(ra, cast_num(luaH_getn(h)));  /* else primitive len */
+      setivalue(ra, luaH_getn(h));  /* else primitive len */
       return;
     }
     case LUA_TSTRING: {
-      setnvalue(ra, cast_num(tsvalue(rb)->len));
+      setivalue(ra, tsvalue(rb)->len);
       return;
     }
     default: {  /* try metamethod */
@@ -353,21 +428,66 @@
       break;
     }
   }
-  callTM(L, tm, rb, rb, ra, 1);
+  luaT_callTM(L, tm, rb, rb, ra, 1);
+}
+
+
+/*
+** Integer division; return 'm // n', that is, floor(m/n).
+** C division truncates its result (rounds towards zero).
+** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,
+** otherwise 'floor(q) == trunc(q) - 1'.
+*/
+lua_Integer luaV_div (lua_State *L, lua_Integer m, lua_Integer n) {
+  if (l_castS2U(n) + 1u <= 1u) {  /* special cases: -1 or 0 */
+    if (n == 0)
+      luaG_runerror(L, "attempt to divide by zero");
+    return intop(-, 0, m);   /* n==-1; avoid overflow with 0x80000...//-1 */
+  }
+  else {
+    lua_Integer q = m / n;  /* perform C division */
+    if ((m ^ n) < 0 && m % n != 0)  /* 'm/n' would be negative non-integer? */
+      q -= 1;  /* correct result for different rounding */
+    return q;
+  }
 }
 
 
-void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
-                 const TValue *rc, TMS op) {
-  TValue tempb, tempc;
-  const TValue *b, *c;
-  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
-      (c = luaV_tonumber(rc, &tempc)) != NULL) {
-    lua_Number res = luaO_arith(op - TM_ADD + LUA_OPADD, nvalue(b), nvalue(c));
-    setnvalue(ra, res);
+/*
+** Integer modulus; return 'm % n'. (Assume that C '%' with 
+** negative operands follows C99 behavior. See previous comment
+** about luaV_div.)
+*/
+lua_Integer luaV_mod (lua_State *L, lua_Integer m, lua_Integer n) {
+  if (l_castS2U(n) + 1u <= 1u) {  /* special cases: -1 or 0 */
+    if (n == 0)
+      luaG_runerror(L, "attempt to perform 'n%%0'");
+    return 0;   /* m % -1 == 0; avoid overflow with 0x80000...%-1 */
+  }
+  else {
+    lua_Integer r = m % n;
+    if (r != 0 && (m ^ n) < 0)  /* 'm/n' would be non-integer negative? */
+      r += n;  /* correct result for different rounding */
+    return r;
+  }
+}
+
+
+/* number of bits in an integer */
+#define NBITS	cast_int(sizeof(lua_Integer) * CHAR_BIT)
+
+/*
+** Shift left operation. (Shift right just negates 'y'.)
+*/
+lua_Integer luaV_shiftl (lua_Integer x, lua_Integer y) {
+  if (y < 0) {  /* shift right? */
+    if (y <= -NBITS) return 0;
+    else return intop(>>, x, -y);
+  }
+  else {  /* shift left */
+    if (y >= NBITS) return 0;
+    else return intop(<<, x, y);
   }
-  else if (!call_binTM(L, rb, rc, ra, op))
-    luaG_aritherror(L, rb, rc);
 }
 
 
@@ -376,15 +496,15 @@
 ** whether there is a cached closure with the same upvalues needed by
 ** new closure to be created.
 */
-static Closure *getcached (Proto *p, UpVal **encup, StkId base) {
-  Closure *c = p->cache;
+static LClosure *getcached (Proto *p, UpVal **encup, StkId base) {
+  LClosure *c = p->cache;
   if (c != NULL) {  /* is there a cached closure? */
     int nup = p->sizeupvalues;
     Upvaldesc *uv = p->upvalues;
     int i;
     for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */
       TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;
-      if (c->l.upvals[i]->v != v)
+      if (c->upvals[i]->v != v)
         return NULL;  /* wrong upvalue; cannot reuse closure */
     }
   }
@@ -394,26 +514,28 @@
 
 /*
 ** create a new Lua closure, push it in the stack, and initialize
-** its upvalues. Note that the call to 'luaC_barrierproto' must come
-** before the assignment to 'p->cache', as the function needs the
-** original value of that field.
+** its upvalues. Note that the closure is not cached if prototype is
+** already black (which means that 'cache' was already cleared by the
+** GC).
 */
 static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,
                          StkId ra) {
   int nup = p->sizeupvalues;
   Upvaldesc *uv = p->upvalues;
   int i;
-  Closure *ncl = luaF_newLclosure(L, nup);
-  ncl->l.p = p;
+  LClosure *ncl = luaF_newLclosure(L, nup);
+  ncl->p = p;
   setclLvalue(L, ra, ncl);  /* anchor new closure in stack */
   for (i = 0; i < nup; i++) {  /* fill in its upvalues */
     if (uv[i].instack)  /* upvalue refers to local variable? */
-      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);
+      ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);
     else  /* get upvalue from enclosing function */
-      ncl->l.upvals[i] = encup[uv[i].idx];
+      ncl->upvals[i] = encup[uv[i].idx];
+    ncl->upvals[i]->refcount++;
+    /* new closure is white, so we do not need a barrier here */
   }
-  luaC_barrierproto(L, p, ncl);
-  p->cache = ncl;  /* save it on cache for reuse */
+  if (!isblack(p))  /* cache will not break GC invariant? */
+    p->cache = ncl;  /* save it on cache for reuse */
 }
 
 
@@ -426,8 +548,10 @@
   Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */
   OpCode op = GET_OPCODE(inst);
   switch (op) {  /* finish its execution */
-    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:
-    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:
+    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV: case OP_IDIV:
+    case OP_BAND: case OP_BOR: case OP_BXOR: case OP_SHL: case OP_SHR:
+    case OP_MOD: case OP_POW:
+    case OP_UNM: case OP_BNOT: case OP_LEN:
     case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {
       setobjs2s(L, base + GETARG_A(inst), --L->top);
       break;
@@ -435,18 +559,18 @@
     case OP_LE: case OP_LT: case OP_EQ: {
       int res = !l_isfalse(L->top - 1);
       L->top--;
-      /* metamethod should not be called when operand is K */
-      lua_assert(!ISK(GETARG_B(inst)));
-      if (op == OP_LE &&  /* "<=" using "<" instead? */
-          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))
-        res = !res;  /* invert result */
+      if (ci->callstatus & CIST_LEQ) {  /* "<=" using "<" instead? */
+        lua_assert(op == OP_LE);
+        ci->callstatus ^= CIST_LEQ;  /* clear mark */
+        res = !res;  /* negate result */
+      }
       lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);
       if (res != GETARG_A(inst))  /* condition failed? */
         ci->u.l.savedpc++;  /* skip jump instruction */
       break;
     }
     case OP_CONCAT: {
-      StkId top = L->top - 1;  /* top when 'call_binTM' was called */
+      StkId top = L->top - 1;  /* top when 'luaT_trybinTM' was called */
       int b = GETARG_B(inst);      /* first element to concatenate */
       int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */
       setobj2s(L, top - 2, top);  /* put TM result in proper position */
@@ -477,8 +601,16 @@
 
 
 
+
 /*
-** some macros for common tasks in `luaV_execute'
+** {==================================================================
+** Function 'luaV_execute': main interpreter loop
+** ===================================================================
+*/
+
+
+/*
+** some macros for common tasks in 'luaV_execute'
 */
 
 #if !defined luai_runtimecheck
@@ -517,19 +649,9 @@
            luai_threadyield(L); )
 
 
-#define arith_op(op,tm) { \
-        TValue *rb = RKB(i); \
-        TValue *rc = RKC(i); \
-        if (ttisnumber(rb) && ttisnumber(rc)) { \
-          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
-          setnvalue(ra, op(L, nb, nc)); \
-        } \
-        else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }
-
-
 #define vmdispatch(o)	switch(o)
-#define vmcase(l,b)	case l: {b}  break;
-#define vmcasenb(l,b)	case l: {b}		/* nb = no break */
+#define vmcase(l)	case l:
+#define vmbreak		break
 
 void luaV_execute (lua_State *L) {
   CallInfo *ci = L->ci;
@@ -547,60 +669,71 @@
     StkId ra;
     if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
         (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
-      Protect(traceexec(L));
+      Protect(luaG_traceexec(L));
     }
-    /* WARNING: several calls may realloc the stack and invalidate `ra' */
+    /* WARNING: several calls may realloc the stack and invalidate 'ra' */
     ra = RA(i);
     lua_assert(base == ci->u.l.base);
     lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
     vmdispatch (GET_OPCODE(i)) {
-      vmcase(OP_MOVE,
+      vmcase(OP_MOVE) {
         setobjs2s(L, ra, RB(i));
-      )
-      vmcase(OP_LOADK,
+        vmbreak;
+      }
+      vmcase(OP_LOADK) {
         TValue *rb = k + GETARG_Bx(i);
         setobj2s(L, ra, rb);
-      )
-      vmcase(OP_LOADKX,
+        vmbreak;
+      }
+      vmcase(OP_LOADKX) {
         TValue *rb;
         lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
         rb = k + GETARG_Ax(*ci->u.l.savedpc++);
         setobj2s(L, ra, rb);
-      )
-      vmcase(OP_LOADBOOL,
+        vmbreak;
+      }
+      vmcase(OP_LOADBOOL) {
         setbvalue(ra, GETARG_B(i));
         if (GETARG_C(i)) ci->u.l.savedpc++;  /* skip next instruction (if C) */
-      )
-      vmcase(OP_LOADNIL,
+        vmbreak;
+      }
+      vmcase(OP_LOADNIL) {
         int b = GETARG_B(i);
         do {
           setnilvalue(ra++);
         } while (b--);
-      )
-      vmcase(OP_GETUPVAL,
+        vmbreak;
+      }
+      vmcase(OP_GETUPVAL) {
         int b = GETARG_B(i);
         setobj2s(L, ra, cl->upvals[b]->v);
-      )
-      vmcase(OP_GETTABUP,
+        vmbreak;
+      }
+      vmcase(OP_GETTABUP) {
         int b = GETARG_B(i);
         Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));
-      )
-      vmcase(OP_GETTABLE,
+        vmbreak;
+      }
+      vmcase(OP_GETTABLE) {
         Protect(luaV_gettable(L, RB(i), RKC(i), ra));
-      )
-      vmcase(OP_SETTABUP,
+        vmbreak;
+      }
+      vmcase(OP_SETTABUP) {
         int a = GETARG_A(i);
         Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));
-      )
-      vmcase(OP_SETUPVAL,
+        vmbreak;
+      }
+      vmcase(OP_SETUPVAL) {
         UpVal *uv = cl->upvals[GETARG_B(i)];
         setobj(L, uv->v, ra);
-        luaC_barrier(L, uv, ra);
-      )
-      vmcase(OP_SETTABLE,
+        luaC_upvalbarrier(L, uv);
+        vmbreak;
+      }
+      vmcase(OP_SETTABLE) {
         Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
-      )
-      vmcase(OP_NEWTABLE,
+        vmbreak;
+      }
+      vmcase(OP_NEWTABLE) {
         int b = GETARG_B(i);
         int c = GETARG_C(i);
         Table *t = luaH_new(L);
@@ -608,49 +741,193 @@
         if (b != 0 || c != 0)
           luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
         checkGC(L, ra + 1);
-      )
-      vmcase(OP_SELF,
+        vmbreak;
+      }
+      vmcase(OP_SELF) {
         StkId rb = RB(i);
         setobjs2s(L, ra+1, rb);
         Protect(luaV_gettable(L, rb, RKC(i), ra));
-      )
-      vmcase(OP_ADD,
-        arith_op(luai_numadd, TM_ADD);
-      )
-      vmcase(OP_SUB,
-        arith_op(luai_numsub, TM_SUB);
-      )
-      vmcase(OP_MUL,
-        arith_op(luai_nummul, TM_MUL);
-      )
-      vmcase(OP_DIV,
-        arith_op(luai_numdiv, TM_DIV);
-      )
-      vmcase(OP_MOD,
-        arith_op(luai_nummod, TM_MOD);
-      )
-      vmcase(OP_POW,
-        arith_op(luai_numpow, TM_POW);
-      )
-      vmcase(OP_UNM,
+        vmbreak;
+      }
+      vmcase(OP_ADD) { 
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Number nb; lua_Number nc;
+        if (ttisinteger(rb) && ttisinteger(rc)) {
+          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
+          setivalue(ra, intop(+, ib, ic));
+        }
+        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
+          setfltvalue(ra, luai_numadd(L, nb, nc));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
+        vmbreak;
+      }
+      vmcase(OP_SUB) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Number nb; lua_Number nc;
+        if (ttisinteger(rb) && ttisinteger(rc)) {
+          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
+          setivalue(ra, intop(-, ib, ic));
+        }
+        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
+          setfltvalue(ra, luai_numsub(L, nb, nc));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
+        vmbreak;
+      }
+      vmcase(OP_MUL) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Number nb; lua_Number nc;
+        if (ttisinteger(rb) && ttisinteger(rc)) {
+          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
+          setivalue(ra, intop(*, ib, ic));
+        }
+        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
+          setfltvalue(ra, luai_nummul(L, nb, nc));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_MUL)); }
+        vmbreak;
+      }
+      vmcase(OP_DIV) {  /* float division (always with floats) */
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Number nb; lua_Number nc;
+        if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
+          setfltvalue(ra, luai_numdiv(L, nb, nc));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_DIV)); }
+        vmbreak;
+      }
+      vmcase(OP_BAND) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Integer ib; lua_Integer ic;
+        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
+          setivalue(ra, intop(&, ib, ic));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_BAND)); }
+        vmbreak;
+      }
+      vmcase(OP_BOR) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Integer ib; lua_Integer ic;
+        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
+          setivalue(ra, intop(|, ib, ic));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_BOR)); }
+        vmbreak;
+      }
+      vmcase(OP_BXOR) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Integer ib; lua_Integer ic;
+        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
+          setivalue(ra, intop(^, ib, ic));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_BXOR)); }
+        vmbreak;
+      }
+      vmcase(OP_SHL) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Integer ib; lua_Integer ic;
+        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
+          setivalue(ra, luaV_shiftl(ib, ic));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SHL)); }
+        vmbreak;
+      }
+      vmcase(OP_SHR) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Integer ib; lua_Integer ic;
+        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
+          setivalue(ra, luaV_shiftl(ib, -ic));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SHR)); }
+        vmbreak;
+      }
+      vmcase(OP_MOD) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Number nb; lua_Number nc;
+        if (ttisinteger(rb) && ttisinteger(rc)) {
+          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
+          setivalue(ra, luaV_mod(L, ib, ic));
+        }
+        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
+          lua_Number m;
+          luai_nummod(L, nb, nc, m);
+          setfltvalue(ra, m);
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_MOD)); }
+        vmbreak;
+      }
+      vmcase(OP_IDIV) {  /* floor division */
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Number nb; lua_Number nc;
+        if (ttisinteger(rb) && ttisinteger(rc)) {
+          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
+          setivalue(ra, luaV_div(L, ib, ic));
+        }
+        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
+          setfltvalue(ra, luai_numidiv(L, nb, nc));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_IDIV)); }
+        vmbreak;
+      }
+      vmcase(OP_POW) {
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        lua_Number nb; lua_Number nc;
+        if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
+          setfltvalue(ra, luai_numpow(L, nb, nc));
+        }
+        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_POW)); }
+        vmbreak;
+      }
+      vmcase(OP_UNM) {
+        TValue *rb = RB(i);
+        lua_Number nb;
+        if (ttisinteger(rb)) {
+          lua_Integer ib = ivalue(rb);
+          setivalue(ra, intop(-, 0, ib));
+        }
+        else if (tonumber(rb, &nb)) {
+          setfltvalue(ra, luai_numunm(L, nb));
+        }
+        else {
+          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));
+        }
+        vmbreak;
+      }
+      vmcase(OP_BNOT) {
         TValue *rb = RB(i);
-        if (ttisnumber(rb)) {
-          lua_Number nb = nvalue(rb);
-          setnvalue(ra, luai_numunm(L, nb));
+        lua_Integer ib;
+        if (tointeger(rb, &ib)) {
+          setivalue(ra, intop(^, ~l_castS2U(0), ib));
         }
         else {
-          Protect(luaV_arith(L, ra, rb, rb, TM_UNM));
+          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));
         }
-      )
-      vmcase(OP_NOT,
+        vmbreak;
+      }
+      vmcase(OP_NOT) {
         TValue *rb = RB(i);
         int res = l_isfalse(rb);  /* next assignment may change this value */
         setbvalue(ra, res);
-      )
-      vmcase(OP_LEN,
+        vmbreak;
+      }
+      vmcase(OP_LEN) {
         Protect(luaV_objlen(L, ra, RB(i)));
-      )
-      vmcase(OP_CONCAT,
+        vmbreak;
+      }
+      vmcase(OP_CONCAT) {
         int b = GETARG_B(i);
         int c = GETARG_C(i);
         StkId rb;
@@ -661,43 +938,49 @@
         setobjs2s(L, ra, rb);
         checkGC(L, (ra >= rb ? ra + 1 : rb));
         L->top = ci->top;  /* restore top */
-      )
-      vmcase(OP_JMP,
+        vmbreak;
+      }
+      vmcase(OP_JMP) {
         dojump(ci, i, 0);
-      )
-      vmcase(OP_EQ,
+        vmbreak;
+      }
+      vmcase(OP_EQ) {
         TValue *rb = RKB(i);
         TValue *rc = RKC(i);
         Protect(
-          if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))
+          if (cast_int(luaV_equalobj(L, rb, rc)) != GETARG_A(i))
             ci->u.l.savedpc++;
           else
             donextjump(ci);
         )
-      )
-      vmcase(OP_LT,
+        vmbreak;
+      }
+      vmcase(OP_LT) {
         Protect(
           if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))
             ci->u.l.savedpc++;
           else
             donextjump(ci);
         )
-      )
-      vmcase(OP_LE,
+        vmbreak;
+      }
+      vmcase(OP_LE) {
         Protect(
           if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))
             ci->u.l.savedpc++;
           else
             donextjump(ci);
         )
-      )
-      vmcase(OP_TEST,
+        vmbreak;
+      }
+      vmcase(OP_TEST) {
         if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))
             ci->u.l.savedpc++;
           else
           donextjump(ci);
-      )
-      vmcase(OP_TESTSET,
+        vmbreak;
+      }
+      vmcase(OP_TESTSET) {
         TValue *rb = RB(i);
         if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))
           ci->u.l.savedpc++;
@@ -705,8 +988,9 @@
           setobjs2s(L, ra, rb);
           donextjump(ci);
         }
-      )
-      vmcase(OP_CALL,
+        vmbreak;
+      }
+      vmcase(OP_CALL) {
         int b = GETARG_B(i);
         int nresults = GETARG_C(i) - 1;
         if (b != 0) L->top = ra+b;  /* else previous instruction set top */
@@ -719,8 +1003,9 @@
           ci->callstatus |= CIST_REENTRY;
           goto newframe;  /* restart luaV_execute over new Lua function */
         }
-      )
-      vmcase(OP_TAILCALL,
+        vmbreak;
+      }
+      vmcase(OP_TAILCALL) {
         int b = GETARG_B(i);
         if (b != 0) L->top = ra+b;  /* else previous instruction set top */
         lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
@@ -748,8 +1033,9 @@
           lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);
           goto newframe;  /* restart luaV_execute over new Lua function */
         }
-      )
-      vmcasenb(OP_RETURN,
+        vmbreak;
+      }
+      vmcase(OP_RETURN) {
         int b = GETARG_B(i);
         if (b != 0) L->top = ra+b-1;
         if (cl->p->sizep > 0) luaF_close(L, base);
@@ -763,32 +1049,60 @@
           lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);
           goto newframe;  /* restart luaV_execute over new Lua function */
         }
-      )
-      vmcase(OP_FORLOOP,
-        lua_Number step = nvalue(ra+2);
-        lua_Number idx = luai_numadd(L, nvalue(ra), step); /* increment index */
-        lua_Number limit = nvalue(ra+1);
-        if (luai_numlt(L, 0, step) ? luai_numle(L, idx, limit)
-                                   : luai_numle(L, limit, idx)) {
-          ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
-          setnvalue(ra, idx);  /* update internal index... */
-          setnvalue(ra+3, idx);  /* ...and external index */
-        }
-      )
-      vmcase(OP_FORPREP,
-        const TValue *init = ra;
-        const TValue *plimit = ra+1;
-        const TValue *pstep = ra+2;
-        if (!tonumber(init, ra))
-          luaG_runerror(L, LUA_QL("for") " initial value must be a number");
-        else if (!tonumber(plimit, ra+1))
-          luaG_runerror(L, LUA_QL("for") " limit must be a number");
-        else if (!tonumber(pstep, ra+2))
-          luaG_runerror(L, LUA_QL("for") " step must be a number");
-        setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));
+      }
+      vmcase(OP_FORLOOP) {
+        if (ttisinteger(ra)) {  /* integer loop? */
+          lua_Integer step = ivalue(ra + 2);
+          lua_Integer idx = ivalue(ra) + step; /* increment index */
+          lua_Integer limit = ivalue(ra + 1);
+          if ((0 < step) ? (idx <= limit) : (limit <= idx)) {
+            ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+            setivalue(ra, idx);  /* update internal index... */
+            setivalue(ra + 3, idx);  /* ...and external index */
+          }
+        }
+        else {  /* floating loop */
+          lua_Number step = fltvalue(ra + 2);
+          lua_Number idx = luai_numadd(L, fltvalue(ra), step); /* inc. index */
+          lua_Number limit = fltvalue(ra + 1);
+          if (luai_numlt(0, step) ? luai_numle(idx, limit)
+                                  : luai_numle(limit, idx)) {
+            ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+            setfltvalue(ra, idx);  /* update internal index... */
+            setfltvalue(ra + 3, idx);  /* ...and external index */
+          }
+        }
+        vmbreak;
+      }
+      vmcase(OP_FORPREP) {
+        TValue *init = ra;
+        TValue *plimit = ra + 1;
+        TValue *pstep = ra + 2;
+        lua_Integer ilimit;
+        int stopnow;
+        if (ttisinteger(init) && ttisinteger(pstep) &&
+            forlimit(plimit, &ilimit, ivalue(pstep), &stopnow)) {
+          /* all values are integer */
+          lua_Integer initv = (stopnow ? 0 : ivalue(init));
+          setivalue(plimit, ilimit);
+          setivalue(init, initv - ivalue(pstep));
+        }
+        else {  /* try making all values floats */
+          lua_Number ninit; lua_Number nlimit; lua_Number nstep;
+          if (!tonumber(plimit, &nlimit))
+            luaG_runerror(L, "'for' limit must be a number");
+          setfltvalue(plimit, nlimit);
+          if (!tonumber(pstep, &nstep))
+            luaG_runerror(L, "'for' step must be a number");
+          setfltvalue(pstep, nstep);
+          if (!tonumber(init, &ninit))
+            luaG_runerror(L, "'for' initial value must be a number");
+          setfltvalue(init, luai_numsub(L, ninit, nstep));
+        }
         ci->u.l.savedpc += GETARG_sBx(i);
-      )
-      vmcasenb(OP_TFORCALL,
+        vmbreak;
+      }
+      vmcase(OP_TFORCALL) {
         StkId cb = ra + 3;  /* call base */
         setobjs2s(L, cb+2, ra+2);
         setobjs2s(L, cb+1, ra+1);
@@ -800,18 +1114,19 @@
         ra = RA(i);
         lua_assert(GET_OPCODE(i) == OP_TFORLOOP);
         goto l_tforloop;
-      )
-      vmcase(OP_TFORLOOP,
+      }
+      vmcase(OP_TFORLOOP) {
         l_tforloop:
         if (!ttisnil(ra + 1)) {  /* continue loop? */
           setobjs2s(L, ra, ra + 1);  /* save control variable */
            ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
         }
-      )
-      vmcase(OP_SETLIST,
+        vmbreak;
+      }
+      vmcase(OP_SETLIST) {
         int n = GETARG_B(i);
         int c = GETARG_C(i);
-        int last;
+        unsigned int last;
         Table *h;
         if (n == 0) n = cast_int(L->top - ra) - 1;
         if (c == 0) {
@@ -826,20 +1141,22 @@
         for (; n > 0; n--) {
           TValue *val = ra+n;
           luaH_setint(L, h, last--, val);
-          luaC_barrierback(L, obj2gco(h), val);
+          luaC_barrierback(L, h, val);
         }
         L->top = ci->top;  /* correct top (in case of previous open call) */
-      )
-      vmcase(OP_CLOSURE,
+        vmbreak;
+      }
+      vmcase(OP_CLOSURE) {
         Proto *p = cl->p->p[GETARG_Bx(i)];
-        Closure *ncl = getcached(p, cl->upvals, base);  /* cached closure */
+        LClosure *ncl = getcached(p, cl->upvals, base);  /* cached closure */
         if (ncl == NULL)  /* no match? */
           pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
         else
           setclLvalue(L, ra, ncl);  /* push cashed closure */
         checkGC(L, ra + 1);
-      )
-      vmcase(OP_VARARG,
+        vmbreak;
+      }
+      vmcase(OP_VARARG) {
         int b = GETARG_B(i) - 1;
         int j;
         int n = cast_int(base - ci->func) - cl->p->numparams - 1;
@@ -857,11 +1174,15 @@
             setnilvalue(ra + j);
           }
         }
-      )
-      vmcase(OP_EXTRAARG,
+        vmbreak;
+      }
+      vmcase(OP_EXTRAARG) {
         lua_assert(0);
-      )
+        vmbreak;
+      }
     }
   }
 }
 
+/* }================================================================== */
+
diff -urN rpm-5.4.15/lua/lvm.h rpm-5.4-cvs/lua/lvm.h
--- rpm-5.4.15/lua/lvm.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lvm.h	2015-04-18 23:34:19.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lvm.h,v 2.18 2013/01/08 14:06:55 roberto Exp $
+** $Id: lvm.h,v 2.34 2014/08/01 17:24:02 roberto Exp $
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */
@@ -13,23 +13,36 @@
 #include "ltm.h"
 
 
-#define tostring(L,o) (ttisstring(o) || (luaV_tostring(L, o)))
+#if !defined(LUA_NOCVTN2S)
+#define cvt2str(o)	ttisnumber(o)
+#else
+#define cvt2str(o)	0	/* no conversion from numbers to strings */
+#endif
+
+
+#if !defined(LUA_NOCVTS2N)
+#define cvt2num(o)	ttisstring(o)
+#else
+#define cvt2num(o)	0	/* no conversion from strings to numbers */
+#endif
 
-#define tonumber(o,n)	(ttisnumber(o) || (((o) = luaV_tonumber(o,n)) != NULL))
 
-#define equalobj(L,o1,o2)  (ttisequal(o1, o2) && luaV_equalobj_(L, o1, o2))
+#define tonumber(o,n) \
+	(ttisfloat(o) ? (*(n) = fltvalue(o), 1) : luaV_tonumber_(o,n))
 
-#define luaV_rawequalobj(o1,o2)		equalobj(NULL,o1,o2)
+#define tointeger(o,i) \
+	(ttisinteger(o) ? (*(i) = ivalue(o), 1) : luaV_tointeger_(o,i))
 
+#define intop(op,v1,v2) l_castU2S(l_castS2U(v1) op l_castS2U(v2))
 
-/* not to called directly */
-LUAI_FUNC int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2);
+#define luaV_rawequalobj(t1,t2)		luaV_equalobj(NULL,t1,t2)
 
 
+LUAI_FUNC int luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2);
 LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
 LUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);
-LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
-LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
+LUAI_FUNC int luaV_tonumber_ (const TValue *obj, lua_Number *n);
+LUAI_FUNC int luaV_tointeger_ (const TValue *obj, lua_Integer *p);
 LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
                                             StkId val);
 LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
@@ -37,8 +50,10 @@
 LUAI_FUNC void luaV_finishOp (lua_State *L);
 LUAI_FUNC void luaV_execute (lua_State *L);
 LUAI_FUNC void luaV_concat (lua_State *L, int total);
-LUAI_FUNC void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
-                           const TValue *rc, TMS op);
+LUAI_FUNC lua_Integer luaV_div (lua_State *L, lua_Integer x, lua_Integer y);
+LUAI_FUNC lua_Integer luaV_mod (lua_State *L, lua_Integer x, lua_Integer y);
+LUAI_FUNC lua_Integer luaV_shiftl (lua_Integer x, lua_Integer y)
+	LUA_GNUC_CONST;
 LUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);
 
 #endif
diff -urN rpm-5.4.15/lua/lzio.c rpm-5.4-cvs/lua/lzio.c
--- rpm-5.4.15/lua/lzio.c	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lzio.c	2015-04-18 23:34:19.000000000 -0500
@@ -1,15 +1,17 @@
 /*
-** $Id: lzio.c,v 1.35 2012/05/14 13:34:18 roberto Exp $
+** $Id: lzio.c,v 1.36 2014/11/02 19:19:04 roberto Exp $
 ** Buffered streams
 ** See Copyright Notice in lua.h
 */
 
-
-#include <string.h>
-
 #define lzio_c
 #define LUA_CORE
 
+#include "lprefix.h"
+
+
+#include <string.h>
+
 #include "lua.h"
 
 #include "llimits.h"
diff -urN rpm-5.4.15/lua/lzio.h rpm-5.4-cvs/lua/lzio.h
--- rpm-5.4.15/lua/lzio.h	2013-06-29 16:03:23.000000000 -0500
+++ rpm-5.4-cvs/lua/lzio.h	2015-04-18 23:34:19.000000000 -0500
@@ -1,5 +1,5 @@
 /*
-** $Id: lzio.h,v 1.26 2011/07/15 12:48:03 roberto Exp $
+** $Id: lzio.h,v 1.30 2014/12/19 17:26:14 roberto Exp $
 ** Buffered streams
 ** See Copyright Notice in lua.h
 */
@@ -32,11 +32,13 @@
 #define luaZ_sizebuffer(buff)	((buff)->buffsize)
 #define luaZ_bufflen(buff)	((buff)->n)
 
+#define luaZ_buffremove(buff,i)	((buff)->n -= (i))
 #define luaZ_resetbuffer(buff) ((buff)->n = 0)
 
 
 #define luaZ_resizebuffer(L, buff, size) \
-	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
+	((buff)->buffer = luaM_reallocvchar(L, (buff)->buffer, \
+				(buff)->buffsize, size), \
 	(buff)->buffsize = size)
 
 #define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
@@ -45,7 +47,7 @@
 LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
 LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
                                         void *data);
-LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+LUAI_FUNC size_t luaZ_read (ZIO* z, void *b, size_t n);	/* read next n bytes */
 
 
 
@@ -55,7 +57,7 @@
   size_t n;			/* bytes still unread */
   const char *p;		/* current position in buffer */
   lua_Reader reader;		/* reader function */
-  void* data;			/* additional data */
+  void *data;			/* additional data */
   lua_State *L;			/* Lua state (for reader) */
 };
 
diff -urN rpm-5.4.15/lua/Makefile.am rpm-5.4-cvs/lua/Makefile.am
--- rpm-5.4.15/lua/Makefile.am	2013-06-29 16:03:22.000000000 -0500
+++ rpm-5.4-cvs/lua/Makefile.am	2015-05-01 15:14:39.000000000 -0500
@@ -1,8 +1,16 @@
 
+AUTOMAKE_OPTIONS = 1.4 foreign
+
+SUBDIRS = . tests
+
+CLEANFILES = \
+	*.gcov .libs/*.gcda .libs/*.gcno *.gcno *.gcda \
+	local/*.gcov local/.libs/*.gcda local/.libs/*.gcno local/*.gcno local/*.gcda
 EXTRA_DIST = \
 	COPYRIGHT \
 	HISTORY \
-	lua.hpp \
+	ltests.c \
+	ltests.h \
 	local/lom.lua \
 	local/llocal.lua
 
@@ -25,11 +33,18 @@
 AM_CPPFLAGS += \
 	-I$(srcdir)
 
-pkgbindir =	@USRLIBRPM@/bin
+pkgdir =	@USRLIBRPM@
+pkgbindir =	$(pkgdir)/bin
+pkgincdir =	$(pkgdir)/include
+pkglibdir =	$(pkgdir)/lib
+pkgsharedir =	$(pkgdir)/share
+
+luaCPATHdir =   ${pkglibdir)/lua
+luaLPATHdir =   ${pkgsharedir)/lua
+
 pkgbin_PROGRAMS =	rpmlua rpmluac
 noinst_PROGRAMS =	bin2c
 
-pkglibdir =	@USRLIBRPM@/lib
 pkglib_LTLIBRARIES =	liblua.la
 
 rpmlua_SOURCES = lua.c
@@ -211,6 +226,7 @@
 	shadow/strtoday.c \
 	shadow/useradd.c
 endif
+
 if USE_LUA_CHKCONFIG
 liblua_la_CFLAGS += \
 	-DUSE_LUA_CHKCONFIG
@@ -247,18 +263,37 @@
 	local/luuid.c \
 	local/luuid.h
 
+pkginc_HEADERS = lauxlib.h lua.h lua.hpp luaconf.h lualib.h
+noinst_HEADERS = \
+	lapi.h \
+	lcode.h \
+	lctype.h \
+	ldebug.h \
+	ldo.h \
+	lfunc.h \
+	lgc.h \
+	llex.h \
+	llimits.h \
+	lmem.h \
+	lobject.h \
+	lopcodes.h \
+	lparser.h \
+	lprefix.h \
+	lstate.h \
+	lstring.h \
+	ltable.h \
+	ltm.h \
+	lundump.h \
+	lvm.h \
+	lzio.h
+
 liblua_la_SOURCES += \
 	linit.c \
 	lauxlib.c \
-	lauxlib.h \
-	lua.h \
-	luaconf.h \
-	lualib.h \
 	lbaselib.c \
 	lbitlib.c \
 	lcorolib.c \
 	lctype.c \
-	lctype.h \
 	ldblib.c \
 	liolib.c \
 	loslib.c \
@@ -267,43 +302,26 @@
 	lstrlib.c \
 	ltablib.c \
 	lapi.c \
-	lapi.h \
 	lcode.c \
-	lcode.h \
 	ldebug.c \
-	ldebug.h \
 	ldo.c \
-	ldo.h \
 	ldump.c \
 	lfunc.c \
-	lfunc.h \
 	lgc.c \
-	lgc.h \
 	llex.c \
-	llex.h \
-	llimits.h \
 	lmem.c \
-	lmem.h \
 	lobject.c \
-	lobject.h \
 	lopcodes.c \
-	lopcodes.h \
 	lparser.c \
-	lparser.h \
 	lstate.c \
-	lstate.h \
 	lstring.c \
-	lstring.h \
 	ltable.c \
-	ltable.h \
 	ltm.c \
-	ltm.h \
 	lundump.c \
-	lundump.h \
+	lutf8lib.c \
 	lvm.c \
-	lvm.h \
-	lzio.c \
-	lzio.h
+	lzio.c
+
 liblua.la: $(liblua_la_OBJECTS) $(liblua_la_DEPENDENCIES) 
 	$(liblua_la_LINK) $(liblua_la_OBJECTS) $(liblua_la_LIBADD)
 	-ln -sf ../liblua.la .libs/liblua.lai		#XXX HACK ALERT
@@ -320,6 +338,9 @@
 	$(builddir)/bin2c $(srcdir)/local/llocal.lua > $(builddir)/local/llocal_lua.c
 endif
 
+distclean-local:
+	rm -f .syntastic_c_config
+
 clean-local:
 	-rm -f $(builddir)/local/llocal_lua.c
 
@@ -332,3 +353,7 @@
 	$(__LN) $(DESTDIR)$(pkgbindir)/rpmlua $(DESTDIR)$(pkgbindir)/lua
 	$(__RM) -f $(DESTDIR)$(pkgbindir)/luac
 	$(__LN) $(DESTDIR)$(pkgbindir)/rpmluac $(DESTDIR)$(pkgbindir)/luac
+
+BUILT_SOURCES = .syntastic_c_config
+.syntastic_c_config: Makefile
+	@echo $(COMPILE) | tr ' ' '\n' | sed -e '1d' > $@
diff -urN rpm-5.4.15/lua/tests/all.lua rpm-5.4-cvs/lua/tests/all.lua
--- rpm-5.4.15/lua/tests/all.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/all.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,258 @@
+#!../lua
+-- $Id: all.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+local version = "Lua 5.3"
+if _VERSION ~= version then
+  io.stderr:write("\nThis test suite is for ", version, ", not for ", _VERSION,
+    "\nExiting tests\n")
+  return
+end
+
+
+-- next variables control the execution of some tests
+-- true means no test (so an undefined variable does not skip a test)
+-- defaults are for Linux; test everything.
+-- Make true to avoid long or memory consuming tests
+_soft = rawget(_G, "_soft") or false
+-- Make true to avoid non-portable tests
+_port = rawget(_G, "_port") or false
+-- Make true to avoid messages about tests not performed
+_nomsg = rawget(_G, "_nomsg") or false
+
+
+local usertests = rawget(_G, "_U")
+
+if usertests then
+  -- tests for sissies ;)  Avoid problems
+  _soft = true
+  _port = true
+  _nomsg = true
+end
+
+-- tests should require debug when needed
+debug = nil
+
+if usertests then
+  T = nil    -- no "internal" tests for user tests
+else
+  T = rawget(_G, "T")  -- avoid problems with 'strict' module
+end
+
+math.randomseed(0)
+
+--[=[
+  example of a long [comment],
+  [[spanning several [lines]]]
+
+]=]
+
+print("current path:\n****" .. package.path .. "****\n")
+
+
+local initclock = os.clock()
+local lastclock = initclock
+local walltime = os.time()
+
+local collectgarbage = collectgarbage
+
+do   -- (
+
+-- track messages for tests not performed
+local msgs = {}
+function Message (m)
+  if not _nomsg then
+    print(m)
+    msgs[#msgs+1] = string.sub(m, 3, -3)
+  end
+end
+
+assert(os.setlocale"C")
+
+local T,print,format,write,assert,type,unpack,floor =
+      T,print,string.format,io.write,assert,type,table.unpack,math.floor
+
+-- use K for 1000 and M for 1000000 (not 2^10 -- 2^20)
+local function F (m)
+  local function round (m)
+    m = m + 0.04999
+    return format("%.1f", m)      -- keep one decimal digit
+  end
+  if m < 1000 then return m
+  else
+    m = m / 1000
+    if m < 1000 then return round(m).."K"
+    else
+      return round(m/1000).."M"
+    end
+  end
+end
+
+local showmem
+if not T then
+  local max = 0
+  showmem = function ()
+    local m = collectgarbage("count") * 1024
+    max = (m > max) and m or max
+    print(format("    ---- total memory: %s, max memory: %s ----\n",
+          F(m), F(max)))
+  end
+else
+  showmem = function ()
+    T.checkmemory()
+    local total, numblocks, maxmem = T.totalmem()
+    local count = collectgarbage("count")
+    print(format(
+      "\n    ---- total memory: %s (%.0fK), max use: %s,  blocks: %d\n",
+      F(total), count, F(maxmem), numblocks))
+    print(format("\t(strings:  %d, tables: %d, functions: %d, "..
+                 "\n\tudata: %d, threads: %d)",
+                 T.totalmem"string", T.totalmem"table", T.totalmem"function",
+                 T.totalmem"userdata", T.totalmem"thread"))
+  end
+end
+
+
+--
+-- redefine dofile to run files through dump/undump
+--
+local function report (n) print("\n***** FILE '"..n.."'*****") end
+local olddofile = dofile
+local dofile = function (n, strip)
+  showmem()
+  local c = os.clock()
+  print(string.format("time: %g (+%g)", c - initclock, c - lastclock))
+  lastclock = c
+  report(n)
+  local f = assert(loadfile(n))
+  local b = string.dump(f, strip)
+  f = assert(load(b))
+  return f()
+end
+
+dofile('main.lua')
+
+do
+  local next, setmetatable, stderr = next, setmetatable, io.stderr
+  -- track collections
+  local mt = {}
+  -- each time a table is collected, remark it for finalization
+  -- on next cycle
+  mt.__gc = function (o)
+     stderr:write'.'    -- mark progress
+     local n = setmetatable(o, mt)   -- remark it
+   end
+   local n = setmetatable({}, mt)    -- create object
+end
+
+report"gc.lua"
+local f = assert(loadfile('gc.lua'))
+f()
+
+dofile('db.lua')
+assert(dofile('calls.lua') == deep and deep)
+olddofile('strings.lua')
+olddofile('literals.lua')
+dofile('tpack.lua')
+assert(dofile('attrib.lua') == 27)
+
+assert(dofile('locals.lua') == 5)
+dofile('constructs.lua')
+dofile('code.lua', true)
+if not _G._soft then
+  report('big.lua')
+  local f = coroutine.wrap(assert(loadfile('big.lua')))
+  assert(f() == 'b')
+  assert(f() == 'a')
+end
+dofile('nextvar.lua')
+dofile('pm.lua')
+dofile('utf8.lua')
+dofile('api.lua')
+assert(dofile('events.lua') == 12)
+dofile('vararg.lua')
+dofile('closure.lua')
+dofile('coroutine.lua')
+dofile('goto.lua', true)
+dofile('errors.lua')
+dofile('math.lua')
+dofile('sort.lua', true)
+dofile('bitwise.lua')
+assert(dofile('verybig.lua', true) == 10); collectgarbage()
+dofile('files.lua')
+
+if #msgs > 0 then
+  print("\ntests not performed:")
+  for i=1,#msgs do
+    print(msgs[i])
+  end
+  print()
+end
+
+-- no test module should define 'debug'
+assert(debug == nil)
+
+local debug = require "debug"
+
+print(string.format("%d-bit integers, %d-bit floats",
+        string.packsize("j") * 8, string.packsize("n") * 8))
+
+debug.sethook(function (a) assert(type(a) == 'string') end, "cr")
+
+-- to survive outside block
+_G.showmem = showmem
+
+end   --)
+
+local _G, showmem, print, format, clock, time, assert, open =
+      _G, showmem, print, string.format, os.clock, os.time, assert, io.open
+
+-- file with time of last performed test
+local fname = T and "time-debug.txt" or "time.txt"
+local lasttime
+
+if not usertests then
+  -- open file with time of last performed test
+  local f = io.open(fname)
+  if f then
+    lasttime = assert(tonumber(f:read'a'))
+    f:close();
+  else   -- no such file; assume it is recording time for first time
+    lasttime = nil
+  end
+end
+
+-- erase (almost) all globals
+print('cleaning all!!!!')
+for n in pairs(_G) do
+  if not ({___Glob = 1, tostring = 1})[n] then
+    _G[n] = nil
+  end
+end
+
+
+collectgarbage()
+collectgarbage()
+collectgarbage()
+collectgarbage()
+collectgarbage()
+collectgarbage();showmem()
+
+local clocktime = clock() - initclock
+walltime = time() - walltime
+
+print(format("\n\ntotal time: %.2fs (wall time: %ds)\n", clocktime, walltime))
+
+if not usertests then
+  lasttime = lasttime or clocktime    -- if no last time, ignore difference
+  -- check whether current test time differs more than 5% from last time
+  local diff = (clocktime - lasttime) / clocktime
+  local tolerance = 0.05    -- 5%
+  if (diff >= tolerance or diff <= -tolerance) then
+    print(format("WARNING: time difference from previous test: %+.1f%%",
+                  diff * 100))
+  end
+  assert(open(fname, "w")):write(clocktime):close()
+end
+
+print("final OK !!!")
+
diff -urN rpm-5.4.15/lua/tests/api.lua rpm-5.4-cvs/lua/tests/api.lua
--- rpm-5.4.15/lua/tests/api.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/api.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,1143 @@
+-- $Id: api.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+if T==nil then
+  (Message or print)('\n >>> testC not active: skipping API tests <<<\n')
+  return
+end
+
+local debug = require "debug"
+
+local pack = table.pack
+
+
+function tcheck (t1, t2)
+  assert(t1.n == (t2.n or #t2) + 1)
+  for i = 2, t1.n do assert(t1[i] == t2[i - 1]) end
+end
+
+
+local function checkerr (msg, f, ...)
+  local stat, err = pcall(f, ...)
+  assert(not stat and string.find(err, msg))
+end
+
+
+print('testing C API')
+
+a = T.testC("pushvalue R; return 1")
+assert(a == debug.getregistry())
+
+
+-- absindex
+assert(T.testC("settop 10; absindex -1; return 1") == 10)
+assert(T.testC("settop 5; absindex -5; return 1") == 1)
+assert(T.testC("settop 10; absindex 1; return 1") == 1)
+assert(T.testC("settop 10; absindex R; return 1") < -10)
+
+-- testing alignment
+a = T.d2s(12458954321123)
+assert(a == string.pack("d", 12458954321123))
+assert(T.s2d(a) == 12458954321123)
+
+a,b,c = T.testC("pushnum 1; pushnum 2; pushnum 3; return 2")
+assert(a == 2 and b == 3 and not c)
+
+f = T.makeCfunc("pushnum 1; pushnum 2; pushnum 3; return 2")
+a,b,c = f()
+assert(a == 2 and b == 3 and not c)
+
+-- test that all trues are equal
+a,b,c = T.testC("pushbool 1; pushbool 2; pushbool 0; return 3")
+assert(a == b and a == true and c == false)
+a,b,c = T.testC"pushbool 0; pushbool 10; pushnil;\
+                      tobool -3; tobool -3; tobool -3; return 3"
+assert(a==false and b==true and c==false)
+
+
+a,b,c = T.testC("gettop; return 2", 10, 20, 30, 40)
+assert(a == 40 and b == 5 and not c)
+
+t = pack(T.testC("settop 5; gettop; return .", 2, 3))
+tcheck(t, {n=4,2,3})
+
+t = pack(T.testC("settop 0; settop 15; return 10", 3, 1, 23))
+assert(t.n == 10 and t[1] == nil and t[10] == nil)
+
+t = pack(T.testC("remove -2; gettop; return .", 2, 3, 4))
+tcheck(t, {n=2,2,4})
+
+t = pack(T.testC("insert -1; gettop; return .", 2, 3))
+tcheck(t, {n=2,2,3})
+
+t = pack(T.testC("insert 3; gettop; return .", 2, 3, 4, 5))
+tcheck(t, {n=4,2,5,3,4})
+
+t = pack(T.testC("replace 2; gettop; return .", 2, 3, 4, 5))
+tcheck(t, {n=3,5,3,4})
+
+t = pack(T.testC("replace -2; gettop; return .", 2, 3, 4, 5))
+tcheck(t, {n=3,2,3,5})
+
+t = pack(T.testC("remove 3; gettop; return .", 2, 3, 4, 5))
+tcheck(t, {n=3,2,4,5})
+
+t = pack(T.testC("copy 3 4; gettop; return .", 2, 3, 4, 5))
+tcheck(t, {n=4,2,3,3,5})
+
+t = pack(T.testC("copy -3 -1; gettop; return .", 2, 3, 4, 5))
+tcheck(t, {n=4,2,3,4,3})
+
+do   -- testing 'rotate'
+  local t = {10, 20, 30, 40, 50, 60}
+  for i = -6, 6 do
+    local s = string.format("rotate 2 %d; return 7", i)
+    local t1 = pack(T.testC(s, 10, 20, 30, 40, 50, 60))
+    tcheck(t1, t)
+    table.insert(t, 1, table.remove(t))
+  end
+
+  t = pack(T.testC("rotate -2 1; gettop; return .", 10, 20, 30, 40))
+  tcheck(t, {10, 20, 40, 30})
+  t = pack(T.testC("rotate -2 -1; gettop; return .", 10, 20, 30, 40))
+  tcheck(t, {10, 20, 40, 30})
+
+  -- some corner cases
+  t = pack(T.testC("rotate -1 0; gettop; return .", 10, 20, 30, 40))
+  tcheck(t, {10, 20, 30, 40})
+  t = pack(T.testC("rotate -1 1; gettop; return .", 10, 20, 30, 40))
+  tcheck(t, {10, 20, 30, 40})
+  t = pack(T.testC("rotate 5 -1; gettop; return .", 10, 20, 30, 40))
+  tcheck(t, {10, 20, 30, 40})
+end
+
+-- testing non-function message handlers
+do
+  local f = T.makeCfunc[[
+    getglobal error
+    pushstring bola
+    pcall 1 1 1   # call 'error' with given handler
+    pushstatus
+    return 2     # return error message and status
+  ]]
+
+  local msg, st = f({})     -- invalid handler
+  assert(st == "ERRERR" and string.find(msg, "error handling"))
+  local msg, st = f(nil)     -- invalid handler
+  assert(st == "ERRERR" and string.find(msg, "error handling"))
+
+  local a = setmetatable({}, {__call = function (_, x) return x:upper() end})
+  local msg, st = f(a)   -- callable handler
+  assert(st == "ERRRUN" and msg == "BOLA")
+end
+
+t = pack(T.testC("insert 3; pushvalue 3; remove 3; pushvalue 2; remove 2; \
+                  insert 2; pushvalue 1; remove 1; insert 1; \
+      insert -2; pushvalue -2; remove -3; gettop; return .",
+      2, 3, 4, 5, 10, 40, 90))
+tcheck(t, {n=7,2,3,4,5,10,40,90})
+
+t = pack(T.testC("concat 5; gettop; return .", "alo", 2, 3, "joao", 12))
+tcheck(t, {n=1,"alo23joao12"})
+
+-- testing MULTRET
+t = pack(T.testC("call 2,-1; gettop; return .",
+     function (a,b) return 1,2,3,4,a,b end, "alo", "joao"))
+tcheck(t, {n=6,1,2,3,4,"alo", "joao"})
+
+do  -- test returning more results than fit in the caller stack
+  local a = {}
+  for i=1,1000 do a[i] = true end; a[999] = 10
+  local b = T.testC([[pcall 1 -1 0; pop 1; tostring -1; return 1]],
+                    table.unpack, a)
+  assert(b == "10")
+end
+
+
+-- testing globals
+_G.a = 14; _G.b = "a31"
+local a = {T.testC[[
+  getglobal a;
+  getglobal b;
+  getglobal b;
+  setglobal a;
+  gettop;
+  return .
+]]}
+assert(a[2] == 14 and a[3] == "a31" and a[4] == nil and _G.a == "a31")
+
+
+-- testing arith
+assert(T.testC("pushnum 10; pushnum 20; arith /; return 1") == 0.5)
+assert(T.testC("pushnum 10; pushnum 20; arith -; return 1") == -10)
+assert(T.testC("pushnum 10; pushnum -20; arith *; return 1") == -200)
+assert(T.testC("pushnum 10; pushnum 3; arith ^; return 1") == 1000)
+assert(T.testC("pushnum 10; pushstring 20; arith /; return 1") == 0.5)
+assert(T.testC("pushstring 10; pushnum 20; arith -; return 1") == -10)
+assert(T.testC("pushstring 10; pushstring -20; arith *; return 1") == -200)
+assert(T.testC("pushstring 10; pushstring 3; arith ^; return 1") == 1000)
+assert(T.testC("arith /; return 1", 2, 0) == 10.0/0)
+a = T.testC("pushnum 10; pushint 3; arith \\; return 1")
+assert(a == 3.0 and math.type(a) == "float")
+a = T.testC("pushint 10; pushint 3; arith \\; return 1")
+assert(a == 3 and math.type(a) == "integer")
+a = assert(T.testC("pushint 10; pushint 3; arith +; return 1"))
+assert(a == 13 and math.type(a) == "integer")
+a = assert(T.testC("pushnum 10; pushint 3; arith +; return 1"))
+assert(a == 13 and math.type(a) == "float")
+a,b,c = T.testC([[pushnum 1;
+                  pushstring 10; arith _;
+                  pushstring 5; return 3]])
+assert(a == 1 and b == -10 and c == "5")
+mt = {__add = function (a,b) return setmetatable({a[1] + b[1]}, mt) end,
+      __mod = function (a,b) return setmetatable({a[1] % b[1]}, mt) end,
+      __unm = function (a) return setmetatable({a[1]* 2}, mt) end}
+a,b,c = setmetatable({4}, mt),
+        setmetatable({8}, mt),
+        setmetatable({-3}, mt)
+x,y,z = T.testC("arith +; return 2", 10, a, b)
+assert(x == 10 and y[1] == 12 and z == nil)
+assert(T.testC("arith %; return 1", a, c)[1] == 4%-3)
+assert(T.testC("arith _; arith +; arith %; return 1", b, a, c)[1] ==
+               8 % (4 + (-3)*2))
+
+-- errors in arithmetic
+checkerr("divide by zero", T.testC, "arith \\", 10, 0)
+checkerr("%%0", T.testC, "arith %", 10, 0)
+
+
+-- testing lessthan and lessequal
+assert(T.testC("compare LT 2 5, return 1", 3, 2, 2, 4, 2, 2))
+assert(T.testC("compare LE 2 5, return 1", 3, 2, 2, 4, 2, 2))
+assert(not T.testC("compare LT 3 4, return 1", 3, 2, 2, 4, 2, 2))
+assert(T.testC("compare LE 3 4, return 1", 3, 2, 2, 4, 2, 2))
+assert(T.testC("compare LT 5 2, return 1", 4, 2, 2, 3, 2, 2))
+assert(not T.testC("compare LT 2 -3, return 1", "4", "2", "2", "3", "2", "2"))
+assert(not T.testC("compare LT -3 2, return 1", "3", "2", "2", "4", "2", "2"))
+
+-- non-valid indices produce false
+assert(not T.testC("compare LT 1 4, return 1"))
+assert(not T.testC("compare LE 9 1, return 1"))
+assert(not T.testC("compare EQ 9 9, return 1"))
+
+local b = {__lt = function (a,b) return a[1] < b[1] end}
+local a1,a3,a4 = setmetatable({1}, b),
+                 setmetatable({3}, b),
+                 setmetatable({4}, b)
+assert(T.testC("compare LT 2 5, return 1", a3, 2, 2, a4, 2, 2))
+assert(T.testC("compare LE 2 5, return 1", a3, 2, 2, a4, 2, 2))
+assert(T.testC("compare LT 5 -6, return 1", a4, 2, 2, a3, 2, 2))
+a,b = T.testC("compare LT 5 -6, return 2", a1, 2, 2, a3, 2, 20)
+assert(a == 20 and b == false)
+a,b = T.testC("compare LE 5 -6, return 2", a1, 2, 2, a3, 2, 20)
+assert(a == 20 and b == false)
+a,b = T.testC("compare LE 5 -6, return 2", a1, 2, 2, a1, 2, 20)
+assert(a == 20 and b == true)
+
+-- testing length
+local t = setmetatable({x = 20}, {__len = function (t) return t.x end})
+a,b,c = T.testC([[
+   len 2;
+   Llen 2;
+   objsize 2;
+   return 3
+]], t)
+assert(a == 20 and b == 20 and c == 0)
+
+t.x = "234"; t[1] = 20
+a,b,c = T.testC([[
+   len 2;
+   Llen 2;
+   objsize 2;
+   return 3
+]], t)
+assert(a == "234" and b == 234 and c == 1)
+
+t.x = print; t[1] = 20
+a,c = T.testC([[
+   len 2;
+   objsize 2;
+   return 2
+]], t)
+assert(a == print and c == 1)
+
+
+-- testing __concat
+
+a = setmetatable({x="u"}, {__concat = function (a,b) return a.x..'.'..b.x end})
+x,y = T.testC([[
+  pushnum 5
+  pushvalue 2;
+  pushvalue 2;
+  concat 2;
+  pushvalue -2;
+  return 2;
+]], a, a)
+assert(x == a..a and y == 5)
+
+-- concat with 0 elements
+assert(T.testC("concat 0; return 1") == "")
+
+-- concat with 1 element
+assert(T.testC("concat 1; return 1", "xuxu") == "xuxu")
+
+
+
+-- testing lua_is
+
+function B(x) return x and 1 or 0 end
+
+function count (x, n)
+  n = n or 2
+  local prog = [[
+    isnumber %d;
+    isstring %d;
+    isfunction %d;
+    iscfunction %d;
+    istable %d;
+    isuserdata %d;
+    isnil %d;
+    isnull %d;
+    return 8
+  ]]
+  prog = string.format(prog, n, n, n, n, n, n, n, n)
+  local a,b,c,d,e,f,g,h = T.testC(prog, x)
+  return B(a)+B(b)+B(c)+B(d)+B(e)+B(f)+B(g)+(100*B(h))
+end
+
+assert(count(3) == 2)
+assert(count('alo') == 1)
+assert(count('32') == 2)
+assert(count({}) == 1)
+assert(count(print) == 2)
+assert(count(function () end) == 1)
+assert(count(nil) == 1)
+assert(count(io.stdin) == 1)
+assert(count(nil, 15) == 100)
+
+
+-- testing lua_to...
+
+function to (s, x, n)
+  n = n or 2
+  return T.testC(string.format("%s %d; return 1", s, n), x)
+end
+
+assert(to("tostring", {}) == nil)
+assert(to("tostring", "alo") == "alo")
+assert(to("tostring", 12) == "12")
+assert(to("tostring", 12, 3) == nil)
+assert(to("objsize", {}) == 0)
+assert(to("objsize", {1,2,3}) == 3)
+assert(to("objsize", "alo\0\0a") == 6)
+assert(to("objsize", T.newuserdata(0)) == 0)
+assert(to("objsize", T.newuserdata(101)) == 101)
+assert(to("objsize", 124) == 0)
+assert(to("objsize", true) == 0)
+assert(to("tonumber", {}) == 0)
+assert(to("tonumber", "12") == 12)
+assert(to("tonumber", "s2") == 0)
+assert(to("tonumber", 1, 20) == 0)
+assert(to("topointer", 10) == 0)
+assert(to("topointer", true) == 0)
+assert(to("topointer", T.pushuserdata(20)) == 20)
+assert(to("topointer", io.read) ~= 0)           -- light C function
+assert(to("topointer", type) ~= 0)        -- "heavy" C function
+assert(to("topointer", function () end) ~= 0)   -- Lua function
+assert(to("func2num", 20) == 0)
+assert(to("func2num", T.pushuserdata(10)) == 0)
+assert(to("func2num", io.read) ~= 0)     -- light C function
+assert(to("func2num", type) ~= 0)  -- "heavy" C function (with upvalue)
+a = to("tocfunction", math.deg)
+assert(a(3) == math.deg(3) and a == math.deg)
+
+
+print("testing panic function")
+do
+  -- trivial error
+  assert(T.checkpanic("pushstring hi; error") == "hi")
+
+  -- using the stack inside panic
+  assert(T.checkpanic("pushstring hi; error;",
+    [[checkstack 5 XX
+      pushstring ' alo'
+      pushstring ' mundo'
+      concat 3]]) == "hi alo mundo")
+
+  -- "argerror" without frames
+  assert(T.checkpanic("loadstring 4") ==
+      "bad argument #4 (string expected, got no value)")
+  
+
+  -- memory error
+  T.totalmem(T.totalmem()+5000)   -- set low memory limit (+5k)
+  assert(T.checkpanic("newuserdata 10000") == "not enough memory")
+  T.totalmem(0)          -- restore high limit
+
+  -- stack error
+  if not _soft then
+    local msg = T.checkpanic[[
+      pushstring "function f() f() end"
+      loadstring -1; call 0 0
+      getglobal f; call 0 0
+    ]]
+    assert(string.find(msg, "stack overflow"))
+  end
+
+end
+
+-- testing deep C stack
+if not _soft then
+  print("testing stack overflow")
+  collectgarbage("stop")
+  checkerr("XXXX", T.testC, "checkstack 1000023 XXXX")   -- too deep
+  -- too deep (with no message)
+  checkerr("^stack overflow$", T.testC, "checkstack 1000023 ''")
+  local s = string.rep("pushnil;checkstack 1 XX;", 1000000)
+  checkerr("XX", T.testC, s)
+  collectgarbage("restart")
+  print'+'
+end
+
+local lim = _soft and 500 or 12000
+local prog = {"checkstack " .. (lim * 2 + 100) .. "msg", "newtable"}
+for i = 1,lim do
+  prog[#prog + 1] = "pushnum " .. i
+  prog[#prog + 1] = "pushnum " .. i * 10
+end
+
+prog[#prog + 1] = "rawgeti R 2"   -- get global table in registry
+prog[#prog + 1] = "insert " .. -(2*lim + 2)
+
+for i = 1,lim do
+  prog[#prog + 1] = "settable " .. -(2*(lim - i + 1) + 1)
+end
+
+prog[#prog + 1] = "return 2"
+
+prog = table.concat(prog, ";")
+local g, t = T.testC(prog)
+assert(g == _G)
+for i = 1,lim do assert(t[i] == i*10); t[i] = nil end
+assert(next(t) == nil)
+prog, g, t = nil
+
+-- testing errors
+
+a = T.testC([[
+  loadstring 2; pcall 0 1 0;
+  pushvalue 3; insert -2; pcall 1 1 0;
+  pcall 0 0 0;
+  return 1
+]], "x=150", function (a) assert(a==nil); return 3 end)
+
+assert(type(a) == 'string' and x == 150)
+
+function check3(p, ...)
+  local arg = {...}
+  assert(#arg == 3)
+  assert(string.find(arg[3], p))
+end
+check3(":1:", T.testC("loadstring 2; gettop; return .", "x="))
+check3("%.", T.testC("loadfile 2; gettop; return .", "."))
+check3("xxxx", T.testC("loadfile 2; gettop; return .", "xxxx"))
+
+-- test errors in non protected threads
+function checkerrnopro (code, msg)
+  local th = coroutine.create(function () end)  -- create new thread
+  local stt, err = pcall(T.testC, th, code)   -- run code there
+  assert(not stt and string.find(err, msg))
+end
+
+if not _soft then
+  checkerrnopro("pushnum 3; call 0 0", "attempt to call")
+  print"testing stack overflow in unprotected thread"
+  function f () f() end
+  checkerrnopro("getglobal 'f'; call 0 0;", "stack overflow")
+end
+print"+"
+
+
+-- testing table access
+
+do   -- getp/setp
+  local a = {}
+  T.testC("rawsetp 2 1", a, 20)
+  assert(a[T.pushuserdata(1)] == 20)
+  assert(T.testC("rawgetp 2 1; return 1", a) == 20)
+end
+
+a = {x=0, y=12}
+x, y = T.testC("gettable 2; pushvalue 4; gettable 2; return 2",
+                a, 3, "y", 4, "x")
+assert(x == 0 and y == 12)
+T.testC("settable -5", a, 3, 4, "x", 15)
+assert(a.x == 15)
+a[a] = print
+x = T.testC("gettable 2; return 1", a)  -- table and key are the same object!
+assert(x == print)
+T.testC("settable 2", a, "x")    -- table and key are the same object!
+assert(a[a] == "x")
+
+b = setmetatable({p = a}, {})
+getmetatable(b).__index = function (t, i) return t.p[i] end
+k, x = T.testC("gettable 3, return 2", 4, b, 20, 35, "x")
+assert(x == 15 and k == 35)
+getmetatable(b).__index = function (t, i) return a[i] end
+getmetatable(b).__newindex = function (t, i,v ) a[i] = v end
+y = T.testC("insert 2; gettable -5; return 1", 2, 3, 4, "y", b)
+assert(y == 12)
+k = T.testC("settable -5, return 1", b, 3, 4, "x", 16)
+assert(a.x == 16 and k == 4)
+a[b] = 'xuxu'
+y = T.testC("gettable 2, return 1", b)
+assert(y == 'xuxu')
+T.testC("settable 2", b, 19)
+assert(a[b] == 19)
+
+-- testing next
+a = {}
+t = pack(T.testC("next; gettop; return .", a, nil))
+tcheck(t, {n=1,a})
+a = {a=3}
+t = pack(T.testC("next; gettop; return .", a, nil))
+tcheck(t, {n=3,a,'a',3})
+t = pack(T.testC("next; pop 1; next; gettop; return .", a, nil))
+tcheck(t, {n=1,a})
+
+
+
+-- testing upvalues
+
+do
+  local A = T.testC[[ pushnum 10; pushnum 20; pushcclosure 2; return 1]]
+  t, b, c = A([[pushvalue U0; pushvalue U1; pushvalue U2; return 3]])
+  assert(b == 10 and c == 20 and type(t) == 'table')
+  a, b = A([[tostring U3; tonumber U4; return 2]])
+  assert(a == nil and b == 0)
+  A([[pushnum 100; pushnum 200; replace U2; replace U1]])
+  b, c = A([[pushvalue U1; pushvalue U2; return 2]])
+  assert(b == 100 and c == 200)
+  A([[replace U2; replace U1]], {x=1}, {x=2})
+  b, c = A([[pushvalue U1; pushvalue U2; return 2]])
+  assert(b.x == 1 and c.x == 2)
+  T.checkmemory()
+end
+
+
+-- testing absent upvalues from C-function pointers
+assert(T.testC[[isnull U1; return 1]] == true)
+assert(T.testC[[isnull U100; return 1]] == true)
+assert(T.testC[[pushvalue U1; return 1]] == nil)
+
+local f = T.testC[[ pushnum 10; pushnum 20; pushcclosure 2; return 1]]
+assert(T.upvalue(f, 1) == 10 and
+       T.upvalue(f, 2) == 20 and
+       T.upvalue(f, 3) == nil)
+T.upvalue(f, 2, "xuxu")
+assert(T.upvalue(f, 2) == "xuxu")
+
+
+-- large closures
+do
+  local A = "checkstack 300 msg;" ..
+            string.rep("pushnum 10;", 255) ..
+            "pushcclosure 255; return 1"
+  A = T.testC(A)
+  for i=1,255 do
+    assert(A(("pushvalue U%d; return 1"):format(i)) == 10)
+  end
+  assert(A("isnull U256; return 1"))
+  assert(not A("isnil U256; return 1"))
+end
+
+
+
+-- testing get/setuservalue
+-- bug in 5.1.2
+checkerr("got number", debug.setuservalue, 3, {})
+checkerr("got nil", debug.setuservalue, nil, {})
+checkerr("got light userdata", debug.setuservalue, T.pushuserdata(1), {})
+
+local b = T.newuserdata(0)
+assert(debug.getuservalue(b) == nil)
+for _, v in pairs{true, false, 4.56, print, {}, b, "XYZ"} do
+  assert(debug.setuservalue(b, v) == b)
+  assert(debug.getuservalue(b) == v)
+end
+
+assert(debug.getuservalue(4) == nil)
+
+debug.setuservalue(b, function () return 10 end)
+collectgarbage()   -- function should not be collected
+assert(debug.getuservalue(b)() == 10)
+
+debug.setuservalue(b, 134)
+collectgarbage()   -- number should not be a problem for collector
+assert(debug.getuservalue(b) == 134)
+
+-- test barrier for uservalues
+T.gcstate("atomic")
+assert(T.gccolor(b) == "black")
+debug.setuservalue(b, {x = 100})
+T.gcstate("pause")  -- complete collection
+assert(debug.getuservalue(b).x == 100)  -- uvalue should be there
+
+-- long chain of userdata
+for i = 1, 1000 do
+  local bb = T.newuserdata(0)
+  debug.setuservalue(bb, b)
+  b = bb
+end
+collectgarbage()     -- nothing should not be collected
+for i = 1, 1000 do
+  b = debug.getuservalue(b)
+end
+assert(debug.getuservalue(b).x == 100)
+b = nil
+
+
+-- testing locks (refs)
+
+-- reuse of references
+local i = T.ref{}
+T.unref(i)
+assert(T.ref{} == i)
+
+Arr = {}
+Lim = 100
+for i=1,Lim do   -- lock many objects
+  Arr[i] = T.ref({})
+end
+
+assert(T.ref(nil) == -1 and T.getref(-1) == nil)
+T.unref(-1); T.unref(-1)
+
+for i=1,Lim do   -- unlock all them
+  T.unref(Arr[i])
+end
+
+function printlocks ()
+  local f = T.makeCfunc("gettable R; return 1")
+  local n = f("n")
+  print("n", n)
+  for i=0,n do
+    print(i, f(i))
+  end
+end
+
+
+for i=1,Lim do   -- lock many objects
+  Arr[i] = T.ref({})
+end
+
+for i=1,Lim,2 do   -- unlock half of them
+  T.unref(Arr[i])
+end
+
+assert(type(T.getref(Arr[2])) == 'table')
+
+
+assert(T.getref(-1) == nil)
+
+
+a = T.ref({})
+
+collectgarbage()
+
+assert(type(T.getref(a)) == 'table')
+
+
+-- colect in cl the `val' of all collected userdata
+tt = {}
+cl = {n=0}
+A = nil; B = nil
+local F
+F = function (x)
+  local udval = T.udataval(x)
+  table.insert(cl, udval)
+  local d = T.newuserdata(100)   -- cria lixo
+  d = nil
+  assert(debug.getmetatable(x).__gc == F)
+  assert(load("table.insert({}, {})"))()   -- cria mais lixo
+  collectgarbage()   -- forca coleta de lixo durante coleta!
+  assert(debug.getmetatable(x).__gc == F)   -- coleta anterior nao melou isso?
+  local dummy = {}    -- cria lixo durante coleta
+  if A ~= nil then
+    assert(type(A) == "userdata")
+    assert(T.udataval(A) == B)
+    debug.getmetatable(A)    -- just acess it
+  end
+  A = x   -- ressucita userdata
+  B = udval
+  return 1,2,3
+end
+tt.__gc = F
+
+-- test whether udate collection frees memory in the right time
+do
+  collectgarbage();
+  collectgarbage();
+  local x = collectgarbage("count");
+  local a = T.newuserdata(5001)
+  assert(T.testC("objsize 2; return 1", a) == 5001)
+  assert(collectgarbage("count") >= x+4)
+  a = nil
+  collectgarbage();
+  assert(collectgarbage("count") <= x+1)
+  -- udata without finalizer
+  x = collectgarbage("count")
+  collectgarbage("stop")
+  for i=1,1000 do T.newuserdata(0) end
+  assert(collectgarbage("count") > x+10)
+  collectgarbage()
+  assert(collectgarbage("count") <= x+1)
+  -- udata with finalizer
+  collectgarbage()
+  x = collectgarbage("count")
+  collectgarbage("stop")
+  a = {__gc = function () end}
+  for i=1,1000 do debug.setmetatable(T.newuserdata(0), a) end
+  assert(collectgarbage("count") >= x+10)
+  collectgarbage()  -- this collection only calls TM, without freeing memory
+  assert(collectgarbage("count") >= x+10)
+  collectgarbage()  -- now frees memory
+  assert(collectgarbage("count") <= x+1)
+  collectgarbage("restart")
+end
+
+
+collectgarbage("stop")
+
+-- create 3 userdatas with tag `tt'
+a = T.newuserdata(0); debug.setmetatable(a, tt); na = T.udataval(a)
+b = T.newuserdata(0); debug.setmetatable(b, tt); nb = T.udataval(b)
+c = T.newuserdata(0); debug.setmetatable(c, tt); nc = T.udataval(c)
+
+-- create userdata without meta table
+x = T.newuserdata(4)
+y = T.newuserdata(0)
+
+checkerr("FILE%* expected, got userdata", io.input, a)
+checkerr("FILE%* expected, got userdata", io.input, x)
+
+assert(debug.getmetatable(x) == nil and debug.getmetatable(y) == nil)
+
+d=T.ref(a);
+e=T.ref(b);
+f=T.ref(c);
+t = {T.getref(d), T.getref(e), T.getref(f)}
+assert(t[1] == a and t[2] == b and t[3] == c)
+
+t=nil; a=nil; c=nil;
+T.unref(e); T.unref(f)
+
+collectgarbage()
+
+-- check that unref objects have been collected
+assert(#cl == 1 and cl[1] == nc)
+
+x = T.getref(d)
+assert(type(x) == 'userdata' and debug.getmetatable(x) == tt)
+x =nil
+tt.b = b  -- create cycle
+tt=nil    -- frees tt for GC
+A = nil
+b = nil
+T.unref(d);
+n5 = T.newuserdata(0)
+debug.setmetatable(n5, {__gc=F})
+n5 = T.udataval(n5)
+collectgarbage()
+assert(#cl == 4)
+-- check order of collection
+assert(cl[2] == n5 and cl[3] == nb and cl[4] == na)
+
+collectgarbage"restart"
+
+
+a, na = {}, {}
+for i=30,1,-1 do
+  a[i] = T.newuserdata(0)
+  debug.setmetatable(a[i], {__gc=F})
+  na[i] = T.udataval(a[i])
+end
+cl = {}
+a = nil; collectgarbage()
+assert(#cl == 30)
+for i=1,30 do assert(cl[i] == na[i]) end
+na = nil
+
+
+for i=2,Lim,2 do   -- unlock the other half
+  T.unref(Arr[i])
+end
+
+x = T.newuserdata(41); debug.setmetatable(x, {__gc=F})
+assert(T.testC("objsize 2; return 1", x) == 41)
+cl = {}
+a = {[x] = 1}
+x = T.udataval(x)
+collectgarbage()
+-- old `x' cannot be collected (`a' still uses it)
+assert(#cl == 0)
+for n in pairs(a) do a[n] = nil end
+collectgarbage()
+assert(#cl == 1 and cl[1] == x)   -- old `x' must be collected
+
+-- testing lua_equal
+assert(T.testC("compare EQ 2 4; return 1", print, 1, print, 20))
+assert(T.testC("compare EQ 3 2; return 1", 'alo', "alo"))
+assert(T.testC("compare EQ 2 3; return 1", nil, nil))
+assert(not T.testC("compare EQ 2 3; return 1", {}, {}))
+assert(not T.testC("compare EQ 2 3; return 1"))
+assert(not T.testC("compare EQ 2 3; return 1", 3))
+
+-- testing lua_equal with fallbacks
+do
+  local map = {}
+  local t = {__eq = function (a,b) return map[a] == map[b] end}
+  local function f(x)
+    local u = T.newuserdata(0)
+    debug.setmetatable(u, t)
+    map[u] = x
+    return u
+  end
+  assert(f(10) == f(10))
+  assert(f(10) ~= f(11))
+  assert(T.testC("compare EQ 2 3; return 1", f(10), f(10)))
+  assert(not T.testC("compare EQ 2 3; return 1", f(10), f(20)))
+  t.__eq = nil
+  assert(f(10) ~= f(10))
+end
+
+print'+'
+
+
+
+-- testing changing hooks during hooks
+_G.t = {}
+T.sethook([[
+  # set a line hook after 3 count hooks
+  sethook 4 0 '
+    getglobal t;
+    pushvalue -3; append -2
+    pushvalue -2; append -2
+  ']], "c", 3)
+local a = 1   -- counting
+a = 1   -- counting
+a = 1   -- count hook (set line hook)
+a = 1   -- line hook
+a = 1   -- line hook
+debug.sethook()
+t = _G.t
+assert(t[1] == "line")
+line = t[2]
+assert(t[3] == "line" and t[4] == line + 1)
+assert(t[5] == "line" and t[6] == line + 2)
+assert(t[7] == nil)
+
+
+-------------------------------------------------------------------------
+do   -- testing errors during GC
+  local a = {}
+  for i=1,20 do
+    a[i] = T.newuserdata(i)   -- creates several udata
+  end
+  for i=1,20,2 do   -- mark half of them to raise errors during GC
+    debug.setmetatable(a[i], {__gc = function (x) error("error inside gc") end})
+  end
+  for i=2,20,2 do   -- mark the other half to count and to create more garbage
+    debug.setmetatable(a[i], {__gc = function (x) load("A=A+1")() end})
+  end
+  _G.A = 0
+  a = 0
+  while 1 do
+    local stat, msg = pcall(collectgarbage)
+    if stat then
+      break   -- stop when no more errors
+    else
+      a = a + 1
+      assert(string.find(msg, "__gc"))
+    end
+  end
+  assert(a == 10)  -- number of errors
+
+  assert(A == 10)  -- number of normal collections
+end
+-------------------------------------------------------------------------
+-- test for userdata vals
+do
+  local a = {}; local lim = 30
+  for i=0,lim do a[i] = T.pushuserdata(i) end
+  for i=0,lim do assert(T.udataval(a[i]) == i) end
+  for i=0,lim do assert(T.pushuserdata(i) == a[i]) end
+  for i=0,lim do a[a[i]] = i end
+  for i=0,lim do a[T.pushuserdata(i)] = i end
+  assert(type(tostring(a[1])) == "string")
+end
+
+
+-------------------------------------------------------------------------
+-- testing multiple states
+T.closestate(T.newstate());
+L1 = T.newstate()
+assert(L1)
+
+assert(T.doremote(L1, "X='a'; return 'a'") == 'a')
+
+
+assert(#pack(T.doremote(L1, "function f () return 'alo', 3 end; f()")) == 0)
+
+a, b = T.doremote(L1, "return f()")
+assert(a == 'alo' and b == '3')
+
+T.doremote(L1, "_ERRORMESSAGE = nil")
+-- error: `sin' is not defined
+a, _, b = T.doremote(L1, "return sin(1)")
+assert(a == nil and b == 2)   -- 2 == run-time error
+
+-- error: syntax error
+a, b, c = T.doremote(L1, "return a+")
+assert(a == nil and c == 3 and type(b) == "string")   -- 3 == syntax error
+
+T.loadlib(L1)
+a, b, c = T.doremote(L1, [[
+  string = require'string'
+  a = require'_G'; assert(a == _G and require("_G") == a)
+  io = require'io'; assert(type(io.read) == "function")
+  assert(require("io") == io)
+  a = require'table'; assert(type(a.insert) == "function")
+  a = require'debug'; assert(type(a.getlocal) == "function")
+  a = require'math'; assert(type(a.sin) == "function")
+  return string.sub('okinama', 1, 2)
+]])
+assert(a == "ok")
+
+T.closestate(L1);
+
+
+L1 = T.newstate()
+T.loadlib(L1)
+T.doremote(L1, "a = {}")
+T.testC(L1, [[getglobal "a"; pushstring "x"; pushint 1;
+             settable -3]])
+assert(T.doremote(L1, "return a.x") == "1")
+
+T.closestate(L1)
+
+L1 = nil
+
+print('+')
+
+-------------------------------------------------------------------------
+-- testing memory limits
+-------------------------------------------------------------------------
+checkerr("block too big", T.newuserdata, math.maxinteger)
+collectgarbage()
+T.totalmem(T.totalmem()+5000)   -- set low memory limit (+5k)
+checkerr("not enough memory", load"local a={}; for i=1,100000 do a[i]=i end")
+T.totalmem(0)          -- restore high limit
+
+-- test memory errors; increase memory limit in small steps, so that
+-- we get memory errors in different parts of a given task, up to there
+-- is enough memory to complete the task without errors
+function testamem (s, f)
+  collectgarbage(); collectgarbage()
+  local M = T.totalmem()
+  local oldM = M
+  local a,b = nil
+  while 1 do
+    M = M+7   -- increase memory limit in small steps
+    T.totalmem(M)
+    a, b = pcall(f)
+    T.totalmem(0)  -- restore high limit
+    if a and b then break end       -- stop when no more errors
+    collectgarbage()
+    if not a and not    -- `real' error?
+      (string.find(b, "memory") or string.find(b, "overflow")) then
+      error(b, 0)   -- propagate it
+    end
+  end
+  print("\nlimit for " .. s .. ": " .. M-oldM)
+  return b
+end
+
+
+-- testing memory errors when creating a new state
+
+b = testamem("state creation", T.newstate)
+T.closestate(b);  -- close new state
+
+
+-- testing threads
+
+-- get main thread from registry (at index LUA_RIDX_MAINTHREAD == 1)
+mt = T.testC("rawgeti R 1; return 1")
+assert(type(mt) == "thread" and coroutine.running() == mt)
+
+
+
+function expand (n,s)
+  if n==0 then return "" end
+  local e = string.rep("=", n)
+  return string.format("T.doonnewstack([%s[ %s;\n collectgarbage(); %s]%s])\n",
+                              e, s, expand(n-1,s), e)
+end
+
+G=0; collectgarbage(); a =collectgarbage("count")
+load(expand(20,"G=G+1"))()
+assert(G==20); collectgarbage();  -- assert(gcinfo() <= a+1)
+
+testamem("thread creation", function ()
+  return T.doonnewstack("x=1") == 0  -- try to create thread
+end)
+
+
+-- testing memory x compiler
+
+testamem("loadstring", function ()
+  return load("x=1")  -- try to do load a string
+end)
+
+
+local testprog = [[
+local function foo () return end
+local t = {"x"}
+a = "aaa"
+for i = 1, #t do a=a..t[i] end
+return true
+]]
+
+-- testing memory x dofile
+_G.a = nil
+local t =os.tmpname()
+local f = assert(io.open(t, "w"))
+f:write(testprog)
+f:close()
+testamem("dofile", function ()
+  local a = loadfile(t)
+  return a and a()
+end)
+assert(os.remove(t))
+assert(_G.a == "aaax")
+
+
+-- other generic tests
+
+testamem("string creation", function ()
+  local a, b = string.gsub("alo alo", "(a)", function (x) return x..'b' end)
+  return (a == 'ablo ablo')
+end)
+
+testamem("dump/undump", function ()
+  local a = load(testprog)
+  local b = a and string.dump(a)
+  a = b and load(b)
+  return a and a()
+end)
+
+local t = os.tmpname()
+testamem("file creation", function ()
+  local f = assert(io.open(t, 'w'))
+  assert (not io.open"nomenaoexistente")
+  io.close(f);
+  return not loadfile'nomenaoexistente'
+end)
+assert(os.remove(t))
+
+testamem("table creation", function ()
+  local a, lim = {}, 10
+  for i=1,lim do a[i] = i; a[i..'a'] = {} end
+  return (type(a[lim..'a']) == 'table' and a[lim] == lim)
+end)
+
+testamem("constructors", function ()
+  local a = {10, 20, 30, 40, 50; a=1, b=2, c=3, d=4, e=5}
+  return (type(a) == 'table' and a.e == 5)
+end)
+
+local a = 1
+close = nil
+testamem("closure creation", function ()
+  function close (b,c)
+   return function (x) return a+b+c+x end
+  end
+  return (close(2,3)(4) == 10)
+end)
+
+testamem("coroutines", function ()
+  local a = coroutine.wrap(function ()
+              coroutine.yield(string.rep("a", 10))
+              return {}
+            end)
+  assert(string.len(a()) == 10)
+  return a()
+end)
+
+print'+'
+
+-- testing some auxlib functions
+local function gsub (a, b, c)
+  a, b = T.testC("gsub 2 3 4; gettop; return 2", a, b, c)
+  assert(b == 5)
+  return a
+end
+
+assert(gsub("alo.alo.uhuh.", ".", "//") == "alo//alo//uhuh//")
+assert(gsub("alo.alo.uhuh.", "alo", "//") == "//.//.uhuh.")
+assert(gsub("", "alo", "//") == "")
+assert(gsub("...", ".", "/.") == "/././.")
+assert(gsub("...", "...", "") == "")
+
+
+-- testing luaL_newmetatable
+local mt_xuxu, res, top = T.testC("newmetatable xuxu; gettop; return 3")
+assert(type(mt_xuxu) == "table" and res and top == 3)
+local d, res, top = T.testC("newmetatable xuxu; gettop; return 3")
+assert(mt_xuxu == d and not res and top == 3)
+d, res, top = T.testC("newmetatable xuxu1; gettop; return 3")
+assert(mt_xuxu ~= d and res and top == 3)
+
+x = T.newuserdata(0);
+y = T.newuserdata(0);
+T.testC("pushstring xuxu; gettable R; setmetatable 2", x)
+assert(getmetatable(x) == mt_xuxu)
+
+-- testing luaL_testudata
+-- correct metatable
+local res1, res2, top = T.testC([[testudata -1 xuxu
+   	 			  testudata 2 xuxu
+				  gettop
+				  return 3]], x)
+assert(res1 and res2 and top == 4)
+
+-- wrong metatable
+res1, res2, top = T.testC([[testudata -1 xuxu1
+			    testudata 2 xuxu1
+			    gettop
+			    return 3]], x)
+assert(not res1 and not res2 and top == 4)
+
+-- non-existent type
+res1, res2, top = T.testC([[testudata -1 xuxu2
+			    testudata 2 xuxu2
+			    gettop
+			    return 3]], x)
+assert(not res1 and not res2 and top == 4)
+
+-- userdata has no metatable
+res1, res2, top = T.testC([[testudata -1 xuxu
+			    testudata 2 xuxu
+			    gettop
+			    return 3]], y)
+assert(not res1 and not res2 and top == 4)
+
+-- erase metatables
+do
+  local r = debug.getregistry()
+  assert(r.xuxu == mt_xuxu and r.xuxu1 == d)
+  r.xuxu = nil; r.xuxu1 = nil
+end
+
+print'OK'
+
diff -urN rpm-5.4.15/lua/tests/attrib.lua rpm-5.4-cvs/lua/tests/attrib.lua
--- rpm-5.4.15/lua/tests/attrib.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/attrib.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,462 @@
+-- $Id: attrib.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print "testing require"
+
+assert(require"string" == string)
+assert(require"math" == math)
+assert(require"table" == table)
+assert(require"io" == io)
+assert(require"os" == os)
+assert(require"coroutine" == coroutine)
+
+assert(type(package.path) == "string")
+assert(type(package.cpath) == "string")
+assert(type(package.loaded) == "table")
+assert(type(package.preload) == "table")
+
+assert(type(package.config) == "string")
+print("package config: "..string.gsub(package.config, "\n", "|"))
+
+do
+  -- create a path with 'max' templates,
+  -- each with 1-10 repetitions of '?'
+  local max = _soft and 100 or 2000
+  local t = {}
+  for i = 1,max do t[i] = string.rep("?", i%10 + 1) end
+  t[#t + 1] = ";"    -- empty template
+  local path = table.concat(t, ";")
+  -- use that path in a search
+  local s, err = package.searchpath("xuxu", path)
+  -- search fails; check that message has an occurence of
+  -- '??????????' with ? replaced by xuxu and at least 'max' lines
+  assert(not s and
+         string.find(err, string.rep("xuxu", 10)) and
+         #string.gsub(err, "[^\n]", "") >= max)
+  -- path with one very long template
+  local path = string.rep("?", max)
+  local s, err = package.searchpath("xuxu", path)
+  assert(not s and string.find(err, string.rep('xuxu', max)))
+end
+
+do
+  local oldpath = package.path
+  package.path = {}
+  local s, err = pcall(require, "no-such-file")
+  assert(not s and string.find(err, "package.path"))
+  package.path = oldpath
+end
+
+print('+')
+
+
+-- The next tests for 'require' assume some specific directories and
+-- libraries.
+
+if not _port then --[
+
+local dirsep = string.match(package.config, "^([^\n]+)\n")
+
+-- auxiliary directory with C modules and temporary files
+local DIR = "libs" .. dirsep
+
+-- prepend DIR to a name and correct directory separators
+local function D (x)
+  x = string.gsub(x, "/", dirsep)
+  return DIR .. x
+end
+
+-- prepend DIR and pospend proper C lib. extension to a name
+local function DC (x)
+  local ext = (dirsep == '\\') and ".dll" or ".so"
+  return D(x .. ext)
+end
+
+
+local function createfiles (files, preextras, posextras)
+  for n,c in pairs(files) do
+    io.output(D(n))
+    io.write(string.format(preextras, n))
+    io.write(c)
+    io.write(string.format(posextras, n))
+    io.close(io.output())
+  end
+end
+
+function removefiles (files)
+  for n in pairs(files) do
+    os.remove(D(n))
+  end
+end
+
+local files = {
+  ["names.lua"] = "do return {...} end\n",
+  ["err.lua"] = "B = 15; a = a + 1;",
+  ["A.lua"] = "",
+  ["B.lua"] = "assert(...=='B');require 'A'",
+  ["A.lc"] = "",
+  ["A"] = "",
+  ["L"] = "",
+  ["XXxX"] = "",
+  ["C.lua"] = "package.loaded[...] = 25; require'C'"
+}
+
+AA = nil
+local extras = [[
+NAME = '%s'
+REQUIRED = ...
+return AA]]
+
+createfiles(files, "", extras)
+
+-- testing explicit "dir" separator in 'searchpath'
+assert(package.searchpath("C.lua", D"?", "", "") == D"C.lua")
+assert(package.searchpath("C.lua", D"?", ".", ".") == D"C.lua")
+assert(package.searchpath("--x-", D"?", "-", "X") == D"XXxX")
+assert(package.searchpath("---xX", D"?", "---", "XX") == D"XXxX")
+assert(package.searchpath(D"C.lua", "?", dirsep) == D"C.lua")
+assert(package.searchpath(".\\C.lua", D"?", "\\") == D"./C.lua")
+
+local oldpath = package.path
+
+package.path = string.gsub("D/?.lua;D/?.lc;D/?;D/??x?;D/L", "D/", DIR)
+
+local try = function (p, n, r)
+  NAME = nil
+  local rr = require(p)
+  assert(NAME == n)
+  assert(REQUIRED == p)
+  assert(rr == r)
+end
+
+a = require"names"
+assert(a[1] == "names" and a[2] == D"names.lua")
+
+_G.a = nil
+assert(not pcall(require, "err"))
+assert(B == 15)
+
+assert(package.searchpath("C", package.path) == D"C.lua")
+assert(require"C" == 25)
+assert(require"C" == 25)
+AA = nil
+try('B', 'B.lua', true)
+assert(package.loaded.B)
+assert(require"B" == true)
+assert(package.loaded.A)
+assert(require"C" == 25)
+package.loaded.A = nil
+try('B', nil, true)   -- should not reload package
+try('A', 'A.lua', true)
+package.loaded.A = nil
+os.remove(D'A.lua')
+AA = {}
+try('A', 'A.lc', AA)  -- now must find second option
+assert(package.searchpath("A", package.path) == D"A.lc")
+assert(require("A") == AA)
+AA = false
+try('K', 'L', false)     -- default option
+try('K', 'L', false)     -- default option (should reload it)
+assert(rawget(_G, "_REQUIREDNAME") == nil)
+
+AA = "x"
+try("X", "XXxX", AA)
+
+
+removefiles(files)
+
+
+-- testing require of sub-packages
+
+local _G = _G
+
+package.path = string.gsub("D/?.lua;D/?/init.lua", "D/", DIR)
+
+files = {
+  ["P1/init.lua"] = "AA = 10",
+  ["P1/xuxu.lua"] = "AA = 20",
+}
+
+createfiles(files, "_ENV = {}\n", "\nreturn _ENV\n")
+AA = 0
+
+local m = assert(require"P1")
+assert(AA == 0 and m.AA == 10)
+assert(require"P1" == m)
+assert(require"P1" == m)
+
+assert(package.searchpath("P1.xuxu", package.path) == D"P1/xuxu.lua")
+m.xuxu = assert(require"P1.xuxu")
+assert(AA == 0 and m.xuxu.AA == 20)
+assert(require"P1.xuxu" == m.xuxu)
+assert(require"P1.xuxu" == m.xuxu)
+assert(require"P1" == m and m.AA == 10)
+
+
+removefiles(files)
+
+
+package.path = ""
+assert(not pcall(require, "file_does_not_exist"))
+package.path = "??\0?"
+assert(not pcall(require, "file_does_not_exist1"))
+
+package.path = oldpath
+
+-- check 'require' error message
+local fname = "file_does_not_exist2"
+local m, err = pcall(require, fname)
+for t in string.gmatch(package.path..";"..package.cpath, "[^;]+") do
+  t = string.gsub(t, "?", fname)
+  assert(string.find(err, t, 1, true))
+end
+
+do  -- testing 'package.searchers' not being a table
+  local searchers = package.searchers
+  package.searchers = 3
+  local st, msg = pcall(require, 'a')
+  assert(not st and string.find(msg, "must be a table"))
+  package.searchers = searchers
+end
+
+local function import(...)
+  local f = {...}
+  return function (m)
+    for i=1, #f do m[f[i]] = _G[f[i]] end
+  end
+end
+
+-- cannot change environment of a C function
+assert(not pcall(module, 'XUXU'))
+
+
+
+-- testing require of C libraries
+
+
+local p = ""   -- On Mac OS X, redefine this to "_"
+
+-- check whether loadlib works in this system
+local st, err, when = package.loadlib(DC"lib1", "*")
+if not st then
+  local f, err, when = package.loadlib("donotexist", p.."xuxu")
+  assert(not f and type(err) == "string" and when == "absent")
+  ;(Message or print)('\n >>> cannot load dynamic library <<<\n')
+  print(err, when)
+else
+  -- tests for loadlib
+  local f = assert(package.loadlib(DC"lib1", p.."onefunction"))
+  local a, b = f(15, 25)
+  assert(a == 25 and b == 15)
+
+  f = assert(package.loadlib(DC"lib1", p.."anotherfunc"))
+  assert(f(10, 20) == "10%20\n")
+
+  -- check error messages
+  local f, err, when = package.loadlib(DC"lib1", p.."xuxu")
+  assert(not f and type(err) == "string" and when == "init")
+  f, err, when = package.loadlib("donotexist", p.."xuxu")
+  assert(not f and type(err) == "string" and when == "open")
+
+  -- symbols from 'lib1' must be visible to other libraries
+  f = assert(package.loadlib(DC"lib11", p.."luaopen_lib11"))
+  assert(f() == "exported")
+
+  -- test C modules with prefixes in names
+  package.cpath = DC"?"
+  local lib2 = require"lib2-v2"
+  -- check correct access to global environment and correct
+  -- parameters
+  assert(_ENV.x == "lib2-v2" and _ENV.y == DC"lib2-v2")
+  assert(lib2.id("x") == "x")
+
+  -- test C submodules
+  local fs = require"lib1.sub"
+  assert(_ENV.x == "lib1.sub" and _ENV.y == DC"lib1")
+  assert(fs.id(45) == 45)
+end
+
+_ENV = _G
+
+
+-- testing preload
+
+do
+  local p = package
+  package = {}
+  p.preload.pl = function (...)
+    local _ENV = {...}
+    function xuxu (x) return x+20 end
+    return _ENV
+  end
+
+  local pl = require"pl"
+  assert(require"pl" == pl)
+  assert(pl.xuxu(10) == 30)
+  assert(pl[1] == "pl" and pl[2] == nil)
+
+  package = p
+  assert(type(package.path) == "string")
+end
+
+print('+')
+
+end  --]
+
+print("testing assignments, logical operators, and constructors")
+
+local res, res2 = 27
+
+a, b = 1, 2+3
+assert(a==1 and b==5)
+a={}
+function f() return 10, 11, 12 end
+a.x, b, a[1] = 1, 2, f()
+assert(a.x==1 and b==2 and a[1]==10)
+a[f()], b, a[f()+3] = f(), a, 'x'
+assert(a[10] == 10 and b == a and a[13] == 'x')
+
+do
+  local f = function (n) local x = {}; for i=1,n do x[i]=i end;
+                         return table.unpack(x) end;
+  local a,b,c
+  a,b = 0, f(1)
+  assert(a == 0 and b == 1)
+  A,b = 0, f(1)
+  assert(A == 0 and b == 1)
+  a,b,c = 0,5,f(4)
+  assert(a==0 and b==5 and c==1)
+  a,b,c = 0,5,f(0)
+  assert(a==0 and b==5 and c==nil)
+end
+
+a, b, c, d = 1 and nil, 1 or nil, (1 and (nil or 1)), 6
+assert(not a and b and c and d==6)
+
+d = 20
+a, b, c, d = f()
+assert(a==10 and b==11 and c==12 and d==nil)
+a,b = f(), 1, 2, 3, f()
+assert(a==10 and b==1)
+
+assert(a<b == false and a>b == true)
+assert((10 and 2) == 2)
+assert((10 or 2) == 10)
+assert((10 or assert(nil)) == 10)
+assert(not (nil and assert(nil)))
+assert((nil or "alo") == "alo")
+assert((nil and 10) == nil)
+assert((false and 10) == false)
+assert((true or 10) == true)
+assert((false or 10) == 10)
+assert(false ~= nil)
+assert(nil ~= false)
+assert(not nil == true)
+assert(not not nil == false)
+assert(not not 1 == true)
+assert(not not a == true)
+assert(not not (6 or nil) == true)
+assert(not not (nil and 56) == false)
+assert(not not (nil and true) == false)
+
+assert({} ~= {})
+print('+')
+
+a = {}
+a[true] = 20
+a[false] = 10
+assert(a[1<2] == 20 and a[1>2] == 10)
+
+function f(a) return a end
+
+local a = {}
+for i=3000,-3000,-1 do a[i + 0.0] = i; end
+a[10e30] = "alo"; a[true] = 10; a[false] = 20
+assert(a[10e30] == 'alo' and a[not 1] == 20 and a[10<20] == 10)
+for i=3000,-3000,-1 do assert(a[i] == i); end
+a[print] = assert
+a[f] = print
+a[a] = a
+assert(a[a][a][a][a][print] == assert)
+a[print](a[a[f]] == a[print])
+assert(not pcall(function () local a = {}; a[nil] = 10 end))
+assert(not pcall(function () local a = {[nil] = 10} end))
+assert(a[nil] == nil)
+a = nil
+
+a = {10,9,8,7,6,5,4,3,2; [-3]='a', [f]=print, a='a', b='ab'}
+a, a.x, a.y = a, a[-3]
+assert(a[1]==10 and a[-3]==a.a and a[f]==print and a.x=='a' and not a.y)
+a[1], f(a)[2], b, c = {['alo']=assert}, 10, a[1], a[f], 6, 10, 23, f(a), 2
+a[1].alo(a[2]==10 and b==10 and c==print)
+
+
+-- test of large float/integer indices 
+
+-- compute maximum integer where all bits fit in a float
+local maxint = math.maxinteger
+
+while maxint - 1.0 == maxint do   -- trim (if needed) to fit in a float
+  maxint = maxint // 2
+end
+
+maxintF = maxint + 0.0   -- float version
+
+assert(math.type(maxintF) == "float" and maxintF >= 2.0^14)
+
+-- floats and integers must index the same places
+a[maxintF] = 10; a[maxintF - 1.0] = 11;
+a[-maxintF] = 12; a[-maxintF + 1.0] = 13;
+
+assert(a[maxint] == 10 and a[maxint - 1] == 11 and
+       a[-maxint] == 12 and a[-maxint + 1] == 13)
+
+a[maxint] = 20
+a[-maxint] = 22
+
+assert(a[maxintF] == 20 and a[maxintF - 1.0] == 11 and
+       a[-maxintF] == 22 and a[-maxintF + 1.0] == 13)
+
+a = nil
+
+
+-- test conflicts in multiple assignment
+do
+  local a,i,j,b
+  a = {'a', 'b'}; i=1; j=2; b=a
+  i, a[i], a, j, a[j], a[i+j] = j, i, i, b, j, i
+  assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and
+         b[3] == 1)
+end
+
+-- repeat test with upvalues
+do
+  local a,i,j,b
+  a = {'a', 'b'}; i=1; j=2; b=a
+  local function foo ()
+    i, a[i], a, j, a[j], a[i+j] = j, i, i, b, j, i
+  end
+  foo()
+  assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and
+         b[3] == 1)
+  local t = {}
+  (function (a) t[a], a = 10, 20  end)(1);
+  assert(t[1] == 10)
+end
+
+-- bug in 5.2 beta
+local function foo ()
+  local a
+  return function ()
+    local b
+    a, b = 3, 14    -- local and upvalue have same index
+    return a, b
+  end
+end
+
+local a, b = foo()()
+assert(a == 3 and b == 14)
+
+print('OK')
+
+return res
+
diff -urN rpm-5.4.15/lua/tests/big.lua rpm-5.4-cvs/lua/tests/big.lua
--- rpm-5.4.15/lua/tests/big.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/big.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,81 @@
+-- $Id: big.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+if _soft then
+  return 'a'
+end
+
+print "testing large tables"
+
+local debug = require"debug" 
+
+local lim = 2^18 + 1000
+local prog = { "local y = {0" }
+for i = 1, lim do prog[#prog + 1] = i  end
+prog[#prog + 1] = "}\n"
+prog[#prog + 1] = "X = y\n"
+prog[#prog + 1] = ("assert(X[%d] == %d)"):format(lim - 1, lim - 2)
+prog[#prog + 1] = "return 0"
+prog = table.concat(prog, ";")
+
+local env = {string = string, assert = assert}
+local f = assert(load(prog, nil, nil, env))
+
+f()
+assert(env.X[lim] == lim - 1 and env.X[lim + 1] == lim)
+for k in pairs(env) do env[k] = nil end
+
+-- yields during accesses larger than K (in RK)
+setmetatable(env, {
+  __index = function (t, n) coroutine.yield('g'); return _G[n] end,
+  __newindex = function (t, n, v) coroutine.yield('s'); _G[n] = v end,
+})
+
+X = nil
+co = coroutine.wrap(f)
+assert(co() == 's')
+assert(co() == 'g')
+assert(co() == 'g')
+assert(co() == 0)
+
+assert(X[lim] == lim - 1 and X[lim + 1] == lim)
+
+-- errors in accesses larger than K (in RK)
+getmetatable(env).__index = function () end
+getmetatable(env).__newindex = function () end
+local e, m = pcall(f)
+assert(not e and m:find("global 'X'"))
+
+-- errors in metamethods 
+getmetatable(env).__newindex = function () error("hi") end
+local e, m = xpcall(f, debug.traceback)
+assert(not e and m:find("'__newindex'"))
+
+f, X = nil
+
+coroutine.yield'b'
+
+if 2^32 == 0 then   -- (small integers) {   
+
+print "testing string length overflow"
+
+local repstrings = 192          -- number of strings to be concatenated
+local ssize = math.ceil(2.0^32 / repstrings) + 1   -- size of each string
+
+assert(repstrings * ssize > 2.0^32)  -- it should be larger than maximum size
+
+local longs = string.rep("\0", ssize)   -- create one long string
+
+-- create function to concatentate 'repstrings' copies of its argument
+local rep = assert(load(
+  "local a = ...; return " .. string.rep("a", repstrings, "..")))
+
+local a, b = pcall(rep, longs)   -- call that function
+
+-- it should fail without creating string (result would be too large)
+assert(not a and string.find(b, "overflow"))
+
+end   -- }
+
+print'OK'
+
+return 'a'
diff -urN rpm-5.4.15/lua/tests/bitwise.lua rpm-5.4-cvs/lua/tests/bitwise.lua
--- rpm-5.4.15/lua/tests/bitwise.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/bitwise.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,327 @@
+-- $Id: bitwise.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print("testing bitwise operations")
+
+local numbits = string.packsize('j') * 8
+
+assert(~0 == -1)
+
+assert((1 << (numbits - 1)) == math.mininteger)
+
+-- basic tests for bitwise operators;
+-- use variables to avoid constant folding
+local a, b, c, d
+a = 0xFFFFFFFFFFFFFFFF
+assert(a == -1 and a & -1 == a and a & 35 == 35)
+a = 0xF0F0F0F0F0F0F0F0
+assert(a | -1 == -1)
+assert(a ~ a == 0 and a ~ 0 == a and a ~ ~a == -1)
+assert(a >> 4 == ~a)
+a = 0xF0; b = 0xCC; c = 0xAA; d = 0xFD
+assert(a | b ~ c & d == 0xF4)
+
+a = 0xF0.0; b = 0xCC.0; c = "0xAA.0"; d = "0xFD.0"
+assert(a | b ~ c & d == 0xF4)
+
+a = 0xF0000000; b = 0xCC000000;
+c = 0xAA000000; d = 0xFD000000
+assert(a | b ~ c & d == 0xF4000000)
+assert(~~a == a and ~a == -1 ~ a and -d == ~d + 1)
+
+a = a << 32
+b = b << 32
+c = c << 32
+d = d << 32
+assert(a | b ~ c & d == 0xF4000000 << 32)
+assert(~~a == a and ~a == -1 ~ a and -d == ~d + 1)
+
+assert(-1 >> 1 == 2^(numbits - 1) - 1 and 1 << 31 == 0x80000000)
+assert(-1 >> (numbits - 1) == 1)
+assert(-1 >> numbits == 0 and
+       -1 >> -numbits == 0 and
+       -1 << numbits == 0 and
+       -1 << -numbits == 0)
+
+assert((2^30 - 1) << 2^30 == 0)
+assert((2^30 - 1) >> 2^30 == 0)
+
+assert(1 >> -3 == 1 << 3 and 1000 >> 5 == 1000 << -5)
+
+
+-- coercion from strings to integers
+assert("0xffffffffffffffff" | 0 == -1)
+assert("0xfffffffffffffffe" & "-1" == -2)
+assert(" \t-0xfffffffffffffffe\n\t" & "-1" == 2)
+assert("   \n  -45  \t " >> "  -2  " == -45 * 4)
+
+-- out of range number
+assert(not pcall(function () return "0xffffffffffffffff.0" | 0 end))
+
+-- embedded zeros
+assert(not pcall(function () return "0xffffffffffffffff\0" | 0 end))
+
+print'+'
+
+
+package.preload.bit32 = function ()     --{
+
+-- no built-in 'bit32' library: implement it using bitwise operators
+
+local bit = {}
+
+function bit.bnot (a)
+  return ~a & 0xFFFFFFFF
+end
+
+
+--
+-- in all vararg functions, avoid creating 'arg' table when there are
+-- only 2 (or less) parameters, as 2 parameters is the common case
+--
+
+function bit.band (x, y, z, ...)
+  if not z then
+    return ((x or -1) & (y or -1)) & 0xFFFFFFFF
+  else
+    local arg = {...}
+    local res = x & y & z
+    for i = 1, #arg do res = res & arg[i] end
+    return res & 0xFFFFFFFF
+  end
+end
+
+function bit.bor (x, y, z, ...)
+  if not z then
+    return ((x or 0) | (y or 0)) & 0xFFFFFFFF
+  else
+    local arg = {...}
+    local res = x | y | z
+    for i = 1, #arg do res = res | arg[i] end
+    return res & 0xFFFFFFFF
+  end
+end
+
+function bit.bxor (x, y, z, ...)
+  if not z then
+    return ((x or 0) ~ (y or 0)) & 0xFFFFFFFF
+  else
+    local arg = {...}
+    local res = x ~ y ~ z
+    for i = 1, #arg do res = res ~ arg[i] end
+    return res & 0xFFFFFFFF
+  end
+end
+
+function bit.btest (...)
+  return bit.band(...) ~= 0
+end
+
+function bit.lshift (a, b)
+  return ((a & 0xFFFFFFFF) << b) & 0xFFFFFFFF
+end
+
+function bit.rshift (a, b)
+  return ((a & 0xFFFFFFFF) >> b) & 0xFFFFFFFF
+end
+
+function bit.arshift (a, b)
+  a = a & 0xFFFFFFFF
+  if b <= 0 or (a & 0x80000000) == 0 then
+    return (a >> b) & 0xFFFFFFFF
+  else
+    return ((a >> b) | ~(0xFFFFFFFF >> b)) & 0xFFFFFFFF
+  end
+end
+
+function bit.lrotate (a ,b)
+  b = b & 31
+  a = a & 0xFFFFFFFF
+  a = (a << b) | (a >> (32 - b))
+  return a & 0xFFFFFFFF
+end
+
+function bit.rrotate (a, b)
+  return bit.lrotate(a, -b)
+end
+
+local function checkfield (f, w)
+  w = w or 1
+  assert(f >= 0, "field cannot be negative")
+  assert(w > 0, "width must be positive")
+  assert(f + w <= 32, "trying to access non-existent bits")
+  return f, ~(-1 << w)
+end
+
+function bit.extract (a, f, w)
+  local f, mask = checkfield(f, w)
+  return (a >> f) & mask
+end
+
+function bit.replace (a, v, f, w)
+  local f, mask = checkfield(f, w)
+  v = v & mask
+  a = (a & ~(mask << f)) | (v << f)
+  return a & 0xFFFFFFFF
+end
+
+return bit
+
+end  --}
+
+
+print("testing bitwise library")
+
+local bit32 = require'bit32'
+
+assert(bit32.band() == bit32.bnot(0))
+assert(bit32.btest() == true)
+assert(bit32.bor() == 0)
+assert(bit32.bxor() == 0)
+
+assert(bit32.band() == bit32.band(0xffffffff))
+assert(bit32.band(1,2) == 0)
+
+
+-- out-of-range numbers
+assert(bit32.band(-1) == 0xffffffff)
+assert(bit32.band((1 << 33) - 1) == 0xffffffff)
+assert(bit32.band(-(1 << 33) - 1) == 0xffffffff)
+assert(bit32.band((1 << 33) + 1) == 1)
+assert(bit32.band(-(1 << 33) + 1) == 1)
+assert(bit32.band(-(1 << 40)) == 0)
+assert(bit32.band(1 << 40) == 0)
+assert(bit32.band(-(1 << 40) - 2) == 0xfffffffe)
+assert(bit32.band((1 << 40) - 4) == 0xfffffffc)
+
+assert(bit32.lrotate(0, -1) == 0)
+assert(bit32.lrotate(0, 7) == 0)
+assert(bit32.lrotate(0x12345678, 0) == 0x12345678)
+assert(bit32.lrotate(0x12345678, 32) == 0x12345678)
+assert(bit32.lrotate(0x12345678, 4) == 0x23456781)
+assert(bit32.rrotate(0x12345678, -4) == 0x23456781)
+assert(bit32.lrotate(0x12345678, -8) == 0x78123456)
+assert(bit32.rrotate(0x12345678, 8) == 0x78123456)
+assert(bit32.lrotate(0xaaaaaaaa, 2) == 0xaaaaaaaa)
+assert(bit32.lrotate(0xaaaaaaaa, -2) == 0xaaaaaaaa)
+for i = -50, 50 do
+  assert(bit32.lrotate(0x89abcdef, i) == bit32.lrotate(0x89abcdef, i%32))
+end
+
+assert(bit32.lshift(0x12345678, 4) == 0x23456780)
+assert(bit32.lshift(0x12345678, 8) == 0x34567800)
+assert(bit32.lshift(0x12345678, -4) == 0x01234567)
+assert(bit32.lshift(0x12345678, -8) == 0x00123456)
+assert(bit32.lshift(0x12345678, 32) == 0)
+assert(bit32.lshift(0x12345678, -32) == 0)
+assert(bit32.rshift(0x12345678, 4) == 0x01234567)
+assert(bit32.rshift(0x12345678, 8) == 0x00123456)
+assert(bit32.rshift(0x12345678, 32) == 0)
+assert(bit32.rshift(0x12345678, -32) == 0)
+assert(bit32.arshift(0x12345678, 0) == 0x12345678)
+assert(bit32.arshift(0x12345678, 1) == 0x12345678 / 2)
+assert(bit32.arshift(0x12345678, -1) == 0x12345678 * 2)
+assert(bit32.arshift(-1, 1) == 0xffffffff)
+assert(bit32.arshift(-1, 24) == 0xffffffff)
+assert(bit32.arshift(-1, 32) == 0xffffffff)
+assert(bit32.arshift(-1, -1) == bit32.band(-1 * 2, 0xffffffff))
+
+assert(0x12345678 << 4 == 0x123456780)
+assert(0x12345678 << 8 == 0x1234567800)
+assert(0x12345678 << -4 == 0x01234567)
+assert(0x12345678 << -8 == 0x00123456)
+assert(0x12345678 << 32 == 0x1234567800000000)
+assert(0x12345678 << -32 == 0)
+assert(0x12345678 >> 4 == 0x01234567)
+assert(0x12345678 >> 8 == 0x00123456)
+assert(0x12345678 >> 32 == 0)
+assert(0x12345678 >> -32 == 0x1234567800000000)
+
+print("+")
+-- some special cases
+local c = {0, 1, 2, 3, 10, 0x80000000, 0xaaaaaaaa, 0x55555555,
+           0xffffffff, 0x7fffffff}
+
+for _, b in pairs(c) do
+  assert(bit32.band(b) == b)
+  assert(bit32.band(b, b) == b)
+  assert(bit32.band(b, b, b, b) == b)
+  assert(bit32.btest(b, b) == (b ~= 0))
+  assert(bit32.band(b, b, b) == b)
+  assert(bit32.band(b, b, b, ~b) == 0)
+  assert(bit32.btest(b, b, b) == (b ~= 0))
+  assert(bit32.band(b, bit32.bnot(b)) == 0)
+  assert(bit32.bor(b, bit32.bnot(b)) == bit32.bnot(0))
+  assert(bit32.bor(b) == b)
+  assert(bit32.bor(b, b) == b)
+  assert(bit32.bor(b, b, b) == b)
+  assert(bit32.bor(b, b, 0, ~b) == 0xffffffff)
+  assert(bit32.bxor(b) == b)
+  assert(bit32.bxor(b, b) == 0)
+  assert(bit32.bxor(b, b, b) == b)
+  assert(bit32.bxor(b, b, b, b) == 0)
+  assert(bit32.bxor(b, 0) == b)
+  assert(bit32.bnot(b) ~= b)
+  assert(bit32.bnot(bit32.bnot(b)) == b)
+  assert(bit32.bnot(b) == (1 << 32) - 1 - b)
+  assert(bit32.lrotate(b, 32) == b)
+  assert(bit32.rrotate(b, 32) == b)
+  assert(bit32.lshift(bit32.lshift(b, -4), 4) == bit32.band(b, bit32.bnot(0xf)))
+  assert(bit32.rshift(bit32.rshift(b, 4), -4) == bit32.band(b, bit32.bnot(0xf)))
+end
+
+-- for this test, use at most 24 bits (mantissa of a single float)
+c = {0, 1, 2, 3, 10, 0x800000, 0xaaaaaa, 0x555555, 0xffffff, 0x7fffff}
+for _, b in pairs(c) do
+  for i = -40, 40 do
+    local x = bit32.lshift(b, i)
+    local y = math.floor(math.fmod(b * 2.0^i, 2.0^32))
+    assert(math.fmod(x - y, 2.0^32) == 0)
+  end
+end
+
+assert(not pcall(bit32.band, {}))
+assert(not pcall(bit32.bnot, "a"))
+assert(not pcall(bit32.lshift, 45))
+assert(not pcall(bit32.lshift, 45, print))
+assert(not pcall(bit32.rshift, 45, print))
+
+print("+")
+
+
+-- testing extract/replace
+
+assert(bit32.extract(0x12345678, 0, 4) == 8)
+assert(bit32.extract(0x12345678, 4, 4) == 7)
+assert(bit32.extract(0xa0001111, 28, 4) == 0xa)
+assert(bit32.extract(0xa0001111, 31, 1) == 1)
+assert(bit32.extract(0x50000111, 31, 1) == 0)
+assert(bit32.extract(0xf2345679, 0, 32) == 0xf2345679)
+
+assert(not pcall(bit32.extract, 0, -1))
+assert(not pcall(bit32.extract, 0, 32))
+assert(not pcall(bit32.extract, 0, 0, 33))
+assert(not pcall(bit32.extract, 0, 31, 2))
+
+assert(bit32.replace(0x12345678, 5, 28, 4) == 0x52345678)
+assert(bit32.replace(0x12345678, 0x87654321, 0, 32) == 0x87654321)
+assert(bit32.replace(0, 1, 2) == 2^2)
+assert(bit32.replace(0, -1, 4) == 2^4)
+assert(bit32.replace(-1, 0, 31) == (1 << 31) - 1)
+assert(bit32.replace(-1, 0, 1, 2) == (1 << 32) - 7)
+
+
+-- testing conversion of floats
+
+assert(bit32.bor(3.0) == 3)
+assert(bit32.bor(-4.0) == 0xfffffffc)
+
+-- large floats and large-enough integers?
+if 2.0^50 < 2.0^50 + 1.0 and 2.0^50 < (-1 >> 1) then
+  assert(bit32.bor(2.0^32 - 5.0) == 0xfffffffb)
+  assert(bit32.bor(-2.0^32 - 6.0) == 0xfffffffa)
+  assert(bit32.bor(2.0^48 - 5.0) == 0xfffffffb)
+  assert(bit32.bor(-2.0^48 - 6.0) == 0xfffffffa)
+end
+
+print'OK'
+
diff -urN rpm-5.4.15/lua/tests/calls.lua rpm-5.4-cvs/lua/tests/calls.lua
--- rpm-5.4.15/lua/tests/calls.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/calls.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,389 @@
+-- $Id: calls.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print("testing functions and calls")
+
+local debug = require "debug"
+
+-- get the opportunity to test 'type' too ;)
+
+assert(type(1<2) == 'boolean')
+assert(type(true) == 'boolean' and type(false) == 'boolean')
+assert(type(nil) == 'nil'
+   and type(-3) == 'number'
+   and type'x' == 'string'
+   and type{} == 'table'
+   and type(type) == 'function')
+
+assert(type(assert) == type(print))
+function f (x) return a:x (x) end
+assert(type(f) == 'function')
+
+
+do    -- test error in 'print' too...
+  local tostring = _ENV.tostring
+
+  _ENV.tostring = nil
+  local st, msg = pcall(print, 1)
+  assert(st == false and string.find(msg, "attempt to call a nil value"))
+
+  _ENV.tostring = function () return {} end
+  local st, msg = pcall(print, 1)
+  assert(st == false and string.find(msg, "must return a string"))
+  
+  _ENV.tostring = tostring
+end
+
+
+-- testing local-function recursion
+fact = false
+do
+  local res = 1
+  local function fact (n)
+    if n==0 then return res
+    else return n*fact(n-1)
+    end
+  end
+  assert(fact(5) == 120)
+end
+assert(fact == false)
+
+-- testing declarations
+a = {i = 10}
+self = 20
+function a:x (x) return x+self.i end
+function a.y (x) return x+self end
+
+assert(a:x(1)+10 == a.y(1))
+
+a.t = {i=-100}
+a["t"].x = function (self, a,b) return self.i+a+b end
+
+assert(a.t:x(2,3) == -95)
+
+do
+  local a = {x=0}
+  function a:add (x) self.x, a.y = self.x+x, 20; return self end
+  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
+end
+
+local a = {b={c={}}}
+
+function a.b.c.f1 (x) return x+1 end
+function a.b.c:f2 (x,y) self[x] = y end
+assert(a.b.c.f1(4) == 5)
+a.b.c:f2('k', 12); assert(a.b.c.k == 12)
+
+print('+')
+
+t = nil   -- 'declare' t
+function f(a,b,c) local d = 'a'; t={a,b,c,d} end
+
+f(      -- this line change must be valid
+  1,2)
+assert(t[1] == 1 and t[2] == 2 and t[3] == nil and t[4] == 'a')
+f(1,2,   -- this one too
+      3,4)
+assert(t[1] == 1 and t[2] == 2 and t[3] == 3 and t[4] == 'a')
+
+function fat(x)
+  if x <= 1 then return 1
+  else return x*load("return fat(" .. x-1 .. ")")()
+  end
+end
+
+assert(load "load 'assert(fat(6)==720)' () ")()
+a = load('return fat(5), 3')
+a,b = a()
+assert(a == 120 and b == 3)
+print('+')
+
+function err_on_n (n)
+  if n==0 then error(); exit(1);
+  else err_on_n (n-1); exit(1);
+  end
+end
+
+do
+  function dummy (n)
+    if n > 0 then
+      assert(not pcall(err_on_n, n))
+      dummy(n-1)
+    end
+  end
+end
+
+dummy(10)
+
+function deep (n)
+  if n>0 then deep(n-1) end
+end
+deep(10)
+deep(200)
+
+-- testing tail call
+function deep (n) if n>0 then return deep(n-1) else return 101 end end
+assert(deep(30000) == 101)
+a = {}
+function a:deep (n) if n>0 then return self:deep(n-1) else return 101 end end
+assert(a:deep(30000) == 101)
+
+print('+')
+
+
+a = nil
+(function (x) a=x end)(23)
+assert(a == 23 and (function (x) return x*2 end)(20) == 40)
+
+
+-- testing closures
+
+-- fixed-point operator
+Z = function (le)
+      local function a (f)
+        return le(function (x) return f(f)(x) end)
+      end
+      return a(a)
+    end
+
+
+-- non-recursive factorial
+
+F = function (f)
+      return function (n)
+               if n == 0 then return 1
+               else return n*f(n-1) end
+             end
+    end
+
+fat = Z(F)
+
+assert(fat(0) == 1 and fat(4) == 24 and Z(F)(5)==5*Z(F)(4))
+
+local function g (z)
+  local function f (a,b,c,d)
+    return function (x,y) return a+b+c+d+a+x+y+z end
+  end
+  return f(z,z+1,z+2,z+3)
+end
+
+f = g(10)
+assert(f(9, 16) == 10+11+12+13+10+9+16+10)
+
+Z, F, f = nil
+print('+')
+
+-- testing multiple returns
+
+function unlpack (t, i)
+  i = i or 1
+  if (i <= #t) then
+    return t[i], unlpack(t, i+1)
+  end
+end
+
+function equaltab (t1, t2)
+  assert(#t1 == #t2)
+  for i = 1, #t1 do
+    assert(t1[i] == t2[i])
+  end
+end
+
+local pack = function (...) return (table.pack(...)) end
+
+function f() return 1,2,30,4 end
+function ret2 (a,b) return a,b end
+
+local a,b,c,d = unlpack{1,2,3}
+assert(a==1 and b==2 and c==3 and d==nil)
+a = {1,2,3,4,false,10,'alo',false,assert}
+equaltab(pack(unlpack(a)), a)
+equaltab(pack(unlpack(a), -1), {1,-1})
+a,b,c,d = ret2(f()), ret2(f())
+assert(a==1 and b==1 and c==2 and d==nil)
+a,b,c,d = unlpack(pack(ret2(f()), ret2(f())))
+assert(a==1 and b==1 and c==2 and d==nil)
+a,b,c,d = unlpack(pack(ret2(f()), (ret2(f()))))
+assert(a==1 and b==1 and c==nil and d==nil)
+
+a = ret2{ unlpack{1,2,3}, unlpack{3,2,1}, unlpack{"a", "b"}}
+assert(a[1] == 1 and a[2] == 3 and a[3] == "a" and a[4] == "b")
+
+
+-- testing calls with 'incorrect' arguments
+rawget({}, "x", 1)
+rawset({}, "x", 1, 2)
+assert(math.sin(1,2) == math.sin(1))
+table.sort({10,9,8,4,19,23,0,0}, function (a,b) return a<b end, "extra arg")
+
+
+-- test for generic load
+local x = "-- a comment\0\0\0\n  x = 10 + \n23; \
+     local a = function () x = 'hi' end; \
+     return '\0'"
+function read1 (x)
+  local i = 0
+  return function ()
+    collectgarbage()
+    i=i+1
+    return string.sub(x, i, i)
+  end
+end
+
+function cannotload (msg, a,b)
+  assert(not a and string.find(b, msg))
+end
+
+a = assert(load(read1(x), "modname", "t", _G))
+assert(a() == "\0" and _G.x == 33)
+assert(debug.getinfo(a).source == "modname")
+-- cannot read text in binary mode
+cannotload("attempt to load a text chunk", load(read1(x), "modname", "b", {}))
+cannotload("attempt to load a text chunk", load(x, "modname", "b"))
+
+a = assert(load(function () return nil end))
+a()  -- empty chunk
+
+assert(not load(function () return true end))
+
+
+-- small bug
+local t = {nil, "return ", "3"}
+f, msg = load(function () return table.remove(t, 1) end)
+assert(f() == nil)   -- should read the empty chunk
+
+-- another small bug (in 5.2.1)
+f = load(string.dump(function () return 1 end), nil, "b", {})
+assert(type(f) == "function" and f() == 1)
+
+
+x = string.dump(load("x = 1; return x"))
+a = assert(load(read1(x), nil, "b"))
+assert(a() == 1 and _G.x == 1)
+cannotload("attempt to load a binary chunk", load(read1(x), nil, "t"))
+cannotload("attempt to load a binary chunk", load(x, nil, "t"))
+
+assert(not pcall(string.dump, print))  -- no dump of C functions
+
+cannotload("unexpected symbol", load(read1("*a = 123")))
+cannotload("unexpected symbol", load("*a = 123"))
+cannotload("hhi", load(function () error("hhi") end))
+
+-- any value is valid for _ENV
+assert(load("return _ENV", nil, nil, 123)() == 123)
+
+
+-- load when _ENV is not first upvalue
+local x; XX = 123
+local function h ()
+  local y=x   -- use 'x', so that it becomes 1st upvalue
+  return XX   -- global name
+end
+local d = string.dump(h)
+x = load(d, "", "b")
+assert(debug.getupvalue(x, 2) == '_ENV')
+debug.setupvalue(x, 2, _G)
+assert(x() == 123)
+
+assert(assert(load("return XX + ...", nil, nil, {XX = 13}))(4) == 17)
+
+
+-- test generic load with nested functions
+x = [[
+  return function (x)
+    return function (y)
+     return function (z)
+       return x+y+z
+     end
+   end
+  end
+]]
+
+a = assert(load(read1(x)))
+assert(a()(2)(3)(10) == 15)
+
+
+-- test for dump/undump with upvalues
+local a, b = 20, 30
+x = load(string.dump(function (x)
+  if x == "set" then a = 10+b; b = b+1 else
+  return a
+  end
+end), "", "b", nil)
+assert(x() == nil)
+assert(debug.setupvalue(x, 1, "hi") == "a")
+assert(x() == "hi")
+assert(debug.setupvalue(x, 2, 13) == "b")
+assert(not debug.setupvalue(x, 3, 10))   -- only 2 upvalues
+x("set")
+assert(x() == 23)
+x("set")
+assert(x() == 24)
+
+-- test for dump/undump with many upvalues
+do
+  local nup = 200    -- maximum number of local variables
+  local prog = {"local a1"}
+  for i = 2, nup do prog[#prog + 1] = ", a" .. i end
+  prog[#prog + 1] = " = 1"
+  for i = 2, nup do prog[#prog + 1] = ", " .. i end
+  local sum = 1
+  prog[#prog + 1] = "; return function () return a1"
+  for i = 2, nup do prog[#prog + 1] = " + a" .. i; sum = sum + i end
+  prog[#prog + 1] = " end"
+  prog = table.concat(prog)
+  local f = assert(load(prog))()
+  assert(f() == sum)
+
+  f = load(string.dump(f))   -- main chunk now has many upvalues
+  local a = 10
+  local h = function () return a end
+  for i = 1, nup do
+    debug.upvaluejoin(f, i, h, 1)
+  end
+  assert(f() == 10 * nup)
+end
+
+-- test for bug in parameter adjustment
+assert((function () return nil end)(4) == nil)
+assert((function () local a; return a end)(4) == nil)
+assert((function (a) return a end)() == nil)
+
+
+print("testing binary chunks")
+do
+  local header = string.pack("c4BBc6BBBBBj",
+    "\27Lua",                -- signature
+    5*16 + 3,                -- version 5.3
+    0,                       -- format
+    "\x19\x93\r\n\x1a\n",    -- data
+    string.packsize("i"),    -- sizeof(int)
+    string.packsize("T"),    -- sizeof(size_t)
+    4,                       -- size of instruction
+    string.packsize("j"),    -- sizeof(lua integer)
+    string.packsize("n"),    -- sizeof(lua number)
+    0x5678                   -- LUAC_INT
+    -- LUAC_NUM may not have a unique binary representation (padding...)
+  )
+  local c = string.dump(function () local a = 1; local b = 3; return a+b*3 end)
+
+  assert(string.sub(c, 1, #header) == header)
+
+  -- corrupted header
+  for i = 1, #header do
+    local s = string.sub(c, 1, i - 1) ..
+              string.char(string.byte(string.sub(c, i, i)) + 1) ..
+              string.sub(c, i + 1, -1)
+    assert(#s == #c)
+    assert(not load(s))
+  end
+
+  -- loading truncated binary chunks
+  for i = 1, #c - 1 do
+    local st, msg = load(string.sub(c, 1, i))
+    assert(not st and string.find(msg, "truncated"))
+  end
+  assert(assert(load(c))() == 10)
+end
+
+print('OK')
+return deep
diff -urN rpm-5.4.15/lua/tests/closure.lua rpm-5.4-cvs/lua/tests/closure.lua
--- rpm-5.4.15/lua/tests/closure.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/closure.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,246 @@
+-- $Id: closure.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print "testing closures"
+
+local A,B = 0,{g=10}
+function f(x)
+  local a = {}
+  for i=1,1000 do
+    local y = 0
+    do
+      a[i] = function () B.g = B.g+1; y = y+x; return y+A end
+    end
+  end
+  local dummy = function () return a[A] end
+  collectgarbage()
+  A = 1; assert(dummy() == a[1]); A = 0;
+  assert(a[1]() == x)
+  assert(a[3]() == x)
+  collectgarbage()
+  assert(B.g == 12)
+  return a
+end
+
+local a = f(10)
+-- force a GC in this level
+local x = {[1] = {}}   -- to detect a GC
+setmetatable(x, {__mode = 'kv'})
+while x[1] do   -- repeat until GC
+  local a = A..A..A..A  -- create garbage
+  A = A+1
+end
+assert(a[1]() == 20+A)
+assert(a[1]() == 30+A)
+assert(a[2]() == 10+A)
+collectgarbage()
+assert(a[2]() == 20+A)
+assert(a[2]() == 30+A)
+assert(a[3]() == 20+A)
+assert(a[8]() == 10+A)
+assert(getmetatable(x).__mode == 'kv')
+assert(B.g == 19)
+
+
+-- testing equality
+a = {}
+for i = 1, 5 do  a[i] = function (x) return x + a + _ENV end  end
+assert(a[3] == a[4] and a[4] == a[5])
+
+for i = 1, 5 do  a[i] = function (x) return i + a + _ENV end  end
+assert(a[3] ~= a[4] and a[4] ~= a[5])
+
+local function f()
+  return function (x)  return math.sin(_ENV[x])  end
+end
+assert(f() == f())
+
+
+-- testing closures with 'for' control variable
+a = {}
+for i=1,10 do
+  a[i] = {set = function(x) i=x end, get = function () return i end}
+  if i == 3 then break end
+end
+assert(a[4] == nil)
+a[1].set(10)
+assert(a[2].get() == 2)
+a[2].set('a')
+assert(a[3].get() == 3)
+assert(a[2].get() == 'a')
+
+a = {}
+local t = {"a", "b"}
+for i = 1, #t do
+  local k = t[i]
+  a[i] = {set = function(x, y) i=x; k=y end,
+          get = function () return i, k end}
+  if i == 2 then break end
+end
+a[1].set(10, 20)
+local r,s = a[2].get()
+assert(r == 2 and s == 'b')
+r,s = a[1].get()
+assert(r == 10 and s == 20)
+a[2].set('a', 'b')
+r,s = a[2].get()
+assert(r == "a" and s == "b")
+
+
+-- testing closures with 'for' control variable x break
+for i=1,3 do
+  f = function () return i end
+  break
+end
+assert(f() == 1)
+
+for k = 1, #t do
+  local v = t[k]
+  f = function () return k, v end
+  break
+end
+assert(({f()})[1] == 1)
+assert(({f()})[2] == "a")
+
+
+-- testing closure x break x return x errors
+
+local b
+function f(x)
+  local first = 1
+  while 1 do
+    if x == 3 and not first then return end
+    local a = 'xuxu'
+    b = function (op, y)
+          if op == 'set' then
+            a = x+y
+          else
+            return a
+          end
+        end
+    if x == 1 then do break end
+    elseif x == 2 then return
+    else if x ~= 3 then error() end
+    end
+    first = nil
+  end
+end
+
+for i=1,3 do
+  f(i)
+  assert(b('get') == 'xuxu')
+  b('set', 10); assert(b('get') == 10+i)
+  b = nil
+end
+
+pcall(f, 4);
+assert(b('get') == 'xuxu')
+b('set', 10); assert(b('get') == 14)
+
+
+local w
+-- testing multi-level closure
+function f(x)
+  return function (y)
+    return function (z) return w+x+y+z end
+  end
+end
+
+y = f(10)
+w = 1.345
+assert(y(20)(30) == 60+w)
+
+-- testing closures x repeat-until
+
+local a = {}
+local i = 1
+repeat
+  local x = i
+  a[i] = function () i = x+1; return x end
+until i > 10 or a[i]() ~= x
+assert(i == 11 and a[1]() == 1 and a[3]() == 3 and i == 4)
+
+
+-- testing closures created in 'then' and 'else' parts of 'if's
+a = {}
+for i = 1, 10 do
+  if i % 3 == 0 then
+    local y = 0
+    a[i] = function (x) local t = y; y = x; return t end
+  elseif i % 3 == 1 then
+    goto L1
+    error'not here'
+  ::L1::
+    local y = 1
+    a[i] = function (x) local t = y; y = x; return t end
+  elseif i % 3 == 2 then
+    local t
+    goto l4
+    ::l4a:: a[i] = t; goto l4b
+    error("should never be here!")
+    ::l4::
+    local y = 2
+    t = function (x) local t = y; y = x; return t end
+    goto l4a
+    error("should never be here!")
+    ::l4b::
+  end
+end
+
+for i = 1, 10 do
+  assert(a[i](i * 10) == i % 3 and a[i]() == i * 10)
+end
+
+print'+'
+
+
+-- test for correctly closing upvalues in tail calls of vararg functions
+local function t ()
+  local function c(a,b) assert(a=="test" and b=="OK") end
+  local function v(f, ...) c("test", f() ~= 1 and "FAILED" or "OK") end
+  local x = 1
+  return v(function() return x end)
+end
+t()
+
+
+-- test for debug manipulation of upvalues
+local debug = require'debug'
+
+do
+  local a , b, c = 3, 5, 7
+  foo1 = function () return a+b end;
+  foo2 = function () return b+a end;
+  do
+    local a = 10
+    foo3 = function () return a+b end;
+  end
+end
+
+assert(debug.upvalueid(foo1, 1))
+assert(debug.upvalueid(foo1, 2))
+assert(not pcall(debug.upvalueid, foo1, 3))
+assert(debug.upvalueid(foo1, 1) == debug.upvalueid(foo2, 2))
+assert(debug.upvalueid(foo1, 2) == debug.upvalueid(foo2, 1))
+assert(debug.upvalueid(foo3, 1))
+assert(debug.upvalueid(foo1, 1) ~= debug.upvalueid(foo3, 1))
+assert(debug.upvalueid(foo1, 2) == debug.upvalueid(foo3, 2))
+
+assert(debug.upvalueid(string.gmatch("x", "x"), 1) ~= nil)
+
+assert(foo1() == 3 + 5 and foo2() == 5 + 3)
+debug.upvaluejoin(foo1, 2, foo2, 2)
+assert(foo1() == 3 + 3 and foo2() == 5 + 3)
+assert(foo3() == 10 + 5)
+debug.upvaluejoin(foo3, 2, foo2, 1)
+assert(foo3() == 10 + 5)
+debug.upvaluejoin(foo3, 2, foo2, 2)
+assert(foo3() == 10 + 3)
+
+assert(not pcall(debug.upvaluejoin, foo1, 3, foo2, 1))
+assert(not pcall(debug.upvaluejoin, foo1, 1, foo2, 3))
+assert(not pcall(debug.upvaluejoin, foo1, 0, foo2, 1))
+assert(not pcall(debug.upvaluejoin, print, 1, foo2, 1))
+assert(not pcall(debug.upvaluejoin, {}, 1, foo2, 1))
+assert(not pcall(debug.upvaluejoin, foo1, 1, print, 1))
+
+print'OK'
diff -urN rpm-5.4.15/lua/tests/code.lua rpm-5.4-cvs/lua/tests/code.lua
--- rpm-5.4.15/lua/tests/code.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/code.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,230 @@
+-- $Id: code.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+if T==nil then
+  (Message or print)('\n >>> testC not active: skipping opcode tests <<<\n')
+  return
+end
+print "testing code generation and optimizations"
+
+
+-- this code gave an error for the code checker
+do
+  local function f (a)
+  for k,v,w in a do end
+  end
+end
+
+
+-- testing reuse in constant table
+local function checkKlist (func, list)
+  local k = T.listk(func)
+  assert(#k == #list)
+  for i = 1, #k do
+    assert(k[i] == list[i] and math.type(k[i]) == math.type(list[i]))
+  end
+end
+
+local function foo ()
+  local a
+  a = 3;
+  a = 0; a = 0.0; a = -7 + 7
+  a = 3.78/4; a = 3.78/4
+  a = -3.78/4; a = 3.78/4; a = -3.78/4
+  a = -3.79/4; a = 0.0; a = -0;
+  a = 3; a = 3.0; a = 3; a = 3.0
+end
+
+checkKlist(foo, {3, 0, 0.0, 3.78/4, -3.78/4, -3.79/4, 3.0})
+
+
+-- testing opcodes
+
+function check (f, ...)
+  local arg = {...}
+  local c = T.listcode(f)
+  for i=1, #arg do
+    -- print(arg[i], c[i])
+    assert(string.find(c[i], '- '..arg[i]..' *%d'))
+  end
+  assert(c[#arg+2] == nil)
+end
+
+
+function checkequal (a, b)
+  a = T.listcode(a)
+  b = T.listcode(b)
+  for i = 1, #a do
+    a[i] = string.gsub(a[i], '%b()', '')   -- remove line number
+    b[i] = string.gsub(b[i], '%b()', '')   -- remove line number
+    assert(a[i] == b[i])
+  end
+end
+
+
+-- some basic instructions
+check(function ()
+  (function () end){f()}
+end, 'CLOSURE', 'NEWTABLE', 'GETTABUP', 'CALL', 'SETLIST', 'CALL', 'RETURN')
+
+
+-- sequence of LOADNILs
+check(function ()
+  local a,b,c
+  local d; local e;
+  local f,g,h;
+  d = nil; d=nil; b=nil; a=nil; c=nil;
+end, 'LOADNIL', 'RETURN')
+
+check(function ()
+  local a,b,c,d = 1,1,1,1
+  d=nil;c=nil;b=nil;a=nil
+end, 'LOADK', 'LOADK', 'LOADK', 'LOADK', 'LOADNIL', 'RETURN')
+
+do
+  local a,b,c,d = 1,1,1,1
+  d=nil;c=nil;b=nil;a=nil
+  assert(a == nil and b == nil and c == nil and d == nil)
+end
+
+
+-- single return
+check (function (a,b,c) return a end, 'RETURN')
+
+
+-- infinite loops
+check(function () while true do local a = -1 end end,
+'LOADK', 'JMP', 'RETURN')
+
+check(function () while 1 do local a = -1 end end,
+'LOADK', 'JMP', 'RETURN')
+
+check(function () repeat local x = 1 until true end,
+'LOADK', 'RETURN')
+
+
+-- concat optimization
+check(function (a,b,c,d) return a..b..c..d end,
+  'MOVE', 'MOVE', 'MOVE', 'MOVE', 'CONCAT', 'RETURN')
+
+-- not
+check(function () return not not nil end, 'LOADBOOL', 'RETURN')
+check(function () return not not false end, 'LOADBOOL', 'RETURN')
+check(function () return not not true end, 'LOADBOOL', 'RETURN')
+check(function () return not not 1 end, 'LOADBOOL', 'RETURN')
+
+-- direct access to locals
+check(function ()
+  local a,b,c,d
+  a = b*2
+  c[4], a[b] = -((a + d/-20.5 - a[b]) ^ a.x), b
+end,
+  'LOADNIL',
+  'MUL',
+  'DIV', 'ADD', 'GETTABLE', 'SUB', 'GETTABLE', 'POW',
+    'UNM', 'SETTABLE', 'SETTABLE', 'RETURN')
+
+
+-- direct access to constants
+check(function ()
+  local a,b
+  a.x = 0
+  a.x = b
+  a[b] = 'y'
+  a = 1 - a
+  b = 1/a
+  b = 5+4
+  a[true] = false
+end,
+  'LOADNIL',
+  'SETTABLE', 'SETTABLE', 'SETTABLE', 'SUB', 'DIV', 'LOADK',
+  'SETTABLE', 'RETURN')
+
+
+-- constant folding
+local function checkK (func, val)
+  check(func, 'LOADK', 'RETURN')
+  local k = T.listk(func)
+  assert(#k == 1 and k[1] == val and math.type(k[1]) == math.type(val))
+  assert(func() == val)
+end
+checkK(function () return 0.0 end, 0.0)
+checkK(function () return 0 end, 0)
+checkK(function () return -0//1 end, 0)
+checkK(function () return 3^-1 end, 1/3)
+checkK(function () return (1 + 1)^(50 + 50) end, 2^100)
+checkK(function () return (-2)^(31 - 2) end, -0x20000000 + 0.0)
+checkK(function () return (-3^0 + 5) // 3.0 end, 1.0)
+checkK(function () return -3 % 5 end, 2)
+checkK(function () return -((2.0^8 + -(-1)) % 8)/2 * 4 - 3 end, -5.0)
+checkK(function () return -((2^8 + -(-1)) % 8)//2 * 4 - 3 end, -7.0)
+checkK(function () return 0xF0.0 | 0xCC.0 ~ 0xAA & 0xFD end, 0xF4)
+checkK(function () return ~(~0xFF0 | 0xFF0) end, 0)
+checkK(function () return ~~-100024.0 end, -100024)
+checkK(function () return ((100 << 6) << -4) >> 2 end, 100)
+
+
+-- no foldings
+check(function () return -0.0 end, 'LOADK', 'UNM', 'RETURN')
+check(function () return 3/0 end, 'DIV', 'RETURN')
+check(function () return 0%0 end, 'MOD', 'RETURN')
+check(function () return -4//0 end, 'IDIV', 'RETURN')
+
+-- bug in constant folding for 5.1
+check(function () return -nil end, 'LOADNIL', 'UNM', 'RETURN')
+
+
+check(function ()
+  local a,b,c
+  b[c], a = c, b
+  b[a], a = c, b
+  a, b = c, a
+  a = a
+end, 
+  'LOADNIL',
+  'MOVE', 'MOVE', 'SETTABLE',
+  'MOVE', 'MOVE', 'MOVE', 'SETTABLE',
+  'MOVE', 'MOVE', 'MOVE',
+  -- no code for a = a
+  'RETURN')
+
+
+-- x == nil , x ~= nil
+checkequal(function () if (a==nil) then a=1 end; if a~=nil then a=1 end end,
+           function () if (a==9) then a=1 end; if a~=9 then a=1 end end)
+
+check(function () if a==nil then a=1 end end,
+'GETTABUP', 'EQ', 'JMP', 'SETTABUP', 'RETURN')
+
+-- de morgan
+checkequal(function () local a; if not (a or b) then b=a end end,
+           function () local a; if (not a and not b) then b=a end end)
+
+checkequal(function (l) local a; return 0 <= a and a <= l end,
+           function (l) local a; return not (not(a >= 0) or not(a <= l)) end)
+
+
+-- if-goto optimizations
+check(function (a)
+        if a == 1 then goto l1
+        elseif a == 2 then goto l2
+        elseif a == 3 then goto l2
+        else if a == 4 then goto l3
+             else goto l3
+             end
+        end
+        ::l1:: ::l2:: ::l3:: ::l4:: 
+end, 'EQ', 'JMP', 'EQ', 'JMP', 'EQ', 'JMP', 'EQ', 'JMP', 'JMP', 'RETURN')
+
+checkequal(
+function (a) while a < 10 do a = a + 1 end end,
+function (a) ::L2:: if not(a < 10) then goto L1 end; a = a + 1;
+                goto L2; ::L1:: end
+)
+
+checkequal(
+function (a) while a < 10 do a = a + 1 end end,
+function (a) while true do if not(a < 10) then break end; a = a + 1; end end
+)
+
+print 'OK'
+
diff -urN rpm-5.4.15/lua/tests/constructs.lua rpm-5.4-cvs/lua/tests/constructs.lua
--- rpm-5.4.15/lua/tests/constructs.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/constructs.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,300 @@
+-- $Id: constructs.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+;;print "testing syntax";;
+
+local debug = require "debug"
+
+-- testing semicollons
+do ;;; end
+; do ; a = 3; assert(a == 3) end;
+;
+
+
+-- invalid operations should not raise errors when not executed
+if false then a = 3 // 0; a = 0 % 0 end
+
+
+-- testing priorities
+
+assert(2^3^2 == 2^(3^2));
+assert(2^3*4 == (2^3)*4);
+assert(2.0^-2 == 1/4 and -2^- -2 == - - -4);
+assert(not nil and 2 and not(2>3 or 3<2));
+assert(-3-1-5 == 0+0-9);
+assert(-2^2 == -4 and (-2)^2 == 4 and 2*2-3-1 == 0);
+assert(-3%5 == 2 and -3+5 == 2)
+assert(2*1+3/3 == 3 and 1+2 .. 3*1 == "33");
+assert(not(2+1 > 3*1) and "a".."b" > "a");
+
+assert("7" .. 3 << 1 == 146)
+assert(10 >> 1 .. "9" == 0)
+assert(10 | 1 .. "9" == 27)
+
+assert(0xF0 | 0xCC ~ 0xAA & 0xFD == 0xF4)
+assert(0xFD & 0xAA ~ 0xCC | 0xF0 == 0xF4)
+assert(0xF0 & 0x0F + 1 == 0x10)
+
+assert(3^4//2^3//5 == 2)
+
+assert(-3+4*5//2^3^2//9+4%10/3 == (-3)+(((4*5)//(2^(3^2)))//9)+((4%10)/3))
+
+assert(not ((true or false) and nil))
+assert(      true or false  and nil)
+
+-- old bug
+assert((((1 or false) and true) or false) == true)
+assert((((nil and true) or false) and true) == false)
+
+local a,b = 1,nil;
+assert(-(1 or 2) == -1 and (1 and 2)+(-1.25 or -4) == 0.75);
+x = ((b or a)+1 == 2 and (10 or a)+1 == 11); assert(x);
+x = (((2<3) or 1) == true and (2<3 and 4) == 4); assert(x);
+
+x,y=1,2;
+assert((x>y) and x or y == 2);
+x,y=2,1;
+assert((x>y) and x or y == 2);
+
+assert(1234567890 == tonumber('1234567890') and 1234567890+1 == 1234567891)
+
+
+-- silly loops
+repeat until 1; repeat until true;
+while false do end; while nil do end;
+
+do  -- test old bug (first name could not be an `upvalue')
+ local a; function f(x) x={a=1}; x={x=1}; x={G=1} end
+end
+
+function f (i)
+  if type(i) ~= 'number' then return i,'jojo'; end;
+  if i > 0 then return i, f(i-1); end;
+end
+
+x = {f(3), f(5), f(10);};
+assert(x[1] == 3 and x[2] == 5 and x[3] == 10 and x[4] == 9 and x[12] == 1);
+assert(x[nil] == nil)
+x = {f'alo', f'xixi', nil};
+assert(x[1] == 'alo' and x[2] == 'xixi' and x[3] == nil);
+x = {f'alo'..'xixi'};
+assert(x[1] == 'aloxixi')
+x = {f{}}
+assert(x[2] == 'jojo' and type(x[1]) == 'table')
+
+
+local f = function (i)
+  if i < 10 then return 'a';
+  elseif i < 20 then return 'b';
+  elseif i < 30 then return 'c';
+  end;
+end
+
+assert(f(3) == 'a' and f(12) == 'b' and f(26) == 'c' and f(100) == nil)
+
+for i=1,1000 do break; end;
+n=100;
+i=3;
+t = {};
+a=nil
+while not a do
+  a=0; for i=1,n do for i=i,1,-1 do a=a+1; t[i]=1; end; end;
+end
+assert(a == n*(n+1)/2 and i==3);
+assert(t[1] and t[n] and not t[0] and not t[n+1])
+
+function f(b)
+  local x = 1;
+  repeat
+    local a;
+    if b==1 then local b=1; x=10; break
+    elseif b==2 then x=20; break;
+    elseif b==3 then x=30;
+    else local a,b,c,d=math.sin(1); x=x+1;
+    end
+  until x>=12;
+  return x;
+end;
+
+assert(f(1) == 10 and f(2) == 20 and f(3) == 30 and f(4)==12)
+
+
+local f = function (i)
+  if i < 10 then return 'a'
+  elseif i < 20 then return 'b'
+  elseif i < 30 then return 'c'
+  else return 8
+  end
+end
+
+assert(f(3) == 'a' and f(12) == 'b' and f(26) == 'c' and f(100) == 8)
+
+local a, b = nil, 23
+x = {f(100)*2+3 or a, a or b+2}
+assert(x[1] == 19 and x[2] == 25)
+x = {f=2+3 or a, a = b+2}
+assert(x.f == 5 and x.a == 25)
+
+a={y=1}
+x = {a.y}
+assert(x[1] == 1)
+
+function f(i)
+  while 1 do
+    if i>0 then i=i-1;
+    else return; end;
+  end;
+end;
+
+function g(i)
+  while 1 do
+    if i>0 then i=i-1
+    else return end
+  end
+end
+
+f(10); g(10);
+
+do
+  function f () return 1,2,3; end
+  local a, b, c = f();
+  assert(a==1 and b==2 and c==3)
+  a, b, c = (f());
+  assert(a==1 and b==nil and c==nil)
+end
+
+local a,b = 3 and f();
+assert(a==1 and b==nil)
+
+function g() f(); return; end;
+assert(g() == nil)
+function g() return nil or f() end
+a,b = g()
+assert(a==1 and b==nil)
+
+print'+';
+
+
+f = [[
+return function ( a , b , c , d , e )
+  local x = a >= b or c or ( d and e ) or nil
+  return x
+end , { a = 1 , b = 2 >= 1 , } or { 1 };
+]]
+f = string.gsub(f, "%s+", "\n");   -- force a SETLINE between opcodes
+f,a = load(f)();
+assert(a.a == 1 and a.b)
+
+function g (a,b,c,d,e)
+  if not (a>=b or c or d and e or nil) then return 0; else return 1; end;
+end
+
+function h (a,b,c,d,e)
+  while (a>=b or c or (d and e) or nil) do return 1; end;
+  return 0;
+end;
+
+assert(f(2,1) == true and g(2,1) == 1 and h(2,1) == 1)
+assert(f(1,2,'a') == 'a' and g(1,2,'a') == 1 and h(1,2,'a') == 1)
+assert(f(1,2,'a')
+~=          -- force SETLINE before nil
+nil, "")
+assert(f(1,2,'a') == 'a' and g(1,2,'a') == 1 and h(1,2,'a') == 1)
+assert(f(1,2,nil,1,'x') == 'x' and g(1,2,nil,1,'x') == 1 and
+                                   h(1,2,nil,1,'x') == 1)
+assert(f(1,2,nil,nil,'x') == nil and g(1,2,nil,nil,'x') == 0 and
+                                     h(1,2,nil,nil,'x') == 0)
+assert(f(1,2,nil,1,nil) == nil and g(1,2,nil,1,nil) == 0 and
+                                   h(1,2,nil,1,nil) == 0)
+
+assert(1 and 2<3 == true and 2<3 and 'a'<'b' == true)
+x = 2<3 and not 3; assert(x==false)
+x = 2<1 or (2>1 and 'a'); assert(x=='a')
+
+
+do
+  local a; if nil then a=1; else a=2; end;    -- this nil comes as PUSHNIL 2
+  assert(a==2)
+end
+
+function F(a)
+  assert(debug.getinfo(1, "n").name == 'F')
+  return a,2,3
+end
+
+a,b = F(1)~=nil; assert(a == true and b == nil);
+a,b = F(nil)==nil; assert(a == true and b == nil)
+
+----------------------------------------------------------------
+------------------------------------------------------------------
+
+-- sometimes will be 0, sometimes will not...
+_ENV.GLOB1 = os.time() % 2
+
+-- basic expressions with their respective values
+local basiccases = {
+  {"nil", nil},
+  {"false", false},
+  {"true", true},
+  {"10", 10},
+  {"(0==_ENV.GLOB1)", 0 == _ENV.GLOB1},
+}
+
+print('testing short-circuit optimizations (' .. _ENV.GLOB1 .. ')')
+
+
+-- operators with their respective values
+local binops = {
+  {" and ", function (a,b) if not a then return a else return b end end},
+  {" or ", function (a,b) if a then return a else return b end end},
+}
+
+local cases = {}
+
+-- creates all combinations of '(cases[i] op cases[n-i])' plus
+-- 'not(cases[i] op cases[n-i])' (syntax + value)
+local function createcases (n)
+  local res = {}
+  for i = 1, n - 1 do
+    for _, v1 in ipairs(cases[i]) do
+      for _, v2 in ipairs(cases[n - i]) do
+        for _, op in ipairs(binops) do
+            local t = {
+              "(" .. v1[1] .. op[1] .. v2[1] .. ")",
+              op[2](v1[2], v2[2])
+            }
+            res[#res + 1] = t
+            res[#res + 1] = {"not" .. t[1], not t[2]}
+        end
+      end
+    end
+  end
+  return res
+end
+
+-- do not do too many combinations for soft tests
+local level = _soft and 3 or 4
+
+cases[1] = basiccases
+for i = 2, level do cases[i] = createcases(i) end
+print("+")
+
+local prog = [[if %s then IX = true end; return %s]]
+
+local i = 0
+for n = 1, level do
+  for _, v in pairs(cases[n]) do
+    local s = v[1]
+    local p = load(string.format(prog, s, s))
+    IX = false
+    assert(p() == v[2] and IX == not not v[2])
+    i = i + 1
+    if i % 60000 == 0 then print('+') end
+  end
+end
+------------------------------------------------------------------
+
+-- testing some syntax errors (chosen through 'gcov')
+assert(string.find(select(2, load("for x do")), "expected"))
+assert(string.find(select(2, load("x:call")), "expected"))
+
+print'OK'
diff -urN rpm-5.4.15/lua/tests/coroutine.lua rpm-5.4-cvs/lua/tests/coroutine.lua
--- rpm-5.4.15/lua/tests/coroutine.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/coroutine.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,784 @@
+-- $Id: coroutine.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print "testing coroutines"
+
+local debug = require'debug'
+
+local f
+
+local main, ismain = coroutine.running()
+assert(type(main) == "thread" and ismain)
+assert(not coroutine.resume(main))
+assert(not coroutine.isyieldable())
+assert(not pcall(coroutine.yield))
+
+
+-- trivial errors
+assert(not pcall(coroutine.resume, 0))
+assert(not pcall(coroutine.status, 0))
+
+
+-- tests for multiple yield/resume arguments
+
+local function eqtab (t1, t2)
+  assert(#t1 == #t2)
+  for i = 1, #t1 do
+    local v = t1[i]
+    assert(t2[i] == v)
+  end
+end
+
+_G.x = nil   -- declare x
+function foo (a, ...)
+  local x, y = coroutine.running()
+  assert(x == f and y == false)
+  -- next call should not corrupt coroutine (but must fail,
+  -- as it attempts to resume the running coroutine)
+  assert(coroutine.resume(f) == false)
+  assert(coroutine.status(f) == "running")
+  local arg = {...}
+  assert(coroutine.isyieldable())
+  for i=1,#arg do
+    _G.x = {coroutine.yield(table.unpack(arg[i]))}
+  end
+  return table.unpack(a)
+end
+
+f = coroutine.create(foo)
+assert(type(f) == "thread" and coroutine.status(f) == "suspended")
+assert(string.find(tostring(f), "thread"))
+local s,a,b,c,d
+s,a,b,c,d = coroutine.resume(f, {1,2,3}, {}, {1}, {'a', 'b', 'c'})
+assert(s and a == nil and coroutine.status(f) == "suspended")
+s,a,b,c,d = coroutine.resume(f)
+eqtab(_G.x, {})
+assert(s and a == 1 and b == nil)
+s,a,b,c,d = coroutine.resume(f, 1, 2, 3)
+eqtab(_G.x, {1, 2, 3})
+assert(s and a == 'a' and b == 'b' and c == 'c' and d == nil)
+s,a,b,c,d = coroutine.resume(f, "xuxu")
+eqtab(_G.x, {"xuxu"})
+assert(s and a == 1 and b == 2 and c == 3 and d == nil)
+assert(coroutine.status(f) == "dead")
+s, a = coroutine.resume(f, "xuxu")
+assert(not s and string.find(a, "dead") and coroutine.status(f) == "dead")
+
+
+-- yields in tail calls
+local function foo (i) return coroutine.yield(i) end
+f = coroutine.wrap(function ()
+  for i=1,10 do
+    assert(foo(i) == _G.x)
+  end
+  return 'a'
+end)
+for i=1,10 do _G.x = i; assert(f(i) == i) end
+_G.x = 'xuxu'; assert(f('xuxu') == 'a')
+
+-- recursive
+function pf (n, i)
+  coroutine.yield(n)
+  pf(n*i, i+1)
+end
+
+f = coroutine.wrap(pf)
+local s=1
+for i=1,10 do
+  assert(f(1, 1) == s)
+  s = s*i
+end
+
+-- sieve
+function gen (n)
+  return coroutine.wrap(function ()
+    for i=2,n do coroutine.yield(i) end
+  end)
+end
+
+
+function filter (p, g)
+  return coroutine.wrap(function ()
+    while 1 do
+      local n = g()
+      if n == nil then return end
+      if math.fmod(n, p) ~= 0 then coroutine.yield(n) end
+    end
+  end)
+end
+
+local x = gen(100)
+local a = {}
+while 1 do
+  local n = x()
+  if n == nil then break end
+  table.insert(a, n)
+  x = filter(n, x)
+end
+
+assert(#a == 25 and a[#a] == 97)
+x, a = nil
+
+-- yielding across C boundaries
+
+co = coroutine.wrap(function()
+       assert(not pcall(table.sort,{1,2,3}, coroutine.yield))
+       assert(coroutine.isyieldable())
+       coroutine.yield(20)
+       return 30
+     end)
+
+assert(co() == 20)
+assert(co() == 30)
+
+
+local f = function (s, i) return coroutine.yield(i) end
+
+local f1 = coroutine.wrap(function ()
+             return xpcall(pcall, function (...) return ... end,
+               function ()
+                 local s = 0
+                 for i in f, nil, 1 do pcall(function () s = s + i end) end
+                 error({s})
+               end)
+           end)
+
+f1()
+for i = 1, 10 do assert(f1(i) == i) end
+local r1, r2, v = f1(nil)
+assert(r1 and not r2 and v[1] ==  (10 + 1)*10/2)
+
+
+function f (a, b) a = coroutine.yield(a);  error{a + b} end
+function g(x) return x[1]*2 end
+
+co = coroutine.wrap(function ()
+       coroutine.yield(xpcall(f, g, 10, 20))
+     end)
+
+assert(co() == 10)
+r, msg = co(100)
+assert(not r and msg == 240)
+
+
+-- unyieldable C call
+do
+  local function f (c)
+          assert(not coroutine.isyieldable())
+          return c .. c
+        end
+
+  local co = coroutine.wrap(function (c)
+               assert(coroutine.isyieldable())
+               local s = string.gsub("a", ".", f)
+               return s
+             end)
+  assert(co() == "aa")
+end
+
+
+-- errors in coroutines
+function foo ()
+  assert(debug.getinfo(1).currentline == debug.getinfo(foo).linedefined + 1)
+  assert(debug.getinfo(2).currentline == debug.getinfo(goo).linedefined)
+  coroutine.yield(3)
+  error(foo)
+end
+
+function goo() foo() end
+x = coroutine.wrap(goo)
+assert(x() == 3)
+local a,b = pcall(x)
+assert(not a and b == foo)
+
+x = coroutine.create(goo)
+a,b = coroutine.resume(x)
+assert(a and b == 3)
+a,b = coroutine.resume(x)
+assert(not a and b == foo and coroutine.status(x) == "dead")
+a,b = coroutine.resume(x)
+assert(not a and string.find(b, "dead") and coroutine.status(x) == "dead")
+
+
+-- co-routines x for loop
+function all (a, n, k)
+  if k == 0 then coroutine.yield(a)
+  else
+    for i=1,n do
+      a[k] = i
+      all(a, n, k-1)
+    end
+  end
+end
+
+local a = 0
+for t in coroutine.wrap(function () all({}, 5, 4) end) do
+  a = a+1
+end
+assert(a == 5^4)
+
+
+-- access to locals of collected corroutines
+local C = {}; setmetatable(C, {__mode = "kv"})
+local x = coroutine.wrap (function ()
+            local a = 10
+            local function f () a = a+10; return a end
+            while true do
+              a = a+1
+              coroutine.yield(f)
+            end
+          end)
+
+C[1] = x;
+
+local f = x()
+assert(f() == 21 and x()() == 32 and x() == f)
+x = nil
+collectgarbage()
+assert(C[1] == nil)
+assert(f() == 43 and f() == 53)
+
+
+-- old bug: attempt to resume itself
+
+function co_func (current_co)
+  assert(coroutine.running() == current_co)
+  assert(coroutine.resume(current_co) == false)
+  coroutine.yield(10, 20)
+  assert(coroutine.resume(current_co) == false)
+  coroutine.yield(23)
+  return 10
+end
+
+local co = coroutine.create(co_func)
+local a,b,c = coroutine.resume(co, co)
+assert(a == true and b == 10 and c == 20)
+a,b = coroutine.resume(co, co)
+assert(a == true and b == 23)
+a,b = coroutine.resume(co, co)
+assert(a == true and b == 10)
+assert(coroutine.resume(co, co) == false)
+assert(coroutine.resume(co, co) == false)
+
+
+-- attempt to resume 'normal' coroutine
+local co1, co2
+co1 = coroutine.create(function () return co2() end)
+co2 = coroutine.wrap(function ()
+        assert(coroutine.status(co1) == 'normal')
+        assert(not coroutine.resume(co1))
+        coroutine.yield(3)
+      end)
+
+a,b = coroutine.resume(co1)
+assert(a and b == 3)
+assert(coroutine.status(co1) == 'dead')
+
+-- infinite recursion of coroutines
+a = function(a) coroutine.wrap(a)(a) end
+assert(not pcall(a, a))
+a = nil
+
+
+-- access to locals of erroneous coroutines
+local x = coroutine.create (function ()
+            local a = 10
+            _G.f = function () a=a+1; return a end
+            error('x')
+          end)
+
+assert(not coroutine.resume(x))
+-- overwrite previous position of local `a'
+assert(not coroutine.resume(x, 1, 1, 1, 1, 1, 1, 1))
+assert(_G.f() == 11)
+assert(_G.f() == 12)
+
+
+if not T then
+  (Message or print)('\n >>> testC not active: skipping yield/hook tests <<<\n')
+else
+  print "testing yields inside hooks"
+
+  local turn
+  
+  function fact (t, x)
+    assert(turn == t)
+    if x == 0 then return 1
+    else return x*fact(t, x-1)
+    end
+  end
+
+  local A, B = 0, 0
+
+  local x = coroutine.create(function ()
+    T.sethook("yield 0", "", 2)
+    A = fact("A", 6)
+  end)
+
+  local y = coroutine.create(function ()
+    T.sethook("yield 0", "", 3)
+    B = fact("B", 7)
+  end)
+
+  while A==0 or B==0 do    -- A ~= 0 when 'x' finishes (similar for 'B','y')
+    if A==0 then turn = "A"; assert(T.resume(x)) end
+    if B==0 then turn = "B"; assert(T.resume(y)) end
+  end
+
+  assert(B // A == 7)    -- fact(7) // fact(6)
+
+  local line = debug.getinfo(1, "l").currentline + 2    -- get line number
+  local function foo ()
+    local x = 10    --<< this line is 'line'
+    x = x + 10
+    _G.XX = x
+  end
+
+  -- testing yields in line hook
+  local co = coroutine.wrap(function ()
+    T.sethook("setglobal X; yield 0", "l", 0); foo(); return 10 end)
+
+  _G.XX = nil;
+  _G.X = nil; co(); assert(_G.X == line)
+  _G.X = nil; co(); assert(_G.X == line + 1)
+  _G.X = nil; co(); assert(_G.X == line + 2 and _G.XX == nil)
+  _G.X = nil; co(); assert(_G.X == line + 3 and _G.XX == 20)
+  assert(co() == 10)
+
+  -- testing yields in count hook
+  co = coroutine.wrap(function ()
+    T.sethook("yield 0", "", 1); foo(); return 10 end)
+
+  _G.XX = nil;
+  local c = 0
+  repeat c = c + 1; local a = co() until a == 10
+  assert(_G.XX == 20 and c == 10)
+
+  co = coroutine.wrap(function ()
+    T.sethook("yield 0", "", 2); foo(); return 10 end)
+
+  _G.XX = nil;
+  local c = 0
+  repeat c = c + 1; local a = co() until a == 10
+  assert(_G.XX == 20 and c == 5)
+  _G.X = nil; _G.XX = nil
+
+
+  print "testing coroutine API"
+  
+  -- reusing a thread
+  assert(T.testC([[
+    newthread      # create thread
+    pushvalue 2    # push body
+    pushstring 'a a a'  # push argument
+    xmove 0 3 2   # move values to new thread
+    resume -1, 1    # call it first time
+    pushstatus
+    xmove 3 0 0   # move results back to stack
+    setglobal X    # result
+    setglobal Y    # status
+    pushvalue 2     # push body (to call it again)
+    pushstring 'b b b'
+    xmove 0 3 2
+    resume -1, 1    # call it again
+    pushstatus
+    xmove 3 0 0
+    return 1        # return result
+  ]], function (...) return ... end) == 'b b b')
+
+  assert(X == 'a a a' and Y == 'OK')
+
+
+  -- resuming running coroutine
+  C = coroutine.create(function ()
+        return T.testC([[
+                 pushnum 10;
+                 pushnum 20;
+                 resume -3 2;
+                 pushstatus
+                 gettop;
+                 return 3]], C)
+      end)
+  local a, b, c, d = coroutine.resume(C)
+  assert(a == true and string.find(b, "non%-suspended") and
+         c == "ERRRUN" and d == 4)
+
+  a, b, c, d = T.testC([[
+    rawgeti R 1    # get main thread
+    pushnum 10;
+    pushnum 20;
+    resume -3 2;
+    pushstatus
+    gettop;
+    return 4]])
+  assert(a == coroutine.running() and string.find(b, "non%-suspended") and
+         c == "ERRRUN" and d == 4)
+
+
+  -- using a main thread as a coroutine
+  local state = T.newstate()
+  T.loadlib(state)
+
+  assert(T.doremote(state, [[
+    coroutine = require'coroutine';
+    X = function (x) coroutine.yield(x, 'BB'); return 'CC' end;
+    return 'ok']]))
+
+  t = table.pack(T.testC(state, [[
+    rawgeti R 1     # get main thread
+    pushstring 'XX'
+    getglobal X    # get function for body
+    pushstring AA      # arg
+    resume 1 1      # 'resume' shadows previous stack!
+    gettop
+    setglobal T    # top
+    setglobal B    # second yielded value
+    setglobal A    # fist yielded value
+    rawgeti R 1     # get main thread
+    pushnum 5       # arg (noise)
+    resume 1 1      # after coroutine ends, previous stack is back
+    pushstatus
+    gettop
+    return .
+  ]]))
+  assert(t.n == 4 and t[2] == 'XX' and t[3] == 'CC' and t[4] == 'OK')
+  assert(T.doremote(state, "return T") == '2')
+  assert(T.doremote(state, "return A") == 'AA')
+  assert(T.doremote(state, "return B") == 'BB')
+
+  T.closestate(state)
+
+  print'+'
+
+end
+
+
+-- leaving a pending coroutine open
+_X = coroutine.wrap(function ()
+      local a = 10
+      local x = function () a = a+1 end
+      coroutine.yield()
+    end)
+
+_X()
+
+
+if not _soft then
+  -- bug (stack overflow)
+  local j = 2^9
+  local lim = 1000000    -- (C stack limit; assume 32-bit machine)
+  local t = {lim - 10, lim - 5, lim - 1, lim, lim + 1}
+  for i = 1, #t do
+    local j = t[i]
+    co = coroutine.create(function()
+           local t = {}
+           for i = 1, j do t[i] = i end
+           return table.unpack(t)
+         end)
+    local r, msg = coroutine.resume(co)
+    assert(not r)
+  end
+  co = nil
+end
+
+
+assert(coroutine.running() == main)
+
+print"+"
+
+
+print"testing yields inside metamethods"
+
+local mt = {
+  __eq = function(a,b) coroutine.yield(nil, "eq"); return a.x == b.x end,
+  __lt = function(a,b) coroutine.yield(nil, "lt"); return a.x < b.x end,
+  __le = function(a,b) coroutine.yield(nil, "le"); return a - b <= 0 end,
+  __add = function(a,b) coroutine.yield(nil, "add"); return a.x + b.x end,
+  __sub = function(a,b) coroutine.yield(nil, "sub"); return a.x - b.x end,
+  __mod = function(a,b) coroutine.yield(nil, "mod"); return a.x % b.x end,
+  __unm = function(a,b) coroutine.yield(nil, "unm"); return -a.x end,
+  __bnot = function(a,b) coroutine.yield(nil, "bnot"); return ~a.x end,
+  __shl = function(a,b) coroutine.yield(nil, "shl"); return a.x << b.x end,
+  __shr = function(a,b) coroutine.yield(nil, "shr"); return a.x >> b.x end,
+  __band = function(a,b)
+             a = type(a) == "table" and a.x or a
+             b = type(b) == "table" and b.x or b
+             coroutine.yield(nil, "band")
+             return a & b
+           end,
+  __bor = function(a,b) coroutine.yield(nil, "bor"); return a.x | b.x end,
+  __bxor = function(a,b) coroutine.yield(nil, "bxor"); return a.x ~ b.x end,
+
+  __concat = function(a,b)
+               coroutine.yield(nil, "concat");
+               a = type(a) == "table" and a.x or a
+               b = type(b) == "table" and b.x or b
+               return a .. b
+             end,
+  __index = function (t,k) coroutine.yield(nil, "idx"); return t.k[k] end,
+  __newindex = function (t,k,v) coroutine.yield(nil, "nidx"); t.k[k] = v end,
+}
+
+
+local function new (x)
+  return setmetatable({x = x, k = {}}, mt)
+end
+
+
+local a = new(10)
+local b = new(12)
+local c = new"hello"
+
+local function run (f, t)
+  local i = 1
+  local c = coroutine.wrap(f)
+  while true do
+    local res, stat = c()
+    if res then assert(t[i] == nil); return res, t end
+    assert(stat == t[i])
+    i = i + 1
+  end
+end
+
+
+assert(run(function () if (a>=b) then return '>=' else return '<' end end,
+       {"le", "sub"}) == "<")
+-- '<=' using '<'
+mt.__le = nil
+assert(run(function () if (a<=b) then return '<=' else return '>' end end,
+       {"lt"}) == "<=")
+assert(run(function () if (a==b) then return '==' else return '~=' end end,
+       {"eq"}) == "~=")
+
+assert(run(function () return a & b + a end, {"add", "band"}) == 2)
+
+assert(run(function () return a % b end, {"mod"}) == 10)
+
+assert(run(function () return ~a & b end, {"bnot", "band"}) == ~10 & 12)
+assert(run(function () return a | b end, {"bor"}) == 10 | 12)
+assert(run(function () return a ~ b end, {"bxor"}) == 10 ~ 12)
+assert(run(function () return a << b end, {"shl"}) == 10 << 12)
+assert(run(function () return a >> b end, {"shr"}) == 10 >> 12)
+
+assert(run(function () return a..b end, {"concat"}) == "1012")
+
+assert(run(function() return a .. b .. c .. a end,
+       {"concat", "concat", "concat"}) == "1012hello10")
+
+assert(run(function() return "a" .. "b" .. a .. "c" .. c .. b .. "x" end,
+       {"concat", "concat", "concat"}) == "ab10chello12x")
+
+assert(run(function ()
+             a.BB = print
+             return a.BB
+           end, {"nidx", "idx"}) == print)
+
+-- getuptable & setuptable
+do local _ENV = _ENV
+  f = function () AAA = BBB + 1; return AAA end
+end
+g = new(10); g.k.BBB = 10;
+debug.setupvalue(f, 1, g)
+assert(run(f, {"idx", "nidx", "idx"}) == 11)
+assert(g.k.AAA == 11)
+
+print"+"
+
+print"testing yields inside 'for' iterators"
+
+local f = function (s, i)
+      if i%2 == 0 then coroutine.yield(nil, "for") end
+      if i < s then return i + 1 end
+    end
+
+assert(run(function ()
+             local s = 0
+             for i in f, 4, 0 do s = s + i end
+             return s
+           end, {"for", "for", "for"}) == 10)
+
+
+
+-- tests for coroutine API
+if T==nil then
+  (Message or print)('\n >>> testC not active: skipping coroutine API tests <<<\n')
+  return
+end
+
+print('testing coroutine API')
+
+local function apico (...)
+  local x = {...}
+  return coroutine.wrap(function ()
+    return T.testC(table.unpack(x))
+  end)
+end
+
+local a = {apico(
+[[
+  pushstring errorcode
+  pcallk 1 0 2;
+  invalid command (should not arrive here)
+]],
+[[gettop; return .]],
+"stackmark",
+error
+)()}
+assert(#a == 4 and
+       a[3] == "stackmark" and
+       a[4] == "errorcode" and
+       _G.status == "ERRRUN" and
+       _G.ctx == 2)       -- 'ctx' to pcallk
+
+local co = apico(
+  "pushvalue 2; pushnum 10; pcallk 1 2 3; invalid command;",
+  coroutine.yield,
+  "getglobal status; getglobal ctx; pushvalue 2; pushstring a; pcallk 1 0 4; invalid command",
+  "getglobal status; getglobal ctx; gettop; return .")
+
+assert(co() == 10)
+assert(co(20, 30) == 'a')
+a = {co()}
+assert(#a == 10 and
+       a[2] == coroutine.yield and
+       a[5] == 20 and a[6] == 30 and
+       a[7] == "YIELD" and a[8] == 3 and
+       a[9] == "YIELD" and a[10] == 4)
+assert(not pcall(co))   -- coroutine is dead now
+
+
+f = T.makeCfunc("pushnum 3; pushnum 5; yield 1;")
+co = coroutine.wrap(function ()
+  assert(f() == 23); assert(f() == 23); return 10
+end)
+assert(co(23,16) == 5)
+assert(co(23,16) == 5)
+assert(co(23,16) == 10)
+
+
+-- testing coroutines with C bodies
+f = T.makeCfunc([[
+        pushnum 102
+	yieldk	1 U2
+	cannot be here!
+]],
+[[      # continuation
+	pushvalue U3   # accessing upvalues inside a continuation
+        pushvalue U4
+	gettop
+	return .
+]], 23, "huu")
+
+x = coroutine.wrap(f)
+assert(x() == 102)
+eqtab({x()}, {23, "huu"})
+
+
+f = T.makeCfunc[[pushstring 'a'; pushnum 102; yield 2; ]]
+
+a, b, c, d = T.testC([[newthread; pushvalue 2; xmove 0 3 1; resume 3 0;
+                       pushstatus; xmove 3 0 0;  resume 3 0; pushstatus;
+                       return 4; ]], f)
+
+assert(a == 'YIELD' and b == 'a' and c == 102 and d == 'OK')
+
+
+-- testing chain of suspendable C calls
+
+local count = 3   -- number of levels
+
+f = T.makeCfunc([[
+  remove 1;             # remove argument
+  pushvalue U3;         # get selection function
+  call 0 1;             # call it  (result is 'f' or 'yield')
+  pushstring hello      # single argument for selected function
+  pushupvalueindex 2;   # index of continuation program
+  callk 1 -1 .;		# call selected function
+  errorerror		# should never arrive here
+]],
+[[
+  # continuation program
+  pushnum 34	# return value
+  gettop
+  return .     # return all results
+]],
+function ()     -- selection function
+  count = count - 1
+  if count == 0 then return coroutine.yield
+  else return f
+  end
+end
+)
+
+co = coroutine.wrap(function () return f(nil) end)
+assert(co() == "hello")   -- argument to 'yield'
+a = {co()}
+-- three '34's (one from each pending C call)
+assert(#a == 3 and a[1] == a[2] and a[2] == a[3] and a[3] == 34)
+
+
+-- testing yields with continuations
+
+co = coroutine.wrap(function (...) return
+       T.testC([[ # initial function
+          yieldk 1 2
+          cannot be here!
+       ]],
+       [[  # 1st continuation
+         yieldk 0 3 
+         cannot be here!
+       ]],
+       [[  # 2nd continuation
+         yieldk 0 4 
+         cannot be here!
+       ]],
+       [[  # 3th continuation
+          pushvalue 6   # function which is last arg. to 'testC' here
+          pushnum 10; pushnum 20;
+          pcall 2 0 0   # call should throw an error and return to next line
+          pop 1		# remove error message
+          pushvalue 6
+          getglobal status; getglobal ctx
+          pcallk 2 2 5  # call should throw an error and jump to continuation
+          cannot be here!
+       ]],
+       [[  # 4th (and last) continuation
+         gettop
+         return .
+       ]],
+       -- function called by 3th continuation
+       function (a,b) x=a; y=b; error("errmsg") end,
+       ...
+)
+end)
+
+local a = {co(3,4,6)}
+assert(a[1] == 6 and a[2] == nil)
+a = {co()}; assert(a[1] == nil and _G.status == "YIELD" and _G.ctx == 2)
+a = {co()}; assert(a[1] == nil and _G.status == "YIELD" and _G.ctx == 3)
+a = {co(7,8)};
+-- original arguments
+assert(type(a[1]) == 'string' and type(a[2]) == 'string' and
+     type(a[3]) == 'string' and type(a[4]) == 'string' and
+     type(a[5]) == 'string' and type(a[6]) == 'function')
+-- arguments left from fist resume
+assert(a[7] == 3 and a[8] == 4)
+-- arguments to last resume
+assert(a[9] == 7 and a[10] == 8)
+-- error message and nothing more
+assert(a[11]:find("errmsg") and #a == 11)
+-- check arguments to pcallk
+assert(x == "YIELD" and y == 4)
+
+assert(not pcall(co))   -- coroutine should be dead
+
+
+-- bug in nCcalls
+local co = coroutine.wrap(function ()
+  local a = {pcall(pcall,pcall,pcall,pcall,pcall,pcall,pcall,error,"hi")}
+  return pcall(assert, table.unpack(a))
+end)
+
+local a = {co()}
+assert(a[10] == "hi")
+
+print'OK'
diff -urN rpm-5.4.15/lua/tests/db.lua rpm-5.4-cvs/lua/tests/db.lua
--- rpm-5.4.15/lua/tests/db.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/db.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,766 @@
+-- $Id: db.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+-- testing debug library
+
+local debug = require "debug"
+
+local function dostring(s) return assert(load(s))() end
+
+print"testing debug library and debug information"
+
+do
+local a=1
+end
+
+assert(not debug.gethook())
+
+function test (s, l, p)
+  collectgarbage()   -- avoid gc during trace
+  local function f (event, line)
+    assert(event == 'line')
+    local l = table.remove(l, 1)
+    if p then print(l, line) end
+    assert(l == line, "wrong trace!!")
+  end
+  debug.sethook(f,"l"); load(s)(); debug.sethook()
+  assert(#l == 0)
+end
+
+
+do
+  assert(not pcall(debug.getinfo, print, "X"))   -- invalid option
+  assert(not debug.getinfo(1000))   -- out of range level
+  assert(not debug.getinfo(-1))     -- out of range level
+  local a = debug.getinfo(print)
+  assert(a.what == "C" and a.short_src == "[C]")
+  a = debug.getinfo(print, "L")
+  assert(a.activelines == nil)
+  local b = debug.getinfo(test, "SfL")
+  assert(b.name == nil and b.what == "Lua" and b.linedefined == 17 and
+         b.lastlinedefined == b.linedefined + 10 and
+         b.func == test and not string.find(b.short_src, "%["))
+  assert(b.activelines[b.linedefined + 1] and
+         b.activelines[b.lastlinedefined])
+  assert(not b.activelines[b.linedefined] and
+         not b.activelines[b.lastlinedefined + 1])
+end
+
+
+-- test file and string names truncation
+a = "function f () end"
+local function dostring (s, x) return load(s, x)() end
+dostring(a)
+assert(debug.getinfo(f).short_src == string.format('[string "%s"]', a))
+dostring(a..string.format("; %s\n=1", string.rep('p', 400)))
+assert(string.find(debug.getinfo(f).short_src, '^%[string [^\n]*%.%.%."%]$'))
+dostring(a..string.format("; %s=1", string.rep('p', 400)))
+assert(string.find(debug.getinfo(f).short_src, '^%[string [^\n]*%.%.%."%]$'))
+dostring("\n"..a)
+assert(debug.getinfo(f).short_src == '[string "..."]')
+dostring(a, "")
+assert(debug.getinfo(f).short_src == '[string ""]')
+dostring(a, "@xuxu")
+assert(debug.getinfo(f).short_src == "xuxu")
+dostring(a, "@"..string.rep('p', 1000)..'t')
+assert(string.find(debug.getinfo(f).short_src, "^%.%.%.p*t$"))
+dostring(a, "=xuxu")
+assert(debug.getinfo(f).short_src == "xuxu")
+dostring(a, string.format("=%s", string.rep('x', 500)))
+assert(string.find(debug.getinfo(f).short_src, "^x*$"))
+dostring(a, "=")
+assert(debug.getinfo(f).short_src == "")
+a = nil; f = nil;
+
+
+repeat
+  local g = {x = function ()
+    local a = debug.getinfo(2)
+    assert(a.name == 'f' and a.namewhat == 'local')
+    a = debug.getinfo(1)
+    assert(a.name == 'x' and a.namewhat == 'field')
+    return 'xixi'
+  end}
+  local f = function () return 1+1 and (not 1 or g.x()) end
+  assert(f() == 'xixi')
+  g = debug.getinfo(f)
+  assert(g.what == "Lua" and g.func == f and g.namewhat == "" and not g.name)
+
+  function f (x, name)   -- local!
+    name = name or 'f'
+    local a = debug.getinfo(1)
+    assert(a.name == name and a.namewhat == 'local')
+    return x
+  end
+
+  -- breaks in different conditions
+  if 3>4 then break end; f()
+  if 3<4 then a=1 else break end; f()
+  while 1 do local x=10; break end; f()
+  local b = 1
+  if 3>4 then return math.sin(1) end; f()
+  a = 3<4; f()
+  a = 3<4 or 1; f()
+  repeat local x=20; if 4>3 then f() else break end; f() until 1
+  g = {}
+  f(g).x = f(2) and f(10)+f(9)
+  assert(g.x == f(19))
+  function g(x) if not x then return 3 end return (x('a', 'x')) end
+  assert(g(f) == 'a')
+until 1
+
+test([[if
+math.sin(1)
+then
+  a=1
+else
+  a=2
+end
+]], {2,3,4,7})
+
+test([[--
+if nil then
+  a=1
+else
+  a=2
+end
+]], {2,5,6})
+
+test([[a=1
+repeat
+  a=a+1
+until a==3
+]], {1,3,4,3,4})
+
+test([[ do
+  return
+end
+]], {2})
+
+test([[local a
+a=1
+while a<=3 do
+  a=a+1
+end
+]], {1,2,3,4,3,4,3,4,3,5})
+
+test([[while math.sin(1) do
+  if math.sin(1)
+  then break
+  end
+end
+a=1]], {1,2,3,6})
+
+test([[for i=1,3 do
+  a=i
+end
+]], {1,2,1,2,1,2,1,3})
+
+test([[for i,v in pairs{'a','b'} do
+  a=tostring(i) .. v
+end
+]], {1,2,1,2,1,3})
+
+test([[for i=1,4 do a=1 end]], {1,1,1,1,1})
+
+
+
+print'+'
+
+-- invalid levels in [gs]etlocal
+assert(not pcall(debug.getlocal, 20, 1))
+assert(not pcall(debug.setlocal, -1, 1, 10))
+
+
+-- parameter names
+local function foo (a,b,...) local d, e end
+local co = coroutine.create(foo)
+
+assert(debug.getlocal(foo, 1) == 'a')
+assert(debug.getlocal(foo, 2) == 'b')
+assert(not debug.getlocal(foo, 3))
+assert(debug.getlocal(co, foo, 1) == 'a')
+assert(debug.getlocal(co, foo, 2) == 'b')
+assert(not debug.getlocal(co, foo, 3))
+
+assert(not debug.getlocal(print, 1))
+
+
+-- varargs
+local function foo (a, ...)
+  local t = table.pack(...)
+  for i = 1, t.n do
+    local n, v = debug.getlocal(1, -i)
+    assert(n == "(*vararg)" and v == t[i])
+  end
+  assert(not debug.getlocal(1, -(t.n + 1)))
+  assert(not debug.setlocal(1, -(t.n + 1), 30))
+  if t.n > 0 then
+    (function (x)
+      assert(debug.setlocal(2, -1, x) == "(*vararg)")
+      assert(debug.setlocal(2, -t.n, x) == "(*vararg)")
+     end)(430)
+     assert(... == 430)
+  end
+end
+
+foo()
+foo(print)
+foo(200, 3, 4)
+local a = {}
+for i = 1, (_soft and 100 or 1000) do a[i] = i end
+foo(table.unpack(a))
+a = nil
+
+-- access to vararg in non-vararg function
+local function foo () return debug.getlocal(1, -1) end
+assert(not foo(10))
+
+
+do   -- test hook presence in debug info
+  assert(not debug.gethook())
+  local count = 0
+  local function f ()
+    assert(debug.getinfo(1).namewhat == "hook")
+    local sndline = string.match(debug.traceback(), "\n(.-)\n")
+    assert(string.find(sndline, "hook"))
+    count = count + 1
+  end
+  debug.sethook(f, "l")
+  local a = 0
+  _ENV.a = a
+  a = 1
+  debug.sethook()
+  assert(count == 4)
+end
+
+
+a = {}; L = nil
+local glob = 1
+local oldglob = glob
+debug.sethook(function (e,l)
+  collectgarbage()   -- force GC during a hook
+  local f, m, c = debug.gethook()
+  assert(m == 'crl' and c == 0)
+  if e == "line" then
+    if glob ~= oldglob then
+      L = l-1   -- get the first line where "glob" has changed
+      oldglob = glob
+    end
+  elseif e == "call" then
+      local f = debug.getinfo(2, "f").func
+      a[f] = 1
+  else assert(e == "return")
+  end
+end, "crl")
+
+
+function f(a,b)
+  collectgarbage()
+  local _, x = debug.getlocal(1, 1)
+  local _, y = debug.getlocal(1, 2)
+  assert(x == a and y == b)
+  assert(debug.setlocal(2, 3, "pera") == "AA".."AA")
+  assert(debug.setlocal(2, 4, "ma") == "B")
+  x = debug.getinfo(2)
+  assert(x.func == g and x.what == "Lua" and x.name == 'g' and
+         x.nups == 2 and string.find(x.source, "^@.*db%.lua$"))
+  glob = glob+1
+  assert(debug.getinfo(1, "l").currentline == L+1)
+  assert(debug.getinfo(1, "l").currentline == L+2)
+end
+
+function foo()
+  glob = glob+1
+  assert(debug.getinfo(1, "l").currentline == L+1)
+end; foo()  -- set L
+-- check line counting inside strings and empty lines
+
+_ = 'alo\
+alo' .. [[
+
+]]
+--[[
+]]
+assert(debug.getinfo(1, "l").currentline == L+11)  -- check count of lines
+
+
+function g(...)
+  local arg = {...}
+  do local a,b,c; a=math.sin(40); end
+  local feijao
+  local AAAA,B = "xuxu", "mamo"
+  f(AAAA,B)
+  assert(AAAA == "pera" and B == "ma")
+  do
+     local B = 13
+     local x,y = debug.getlocal(1,5)
+     assert(x == 'B' and y == 13)
+  end
+end
+
+g()
+
+
+assert(a[f] and a[g] and a[assert] and a[debug.getlocal] and not a[print])
+
+
+-- tests for manipulating non-registered locals (C and Lua temporaries)
+
+local n, v = debug.getlocal(0, 1)
+assert(v == 0 and n == "(*temporary)")
+local n, v = debug.getlocal(0, 2)
+assert(v == 2 and n == "(*temporary)")
+assert(not debug.getlocal(0, 3))
+assert(not debug.getlocal(0, 0))
+
+function f()
+  assert(select(2, debug.getlocal(2,3)) == 1)
+  assert(not debug.getlocal(2,4))
+  debug.setlocal(2, 3, 10)
+  return 20
+end
+
+function g(a,b) return (a+1) + f() end
+
+assert(g(0,0) == 30)
+ 
+
+debug.sethook(nil);
+assert(debug.gethook() == nil)
+
+
+-- testing access to function arguments
+
+X = nil
+a = {}
+function a:f (a, b, ...) local arg = {...}; local c = 13 end
+debug.sethook(function (e)
+  assert(e == "call")
+  dostring("XX = 12")  -- test dostring inside hooks
+  -- testing errors inside hooks
+  assert(not pcall(load("a='joao'+1")))
+  debug.sethook(function (e, l) 
+    assert(debug.getinfo(2, "l").currentline == l)
+    local f,m,c = debug.gethook()
+    assert(e == "line")
+    assert(m == 'l' and c == 0)
+    debug.sethook(nil)  -- hook is called only once
+    assert(not X)       -- check that
+    X = {}; local i = 1
+    local x,y
+    while 1 do
+      x,y = debug.getlocal(2, i)
+      if x==nil then break end
+      X[x] = y
+      i = i+1
+    end
+  end, "l")
+end, "c")
+
+a:f(1,2,3,4,5)
+assert(X.self == a and X.a == 1   and X.b == 2 and X.c == nil)
+assert(XX == 12)
+assert(debug.gethook() == nil)
+
+
+-- testing upvalue access
+local function getupvalues (f)
+  local t = {}
+  local i = 1
+  while true do
+    local name, value = debug.getupvalue(f, i)
+    if not name then break end
+    assert(not t[name])
+    t[name] = value
+    i = i + 1
+  end
+  return t
+end
+
+local a,b,c = 1,2,3
+local function foo1 (a) b = a; return c end
+local function foo2 (x) a = x; return c+b end
+assert(not debug.getupvalue(foo1, 3))
+assert(not debug.getupvalue(foo1, 0))
+assert(not debug.setupvalue(foo1, 3, "xuxu"))
+local t = getupvalues(foo1)
+assert(t.a == nil and t.b == 2 and t.c == 3)
+t = getupvalues(foo2)
+assert(t.a == 1 and t.b == 2 and t.c == 3)
+assert(debug.setupvalue(foo1, 1, "xuxu") == "b")
+assert(({debug.getupvalue(foo2, 3)})[2] == "xuxu")
+-- upvalues of C functions are allways "called" "" (the empty string)
+assert(debug.getupvalue(string.gmatch("x", "x"), 1) == "")  
+
+
+-- testing count hooks
+local a=0
+debug.sethook(function (e) a=a+1 end, "", 1)
+a=0; for i=1,1000 do end; assert(1000 < a and a < 1012)
+debug.sethook(function (e) a=a+1 end, "", 4)
+a=0; for i=1,1000 do end; assert(250 < a and a < 255)
+local f,m,c = debug.gethook()
+assert(m == "" and c == 4)
+debug.sethook(function (e) a=a+1 end, "", 4000)
+a=0; for i=1,1000 do end; assert(a == 0)
+
+do
+  debug.sethook(print, "", 2^24 - 1)   -- count upperbound
+  local f,m,c = debug.gethook()
+  assert(({debug.gethook()})[3] == 2^24 - 1)
+end
+
+debug.sethook()
+
+
+-- tests for tail calls
+local function f (x)
+  if x then
+    assert(debug.getinfo(1, "S").what == "Lua")
+    assert(debug.getinfo(1, "t").istailcall == true)
+    local tail = debug.getinfo(2)
+    assert(tail.func == g1 and tail.istailcall == true)
+    assert(debug.getinfo(3, "S").what == "main")
+    print"+"
+    end
+end
+
+function g(x) return f(x) end
+
+function g1(x) g(x) end
+
+local function h (x) local f=g1; return f(x) end
+
+h(true)
+
+local b = {}
+debug.sethook(function (e) table.insert(b, e) end, "cr")
+h(false)
+debug.sethook()
+local res = {"return",   -- first return (from sethook)
+  "call", "tail call", "call", "tail call",
+  "return", "return",
+  "call",    -- last call (to sethook)
+}
+for i = 1, #res do assert(res[i] == table.remove(b, 1)) end
+
+b = 0
+debug.sethook(function (e)
+                if e == "tail call" then
+                  b = b + 1
+                  assert(debug.getinfo(2, "t").istailcall == true)
+                else
+                  assert(debug.getinfo(2, "t").istailcall == false)
+                end
+              end, "c")
+h(false)
+debug.sethook()
+assert(b == 2)   -- two tail calls
+
+lim = _soft and 3000 or 30000
+local function foo (x)
+  if x==0 then
+    assert(debug.getinfo(2).what == "main")
+    local info = debug.getinfo(1)
+    assert(info.istailcall == true and info.func == foo)
+  else return foo(x-1)
+  end
+end
+
+foo(lim)
+
+
+print"+"
+
+
+-- testing local function information
+co = load[[
+  local A = function ()
+    return x
+  end
+  return
+]]
+
+local a = 0
+-- 'A' should be visible to debugger only after its complete definition
+debug.sethook(function (e, l)
+  if l == 3 then a = a + 1; assert(debug.getlocal(2, 1) == "(*temporary)")
+  elseif l == 4 then a = a + 1; assert(debug.getlocal(2, 1) == "A")
+  end
+end, "l")
+co()  -- run local function definition
+debug.sethook()  -- turn off hook
+assert(a == 2)   -- ensure all two lines where hooked
+
+-- testing traceback
+
+assert(debug.traceback(print) == print)
+assert(debug.traceback(print, 4) == print)
+assert(string.find(debug.traceback("hi", 4), "^hi\n"))
+assert(string.find(debug.traceback("hi"), "^hi\n"))
+assert(not string.find(debug.traceback("hi"), "'debug.traceback'"))
+assert(string.find(debug.traceback("hi", 0), "'debug.traceback'"))
+assert(string.find(debug.traceback(), "^stack traceback:\n"))
+
+do  -- C-function names in traceback
+  local st, msg = (function () return pcall end)()(debug.traceback)
+  assert(st == true and string.find(msg, "pcall"))
+end
+
+
+-- testing nparams, nups e isvararg
+local t = debug.getinfo(print, "u")
+assert(t.isvararg == true and t.nparams == 0 and t.nups == 0)
+
+t = debug.getinfo(function (a,b,c) end, "u")
+assert(t.isvararg == false and t.nparams == 3 and t.nups == 0)
+
+t = debug.getinfo(function (a,b,...) return t[a] end, "u")
+assert(t.isvararg == true and t.nparams == 2 and t.nups == 1)
+
+t = debug.getinfo(1)   -- main
+assert(t.isvararg == true and t.nparams == 0 and t.nups == 1 and
+       debug.getupvalue(t.func, 1) == "_ENV")
+
+
+-- testing debugging of coroutines
+
+local function checktraceback (co, p, level)
+  local tb = debug.traceback(co, nil, level)
+  local i = 0
+  for l in string.gmatch(tb, "[^\n]+\n?") do
+    assert(i == 0 or string.find(l, p[i]))
+    i = i+1
+  end
+  assert(p[i] == nil)
+end
+
+
+local function f (n)
+  if n > 0 then f(n-1)
+  else coroutine.yield() end
+end
+
+local co = coroutine.create(f)
+coroutine.resume(co, 3)
+checktraceback(co, {"yield", "db.lua", "db.lua", "db.lua", "db.lua"})
+checktraceback(co, {"db.lua", "db.lua", "db.lua", "db.lua"}, 1)
+checktraceback(co, {"db.lua", "db.lua", "db.lua"}, 2)
+checktraceback(co, {"db.lua"}, 4)
+checktraceback(co, {}, 40)
+
+
+co = coroutine.create(function (x)
+       local a = 1
+       coroutine.yield(debug.getinfo(1, "l"))
+       coroutine.yield(debug.getinfo(1, "l").currentline)
+       return a
+     end)
+
+local tr = {}
+local foo = function (e, l) if l then table.insert(tr, l) end end
+debug.sethook(co, foo, "lcr")
+
+local _, l = coroutine.resume(co, 10)
+local x = debug.getinfo(co, 1, "lfLS")
+assert(x.currentline == l.currentline and x.activelines[x.currentline])
+assert(type(x.func) == "function")
+for i=x.linedefined + 1, x.lastlinedefined do
+  assert(x.activelines[i])
+  x.activelines[i] = nil
+end
+assert(next(x.activelines) == nil)   -- no 'extra' elements
+assert(not debug.getinfo(co, 2))
+local a,b = debug.getlocal(co, 1, 1)
+assert(a == "x" and b == 10)
+a,b = debug.getlocal(co, 1, 2)
+assert(a == "a" and b == 1)
+debug.setlocal(co, 1, 2, "hi")
+assert(debug.gethook(co) == foo)
+assert(#tr == 2 and
+       tr[1] == l.currentline-1 and tr[2] == l.currentline)
+
+a,b,c = pcall(coroutine.resume, co)
+assert(a and b and c == l.currentline+1)
+checktraceback(co, {"yield", "in function <"})
+
+a,b = coroutine.resume(co)
+assert(a and b == "hi")
+assert(#tr == 4 and tr[4] == l.currentline+2)
+assert(debug.gethook(co) == foo)
+assert(not debug.gethook())
+checktraceback(co, {})
+
+
+-- check get/setlocal in coroutines
+co = coroutine.create(function (x)
+  local a, b = coroutine.yield(x)
+  assert(a == 100 and b == nil)
+  return x
+end)
+a, b = coroutine.resume(co, 10)
+assert(a and b == 10)
+a, b = debug.getlocal(co, 1, 1)
+assert(a == "x" and b == 10)
+assert(not debug.getlocal(co, 1, 5))
+assert(debug.setlocal(co, 1, 1, 30) == "x")
+assert(not debug.setlocal(co, 1, 5, 40))
+a, b = coroutine.resume(co, 100)
+assert(a and b == 30)
+
+
+-- check traceback of suspended (or dead with error) coroutines
+
+function f(i) if i==0 then error(i) else coroutine.yield(); f(i-1) end end
+
+co = coroutine.create(function (x) f(x) end)
+a, b = coroutine.resume(co, 3)
+t = {"'coroutine.yield'", "'f'", "in function <"}
+while coroutine.status(co) == "suspended" do
+  checktraceback(co, t)
+  a, b = coroutine.resume(co)
+  table.insert(t, 2, "'f'")   -- one more recursive call to 'f'
+end
+t[1] = "'error'"
+checktraceback(co, t)
+
+
+-- test acessing line numbers of a coroutine from a resume inside
+-- a C function (this is a known bug in Lua 5.0)
+
+local function g(x)
+    coroutine.yield(x)
+end
+
+local function f (i)
+  debug.sethook(function () end, "l")
+  for j=1,1000 do
+    g(i+j)
+  end
+end
+
+local co = coroutine.wrap(f)
+co(10)
+pcall(co)
+pcall(co)
+
+
+assert(type(debug.getregistry()) == "table")
+
+
+-- test tagmethod information
+local a = {}
+local function f (t)
+  local info = debug.getinfo(1);
+  assert(info.namewhat == "metamethod")
+  a.op = info.name
+  return info.name
+end
+setmetatable(a, {
+  __index = f; __add = f; __div = f; __mod = f; __concat = f; __pow = f;
+  __mul = f; __idiv = f; __unm = f; __len = f; __sub = f;
+  __shl = f; __shr = f; __bor = f; __bxor = f;
+  __eq = f; __le = f; __lt = f; __unm = f; __len = f; __band = f;
+  __bnot = f;
+})
+
+local b = setmetatable({}, getmetatable(a))
+
+assert(a[3] == "__index" and a^3 == "__pow" and a..a == "__concat")
+assert(a/3 == "__div" and 3%a == "__mod")
+assert(a+3 == "__add" and 3-a == "__sub" and a*3 == "__mul" and
+       -a == "__unm" and #a == "__len" and a&3 == "__band")
+assert(a|3 == "__bor" and 3~a == "__bxor" and a<<3 == "__shl" and
+       a>>1 == "__shr")
+assert (a==b and a.op == "__eq")
+assert (a>=b and a.op == "__le")
+assert (a>b and a.op == "__lt")
+assert(~a == "__bnot")
+
+do   -- testing for-iterator name
+  local function f()
+    assert(debug.getinfo(1).name == "for iterator")
+  end
+
+  for i in f do end
+end
+
+
+print("testing debug functions on chunk without debug info")
+prog = [[-- program to be loaded without debug information
+local debug = require'debug'
+local a = 12  -- a local variable
+
+local n, v = debug.getlocal(1, 1)
+assert(n == "(*temporary)" and v == debug)   -- unkown name but known value
+n, v = debug.getlocal(1, 2)
+assert(n == "(*temporary)" and v == 12)   -- unkown name but known value
+
+-- a function with an upvalue
+local f = function () local x; return a end
+n, v = debug.getupvalue(f, 1)
+assert(n == "(*no name)" and v == 12)
+assert(debug.setupvalue(f, 1, 13) == "(*no name)")
+assert(a == 13)
+
+local t = debug.getinfo(f)
+assert(t.name == nil and t.linedefined > 0 and
+       t.lastlinedefined == t.linedefined and
+       t.short_src == "?")
+assert(debug.getinfo(1).currentline == -1)
+
+t = debug.getinfo(f, "L").activelines
+assert(next(t) == nil)    -- active lines are empty
+
+-- dump/load a function without debug info
+f = load(string.dump(f))
+
+t = debug.getinfo(f)
+assert(t.name == nil and t.linedefined > 0 and
+       t.lastlinedefined == t.linedefined and
+       t.short_src == "?")
+assert(debug.getinfo(1).currentline == -1)
+
+return a
+]]
+
+
+-- load 'prog' without debug info
+local f = assert(load(string.dump(load(prog), true)))
+
+assert(f() == 13)
+
+do   -- tests for 'source' in binary dumps
+  local prog = [[
+    return function (x)
+      return function (y) 
+        return x + y
+      end
+    end
+  ]]
+  local name = string.rep("x", 1000)
+  local p = assert(load(prog, name))
+  -- load 'p' as a binary chunk with debug information
+  local c = string.dump(p)
+  assert(#c > 1000 and #c < 2000)   -- no repetition of 'source' in dump
+  local f = assert(load(c))
+  local g = f()
+  local h = g(3)
+  assert(h(5) == 8)
+  assert(debug.getinfo(f).source == name and   -- all functions have 'source'
+         debug.getinfo(g).source == name and 
+         debug.getinfo(h).source == name)
+  -- again, without debug info
+  local c = string.dump(p, true)
+  assert(#c < 500)   -- no 'source' in dump
+  local f = assert(load(c))
+  local g = f()
+  local h = g(30)
+  assert(h(50) == 80)
+  assert(debug.getinfo(f).source == '=?' and   -- no function has 'source'
+         debug.getinfo(g).source == '=?' and 
+         debug.getinfo(h).source == '=?')
+end
+
+print"OK"
+
diff -urN rpm-5.4.15/lua/tests/errors.lua rpm-5.4-cvs/lua/tests/errors.lua
--- rpm-5.4.15/lua/tests/errors.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/errors.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,531 @@
+-- $Id: errors.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print("testing errors")
+
+local debug = require"debug"
+
+-- avoid problems with 'strict' module (which may generate other error messages)
+local mt = getmetatable(_G) or {}
+local oldmm = mt.__index
+mt.__index = nil
+
+local function checkerr (msg, f, ...)
+  local st, err = pcall(f, ...)
+  assert(not st and string.find(err, msg))
+end
+
+
+local function doit (s)
+  local f, msg = load(s)
+  if f == nil then return msg end
+  local cond, msg = pcall(f)
+  return (not cond) and msg
+end
+
+
+local function checkmessage (prog, msg)
+  local m = doit(prog)
+  assert(string.find(m, msg, 1, true))
+end
+
+local function checksyntax (prog, extra, token, line)
+  local msg = doit(prog)
+  if not string.find(token, "^<%a") and not string.find(token, "^char%(")
+    then token = "'"..token.."'" end
+  token = string.gsub(token, "(%p)", "%%%1")
+  local pt = string.format([[^%%[string ".*"%%]:%d: .- near %s$]],
+                           line, token)
+  assert(string.find(msg, pt))
+  assert(string.find(msg, msg, 1, true))
+end
+
+
+-- test error message with no extra info
+assert(doit("error('hi', 0)") == 'hi')
+
+-- test error message with no info
+assert(doit("error()") == nil)
+
+
+-- test common errors/errors that crashed in the past
+assert(doit("table.unpack({}, 1, n=2^30)"))
+assert(doit("a=math.sin()"))
+assert(not doit("tostring(1)") and doit("tostring()"))
+assert(doit"tonumber()")
+assert(doit"repeat until 1; a")
+assert(doit"return;;")
+assert(doit"assert(false)")
+assert(doit"assert(nil)")
+assert(doit("function a (... , ...) end"))
+assert(doit("function a (, ...) end"))
+assert(doit("local t={}; t = t[#t] + 1"))
+
+checksyntax([[
+  local a = {4
+
+]], "'}' expected (to close '{' at line 1)", "<eof>", 3)
+
+
+-- tests for better error messages
+
+checkmessage("a = {} + 1", "arithmetic")
+checkmessage("a = {} | 1", "bitwise operation")
+checkmessage("a = {} < 1", "attempt to compare")
+checkmessage("a = {} <= 1", "attempt to compare")
+
+checkmessage("a=1; bbbb=2; a=math.sin(3)+bbbb(3)", "global 'bbbb'")
+checkmessage("a={}; do local a=1 end a:bbbb(3)", "method 'bbbb'")
+checkmessage("local a={}; a.bbbb(3)", "field 'bbbb'")
+assert(not string.find(doit"a={13}; local bbbb=1; a[bbbb](3)", "'bbbb'"))
+checkmessage("a={13}; local bbbb=1; a[bbbb](3)", "number")
+checkmessage("a=(1)..{}", "a table value")
+
+checkmessage("a = #print", "length of a function value")
+checkmessage("a = #3", "length of a number value")
+
+aaa = nil
+checkmessage("aaa.bbb:ddd(9)", "global 'aaa'")
+checkmessage("local aaa={bbb=1}; aaa.bbb:ddd(9)", "field 'bbb'")
+checkmessage("local aaa={bbb={}}; aaa.bbb:ddd(9)", "method 'ddd'")
+checkmessage("local a,b,c; (function () a = b+1 end)()", "upvalue 'b'")
+assert(not doit"local aaa={bbb={ddd=next}}; aaa.bbb:ddd(nil)")
+
+-- upvalues being indexed do not go to the stack
+checkmessage("local a,b,cc; (function () a = cc[1] end)()", "upvalue 'cc'")
+checkmessage("local a,b,cc; (function () a.x = 1 end)()", "upvalue 'a'")
+
+checkmessage("local _ENV = {x={}}; a = a + 1", "global 'a'")
+
+checkmessage("b=1; local aaa='a'; x=aaa+b", "local 'aaa'")
+checkmessage("aaa={}; x=3/aaa", "global 'aaa'")
+checkmessage("aaa='2'; b=nil;x=aaa*b", "global 'b'")
+checkmessage("aaa={}; x=-aaa", "global 'aaa'")
+
+-- short circuit
+checkmessage("a=1; local a,bbbb=2,3; a = math.sin(1) and bbbb(3)",
+       "local 'bbbb'")
+checkmessage("a=1; local a,bbbb=2,3; a = bbbb(1) or a(3)", "local 'bbbb'")
+checkmessage("local a,b,c,f = 1,1,1; f((a and b) or c)", "local 'f'")
+checkmessage("local a,b,c = 1,1,1; ((a and b) or c)()", "call a number value")
+assert(not string.find(doit"aaa={}; x=(aaa or aaa)+(aaa and aaa)", "'aaa'"))
+assert(not string.find(doit"aaa={}; (aaa or aaa)()", "'aaa'"))
+
+checkmessage("print(print < 10)", "function with number")
+checkmessage("print(print < print)", "two function values")
+checkmessage("print('10' < 10)", "string with number")
+checkmessage("print(10 < '23')", "number with string")
+
+-- float->integer conversions
+checkmessage("local a = 2.0^100; x = a << 2", "local a")
+checkmessage("local a = 1 >> 2.0^100", "has no integer representation")
+checkmessage("local a = '10' << 2.0^100", "has no integer representation")
+checkmessage("local a = 2.0^100 & 1", "has no integer representation")
+checkmessage("local a = 2.0^100 & '1'", "has no integer representation")
+checkmessage("local a = 2.0 | 1e40", "has no integer representation")
+checkmessage("local a = 2e100 ~ 1", "has no integer representation")
+checkmessage("string.sub('a', 2.0^100)", "has no integer representation")
+checkmessage("string.rep('a', 3.3)", "has no integer representation")
+checkmessage("return 6e40 & 7", "has no integer representation")
+checkmessage("return 34 << 7e30", "has no integer representation")
+checkmessage("return ~-3e40", "has no integer representation")
+checkmessage("return ~-3.009", "has no integer representation")
+checkmessage("return 3.009 & 1", "has no integer representation")
+checkmessage("return 34 >> {}", "table value")
+checkmessage("a = 24 // 0", "divide by zero")
+checkmessage("a = 1 % 0", "'n%0'")
+
+
+-- passing light userdata instead of full userdata
+_G.D = debug
+checkmessage([[
+  -- create light udata
+  local x = D.upvalueid(function () return debug end, 1)
+  D.setuservalue(x, {})
+]], "light userdata")
+_G.D = nil
+
+do   -- named userdata
+  checkmessage("math.sin(io.input())", "(number expected, got FILE*)")
+  _ENV.XX = setmetatable({}, {__name = "My Type"})
+  checkmessage("io.input(XX)", "(FILE* expected, got My Type)")
+  _ENV.XX = nil
+end
+
+-- global functions
+checkmessage("(io.write or print){}", "io.write")
+checkmessage("(collectgarbage or print){}", "collectgarbage")
+
+-- errors in functions without debug info
+do
+  local f = function (a) return a + 1 end
+  f = assert(load(string.dump(f, true)))
+  assert(f(3) == 4)
+  checkerr("^%?:%-1:", f, {})
+
+  -- code with a move to a local var ('OP_MOV A B' with A<B)
+  f = function () local a; a = {}; return a + 2 end
+  -- no debug info (so that 'a' is unknown)
+  f = assert(load(string.dump(f, true)))
+  -- symbolic execution should not get lost
+  checkerr("^%?:%-1:.*table value", f)
+end
+
+
+-- tests for field accesses after RK limit
+local t = {}
+for i = 1, 1000 do
+  t[i] = "a = x" .. i
+end
+local s = table.concat(t, "; ")
+t = nil
+checkmessage(s.."; a = bbb + 1", "global 'bbb'")
+checkmessage("local _ENV=_ENV;"..s.."; a = bbb + 1", "global 'bbb'")
+checkmessage(s.."; local t = {}; a = t.bbb + 1", "field 'bbb'")
+checkmessage(s.."; local t = {}; t:bbb()", "method 'bbb'")
+
+checkmessage([[aaa=9
+repeat until 3==3
+local x=math.sin(math.cos(3))
+if math.sin(1) == x then return math.sin(1) end   -- tail call
+local a,b = 1, {
+  {x='a'..'b'..'c', y='b', z=x},
+  {1,2,3,4,5} or 3+3<=3+3,
+  3+1>3+1,
+  {d = x and aaa[x or y]}}
+]], "global 'aaa'")
+
+checkmessage([[
+local x,y = {},1
+if math.sin(1) == 0 then return 3 end    -- return
+x.a()]], "field 'a'")
+
+checkmessage([[
+prefix = nil
+insert = nil
+while 1 do
+  local a
+  if nil then break end
+  insert(prefix, a)
+end]], "global 'insert'")
+
+checkmessage([[  -- tail call
+  return math.sin("a")
+]], "'sin'")
+
+checkmessage([[collectgarbage("nooption")]], "invalid option")
+
+checkmessage([[x = print .. "a"]], "concatenate")
+checkmessage([[x = "a" .. false]], "concatenate")
+checkmessage([[x = {} .. 2]], "concatenate")
+
+checkmessage("getmetatable(io.stdin).__gc()", "no value")
+
+checkmessage([[
+local Var
+local function main()
+  NoSuchName (function() Var=0 end)
+end
+main()
+]], "global 'NoSuchName'")
+print'+'
+
+a = {}; setmetatable(a, {__index = string})
+checkmessage("a:sub()", "bad self")
+checkmessage("string.sub('a', {})", "#2")
+checkmessage("('a'):sub{}", "#1")
+
+checkmessage("table.sort({1,2,3}, table.sort)", "'table.sort'")
+checkmessage("string.gsub('s', 's', setmetatable)", "'setmetatable'")
+
+-- tests for errors in coroutines
+
+local function f (n)
+  local c = coroutine.create(f)
+  local a,b = coroutine.resume(c)
+  return b
+end
+assert(string.find(f(), "C stack overflow"))
+
+checkmessage("coroutine.yield()", "outside a coroutine")
+
+f = coroutine.wrap(function () table.sort({1,2,3}, coroutine.yield) end)
+checkerr("yield across", f)
+
+
+-- testing size of 'source' info; size of buffer for that info is
+-- LUA_IDSIZE, declared as 60 in luaconf. Get one position for '\0'.
+idsize = 60 - 1
+local function checksize (source)
+  -- syntax error
+  local _, msg = load("x", source)
+  msg = string.match(msg, "^([^:]*):")   -- get source (1st part before ':')
+  assert(msg:len() <= idsize)
+end
+
+for i = 60 - 10, 60 + 10 do   -- check border cases around 60
+  checksize("@" .. string.rep("x", i))   -- file names
+  checksize(string.rep("x", i - 10))     -- string sources
+  checksize("=" .. string.rep("x", i))   -- exact sources
+end
+
+
+-- testing line error
+
+local function lineerror (s, l)
+  local err,msg = pcall(load(s))
+  local line = string.match(msg, ":(%d+):")
+  assert((line and line+0) == l)
+end
+
+lineerror("local a\n for i=1,'a' do \n print(i) \n end", 2)
+lineerror("\n local a \n for k,v in 3 \n do \n print(k) \n end", 3)
+lineerror("\n\n for k,v in \n 3 \n do \n print(k) \n end", 4)
+lineerror("function a.x.y ()\na=a+1\nend", 1)
+
+lineerror("a = \na\n+\n{}", 3)
+lineerror("a = \n3\n+\n(\n4\n/\nprint)", 6)
+lineerror("a = \nprint\n+\n(\n4\n/\n7)", 3)
+
+lineerror("a\n=\n-\n\nprint\n;", 3)
+
+lineerror([[
+a
+(
+23)
+]], 1)
+
+lineerror([[
+local a = {x = 13}
+a
+.
+x
+(
+23
+)
+]], 2)
+
+lineerror([[
+local a = {x = 13}
+a
+.
+x
+(
+23 + a
+)
+]], 6)
+
+local p = [[
+  function g() f() end
+  function f(x) error('a', X) end
+g()
+]]
+X=3;lineerror((p), 3)
+X=0;lineerror((p), nil)
+X=1;lineerror((p), 2)
+X=2;lineerror((p), 1)
+
+
+if not _soft then
+  -- several tests that exaust the Lua stack
+  collectgarbage()
+  print"testing stack overflow"
+  C = 0
+  local l = debug.getinfo(1, "l").currentline; function y () C=C+1; y() end
+
+  local function checkstackmessage (m)
+    return (string.find(m, "^.-:%d+: stack overflow"))
+  end
+  -- repeated stack overflows (to check stack recovery)
+  assert(checkstackmessage(doit('y()')))
+  print('+')
+  assert(checkstackmessage(doit('y()')))
+  print('+')
+  assert(checkstackmessage(doit('y()')))
+  print('+')
+
+
+  -- error lines in stack overflow
+  C = 0
+  local l1
+  local function g(x)
+    l1 = debug.getinfo(x, "l").currentline; y()
+  end
+  local _, stackmsg = xpcall(g, debug.traceback, 1)
+  print('+')
+  local stack = {}
+  for line in string.gmatch(stackmsg, "[^\n]*") do
+    local curr = string.match(line, ":(%d+):")
+    if curr then table.insert(stack, tonumber(curr)) end
+  end
+  local i=1
+  while stack[i] ~= l1 do
+    assert(stack[i] == l)
+    i = i+1
+  end
+  assert(i > 15)
+
+
+  -- error in error handling
+  local res, msg = xpcall(error, error)
+  assert(not res and type(msg) == 'string')
+  print('+')
+
+  local function f (x)
+    if x==0 then error('a\n')
+    else
+      local aux = function () return f(x-1) end
+      local a,b = xpcall(aux, aux)
+      return a,b
+    end
+  end
+  f(3)
+
+  local function loop (x,y,z) return 1 + loop(x, y, z) end
+ 
+  local res, msg = xpcall(loop, function (m)
+    assert(string.find(m, "stack overflow"))
+    checkerr("error handling", loop)
+    assert(math.sin(0) == 0)
+    return 15
+  end)
+  assert(msg == 15)
+
+  local f = function ()
+    for i = 999900, 1000000, 1 do table.unpack({}, 1, i) end
+  end
+  checkerr("too many results", f)
+
+end
+
+
+do
+  -- non string messages
+  local t = {}
+  local res, msg = pcall(function () error(t) end)
+  assert(not res and msg == t)
+
+  res, msg = pcall(function () error(nil) end)
+  assert(not res and msg == nil)
+
+  local function f() error{msg='x'} end
+  res, msg = xpcall(f, function (r) return {msg=r.msg..'y'} end)
+  assert(msg.msg == 'xy')
+
+  -- 'assert' with extra arguments
+  res, msg = pcall(assert, false, "X", t)
+  assert(not res and msg == "X")
+ 
+  -- 'assert' with no message
+  res, msg = pcall(function () assert(false) end)
+  local line = string.match(msg, "%w+%.lua:(%d+): assertion failed!$")
+  assert(tonumber(line) == debug.getinfo(1, "l").currentline - 2)
+
+  -- 'assert' with non-string messages
+  res, msg = pcall(assert, false, t)
+  assert(not res and msg == t)
+
+  res, msg = pcall(assert, nil, nil)
+  assert(not res and msg == nil)
+
+  -- 'assert' without arguments
+  res, msg = pcall(assert)
+  assert(not res and string.find(msg, "value expected"))
+end
+
+-- xpcall with arguments
+a, b, c = xpcall(string.find, error, "alo", "al")
+assert(a and b == 1 and c == 2)
+a, b, c = xpcall(string.find, function (x) return {} end, true, "al")
+assert(not a and type(b) == "table" and c == nil)
+
+
+print("testing tokens in error messages")
+checksyntax("syntax error", "", "error", 1)
+checksyntax("1.000", "", "1.000", 1)
+checksyntax("[[a]]", "", "[[a]]", 1)
+checksyntax("'aa'", "", "'aa'", 1)
+checksyntax("while << do end", "", "<<", 1)
+checksyntax("for >> do end", "", ">>", 1)
+
+-- test invalid non-printable char in a chunk
+checksyntax("a\1a = 1", "", "<\\1>", 1)
+
+-- test 255 as first char in a chunk
+checksyntax("\255a = 1", "", "<\\255>", 1)
+
+doit('I = load("a=9+"); a=3')
+assert(a==3 and I == nil)
+print('+')
+
+lim = 1000
+if _soft then lim = 100 end
+for i=1,lim do
+  doit('a = ')
+  doit('a = 4+nil')
+end
+
+
+-- testing syntax limits
+
+local maxClevel = 200    -- LUAI_MAXCCALLS (in llimits.h)
+
+local function testrep (init, rep, close, repc)
+  local s = "local a; "..init .. string.rep(rep, maxClevel - 10) .. close ..
+               string.rep(repc, maxClevel - 10)
+  assert(load(s))   -- 190 levels is OK
+  s = "local a; "..init .. string.rep(rep, maxClevel + 1)
+  checkmessage(s, "too many C levels")
+end
+
+testrep("a", ",a", "= 1", ",1")    -- multiple assignment
+testrep("a=", "{", "0", "}")
+testrep("a=", "(", "2", ")")
+testrep("", "a(", "2", ")")
+testrep("", "do ", "", " end")
+testrep("", "while a do ", "", " end")
+testrep("", "if a then else ", "", " end")
+testrep("", "function foo () ", "", " end")
+testrep("a=", "a..", "a", "")
+testrep("a=", "a^", "a", "")
+
+checkmessage("a = f(x" .. string.rep(",x", 260) .. ")",
+             "expression too complex")
+
+
+-- testing other limits
+
+-- upvalues
+local lim = 127
+local  s = "local function fooA ()\n  local "
+for j = 1,lim do
+  s = s.."a"..j..", "
+end
+s = s.."b,c\n"
+s = s.."local function fooB ()\n  local "
+for j = 1,lim do
+  s = s.."b"..j..", "
+end
+s = s.."b\n"
+s = s.."function fooC () return b+c"
+local c = 1+2
+for j = 1,lim do
+  s = s.."+a"..j.."+b"..j
+  c = c + 2
+end
+s = s.."\nend  end end"
+local a,b = load(s)
+assert(c > 255 and string.find(b, "too many upvalues") and
+       string.find(b, "line 5"))
+
+-- local variables
+s = "\nfunction foo ()\n  local "
+for j = 1,300 do
+  s = s.."a"..j..", "
+end
+s = s.."b\n"
+local a,b = load(s)
+assert(string.find(b, "line 2") and string.find(b, "too many local variables"))
+
+mt.__index = oldmm
+
+print('OK')
diff -urN rpm-5.4.15/lua/tests/events.lua rpm-5.4-cvs/lua/tests/events.lua
--- rpm-5.4.15/lua/tests/events.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/events.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,443 @@
+-- $Id: events.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print('testing metatables')
+
+local debug = require'debug'
+
+X = 20; B = 30
+
+_ENV = setmetatable({}, {__index=_G})
+
+collectgarbage()
+
+X = X+10
+assert(X == 30 and _G.X == 20)
+B = false
+assert(B == false)
+B = nil
+assert(B == 30)
+
+assert(getmetatable{} == nil)
+assert(getmetatable(4) == nil)
+assert(getmetatable(nil) == nil)
+a={}; setmetatable(a, {__metatable = "xuxu",
+                    __tostring=function(x) return x.name end})
+assert(getmetatable(a) == "xuxu")
+assert(tostring(a) == nil)
+-- cannot change a protected metatable
+assert(pcall(setmetatable, a, {}) == false)
+a.name = "gororoba"
+assert(tostring(a) == "gororoba")
+
+local a, t = {10,20,30; x="10", y="20"}, {}
+assert(setmetatable(a,t) == a)
+assert(getmetatable(a) == t)
+assert(setmetatable(a,nil) == a)
+assert(getmetatable(a) == nil)
+assert(setmetatable(a,t) == a)
+
+
+function f (t, i, e)
+  assert(not e)
+  local p = rawget(t, "parent")
+  return (p and p[i]+3), "dummy return"
+end
+
+t.__index = f
+
+a.parent = {z=25, x=12, [4] = 24}
+assert(a[1] == 10 and a.z == 28 and a[4] == 27 and a.x == "10")
+
+collectgarbage()
+
+a = setmetatable({}, t)
+function f(t, i, v) rawset(t, i, v-3) end
+setmetatable(t, t)   -- causes a bug in 5.1 !
+t.__newindex = f
+a[1] = 30; a.x = "101"; a[5] = 200
+assert(a[1] == 27 and a.x == 98 and a[5] == 197)
+
+
+local c = {}
+a = setmetatable({}, t)
+t.__newindex = c
+a[1] = 10; a[2] = 20; a[3] = 90
+assert(c[1] == 10 and c[2] == 20 and c[3] == 90)
+
+
+do
+  local a;
+  a = setmetatable({}, {__index = setmetatable({},
+                     {__index = setmetatable({},
+                     {__index = function (_,n) return a[n-3]+4, "lixo" end})})})
+  a[0] = 20
+  for i=0,10 do
+    assert(a[i*3] == 20 + i*4)
+  end
+end
+
+
+do  -- newindex
+  local foi
+  local a = {}
+  for i=1,10 do a[i] = 0; a['a'..i] = 0; end
+  setmetatable(a, {__newindex = function (t,k,v) foi=true; rawset(t,k,v) end})
+  foi = false; a[1]=0; assert(not foi)
+  foi = false; a['a1']=0; assert(not foi)
+  foi = false; a['a11']=0; assert(foi)
+  foi = false; a[11]=0; assert(foi)
+  foi = false; a[1]=nil; assert(not foi)
+  foi = false; a[1]=nil; assert(foi)
+end
+
+
+setmetatable(t, nil)
+function f (t, ...) return t, {...} end
+t.__call = f
+
+do
+  local x,y = a(table.unpack{'a', 1})
+  assert(x==a and y[1]=='a' and y[2]==1 and y[3]==nil)
+  x,y = a()
+  assert(x==a and y[1]==nil)
+end
+
+
+local b = setmetatable({}, t)
+setmetatable(b,t)
+
+function f(op)
+  return function (...) cap = {[0] = op, ...} ; return (...) end
+end
+t.__add = f("add")
+t.__sub = f("sub")
+t.__mul = f("mul")
+t.__div = f("div")
+t.__idiv = f("idiv")
+t.__mod = f("mod")
+t.__unm = f("unm")
+t.__pow = f("pow")
+t.__len = f("len")
+t.__band = f("band")
+t.__bor = f("bor")
+t.__bxor = f("bxor")
+t.__shl = f("shl")
+t.__shr = f("shr")
+t.__bnot = f("bnot")
+
+assert(b+5 == b)
+assert(cap[0] == "add" and cap[1] == b and cap[2] == 5 and cap[3]==nil)
+assert(b+'5' == b)
+assert(cap[0] == "add" and cap[1] == b and cap[2] == '5' and cap[3]==nil)
+assert(5+b == 5)
+assert(cap[0] == "add" and cap[1] == 5 and cap[2] == b and cap[3]==nil)
+assert('5'+b == '5')
+assert(cap[0] == "add" and cap[1] == '5' and cap[2] == b and cap[3]==nil)
+b=b-3; assert(getmetatable(b) == t)
+assert(5-a == 5)
+assert(cap[0] == "sub" and cap[1] == 5 and cap[2] == a and cap[3]==nil)
+assert('5'-a == '5')
+assert(cap[0] == "sub" and cap[1] == '5' and cap[2] == a and cap[3]==nil)
+assert(a*a == a)
+assert(cap[0] == "mul" and cap[1] == a and cap[2] == a and cap[3]==nil)
+assert(a/0 == a)
+assert(cap[0] == "div" and cap[1] == a and cap[2] == 0 and cap[3]==nil)
+assert(a%2 == a)
+assert(cap[0] == "mod" and cap[1] == a and cap[2] == 2 and cap[3]==nil)
+assert(a // (1/0) == a)
+assert(cap[0] == "idiv" and cap[1] == a and cap[2] == 1/0 and cap[3]==nil)
+assert(a & "hi" == a)
+assert(cap[0] == "band" and cap[1] == a and cap[2] == "hi" and cap[3]==nil)
+assert(a | "hi" == a)
+assert(cap[0] == "bor" and cap[1] == a and cap[2] == "hi" and cap[3]==nil)
+assert("hi" ~ a == "hi")
+assert(cap[0] == "bxor" and cap[1] == "hi" and cap[2] == a and cap[3]==nil)
+assert(-a == a)
+assert(cap[0] == "unm" and cap[1] == a)
+assert(a^4 == a)
+assert(cap[0] == "pow" and cap[1] == a and cap[2] == 4 and cap[3]==nil)
+assert(a^'4' == a)
+assert(cap[0] == "pow" and cap[1] == a and cap[2] == '4' and cap[3]==nil)
+assert(4^a == 4)
+assert(cap[0] == "pow" and cap[1] == 4 and cap[2] == a and cap[3]==nil)
+assert('4'^a == '4')
+assert(cap[0] == "pow" and cap[1] == '4' and cap[2] == a and cap[3]==nil)
+assert(#a == a)
+assert(cap[0] == "len" and cap[1] == a)
+assert(~a == a)
+assert(cap[0] == "bnot" and cap[1] == a)
+assert(a << 3 == a)
+assert(cap[0] == "shl" and cap[1] == a and cap[2] == 3)
+assert(1.5 >> a == 1.5)
+assert(cap[0] == "shr" and cap[1] == 1.5 and cap[2] == a)
+
+
+-- test for rawlen
+t = setmetatable({1,2,3}, {__len = function () return 10 end})
+assert(#t == 10 and rawlen(t) == 3)
+assert(rawlen"abc" == 3)
+assert(not pcall(rawlen, io.stdin))
+assert(not pcall(rawlen, 34))
+assert(not pcall(rawlen))
+
+t = {}
+t.__lt = function (a,b,c)
+  collectgarbage()
+  assert(c == nil)
+  if type(a) == 'table' then a = a.x end
+  if type(b) == 'table' then b = b.x end
+ return a<b, "dummy"
+end
+
+function Op(x) return setmetatable({x=x}, t) end
+
+local function test ()
+  assert(not(Op(1)<Op(1)) and (Op(1)<Op(2)) and not(Op(2)<Op(1)))
+  assert(not(1 < Op(1)) and (Op(1) < 2) and not(2 < Op(1)))
+  assert(not(Op('a')<Op('a')) and (Op('a')<Op('b')) and not(Op('b')<Op('a')))
+  assert(not('a' < Op('a')) and (Op('a') < 'b') and not(Op('b') < Op('a')))
+  assert((Op(1)<=Op(1)) and (Op(1)<=Op(2)) and not(Op(2)<=Op(1)))
+  assert((Op('a')<=Op('a')) and (Op('a')<=Op('b')) and not(Op('b')<=Op('a')))
+  assert(not(Op(1)>Op(1)) and not(Op(1)>Op(2)) and (Op(2)>Op(1)))
+  assert(not(Op('a')>Op('a')) and not(Op('a')>Op('b')) and (Op('b')>Op('a')))
+  assert((Op(1)>=Op(1)) and not(Op(1)>=Op(2)) and (Op(2)>=Op(1)))
+  assert((1 >= Op(1)) and not(1 >= Op(2)) and (Op(2) >= 1))
+  assert((Op('a')>=Op('a')) and not(Op('a')>=Op('b')) and (Op('b')>=Op('a')))
+  assert(('a' >= Op('a')) and not(Op('a') >= 'b') and (Op('b') >= Op('a')))
+end
+
+test()
+
+t.__le = function (a,b,c)
+  assert(c == nil)
+  if type(a) == 'table' then a = a.x end
+  if type(b) == 'table' then b = b.x end
+ return a<=b, "dummy"
+end
+
+test()  -- retest comparisons, now using both `lt' and `le'
+
+
+-- test `partial order'
+
+local function rawSet(x)
+  local y = {}
+  for _,k in pairs(x) do y[k] = 1 end
+  return y
+end
+
+local function Set(x)
+  return setmetatable(rawSet(x), t)
+end
+
+t.__lt = function (a,b)
+  for k in pairs(a) do
+    if not b[k] then return false end
+    b[k] = nil
+  end
+  return next(b) ~= nil
+end
+
+t.__le = nil
+
+assert(Set{1,2,3} < Set{1,2,3,4})
+assert(not(Set{1,2,3,4} < Set{1,2,3,4}))
+assert((Set{1,2,3,4} <= Set{1,2,3,4}))
+assert((Set{1,2,3,4} >= Set{1,2,3,4}))
+assert((Set{1,3} <= Set{3,5}))   -- wrong!! model needs a `le' method ;-)
+
+t.__le = function (a,b)
+  for k in pairs(a) do
+    if not b[k] then return false end
+  end
+  return true
+end
+
+assert(not (Set{1,3} <= Set{3,5}))   -- now its OK!
+assert(not(Set{1,3} <= Set{3,5}))
+assert(not(Set{1,3} >= Set{3,5}))
+
+t.__eq = function (a,b)
+  for k in pairs(a) do
+    if not b[k] then return false end
+    b[k] = nil
+  end
+  return next(b) == nil
+end
+
+local s = Set{1,3,5}
+assert(s == Set{3,5,1})
+assert(not rawequal(s, Set{3,5,1}))
+assert(rawequal(s, s))
+assert(Set{1,3,5,1} == rawSet{3,5,1})
+assert(rawSet{1,3,5,1} == Set{3,5,1})
+assert(Set{1,3,5} ~= Set{3,5,1,6})
+
+-- '__eq' is not used for table accesses
+t[Set{1,3,5}] = 1
+assert(t[Set{1,3,5}] == nil)
+
+
+if not T then
+  (Message or print)('\n >>> testC not active: skipping tests for \z
+userdata equality <<<\n')
+else
+  local u1 = T.newuserdata(0)
+  local u2 = T.newuserdata(0)
+  local u3 = T.newuserdata(0)
+  assert(u1 ~= u2 and u1 ~= u3)
+  debug.setuservalue(u1, 1);
+  debug.setuservalue(u2, 2);
+  debug.setuservalue(u3, 1);
+  debug.setmetatable(u1, {__eq = function (a, b)
+    return debug.getuservalue(a) == debug.getuservalue(b)
+  end})
+  debug.setmetatable(u2, {__eq = function (a, b)
+    return true
+  end})
+  assert(u1 == u3 and u3 == u1 and u1 ~= u2)
+  assert(u2 == u1 and u2 == u3 and u3 == u2)
+  assert(u2 ~= {})   -- different types cannot be equal
+end
+
+
+t.__concat = function (a,b,c)
+  assert(c == nil)
+  if type(a) == 'table' then a = a.val end
+  if type(b) == 'table' then b = b.val end
+  if A then return a..b
+  else
+    return setmetatable({val=a..b}, t)
+  end
+end
+
+c = {val="c"}; setmetatable(c, t)
+d = {val="d"}; setmetatable(d, t)
+
+A = true
+assert(c..d == 'cd')
+assert(0 .."a".."b"..c..d.."e".."f"..(5+3).."g" == "0abcdef8g")
+
+A = false
+assert((c..d..c..d).val == 'cdcd')
+x = c..d
+assert(getmetatable(x) == t and x.val == 'cd')
+x = 0 .."a".."b"..c..d.."e".."f".."g"
+assert(x.val == "0abcdefg")
+
+
+-- concat metamethod x numbers (bug in 5.1.1)
+c = {}
+local x
+setmetatable(c, {__concat = function (a,b)
+  assert(type(a) == "number" and b == c or type(b) == "number" and a == c)
+  return c
+end})
+assert(c..5 == c and 5 .. c == c)
+assert(4 .. c .. 5 == c and 4 .. 5 .. 6 .. 7 .. c == c)
+
+
+-- test comparison compatibilities
+local t1, t2, c, d
+t1 = {};  c = {}; setmetatable(c, t1)
+d = {}
+t1.__eq = function () return true end
+t1.__lt = function () return true end
+setmetatable(d, t1)
+assert(c == d and c < d and not(d <= c))
+t2 = {}
+t2.__eq = t1.__eq
+t2.__lt = t1.__lt
+setmetatable(d, t2)
+assert(c == d and c < d and not(d <= c))
+
+
+
+-- test for several levels of calls
+local i
+local tt = {
+  __call = function (t, ...)
+    i = i+1
+    if t.f then return t.f(...)
+    else return {...}
+    end
+  end
+}
+
+local a = setmetatable({}, tt)
+local b = setmetatable({f=a}, tt)
+local c = setmetatable({f=b}, tt)
+
+i = 0
+x = c(3,4,5)
+assert(i == 3 and x[1] == 3 and x[3] == 5)
+
+
+assert(_G.X == 20)
+
+print'+'
+
+local _g = _G
+_ENV = setmetatable({}, {__index=function (_,k) return _g[k] end})
+
+
+a = {}
+rawset(a, "x", 1, 2, 3)
+assert(a.x == 1 and rawget(a, "x", 3) == 1)
+
+print '+'
+
+-- testing metatables for basic types
+mt = {__index = function (a,b) return a+b end,
+      __len = function (x) return math.floor(x) end}
+debug.setmetatable(10, mt)
+assert(getmetatable(-2) == mt)
+assert((10)[3] == 13)
+assert((10)["3"] == 13)
+assert(#3.45 == 3)
+debug.setmetatable(23, nil)
+assert(getmetatable(-2) == nil)
+
+debug.setmetatable(true, mt)
+assert(getmetatable(false) == mt)
+mt.__index = function (a,b) return a or b end
+assert((true)[false] == true)
+assert((false)[false] == false)
+debug.setmetatable(false, nil)
+assert(getmetatable(true) == nil)
+
+debug.setmetatable(nil, mt)
+assert(getmetatable(nil) == mt)
+mt.__add = function (a,b) return (a or 0) + (b or 0) end
+assert(10 + nil == 10)
+assert(nil + 23 == 23)
+assert(nil + nil == 0)
+debug.setmetatable(nil, nil)
+assert(getmetatable(nil) == nil)
+
+debug.setmetatable(nil, {})
+
+
+-- loops in delegation
+a = {}; setmetatable(a, a); a.__index = a; a.__newindex = a
+assert(not pcall(function (a,b) return a[b] end, a, 10))
+assert(not pcall(function (a,b,c) a[b] = c end, a, 10, true))
+
+-- bug in 5.1
+T, K, V = nil
+grandparent = {}
+grandparent.__newindex = function(t,k,v) T=t; K=k; V=v end
+
+parent = {}
+parent.__newindex = parent
+setmetatable(parent, grandparent)
+
+child = setmetatable({}, parent)
+child.foo = 10      --> CRASH (on some machines)
+assert(T == parent and K == "foo" and V == 10)
+
+print 'OK'
+
+return 12
+
+
diff -urN rpm-5.4.15/lua/tests/files.lua rpm-5.4-cvs/lua/tests/files.lua
--- rpm-5.4.15/lua/tests/files.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/files.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,702 @@
+-- $Id: files.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+local debug = require "debug"
+
+assert(type(os.getenv"PATH") == "string")
+
+assert(io.input(io.stdin) == io.stdin)
+assert(not pcall(io.input, "non-existent-file"))
+assert(io.output(io.stdout) == io.stdout)
+
+local function checkerr (msg, f, ...)
+  local stat, err = pcall(f, ...)
+  assert(not stat and string.find(err, msg))
+end
+
+
+-- cannot close standard files
+assert(not io.close(io.stdin) and
+       not io.stdout:close() and
+       not io.stderr:close())
+
+
+assert(type(io.input()) == "userdata" and io.type(io.output()) == "file")
+assert(type(io.stdin) == "userdata" and io.type(io.stderr) == "file")
+assert(not io.type(8))
+local a = {}; setmetatable(a, {})
+assert(not io.type(a))
+
+assert(getmetatable(io.input()).__name == "FILE*")
+
+local a,b,c = io.open('xuxu_nao_existe')
+assert(not a and type(b) == "string" and type(c) == "number")
+
+a,b,c = io.open('/a/b/c/d', 'w')
+assert(not a and type(b) == "string" and type(c) == "number")
+
+local file = os.tmpname()
+local f, msg = io.open(file, "w")
+if not f then
+  (Message or print)("'os.tmpname' file cannot be open; skipping file tests")
+
+else  --{  most tests here need tmpname
+f:close()
+
+print('testing i/o')
+
+local otherfile = os.tmpname()
+
+checkerr("invalid mode", io.open, file, "rw")
+checkerr("invalid mode", io.open, file, "rb+")
+checkerr("invalid mode", io.open, file, "r+bk")
+checkerr("invalid mode", io.open, file, "")
+checkerr("invalid mode", io.open, file, "+")
+checkerr("invalid mode", io.open, file, "b")
+assert(io.open(file, "r+b")):close()
+assert(io.open(file, "r+")):close()
+assert(io.open(file, "rb")):close()
+
+assert(os.setlocale('C', 'all'))
+
+io.input(io.stdin); io.output(io.stdout);
+
+os.remove(file)
+assert(not loadfile(file))
+checkerr("", dofile, file)
+assert(not io.open(file))
+io.output(file)
+assert(io.output() ~= io.stdout)
+
+if not _port then   -- invalid seek
+  local status, msg, code = io.stdin:seek("set", 1000)
+  assert(not status and type(msg) == "string" and type(code) == "number")
+end
+
+assert(io.output():seek() == 0)
+assert(io.write("alo alo"):seek() == string.len("alo alo"))
+assert(io.output():seek("cur", -3) == string.len("alo alo")-3)
+assert(io.write("joao"))
+assert(io.output():seek("end") == string.len("alo joao"))
+
+assert(io.output():seek("set") == 0)
+
+assert(io.write('"lo"', "{a}\n", "second line\n", "third line \n"))
+assert(io.write('fourth_line'))
+io.output(io.stdout)
+collectgarbage()  -- file should be closed by GC
+assert(io.input() == io.stdin and rawequal(io.output(), io.stdout))
+print('+')
+
+-- test GC for files
+collectgarbage()
+for i=1,120 do
+  for i=1,5 do
+    io.input(file)
+    assert(io.open(file, 'r'))
+    io.lines(file)
+  end
+  collectgarbage()
+end
+
+io.input():close()
+io.close()
+
+assert(os.rename(file, otherfile))
+assert(not os.rename(file, otherfile))
+
+io.output(io.open(otherfile, "ab"))
+assert(io.write("\n\n\t\t  ", 3450, "\n"));
+io.close()
+
+-- test writing/reading numbers
+local largeint = math.maxinteger
+f = assert(io.open(file, "w"))
+f:write(largeint, '\n')
+f:write(string.format("0X%x\n", largeint))
+f:write("0xABCp-3", '\n')
+f:write(0, '\n')
+f:write(-largeint, '\n')
+f:write(string.format("0x%X\n", -largeint))
+f:write("-0xABCp-3", '\n')
+assert(f:close())
+f = assert(io.open(file, "r"))
+assert(f:read("n") == largeint)
+assert(f:read("n") == largeint)
+assert(f:read("n") == 0xABCp-3)
+assert(f:read("n") == 0)
+assert(f:read("*n") == -largeint)            -- test old format (with '*')
+assert(f:read("n") == -largeint)
+assert(f:read("*n") == -0xABCp-3)            -- test old format (with '*')
+assert(f:close())
+assert(os.remove(file))
+
+
+f = assert(io.open(file, "w"))
+-- test number termination
+f:write[[
+-12.3-	-0xffff+  .3|5.E-3X  +234e+13E 0xDEADBEEFDEADBEEFx
+0x1.13Ap+3e
+]]
+-- very long number
+f:write("1234"); for i = 1, 1000 do f:write("0") end;  f:write("\n")
+-- invalid sequences (must read and discard valid prefixes)
+f:write[[
+.e+	0.e;	--;  0xX;
+]]
+assert(f:close())
+f = assert(io.open(file, "r"))
+assert(f:read("n") == -12.3); assert(f:read(1) == "-")
+assert(f:read("n") == -0xffff); assert(f:read(2) == "+ ")
+assert(f:read("n") == 0.3); assert(f:read(1) == "|")
+assert(f:read("n") == 5e-3); assert(f:read(1) == "X")
+assert(f:read("n") == 234e13); assert(f:read(1) == "E")
+assert(f:read("n") == 0Xdeadbeefdeadbeef); assert(f:read(2) == "x\n")
+assert(f:read("n") == 0x1.13aP3); assert(f:read(1) == "e")
+
+do   -- attempt to read too long number
+  assert(f:read("n") == nil)  -- fails
+  local s = f:read("L")   -- read rest of line
+  assert(string.find(s, "^00*\n$"))  -- lots of 0's left
+end
+
+assert(not f:read("n")); assert(f:read(2) == "e+")
+assert(not f:read("n")); assert(f:read(1) == ";")
+assert(not f:read("n")); assert(f:read(2) == "-;")
+assert(not f:read("n")); assert(f:read(1) == "X")
+assert(not f:read("n")); assert(f:read(1) == ";")
+assert(not f:read("n")); assert(not f:read(0))   -- end of file
+assert(f:close())
+assert(os.remove(file))
+
+
+-- test line generators
+assert(not pcall(io.lines, "non-existent-file"))
+assert(os.rename(otherfile, file))
+io.output(otherfile)
+local n = 0
+local f = io.lines(file)
+while f() do n = n + 1 end;
+assert(n == 6)   -- number of lines in the file
+checkerr("file is already closed", f)
+checkerr("file is already closed", f)
+-- copy from file to otherfile
+n = 0
+for l in io.lines(file) do io.write(l, "\n"); n = n + 1 end
+io.close()
+assert(n == 6)
+-- copy from otherfile back to file
+local f = assert(io.open(otherfile))
+assert(io.type(f) == "file")
+io.output(file)
+assert(not io.output():read())
+n = 0
+for l in f:lines() do io.write(l, "\n"); n = n + 1 end
+assert(tostring(f):sub(1, 5) == "file ")
+assert(f:close()); io.close()
+assert(n == 6)
+checkerr("closed file", io.close, f)
+assert(tostring(f) == "file (closed)")
+assert(io.type(f) == "closed file")
+io.input(file)
+f = io.open(otherfile):lines()
+n = 0
+for l in io.lines() do assert(l == f()); n = n + 1 end
+f = nil; collectgarbage()
+assert(n == 6)
+assert(os.remove(otherfile))
+
+io.input(file)
+do  -- test error returns
+  local a,b,c = io.input():write("xuxu")
+  assert(not a and type(b) == "string" and type(c) == "number")
+end
+checkerr("invalid format", io.read, "x")
+assert(io.read(0) == "")   -- not eof
+assert(io.read(5, 'l') == '"lo"')
+assert(io.read(0) == "")
+assert(io.read() == "second line")
+local x = io.input():seek()
+assert(io.read() == "third line ")
+assert(io.input():seek("set", x))
+assert(io.read('L') == "third line \n")
+assert(io.read(1) == "")
+assert(io.read(string.len"fourth_line") == "fourth_line")
+assert(io.input():seek("cur", -string.len"fourth_line"))
+assert(io.read() == "fourth_line")
+assert(io.read() == "")  -- empty line
+assert(io.read('n') == 3450)
+assert(io.read(1) == '\n')
+assert(io.read(0) == nil)  -- end of file
+assert(io.read(1) == nil)  -- end of file
+assert(io.read(30000) == nil)  -- end of file
+assert(({io.read(1)})[2] == nil)
+assert(io.read() == nil)  -- end of file
+assert(({io.read()})[2] == nil)
+assert(io.read('n') == nil)  -- end of file
+assert(({io.read('n')})[2] == nil)
+assert(io.read('a') == '')  -- end of file (OK for 'a')
+assert(io.read('a') == '')  -- end of file (OK for 'a')
+collectgarbage()
+print('+')
+io.close(io.input())
+checkerr(" input file is closed", io.read)
+
+assert(os.remove(file))
+
+local t = '0123456789'
+for i=1,10 do t = t..t; end
+assert(string.len(t) == 10*2^10)
+
+io.output(file)
+io.write("alo"):write("\n")
+io.close()
+checkerr(" output file is closed", io.write)
+local f = io.open(file, "a+b")
+io.output(f)
+collectgarbage()
+
+assert(io.write(' ' .. t .. ' '))
+assert(io.write(';', 'end of file\n'))
+f:flush(); io.flush()
+f:close()
+print('+')
+
+io.input(file)
+assert(io.read() == "alo")
+assert(io.read(1) == ' ')
+assert(io.read(string.len(t)) == t)
+assert(io.read(1) == ' ')
+assert(io.read(0))
+assert(io.read('a') == ';end of file\n')
+assert(io.read(0) == nil)
+assert(io.close(io.input()))
+
+
+-- test errors in read/write
+do
+  local function ismsg (m)
+    -- error message is not a code number
+    return (type(m) == "string" and tonumber(m) == nil)
+  end
+
+  -- read
+  local f = io.open(file, "w")
+  local r, m, c = f:read()
+  assert(not r and ismsg(m) and type(c) == "number")
+  assert(f:close())
+  -- write
+  f = io.open(file, "r")
+  r, m, c = f:write("whatever")
+  assert(not r and ismsg(m) and type(c) == "number")
+  assert(f:close())
+  -- lines
+  f = io.open(file, "w")
+  r, m = pcall(f:lines())
+  assert(r == false and ismsg(m))
+  assert(f:close())
+end
+
+assert(os.remove(file))
+
+-- test for L format
+io.output(file); io.write"\n\nline\nother":close()
+io.input(file)
+assert(io.read"L" == "\n")
+assert(io.read"L" == "\n")
+assert(io.read"L" == "line\n")
+assert(io.read"L" == "other")
+assert(io.read"L" == nil)
+io.input():close()
+
+local f = assert(io.open(file))
+local s = ""
+for l in f:lines("L") do s = s .. l end
+assert(s == "\n\nline\nother")
+f:close()
+
+io.input(file)
+s = ""
+for l in io.lines(nil, "L") do s = s .. l end
+assert(s == "\n\nline\nother")
+io.input():close()
+
+s = ""
+for l in io.lines(file, "L") do s = s .. l end
+assert(s == "\n\nline\nother")
+
+s = ""
+for l in io.lines(file, "l") do s = s .. l end
+assert(s == "lineother")
+
+io.output(file); io.write"a = 10 + 34\na = 2*a\na = -a\n":close()
+local t = {}
+load(io.lines(file, "L"), nil, nil, t)()
+assert(t.a == -((10 + 34) * 2))
+
+
+-- test for multipe arguments in 'lines'
+io.output(file); io.write"0123456789\n":close()
+for a,b in io.lines(file, 1, 1) do
+  if a == "\n" then assert(b == nil)
+  else assert(tonumber(a) == tonumber(b) - 1)
+  end
+end
+
+for a,b,c in io.lines(file, 1, 2, "a") do
+  assert(a == "0" and b == "12" and c == "3456789\n")
+end
+
+for a,b,c in io.lines(file, "a", 0, 1) do
+  if a == "" then break end
+  assert(a == "0123456789\n" and b == nil and c == nil)
+end
+collectgarbage()   -- to close file in previous iteration
+
+io.output(file); io.write"00\n10\n20\n30\n40\n":close()
+for a, b in io.lines(file, "n", "n") do
+  if a == 40 then assert(b == nil)
+  else assert(a == b - 10)
+  end
+end
+
+
+-- test load x lines
+io.output(file);
+io.write[[
+local y
+= X
+X =
+X *
+2 +
+X;
+X =
+X
+-                                   y;
+]]:close()
+_G.X = 1
+assert(not load(io.lines(file)))
+collectgarbage()   -- to close file in previous iteration
+load(io.lines(file, "L"))()
+assert(_G.X == 2)
+load(io.lines(file, 1))()
+assert(_G.X == 4)
+load(io.lines(file, 3))()
+assert(_G.X == 8)
+
+print('+')
+
+local x1 = "string\n\n\\com \"\"''coisas [[estranhas]] ]]'"
+io.output(file)
+assert(io.write(string.format("x2 = %q\n-- comment without ending EOS", x1)))
+io.close()
+assert(loadfile(file))()
+assert(x1 == x2)
+print('+')
+assert(os.remove(file))
+assert(not os.remove(file))
+assert(not os.remove(otherfile))
+
+-- testing loadfile
+local function testloadfile (s, expres)
+  io.output(file)
+  if s then io.write(s) end
+  io.close()
+  local res = assert(loadfile(file))()
+  assert(os.remove(file))
+  assert(res == expres)
+end
+
+-- loading empty file
+testloadfile(nil, nil)
+
+-- loading file with initial comment without end of line
+testloadfile("# a non-ending comment", nil)
+
+
+-- checking Unicode BOM in files
+testloadfile("\xEF\xBB\xBF# some comment\nreturn 234", 234)
+testloadfile("\xEF\xBB\xBFreturn 239", 239)
+testloadfile("\xEF\xBB\xBF", nil)   -- empty file with a BOM
+
+
+-- checking line numbers in files with initial comments
+testloadfile("# a comment\nreturn require'debug'.getinfo(1).currentline", 2)
+
+
+-- loading binary file
+io.output(io.open(file, "wb"))
+assert(io.write(string.dump(function () return 10, '\0alo\255', 'hi' end)))
+io.close()
+a, b, c = assert(loadfile(file))()
+assert(a == 10 and b == "\0alo\255" and c == "hi")
+assert(os.remove(file))
+
+-- bug in 5.2.1
+do
+  io.output(io.open(file, "wb"))
+  -- save function with no upvalues
+  assert(io.write(string.dump(function () return 1 end)))
+  io.close()
+  f = assert(loadfile(file, "b", {}))
+  assert(type(f) == "function" and f() == 1)
+  assert(os.remove(file))
+end
+
+-- loading binary file with initial comment
+io.output(io.open(file, "wb"))
+assert(io.write("#this is a comment for a binary file\0\n",
+                string.dump(function () return 20, '\0\0\0' end)))
+io.close()
+a, b, c = assert(loadfile(file))()
+assert(a == 20 and b == "\0\0\0" and c == nil)
+assert(os.remove(file))
+
+
+-- 'loadfile' with 'env'
+do
+  local f = io.open(file, 'w')
+  f:write[[
+    if (...) then a = 15; return b, c, d
+    else return _ENV
+    end
+  ]]
+  f:close()
+  local t = {b = 12, c = "xuxu", d = print}
+  local f = assert(loadfile(file, 't', t))
+  local b, c, d = f(1)
+  assert(t.a == 15 and b == 12 and c == t.c and d == print)
+  assert(f() == t)
+  f = assert(loadfile(file, 't', nil))
+  assert(f() == nil)
+  f = assert(loadfile(file))
+  assert(f() == _G)
+  assert(os.remove(file))
+end
+
+
+-- 'loadfile' x modes
+do
+  io.open(file, 'w'):write("return 10"):close()
+  local s, m = loadfile(file, 'b')
+  assert(not s and string.find(m, "a text chunk"))
+  io.open(file, 'w'):write("\27 return 10"):close()
+  local s, m = loadfile(file, 't')
+  assert(not s and string.find(m, "a binary chunk"))
+  assert(os.remove(file))
+end
+
+
+io.output(file)
+assert(io.write("qualquer coisa\n"))
+assert(io.write("mais qualquer coisa"))
+io.close()
+assert(io.output(assert(io.open(otherfile, 'wb')))
+       :write("outra coisa\0\1\3\0\0\0\0\255\0")
+       :close())
+
+local filehandle = assert(io.open(file, 'r+'))
+local otherfilehandle = assert(io.open(otherfile, 'rb'))
+assert(filehandle ~= otherfilehandle)
+assert(type(filehandle) == "userdata")
+assert(filehandle:read('l') == "qualquer coisa")
+io.input(otherfilehandle)
+assert(io.read(string.len"outra coisa") == "outra coisa")
+assert(filehandle:read('l') == "mais qualquer coisa")
+filehandle:close();
+assert(type(filehandle) == "userdata")
+io.input(otherfilehandle)
+assert(io.read(4) == "\0\1\3\0")
+assert(io.read(3) == "\0\0\0")
+assert(io.read(0) == "")        -- 255 is not eof
+assert(io.read(1) == "\255")
+assert(io.read('a') == "\0")
+assert(not io.read(0))
+assert(otherfilehandle == io.input())
+otherfilehandle:close()
+assert(os.remove(file))
+assert(os.remove(otherfile))
+collectgarbage()
+
+io.output(file)
+  :write[[
+ 123.4	-56e-2  not a number
+second line
+third line
+
+and the rest of the file
+]]
+  :close()
+io.input(file)
+local _,a,b,c,d,e,h,__ = io.read(1, 'n', 'n', 'l', 'l', 'l', 'a', 10)
+assert(io.close(io.input()))
+assert(_ == ' ' and __ == nil)
+assert(type(a) == 'number' and a==123.4 and b==-56e-2)
+assert(d=='second line' and e=='third line')
+assert(h==[[
+
+and the rest of the file
+]])
+assert(os.remove(file))
+collectgarbage()
+
+-- testing buffers
+do
+  local f = assert(io.open(file, "w"))
+  local fr = assert(io.open(file, "r"))
+  assert(f:setvbuf("full", 2000))
+  f:write("x")
+  assert(fr:read("all") == "")  -- full buffer; output not written yet
+  f:close()
+  fr:seek("set")
+  assert(fr:read("all") == "x")   -- `close' flushes it
+  f = assert(io.open(file), "w")
+  assert(f:setvbuf("no"))
+  f:write("x")
+  fr:seek("set")
+  assert(fr:read("all") == "x")  -- no buffer; output is ready
+  f:close()
+  f = assert(io.open(file, "a"))
+  assert(f:setvbuf("line"))
+  f:write("x")
+  fr:seek("set", 1)
+  assert(fr:read("all") == "")   -- line buffer; no output without `\n'
+  f:write("a\n"):seek("set", 1)
+  assert(fr:read("all") == "xa\n")  -- now we have a whole line
+  f:close(); fr:close()
+  assert(os.remove(file))
+end
+
+
+if not _soft then
+  print("testing large files (> BUFSIZ)")
+  io.output(file)
+  for i=1,5001 do io.write('0123456789123') end
+  io.write('\n12346'):close()
+  io.input(file)
+  local x = io.read('a')
+  io.input():seek('set', 0)
+  local y = io.read(30001)..io.read(1005)..io.read(0)..
+            io.read(1)..io.read(100003)
+  assert(x == y and string.len(x) == 5001*13 + 6)
+  io.input():seek('set', 0)
+  y = io.read()  -- huge line
+  assert(x == y..'\n'..io.read())
+  assert(io.read() == nil)
+  io.close(io.input())
+  assert(os.remove(file))
+  x = nil; y = nil
+end
+
+if not _port then
+  print("testing popen/pclose and execute")
+  local tests = {
+    -- command,   what,  code
+    {"ls > /dev/null", "ok"},
+    {"not-to-be-found-command", "exit"},
+    {"exit 3", "exit", 3},
+    {"exit 129", "exit", 129},
+    {"kill -s HUP $$", "signal", 1},
+    {"kill -s KILL $$", "signal", 9},
+    {"sh -c 'kill -s HUP $$'", "exit"},
+    {'lua -e "os.exit(20, true)"', "exit", 20},
+  }
+  print("\n(some error messages are expected now)")
+  for _, v in ipairs(tests) do
+    local x, y, z = io.popen(v[1]):close()
+    local x1, y1, z1 = os.execute(v[1])
+    assert(x == x1 and y == y1 and z == z1)
+    if v[2] == "ok" then
+      assert(x and y == 'exit' and z == 0)
+    else
+      assert(not x and y == v[2])   -- correct status and 'what'
+      -- correct code if known (but always different from 0)
+      assert((v[3] == nil and z > 0) or v[3] == z)
+    end
+  end
+end
+
+
+-- testing tmpfile
+f = io.tmpfile()
+assert(io.type(f) == "file")
+f:write("alo")
+f:seek("set")
+assert(f:read"a" == "alo")
+
+end --}
+
+print'+'
+
+
+assert(os.date("") == "")
+assert(os.date("!") == "")
+local x = string.rep("a", 10000)
+assert(os.date(x) == x)
+local t = os.time()
+D = os.date("*t", t)
+assert(os.date(string.rep("%d", 1000), t) ==
+       string.rep(os.date("%d", t), 1000))
+assert(os.date(string.rep("%", 200)) == string.rep("%", 100))
+
+local t = os.time()
+D = os.date("*t", t)
+load(os.date([[assert(D.year==%Y and D.month==%m and D.day==%d and
+  D.hour==%H and D.min==%M and D.sec==%S and
+  D.wday==%w+1 and D.yday==%j and type(D.isdst) == 'boolean')]], t))()
+
+assert(not pcall(os.date, "%9"))   -- invalid conversion specifier
+assert(not pcall(os.date, "%"))   -- invalid conversion specifier
+assert(not pcall(os.date, "%O"))   -- invalid conversion specifier
+assert(not pcall(os.date, "%E"))   -- invalid conversion specifier
+assert(not pcall(os.date, "%Ea"))   -- invalid conversion specifier
+
+if not _port then
+  -- test Posix-specific modifiers
+  assert(type(os.date("%Ex")) == 'string')
+  assert(type(os.date("%Oy")) == 'string')
+end
+
+assert(os.time(D) == t)
+assert(not pcall(os.time, {hour = 12}))
+
+D = os.date("!*t", t)
+load(os.date([[!assert(D.year==%Y and D.month==%m and D.day==%d and
+  D.hour==%H and D.min==%M and D.sec==%S and
+  D.wday==%w+1 and D.yday==%j and type(D.isdst) == 'boolean')]], t))()
+
+do
+  local D = os.date("*t")
+  local t = os.time(D)
+  assert(type(D.isdst) == 'boolean')
+  D.isdst = nil
+  local t1 = os.time(D)
+  assert(t == t1)   -- if isdst is absent uses correct default
+end
+
+t = os.time(D)
+D.year = D.year-1;
+local t1 = os.time(D)
+-- allow for leap years
+assert(math.abs(os.difftime(t,t1)/(24*3600) - 365) < 2)
+
+t = os.time()
+t1 = os.time(os.date("*t"))
+assert(os.difftime(t1,t) <= 2)
+
+local t1 = os.time{year=2000, month=10, day=1, hour=23, min=12}
+local t2 = os.time{year=2000, month=10, day=1, hour=23, min=10, sec=19}
+assert(os.difftime(t1,t2) == 60*2-19)
+
+io.output(io.stdout)
+local d = tonumber(os.date('%d'))
+local m = tonumber(os.date('%m'))
+local a = tonumber(os.date('%Y'))
+local ds = tonumber(os.date('%w')) + 1
+local h = tonumber(os.date('%H'))
+local min = tonumber(os.date('%M'))
+local s = tonumber(os.date('%S'))
+io.write(string.format('test done on %2.2d/%2.2d/%d', d, m, a))
+io.write(string.format(', at %2.2d:%2.2d:%2.2d\n', h, min, s))
+io.write(string.format('%s\n', _VERSION))
+
+
diff -urN rpm-5.4.15/lua/tests/gc.lua rpm-5.4-cvs/lua/tests/gc.lua
--- rpm-5.4.15/lua/tests/gc.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/gc.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,623 @@
+-- $Id: gc.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print('testing garbage collection')
+
+local debug = require"debug"
+
+collectgarbage()
+
+assert(collectgarbage("isrunning"))
+
+local function gcinfo () return collectgarbage"count" * 1024 end
+
+
+-- test weird parameters
+do
+  -- save original parameters
+  local a = collectgarbage("setpause", 200)
+  local b = collectgarbage("setstepmul", 200)
+  local t = {0, 2, 10, 90, 500, 5000, 30000, 0x7ffffffe}
+  for i = 1, #t do
+    local p = t[i]
+    for j = 1, #t do
+      local m = t[j]
+      collectgarbage("setpause", p)
+      collectgarbage("setstepmul", m)
+      collectgarbage("step", 0)
+      collectgarbage("step", 10000)
+    end
+  end
+  -- restore original parameters
+  collectgarbage("setpause", a)
+  collectgarbage("setstepmul", b)
+  collectgarbage()
+end
+
+
+_G["while"] = 234
+
+limit = 5000
+
+
+local function GC1 ()
+  local u
+  local b     -- must be declared after 'u' (to be above it in the stack)
+  local finish = false
+  u = setmetatable({}, {__gc = function () finish = true end})
+  b = {34}
+  repeat u = {} until finish
+  assert(b[1] == 34)   -- 'u' was collected, but 'b' was not
+
+  finish = false; local i = 1
+  u = setmetatable({}, {__gc = function () finish = true end})
+  repeat i = i + 1; u = tostring(i) .. tostring(i) until finish
+  assert(b[1] == 34)   -- 'u' was collected, but 'b' was not
+
+  finish = false
+  u = setmetatable({}, {__gc = function () finish = true end})
+  repeat local i; u = function () return i end until finish
+  assert(b[1] == 34)   -- 'u' was collected, but 'b' was not
+end
+
+local function GC2 ()
+  local u
+  local finish = false
+  u = {setmetatable({}, {__gc = function () finish = true end})}
+  b = {34}
+  repeat u = {{}} until finish
+  assert(b[1] == 34)   -- 'u' was collected, but 'b' was not
+
+  finish = false; local i = 1
+  u = {setmetatable({}, {__gc = function () finish = true end})}
+  repeat i = i + 1; u = {tostring(i) .. tostring(i)} until finish
+  assert(b[1] == 34)   -- 'u' was collected, but 'b' was not
+
+  finish = false
+  u = {setmetatable({}, {__gc = function () finish = true end})}
+  repeat local i; u = {function () return i end} until finish
+  assert(b[1] == 34)   -- 'u' was collected, but 'b' was not
+end
+
+local function GC()  GC1(); GC2() end
+
+
+contCreate = 0
+
+print('tables')
+while contCreate <= limit do
+  local a = {}; a = nil
+  contCreate = contCreate+1
+end
+
+a = "a"
+
+contCreate = 0
+print('strings')
+while contCreate <= limit do
+  a = contCreate .. "b";
+  a = string.gsub(a, '(%d%d*)', string.upper)
+  a = "a"
+  contCreate = contCreate+1
+end
+
+
+contCreate = 0
+
+a = {}
+
+print('functions')
+function a:test ()
+  while contCreate <= limit do
+    load(string.format("function temp(a) return 'a%d' end", contCreate))()
+    assert(temp() == string.format('a%d', contCreate))
+    contCreate = contCreate+1
+  end
+end
+
+a:test()
+
+-- collection of functions without locals, globals, etc.
+do local f = function () end end
+
+
+print("functions with errors")
+prog = [[
+do
+  a = 10;
+  function foo(x,y)
+    a = sin(a+0.456-0.23e-12);
+    return function (z) return sin(%x+z) end
+  end
+  local x = function (w) a=a+w; end
+end
+]]
+do
+  local step = 1
+  if _soft then step = 13 end
+  for i=1, string.len(prog), step do
+    for j=i, string.len(prog), step do
+      pcall(load(string.sub(prog, i, j)))
+    end
+  end
+end
+
+foo = nil
+print('long strings')
+x = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"
+assert(string.len(x)==80)
+s = ''
+n = 0
+k = math.min(300, (math.maxinteger // 80) // 2)
+while n < k do s = s..x; n=n+1; j=tostring(n)  end
+assert(string.len(s) == k*80)
+s = string.sub(s, 1, 10000)
+s, i = string.gsub(s, '(%d%d%d%d)', '')
+assert(i==10000 // 4)
+s = nil
+x = nil
+
+assert(_G["while"] == 234)
+
+
+print("steps")
+
+print("steps (2)")
+
+local function dosteps (siz)
+  assert(not collectgarbage("isrunning"))
+  collectgarbage()
+  assert(not collectgarbage("isrunning"))
+  local a = {}
+  for i=1,100 do a[i] = {{}}; local b = {} end
+  local x = gcinfo()
+  local i = 0
+  repeat   -- do steps until it completes a collection cycle
+    i = i+1
+  until collectgarbage("step", siz)
+  assert(gcinfo() < x)
+  return i
+end
+
+collectgarbage"stop"
+
+if not _port then
+  -- test the "size" of basic GC steps (whatever they mean...)
+  assert(dosteps(0) > 10)
+  assert(dosteps(10) < dosteps(2))
+end
+
+-- collector should do a full collection with so many steps
+assert(dosteps(20000) == 1)
+assert(collectgarbage("step", 20000) == true)
+assert(collectgarbage("step", 20000) == true)
+
+assert(not collectgarbage("isrunning"))
+collectgarbage"restart"
+assert(collectgarbage("isrunning"))
+
+
+if not _port then
+  -- test the pace of the collector
+  collectgarbage(); collectgarbage()
+  local x = gcinfo()
+  collectgarbage"stop"
+  assert(not collectgarbage("isrunning"))
+  repeat
+    local a = {}
+  until gcinfo() > 3 * x
+  collectgarbage"restart"
+  assert(collectgarbage("isrunning"))
+  repeat
+    local a = {}
+  until gcinfo() <= x * 2
+end
+
+
+print("clearing tables")
+lim = 15
+a = {}
+-- fill a with `collectable' indices
+for i=1,lim do a[{}] = i end
+b = {}
+for k,v in pairs(a) do b[k]=v end
+-- remove all indices and collect them
+for n in pairs(b) do
+  a[n] = nil
+  assert(type(n) == 'table' and next(n) == nil)
+  collectgarbage()
+end
+b = nil
+collectgarbage()
+for n in pairs(a) do error'cannot be here' end
+for i=1,lim do a[i] = i end
+for i=1,lim do assert(a[i] == i) end
+
+
+print('weak tables')
+a = {}; setmetatable(a, {__mode = 'k'});
+-- fill a with some `collectable' indices
+for i=1,lim do a[{}] = i end
+-- and some non-collectable ones
+for i=1,lim do a[i] = i end
+for i=1,lim do local s=string.rep('@', i); a[s] = s..'#' end
+collectgarbage()
+local i = 0
+for k,v in pairs(a) do assert(k==v or k..'#'==v); i=i+1 end
+assert(i == 2*lim)
+
+a = {}; setmetatable(a, {__mode = 'v'});
+a[1] = string.rep('b', 21)
+collectgarbage()
+assert(a[1])   -- strings are *values*
+a[1] = nil
+-- fill a with some `collectable' values (in both parts of the table)
+for i=1,lim do a[i] = {} end
+for i=1,lim do a[i..'x'] = {} end
+-- and some non-collectable ones
+for i=1,lim do local t={}; a[t]=t end
+for i=1,lim do a[i+lim]=i..'x' end
+collectgarbage()
+local i = 0
+for k,v in pairs(a) do assert(k==v or k-lim..'x' == v); i=i+1 end
+assert(i == 2*lim)
+
+a = {}; setmetatable(a, {__mode = 'vk'});
+local x, y, z = {}, {}, {}
+-- keep only some items
+a[1], a[2], a[3] = x, y, z
+a[string.rep('$', 11)] = string.rep('$', 11)
+-- fill a with some `collectable' values
+for i=4,lim do a[i] = {} end
+for i=1,lim do a[{}] = i end
+for i=1,lim do local t={}; a[t]=t end
+collectgarbage()
+assert(next(a) ~= nil)
+local i = 0
+for k,v in pairs(a) do
+  assert((k == 1 and v == x) or
+         (k == 2 and v == y) or
+         (k == 3 and v == z) or k==v);
+  i = i+1
+end
+assert(i == 4)
+x,y,z=nil
+collectgarbage()
+assert(next(a) == string.rep('$', 11))
+
+
+-- 'bug' in 5.1
+a = {}
+local t = {x = 10}
+local C = setmetatable({key = t}, {__mode = 'v'})
+local C1 = setmetatable({[t] = 1}, {__mode = 'k'})
+a.x = t  -- this should not prevent 't' from being removed from
+         -- weak table 'C' by the time 'a' is finalized
+
+setmetatable(a, {__gc = function (u)
+                          assert(C.key == nil)
+                          assert(type(next(C1)) == 'table')
+                          end})
+
+a, t = nil
+collectgarbage()
+collectgarbage()
+assert(next(C) == nil and next(C1) == nil)
+C, C1 = nil
+
+
+-- ephemerons
+local mt = {__mode = 'k'}
+a = {{10},{20},{30},{40}}; setmetatable(a, mt)
+x = nil
+for i = 1, 100 do local n = {}; a[n] = {k = {x}}; x = n end
+GC()
+local n = x
+local i = 0
+while n do n = a[n].k[1]; i = i + 1 end
+assert(i == 100)
+x = nil
+GC()
+for i = 1, 4 do assert(a[i][1] == i * 10); a[i] = nil end
+assert(next(a) == nil)
+
+local K = {}
+a[K] = {}
+for i=1,10 do a[K][i] = {}; a[a[K][i]] = setmetatable({}, mt) end
+x = nil
+local k = 1
+for j = 1,100 do
+  local n = {}; local nk = k%10 + 1
+  a[a[K][nk]][n] = {x, k = k}; x = n; k = nk
+end
+GC()
+local n = x
+local i = 0
+while n do local t = a[a[K][k]][n]; n = t[1]; k = t.k; i = i + 1 end
+assert(i == 100)
+K = nil
+GC()
+-- assert(next(a) == nil)
+
+
+-- testing errors during GC
+do
+collectgarbage("stop")   -- stop collection
+local u = {}
+local s = {}; setmetatable(s, {__mode = 'k'})
+setmetatable(u, {__gc = function (o)
+  local i = s[o]
+  s[i] = true
+  assert(not s[i - 1])   -- check proper finalization order
+  if i == 8 then error("here") end   -- error during GC
+end})
+
+for i = 6, 10 do
+  local n = setmetatable({}, getmetatable(u))
+  s[n] = i
+end
+
+assert(not pcall(collectgarbage))
+for i = 8, 10 do assert(s[i]) end
+
+for i = 1, 5 do
+  local n = setmetatable({}, getmetatable(u))
+  s[n] = i
+end
+
+collectgarbage()
+for i = 1, 10 do assert(s[i]) end
+
+getmetatable(u).__gc = false
+
+
+-- __gc errors with non-string messages
+setmetatable({}, {__gc = function () error{} end})
+local a, b = pcall(collectgarbage)
+assert(not a and type(b) == "string" and string.find(b, "error in __gc"))
+
+end
+print '+'
+
+
+-- testing userdata
+if T==nil then
+  (Message or print)('\n >>> testC not active: skipping userdata GC tests <<<\n')
+
+else
+
+  local function newproxy(u)
+    return debug.setmetatable(T.newuserdata(0), debug.getmetatable(u))
+  end
+
+  collectgarbage("stop")   -- stop collection
+  local u = newproxy(nil)
+  debug.setmetatable(u, {__gc = true})
+  local s = 0
+  local a = {[u] = 0}; setmetatable(a, {__mode = 'vk'})
+  for i=1,10 do a[newproxy(u)] = i end
+  for k in pairs(a) do assert(getmetatable(k) == getmetatable(u)) end
+  local a1 = {}; for k,v in pairs(a) do a1[k] = v end
+  for k,v in pairs(a1) do a[v] = k end
+  for i =1,10 do assert(a[i]) end
+  getmetatable(u).a = a1
+  getmetatable(u).u = u
+  do
+    local u = u
+    getmetatable(u).__gc = function (o)
+      assert(a[o] == 10-s)
+      assert(a[10-s] == nil) -- udata already removed from weak table
+      assert(getmetatable(o) == getmetatable(u))
+    assert(getmetatable(o).a[o] == 10-s)
+      s=s+1
+    end
+  end
+  a1, u = nil
+  assert(next(a) ~= nil)
+  collectgarbage()
+  assert(s==11)
+  collectgarbage()
+  assert(next(a) == nil)  -- finalized keys are removed in two cycles
+end
+
+
+-- __gc x weak tables
+local u = setmetatable({}, {__gc = true})
+-- __gc metamethod should be collected before running
+setmetatable(getmetatable(u), {__mode = "v"})
+getmetatable(u).__gc = function (o) os.exit(1) end  -- cannot happen
+u = nil
+collectgarbage()
+
+local u = setmetatable({}, {__gc = true})
+local m = getmetatable(u)
+m.x = {[{0}] = 1; [0] = {1}}; setmetatable(m.x, {__mode = "kv"});
+m.__gc = function (o)
+  assert(next(getmetatable(o).x) == nil)
+  m = 10
+end
+u, m = nil
+collectgarbage()
+assert(m==10)
+
+
+-- errors during collection
+u = setmetatable({}, {__gc = function () error "!!!" end})
+u = nil
+assert(not pcall(collectgarbage))
+
+
+if not _soft then
+  print("deep structures")
+  local a = {}
+  for i = 1,200000 do
+    a = {next = a}
+  end
+  collectgarbage()
+end
+
+-- create many threads with self-references and open upvalues
+print("self-referenced threads")
+local thread_id = 0
+local threads = {}
+
+local function fn (thread)
+    local x = {}
+    threads[thread_id] = function()
+                             thread = x
+                         end
+    coroutine.yield()
+end
+
+while thread_id < 1000 do
+    local thread = coroutine.create(fn)
+    coroutine.resume(thread, thread)
+    thread_id = thread_id + 1
+end
+
+
+-- Create a closure (function inside 'f') with an upvalue ('param') that
+-- points (through a table) to the closure itself and to the thread
+-- ('co' and the initial value of 'param') where closure is running.
+-- Then, assert that table (and therefore everything else) will be
+-- collected.
+do
+  local collected = false   -- to detect collection
+  collectgarbage(); collectgarbage("stop")
+  do
+    local function f (param) 
+      ;(function ()
+        assert(type(f) == 'function' and type(param) == 'thread')
+        param = {param, f}
+        setmetatable(param, {__gc = function () collected = true end})
+        coroutine.yield(100)
+      end)()
+    end
+    local co = coroutine.create(f)
+    assert(coroutine.resume(co, co))
+  end
+  -- Now, thread and closure are not reacheable any more;
+  -- two collections are needed to break cycle
+  collectgarbage()
+  assert(not collected)
+  collectgarbage()
+  assert(collected)
+  collectgarbage("restart")
+end
+
+
+do
+  collectgarbage()
+  collectgarbage"stop"
+  local x = gcinfo()
+  repeat
+    for i=1,1000 do _ENV.a = {} end
+    collectgarbage("step", 0)   -- steps should not unblock the collector
+  until gcinfo() > 2 * x
+  collectgarbage"restart"
+end
+
+
+if T then   -- tests for weird cases collecting upvalues
+
+  local function foo ()
+    local a = {x = 20}
+    coroutine.yield(function () return a.x end)  -- will run collector
+    assert(a.x == 20)   -- 'a' is 'ok'
+    a = {x = 30}   -- create a new object
+    assert(T.gccolor(a) == "white")   -- of course it is new...
+    coroutine.yield(100)   -- 'a' is still local to this thread
+  end
+
+  local t = setmetatable({}, {__mode = "kv"})
+  collectgarbage(); collectgarbage('stop')
+  -- create coroutine in a weak table, so it will never be marked
+  t.co = coroutine.wrap(foo)
+  local f = t.co()   -- create function to access local 'a'
+  T.gcstate("atomic")   -- ensure all objects are traversed
+  assert(T.gcstate() == "atomic")
+  assert(t.co() == 100)   -- resume coroutine, creating new table for 'a'
+  assert(T.gccolor(t.co) == "white")  -- thread was not traversed
+  T.gcstate("pause")   -- collect thread, but should mark 'a' before that
+  assert(t.co == nil and f() == 30)   -- ensure correct access to 'a'
+
+  collectgarbage("restart")
+
+  -- test barrier in sweep phase (advance cleaning of upvalue to white)
+  local u = T.newuserdata(0)   -- create a userdata
+  collectgarbage()
+  collectgarbage"stop"
+  T.gcstate"atomic"
+  local x = {}
+  T.gcstate"sweepallgc"
+  assert(T.gccolor(u) == "black")   -- upvalue is "old" (black)
+  assert(T.gccolor(x) == "white")   -- table is "new" (white)
+  debug.setuservalue(u, x)          -- trigger barrier
+  assert(T.gccolor(u) == "white")   -- upvalue changed to white
+  collectgarbage"restart"
+
+  print"+"
+end
+
+
+if T then
+  local debug = require "debug"
+  collectgarbage("stop")
+  local x = T.newuserdata(0)
+  local y = T.newuserdata(0)
+  debug.setmetatable(y, {__gc = true})   -- bless the new udata before...
+  debug.setmetatable(x, {__gc = true})   -- ...the old one
+  assert(T.gccolor(y) == "white")
+  T.checkmemory()
+  collectgarbage("restart")
+end
+
+
+if T then
+  print("emergency collections")
+  collectgarbage()
+  collectgarbage()
+  T.totalmem(T.totalmem() + 200)
+  for i=1,200 do local a = {} end
+  T.totalmem(0)
+  collectgarbage()
+  local t = T.totalmem("table")
+  local a = {{}, {}, {}}   -- create 4 new tables
+  assert(T.totalmem("table") == t + 4)
+  t = T.totalmem("function")
+  a = function () end   -- create 1 new closure
+  assert(T.totalmem("function") == t + 1)
+  t = T.totalmem("thread")
+  a = coroutine.create(function () end)   -- create 1 new coroutine
+  assert(T.totalmem("thread") == t + 1)
+end
+
+-- create an object to be collected when state is closed
+do
+  local setmetatable,assert,type,print,getmetatable =
+        setmetatable,assert,type,print,getmetatable
+  local tt = {}
+  tt.__gc = function (o)
+    assert(getmetatable(o) == tt)
+    -- create new objects during GC
+    local a = 'xuxu'..(10+3)..'joao', {}
+    ___Glob = o  -- ressurect object!
+    setmetatable({}, tt)  -- creates a new one with same metatable
+    print(">>> closing state " .. "<<<\n")
+  end
+  local u = setmetatable({}, tt)
+  ___Glob = {u}   -- avoid object being collected before program end
+end
+
+-- create several objects to raise errors when collected while closing state
+do
+  local mt = {__gc = function (o) return o + 1 end}
+  for i = 1,10 do
+    -- create object and preserve it until the end
+    table.insert(___Glob, setmetatable({}, mt))
+  end
+end
+
+-- just to make sure
+assert(collectgarbage'isrunning')
+
+print('OK')
diff -urN rpm-5.4.15/lua/tests/goto.lua rpm-5.4-cvs/lua/tests/goto.lua
--- rpm-5.4.15/lua/tests/goto.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/goto.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,217 @@
+-- $Id: goto.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+collectgarbage()
+
+local function errmsg (code, m)
+  local st, msg = load(code)
+  assert(not st and string.find(msg, m))
+end
+
+-- cannot see label inside block
+errmsg([[ goto l1; do ::l1:: end ]], "label 'l1'")
+errmsg([[ do ::l1:: end goto l1; ]], "label 'l1'")
+
+-- repeated label
+errmsg([[ ::l1:: ::l1:: ]], "label 'l1'")
+
+
+-- undefined label
+errmsg([[ goto l1; local aa ::l1:: ::l2:: print(3) ]], "local 'aa'")
+
+-- jumping over variable definition
+errmsg([[
+do local bb, cc; goto l1; end
+local aa
+::l1:: print(3)
+]], "local 'aa'")
+
+-- jumping into a block
+errmsg([[ do ::l1:: end goto l1 ]], "label 'l1'")
+errmsg([[ goto l1 do ::l1:: end ]], "label 'l1'")
+
+-- cannot continue a repeat-until with variables
+errmsg([[
+  repeat
+    if x then goto cont end
+    local xuxu = 10
+    ::cont::
+  until xuxu < x
+]], "local 'xuxu'")
+
+-- simple gotos
+local x
+do
+  local y = 12
+  goto l1
+  ::l2:: x = x + 1; goto l3
+  ::l1:: x = y; goto l2
+end
+::l3:: ::l3_1:: assert(x == 13)
+
+
+-- long labels
+do
+  local prog = [[
+  do
+    local a = 1
+    goto l%sa; a = a + 1
+   ::l%sa:: a = a + 10
+    goto l%sb; a = a + 2
+   ::l%sb:: a = a + 20
+    return a
+  end
+  ]]
+  local label = string.rep("0123456789", 40)
+  prog = string.format(prog, label, label, label, label)
+  assert(assert(load(prog))() == 31)
+end
+
+-- goto to correct label when nested
+do goto l3; ::l3:: end   -- does not loop jumping to previous label 'l3'
+
+-- ok to jump over local dec. to end of block
+do
+  goto l1
+  local a = 23
+  x = a
+  ::l1::;
+end
+
+while true do
+  goto l4
+  goto l1  -- ok to jump over local dec. to end of block
+  goto l1  -- multiple uses of same label
+  local x = 45
+  ::l1:: ;;;
+end
+::l4:: assert(x == 13)
+
+if print then
+  goto l1   -- ok to jump over local dec. to end of block
+  error("should not be here")
+  goto l2   -- ok to jump over local dec. to end of block
+  local x
+  ::l1:: ; ::l2:: ;;
+else end
+
+-- to repeat a label in a different function is OK
+local function foo ()
+  local a = {}
+  goto l3
+  ::l1:: a[#a + 1] = 1; goto l2;
+  ::l2:: a[#a + 1] = 2; goto l5;
+  ::l3::
+  ::l3a:: a[#a + 1] = 3; goto l1;
+  ::l4:: a[#a + 1] = 4; goto l6;
+  ::l5:: a[#a + 1] = 5; goto l4;
+  ::l6:: assert(a[1] == 3 and a[2] == 1 and a[3] == 2 and
+              a[4] == 5 and a[5] == 4)
+  if not a[6] then a[6] = true; goto l3a end   -- do it twice
+end
+
+::l6:: foo()
+
+
+
+--------------------------------------------------------------------------------
+-- testing closing of upvalues
+
+local debug = require 'debug'
+
+local function foo ()
+  local t = {}
+  do
+  local i = 1
+  local a, b, c, d
+  t[1] = function () return a, b, c, d end
+  ::l1::
+  local b
+  do
+    local c
+    t[#t + 1] = function () return a, b, c, d end    -- t[2], t[4], t[6]
+    if i > 2 then goto l2 end
+    do
+      local d
+      t[#t + 1] = function () return a, b, c, d end   -- t[3], t[5]
+      i = i + 1
+      local a
+      goto l1
+    end
+  end
+  end
+  ::l2:: return t
+end
+
+local a = foo()
+assert(#a == 6)
+
+-- all functions share same 'a'
+for i = 2, 6 do
+  assert(debug.upvalueid(a[1], 1) == debug.upvalueid(a[i], 1))
+end
+
+-- 'b' and 'c' are shared among some of them
+for i = 2, 6 do
+  -- only a[1] uses external 'b'/'b'
+  assert(debug.upvalueid(a[1], 2) ~= debug.upvalueid(a[i], 2))
+  assert(debug.upvalueid(a[1], 3) ~= debug.upvalueid(a[i], 3))
+end
+
+for i = 3, 5, 2 do
+  -- inner functions share 'b'/'c' with previous ones
+  assert(debug.upvalueid(a[i], 2) == debug.upvalueid(a[i - 1], 2))
+  assert(debug.upvalueid(a[i], 3) == debug.upvalueid(a[i - 1], 3))
+  -- but not with next ones
+  assert(debug.upvalueid(a[i], 2) ~= debug.upvalueid(a[i + 1], 2))
+  assert(debug.upvalueid(a[i], 3) ~= debug.upvalueid(a[i + 1], 3))
+end
+
+-- only external 'd' is shared
+for i = 2, 6, 2 do
+  assert(debug.upvalueid(a[1], 4) == debug.upvalueid(a[i], 4))
+end
+
+-- internal 'd's are all different
+for i = 3, 5, 2 do
+  for j = 1, 6 do
+    assert((debug.upvalueid(a[i], 4) == debug.upvalueid(a[j], 4))
+      == (i == j))
+  end
+end
+
+--------------------------------------------------------------------------------
+-- testing if x goto optimizations
+
+local function testG (a)
+  if a == 1 then
+    goto l1
+    error("should never be here!")
+  elseif a == 2 then goto l2
+  elseif a == 3 then goto l3
+  elseif a == 4 then
+    goto l1  -- go to inside the block
+    error("should never be here!")
+    ::l1:: a = a + 1   -- must go to 'if' end
+  else
+    goto l4
+    ::l4a:: a = a * 2; goto l4b
+    error("should never be here!")
+    ::l4:: goto l4a
+    error("should never be here!")
+    ::l4b::
+  end
+  do return a end
+  ::l2:: do return "2" end
+  ::l3:: do return "3" end
+  ::l1:: return "1"
+end
+
+assert(testG(1) == "1")
+assert(testG(2) == "2")
+assert(testG(3) == "3")
+assert(testG(4) == 5)
+assert(testG(5) == 10)
+--------------------------------------------------------------------------------
+
+
+print'OK'
diff -urN rpm-5.4.15/lua/tests/libs/lib11.c rpm-5.4-cvs/lua/tests/libs/lib11.c
--- rpm-5.4.15/lua/tests/libs/lib11.c	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/libs/lib11.c	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,10 @@
+#include "lua.h"
+
+/* function from lib1.c */
+int lib1_export (lua_State *L);
+
+LUAMOD_API int luaopen_lib11 (lua_State *L) {
+  return lib1_export(L);
+}
+
+
diff -urN rpm-5.4.15/lua/tests/libs/lib1.c rpm-5.4-cvs/lua/tests/libs/lib1.c
--- rpm-5.4.15/lua/tests/libs/lib1.c	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/libs/lib1.c	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,44 @@
+#include "lua.h"
+#include "lauxlib.h"
+
+static int id (lua_State *L) {
+  return lua_gettop(L);
+}
+
+
+static const struct luaL_Reg funcs[] = {
+  {"id", id},
+  {NULL, NULL}
+};
+
+
+/* function used by lib11.c */
+LUAMOD_API int lib1_export (lua_State *L) {
+  lua_pushstring(L, "exported");
+  return 1;
+}
+
+
+LUAMOD_API int onefunction (lua_State *L) {
+  luaL_checkversion(L);
+  lua_settop(L, 2);
+  lua_pushvalue(L, 1);
+  return 2;
+}
+
+
+LUAMOD_API int anotherfunc (lua_State *L) {
+  luaL_checkversion(L);
+  lua_pushfstring(L, "%d%%%d\n", (int)lua_tointeger(L, 1),
+                                 (int)lua_tointeger(L, 2));
+  return 1;
+} 
+
+
+LUAMOD_API int luaopen_lib1_sub (lua_State *L) {
+  lua_setglobal(L, "y");  /* 2nd arg: extra value (file name) */
+  lua_setglobal(L, "x");  /* 1st arg: module name */
+  luaL_newlib(L, funcs);
+  return 1;
+}
+
diff -urN rpm-5.4.15/lua/tests/libs/lib21.c rpm-5.4-cvs/lua/tests/libs/lib21.c
--- rpm-5.4.15/lua/tests/libs/lib21.c	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/libs/lib21.c	2015-04-19 13:25:00.000000000 -0500
@@ -0,0 +1,10 @@
+#include "lua.h"
+
+
+int luaopen_lib2 (lua_State *L);
+
+LUAMOD_API int luaopen_lib21 (lua_State *L) {
+  return luaopen_lib2(L);
+}
+
+
diff -urN rpm-5.4.15/lua/tests/libs/lib2.c rpm-5.4-cvs/lua/tests/libs/lib2.c
--- rpm-5.4.15/lua/tests/libs/lib2.c	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/libs/lib2.c	2015-04-19 13:25:00.000000000 -0500
@@ -0,0 +1,23 @@
+#include "lua.h"
+#include "lauxlib.h"
+
+static int id (lua_State *L) {
+  return lua_gettop(L);
+}
+
+
+static const struct luaL_Reg funcs[] = {
+  {"id", id},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_lib2 (lua_State *L) {
+  lua_settop(L, 2);
+  lua_setglobal(L, "y");  /* y gets 2nd parameter */
+  lua_setglobal(L, "x");  /* x gets 1st parameter */
+  luaL_newlib(L, funcs);
+  return 1;
+}
+
+
diff -urN rpm-5.4.15/lua/tests/libs/Makefile.am rpm-5.4-cvs/lua/tests/libs/Makefile.am
--- rpm-5.4.15/lua/tests/libs/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/libs/Makefile.am	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,43 @@
+
+AUTOMAKE_OPTIONS = 1.4 foreign
+
+EXTRA_DIST = \
+	lib11.c \
+	lib1.c \
+	lib21.c \
+	lib2.c \
+	P1
+
+#
+# change this variable to point to the directory with Lua headers
+# of the version being tested
+LUA_DIR = ../..
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/lua
+
+CC = gcc
+
+# compilation should generate Dynamic-Link Libraries
+CFLAGS = -Wall -std=gnu99 -O2 $(AM_CPPFLAGS) -fpic -shared
+
+# libraries used by the tests
+all: lib1.so lib11.so lib2.so lib21.so lib2-v2.so
+
+clean:
+	rm -f lib1.so lib11.so lib2.so lib21.so lib2-v2.so
+
+lib1.so: lib1.c
+	$(CC) $(CFLAGS) -o lib1.so lib1.c
+
+lib11.so: lib11.c
+	$(CC) $(CFLAGS) -o lib11.so lib11.c
+
+lib2.so: lib2.c
+	$(CC) $(CFLAGS) -o lib2.so lib2.c
+
+lib21.so: lib21.c
+	$(CC) $(CFLAGS) -o lib21.so lib21.c
+
+lib2-v2.so: lib2.so
+	mv lib2.so ./lib2-v2.so
diff -urN rpm-5.4.15/lua/tests/literals.lua rpm-5.4-cvs/lua/tests/literals.lua
--- rpm-5.4.15/lua/tests/literals.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/literals.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,291 @@
+-- $Id: literals.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print('testing scanner')
+
+local debug = require "debug"
+
+
+local function dostring (x) return assert(load(x))() end
+
+dostring("x \v\f = \t\r 'a\0a' \v\f\f")
+assert(x == 'a\0a' and string.len(x) == 3)
+
+-- escape sequences
+assert('\n\"\'\\' == [[
+
+"'\]])
+
+assert(string.find("\a\b\f\n\r\t\v", "^%c%c%c%c%c%c%c$"))
+
+-- assume ASCII just for tests:
+assert("\09912" == 'c12')
+assert("\99ab" == 'cab')
+assert("\099" == '\99')
+assert("\099\n" == 'c\10')
+assert('\0\0\0alo' == '\0' .. '\0\0' .. 'alo')
+
+assert(010 .. 020 .. -030 == "1020-30")
+
+-- hexadecimal escapes
+assert("\x00\x05\x10\x1f\x3C\xfF\xe8" == "\0\5\16\31\60\255\232")
+
+local function lexstring (x, y, n)
+  local f = assert(load('return ' .. x ..
+            ', require"debug".getinfo(1).currentline'))
+  local s, l = f()
+  assert(s == y and l == n)
+end
+
+lexstring("'abc\\z  \n   efg'", "abcefg", 2)
+lexstring("'abc\\z  \n\n\n'", "abc", 4)
+lexstring("'\\z  \n\t\f\v\n'",  "", 3)
+lexstring("[[\nalo\nalo\n\n]]", "alo\nalo\n\n", 5)
+lexstring("[[\nalo\ralo\n\n]]", "alo\nalo\n\n", 5)
+lexstring("[[\nalo\ralo\r\n]]", "alo\nalo\n", 4)
+lexstring("[[\ralo\n\ralo\r\n]]", "alo\nalo\n", 4)
+lexstring("[[alo]\n]alo]]", "alo]\n]alo", 2)
+
+assert("abc\z
+        def\z
+        ghi\z
+       " == 'abcdefghi')
+
+
+-- UTF-8 sequences
+assert("\u{0}\u{00000000}\x00\0" == string.char(0, 0, 0, 0))
+
+-- limits for 1-byte sequences
+assert("\u{0}\u{7F}" == "\x00\z\x7F")
+
+-- limits for 2-byte sequences
+assert("\u{80}\u{7FF}" == "\xC2\x80\z\xDF\xBF")
+
+-- limits for 3-byte sequences
+assert("\u{800}\u{FFFF}" ==   "\xE0\xA0\x80\z\xEF\xBF\xBF")
+
+-- limits for 4-byte sequences
+assert("\u{10000}\u{10FFFF}" == "\xF0\x90\x80\x80\z\xF4\x8F\xBF\xBF")
+
+
+-- Error in escape sequences
+local function lexerror (s, err)
+  local st, msg = load('return ' .. s)
+  if err ~= '<eof>' then err = err .. "'" end
+  assert(not st and string.find(msg, "near .-" .. err))
+end
+
+lexerror([["abc\x"]], [[\x"]])
+lexerror([["abc\x]], [[\x]])
+lexerror([["\x]], [[\x]])
+lexerror([["\x5"]], [[\x5"]])
+lexerror([["\x5]], [[\x5]])
+lexerror([["\xr"]], [[\xr]])
+lexerror([["\xr]], [[\xr]])
+lexerror([["\x.]], [[\x.]])
+lexerror([["\x8%"]], [[\x8%%]])
+lexerror([["\xAG]], [[\xAG]])
+lexerror([["\g"]], [[\g]])
+lexerror([["\g]], [[\g]])
+lexerror([["\."]], [[\%.]])
+
+lexerror([["\999"]], [[\999"]])
+lexerror([["xyz\300"]], [[\300"]])
+lexerror([["   \256"]], [[\256"]])
+
+-- errors in UTF-8 sequences
+lexerror([["abc\u{110000}"]], [[abc\u{110000]])   -- too large
+lexerror([["abc\u11r"]], [[abc\u1]])    -- missing '{'
+lexerror([["abc\u"]], [[abc\u"]])    -- missing '{'
+lexerror([["abc\u{11r"]], [[abc\u{11r]])    -- missing '}'
+lexerror([["abc\u{11"]], [[abc\u{11"]])    -- missing '}'
+lexerror([["abc\u{11]], [[abc\u{11]])    -- missing '}'
+lexerror([["abc\u{r"]], [[abc\u{r]])     -- no digits
+
+-- unfinished strings
+lexerror("[=[alo]]", "<eof>")
+lexerror("[=[alo]=", "<eof>")
+lexerror("[=[alo]", "<eof>")
+lexerror("'alo", "<eof>")
+lexerror("'alo \\z  \n\n", "<eof>")
+lexerror("'alo \\z", "<eof>")
+lexerror([['alo \98]], "<eof>")
+
+-- valid characters in variable names
+for i = 0, 255 do
+  local s = string.char(i)
+  assert(not string.find(s, "[a-zA-Z_]") == not load(s .. "=1"))
+  assert(not string.find(s, "[a-zA-Z_0-9]") ==
+         not load("a" .. s .. "1 = 1"))
+end
+
+
+-- long variable names
+
+var1 = string.rep('a', 15000) .. '1'
+var2 = string.rep('a', 15000) .. '2'
+prog = string.format([[
+  %s = 5
+  %s = %s + 1
+  return function () return %s - %s end
+]], var1, var2, var1, var1, var2)
+local f = dostring(prog)
+assert(_G[var1] == 5 and _G[var2] == 6 and f() == -1)
+var1, var2, f = nil
+print('+')
+
+-- escapes --
+assert("\n\t" == [[
+
+	]])
+assert([[
+
+ $debug]] == "\n $debug")
+assert([[ [ ]] ~= [[ ] ]])
+-- long strings --
+b = "001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789"
+assert(string.len(b) == 960)
+prog = [=[
+print('+')
+
+a1 = [["this is a 'string' with several 'quotes'"]]
+a2 = "'quotes'"
+
+assert(string.find(a1, a2) == 34)
+print('+')
+
+a1 = [==[temp = [[an arbitrary value]]; ]==]
+assert(load(a1))()
+assert(temp == 'an arbitrary value')
+-- long strings --
+b = "001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789"
+assert(string.len(b) == 960)
+print('+')
+
+a = [[00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+00123456789012345678901234567890123456789123456789012345678901234567890123456789
+]]
+assert(string.len(a) == 1863)
+assert(string.sub(a, 1, 40) == string.sub(b, 1, 40))
+x = 1
+]=]
+
+print('+')
+x = nil
+dostring(prog)
+assert(x)
+
+prog = nil
+a = nil
+b = nil
+
+
+-- testing line ends
+prog = [[
+a = 1        -- a comment
+b = 2
+
+
+x = [=[
+hi
+]=]
+y = "\
+hello\r\n\
+"
+return require"debug".getinfo(1).currentline
+]]
+
+for _, n in pairs{"\n", "\r", "\n\r", "\r\n"} do
+  local prog, nn = string.gsub(prog, "\n", n)
+  assert(dostring(prog) == nn)
+  assert(_G.x == "hi\n" and _G.y == "\nhello\r\n\n")
+end
+
+
+-- testing comments and strings with long brackets
+a = [==[]=]==]
+assert(a == "]=")
+
+a = [==[[===[[=[]]=][====[]]===]===]==]
+assert(a == "[===[[=[]]=][====[]]===]===")
+
+a = [====[[===[[=[]]=][====[]]===]===]====]
+assert(a == "[===[[=[]]=][====[]]===]===")
+
+a = [=[]]]]]]]]]=]
+assert(a == "]]]]]]]]")
+
+
+--[===[
+x y z [==[ blu foo
+]==
+]
+]=]==]
+error error]=]===]
+
+-- generate all strings of four of these chars
+local x = {"=", "[", "]", "\n"}
+local len = 4
+local function gen (c, n)
+  if n==0 then coroutine.yield(c)
+  else
+    for _, a in pairs(x) do
+      gen(c..a, n-1)
+    end
+  end
+end
+
+for s in coroutine.wrap(function () gen("", len) end) do
+  assert(s == load("return [====[\n"..s.."]====]")())
+end
+
+
+-- testing decimal point locale
+if os.setlocale("pt_BR") or os.setlocale("ptb") then
+  assert(not load("a = (3,4)"))
+  assert(tonumber("3,4") == 3.4 and tonumber"3.4" == nil)
+  assert(assert(load("return 3.4"))() == 3.4)
+  assert(assert(load("return .4,3"))() == .4)
+  assert(assert(load("return 4."))() == 4.)
+  assert(assert(load("return 4.+.5"))() == 4.5)
+  local a,b = load("return 4.5.")
+  assert(string.find(b, "'4%.5%.'"))
+  assert(os.setlocale("C"))
+else
+  (Message or print)(
+   '\n >>> pt_BR locale not available: skipping decimal point tests <<<\n')
+end
+
+
+-- testing %q x line ends
+local s = "a string with \r and \n and \r\n and \n\r"
+local c = string.format("return %q", s)
+assert(assert(load(c))() == s)
+
+-- testing errors
+assert(not load"a = 'non-ending string")
+assert(not load"a = 'non-ending string\n'")
+assert(not load"a = '\\345'")
+assert(not load"a = [=x]")
+
+print('OK')
diff -urN rpm-5.4.15/lua/tests/locals.lua rpm-5.4-cvs/lua/tests/locals.lua
--- rpm-5.4.15/lua/tests/locals.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/locals.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,161 @@
+-- $Id: locals.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print('testing local variables and environments')
+
+local debug = require"debug"
+
+
+-- bug in 5.1:
+
+local function f(x) x = nil; return x end
+assert(f(10) == nil)
+
+local function f() local x; return x end
+assert(f(10) == nil)
+
+local function f(x) x = nil; local y; return x, y end
+assert(f(10) == nil and select(2, f(20)) == nil)
+
+do
+  local i = 10
+  do local i = 100; assert(i==100) end
+  do local i = 1000; assert(i==1000) end
+  assert(i == 10)
+  if i ~= 10 then
+    local i = 20
+  else
+    local i = 30
+    assert(i == 30)
+  end
+end
+
+
+
+f = nil
+
+local f
+x = 1
+
+a = nil
+load('local a = {}')()
+assert(a == nil)
+
+function f (a)
+  local _1, _2, _3, _4, _5
+  local _6, _7, _8, _9, _10
+  local x = 3
+  local b = a
+  local c,d = a,b
+  if (d == b) then
+    local x = 'q'
+    x = b
+    assert(x == 2)
+  else
+    assert(nil)
+  end
+  assert(x == 3)
+  local f = 10
+end
+
+local b=10
+local a; repeat local b; a,b=1,2; assert(a+1==b); until a+b==3
+
+
+assert(x == 1)
+
+f(2)
+assert(type(f) == 'function')
+
+
+local function getenv (f)
+  local a,b = debug.getupvalue(f, 1)
+  assert(a == '_ENV')
+  return b
+end
+
+-- test for global table of loaded chunks
+assert(getenv(load"a=3") == _G)
+local c = {}; local f = load("a = 3", nil, nil, c)
+assert(getenv(f) == c)
+assert(c.a == nil)
+f()
+assert(c.a == 3)
+
+-- old test for limits for special instructions (now just a generic test)
+do
+  local i = 2
+  local p = 4    -- p == 2^i
+  repeat
+    for j=-3,3 do
+      assert(load(string.format([[local a=%s;
+                                        a=a+%s;
+                                        assert(a ==2^%s)]], j, p-j, i))) ()
+      assert(load(string.format([[local a=%s;
+                                        a=a-%s;
+                                        assert(a==-2^%s)]], -j, p-j, i))) ()
+      assert(load(string.format([[local a,b=0,%s;
+                                        a=b-%s;
+                                        assert(a==-2^%s)]], -j, p-j, i))) ()
+    end
+    p = 2 * p;  i = i + 1
+  until p <= 0
+end
+
+print'+'
+
+
+if rawget(_G, "querytab") then
+  -- testing clearing of dead elements from tables
+  collectgarbage("stop")   -- stop GC
+  local a = {[{}] = 4, [3] = 0, alo = 1, 
+             a1234567890123456789012345678901234567890 = 10}
+
+  local t = querytab(a)
+
+  for k,_ in pairs(a) do a[k] = nil end
+  collectgarbage()   -- restore GC and collect dead fiels in `a'
+  for i=0,t-1 do
+    local k = querytab(a, i)
+    assert(k == nil or type(k) == 'number' or k == 'alo')
+  end
+end
+
+
+-- testing lexical environments
+
+assert(_ENV == _G)
+
+do
+local dummy
+local _ENV = (function (...) return ... end)(_G, dummy)   -- {
+
+do local _ENV = {assert=assert}; assert(true) end
+mt = {_G = _G}
+local foo,x
+A = false    -- "declare" A
+do local _ENV = mt
+  function foo (x)
+    A = x
+    do local _ENV =  _G; A = 1000 end
+    return function (x) return A .. x end
+  end
+end
+assert(getenv(foo) == mt)
+x = foo('hi'); assert(mt.A == 'hi' and A == 1000)
+assert(x('*') == mt.A .. '*')
+
+do local _ENV = {assert=assert, A=10};
+  do local _ENV = {assert=assert, A=20};
+    assert(A==20);x=A
+  end
+  assert(A==10 and x==20)
+end
+assert(x==20)
+
+
+print('OK')
+
+return 5,f
+
+end   -- }
+
diff -urN rpm-5.4.15/lua/tests/ltests/ltests.c rpm-5.4-cvs/lua/tests/ltests/ltests.c
--- rpm-5.4.15/lua/tests/ltests/ltests.c	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/ltests/ltests.c	2015-04-19 13:25:00.000000000 -0500
@@ -0,0 +1,1557 @@
+/*
+** $Id: ltests.c,v 1.1.2.1 2015/04/19 18:25:00 jbj Exp $
+** Internal Module for Debugging of the Lua Implementation
+** See Copyright Notice in lua.h
+*/
+
+#define ltests_c
+#define LUA_CORE
+
+#include "lprefix.h"
+
+
+#include <limits.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lauxlib.h"
+#include "lcode.h"
+#include "lctype.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lualib.h"
+
+
+
+/*
+** The whole module only makes sense with LUA_DEBUG on
+*/
+#if defined(LUA_DEBUG)
+
+
+void *l_Trick = 0;
+
+
+int islocked = 0;
+
+
+#define obj_at(L,k)	(L->ci->func + (k))
+
+
+static int runC (lua_State *L, lua_State *L1, const char *pc);
+
+
+static void setnameval (lua_State *L, const char *name, int val) {
+  lua_pushstring(L, name);
+  lua_pushinteger(L, val);
+  lua_settable(L, -3);
+}
+
+
+static void pushobject (lua_State *L, const TValue *o) {
+  setobj2s(L, L->top, o);
+  api_incr_top(L);
+}
+
+
+static int tpanic (lua_State *L) {
+  fprintf(stderr, "PANIC: unprotected error in call to Lua API (%s)\n",
+                   lua_tostring(L, -1));
+  return (exit(EXIT_FAILURE), 0);  /* do not return to Lua */
+}
+
+
+/*
+** {======================================================================
+** Controlled version for realloc.
+** =======================================================================
+*/
+
+#define MARK		0x55  /* 01010101 (a nice pattern) */
+
+typedef union Header {
+  L_Umaxalign a;  /* ensures maximum alignment for Header */
+  struct {
+    size_t size;
+    int type;
+  } d;
+} Header;
+
+
+#if !defined(EXTERNMEMCHECK)
+
+/* full memory check */
+#define MARKSIZE	16  /* size of marks after each block */
+#define fillmem(mem,size)	memset(mem, -MARK, size)
+
+#else
+
+/* external memory check: don't do it twice */
+#define MARKSIZE	0
+#define fillmem(mem,size)	/* empty */
+
+#endif
+
+
+Memcontrol l_memcontrol =
+  {0L, 0L, 0L, 0L, {0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L}};
+
+
+static void freeblock (Memcontrol *mc, Header *block) {
+  if (block) {
+    size_t size = block->d.size;
+    int i;
+    for (i = 0; i < MARKSIZE; i++)  /* check marks after block */
+      lua_assert(*(cast(char *, block + 1) + size + i) == MARK);
+    mc->objcount[block->d.type]--;
+    fillmem(block, sizeof(Header) + size + MARKSIZE);  /* erase block */
+    free(block);  /* actually free block */
+    mc->numblocks--;  /* update counts */
+    mc->total -= size;
+  }
+}
+
+
+void *debug_realloc (void *ud, void *b, size_t oldsize, size_t size) {
+  Memcontrol *mc = cast(Memcontrol *, ud);
+  Header *block = cast(Header *, b);
+  int type;
+  if (mc->memlimit == 0) {  /* first time? */
+    char *limit = getenv("MEMLIMIT");  /* initialize memory limit */
+    mc->memlimit = limit ? strtoul(limit, NULL, 10) : ULONG_MAX;
+  }
+  if (block == NULL) {
+    type = (oldsize < LUA_NUMTAGS) ? oldsize : 0;
+    oldsize = 0;
+  }
+  else {
+    block--;  /* go to real header */
+    type = block->d.type;
+    lua_assert(oldsize == block->d.size);
+  }
+  if (size == 0) {
+    freeblock(mc, block);
+    return NULL;
+  }
+  else if (size > oldsize && mc->total+size-oldsize > mc->memlimit)
+    return NULL;  /* fake a memory allocation error */
+  else {
+    Header *newblock;
+    int i;
+    size_t commonsize = (oldsize < size) ? oldsize : size;
+    size_t realsize = sizeof(Header) + size + MARKSIZE;
+    if (realsize < size) return NULL;  /* arithmetic overflow! */
+    newblock = cast(Header *, malloc(realsize));  /* alloc a new block */
+    if (newblock == NULL) return NULL;  /* really out of memory? */
+    if (block) {
+      memcpy(newblock + 1, block + 1, commonsize);  /* copy old contents */
+      freeblock(mc, block);  /* erase (and check) old copy */
+    }
+    /* initialize new part of the block with something weird */
+    fillmem(cast(char *, newblock + 1) + commonsize, size - commonsize);
+    /* initialize marks after block */
+    for (i = 0; i < MARKSIZE; i++)
+      *(cast(char *, newblock + 1) + size + i) = MARK;
+    newblock->d.size = size;
+    newblock->d.type = type;
+    mc->total += size;
+    if (mc->total > mc->maxmem)
+      mc->maxmem = mc->total;
+    mc->numblocks++;
+    mc->objcount[type]++;
+    return newblock + 1;
+  }
+}
+
+
+/* }====================================================================== */
+
+
+
+/*
+** {======================================================
+** Functions to check memory consistency
+** =======================================================
+*/
+
+
+static int testobjref1 (global_State *g, GCObject *f, GCObject *t) {
+  if (isdead(g,t)) return 0;
+  if (!issweepphase(g))
+    return !(isblack(f) && iswhite(t));
+  else return 1;
+}
+
+
+static void printobj (global_State *g, GCObject *o) {
+  printf("||%s(%p)-%c(%02X)||",
+           ttypename(novariant(o->tt)), (void *)o,
+           isdead(g,o)?'d':isblack(o)?'b':iswhite(o)?'w':'g', o->marked);
+}
+
+
+static int testobjref (global_State *g, GCObject *f, GCObject *t) {
+  int r1 = testobjref1(g, f, t);
+  if (!r1) {
+    printf("%d(%02X) - ", g->gcstate, g->currentwhite);
+    printobj(g, f);
+    printf("  ->  ");
+    printobj(g, t);
+    printf("\n");
+  }
+  return r1;
+}
+
+#define checkobjref(g,f,t)  \
+	{ if (t) lua_longassert(testobjref(g,f,obj2gco(t))); }
+
+
+static void checkvalref (global_State *g, GCObject *f, const TValue *t) {
+  lua_assert(!iscollectable(t) ||
+    (righttt(t) && testobjref(g, f, gcvalue(t))));
+}
+
+
+static void checktable (global_State *g, Table *h) {
+  unsigned int i;
+  Node *n, *limit = gnode(h, sizenode(h));
+  GCObject *hgc = obj2gco(h);
+  checkobjref(g, hgc, h->metatable);
+  for (i = 0; i < h->sizearray; i++)
+    checkvalref(g, hgc, &h->array[i]);
+  for (n = gnode(h, 0); n < limit; n++) {
+    if (!ttisnil(gval(n))) {
+      lua_assert(!ttisnil(gkey(n)));
+      checkvalref(g, hgc, gkey(n));
+      checkvalref(g, hgc, gval(n));
+    }
+  }
+}
+
+
+/*
+** All marks are conditional because a GC may happen while the
+** prototype is still being created
+*/
+static void checkproto (global_State *g, Proto *f) {
+  int i;
+  GCObject *fgc = obj2gco(f);
+  checkobjref(g, fgc, f->cache);
+  checkobjref(g, fgc, f->source);
+  for (i=0; i<f->sizek; i++) {
+    if (ttisstring(f->k + i))
+      checkobjref(g, fgc, tsvalue(f->k + i));
+  }
+  for (i=0; i<f->sizeupvalues; i++)
+    checkobjref(g, fgc, f->upvalues[i].name);
+  for (i=0; i<f->sizep; i++)
+    checkobjref(g, fgc, f->p[i]);
+  for (i=0; i<f->sizelocvars; i++)
+    checkobjref(g, fgc, f->locvars[i].varname);
+}
+
+
+
+static void checkCclosure (global_State *g, CClosure *cl) {
+  GCObject *clgc = obj2gco(cl);
+  int i;
+  for (i = 0; i < cl->nupvalues; i++)
+    checkvalref(g, clgc, &cl->upvalue[i]);
+}
+
+
+static void checkLclosure (global_State *g, LClosure *cl) {
+  GCObject *clgc = obj2gco(cl);
+  int i;
+  checkobjref(g, clgc, cl->p);
+  for (i=0; i<cl->nupvalues; i++) {
+    UpVal *uv = cl->upvals[i];
+    if (uv) {
+      if (!upisopen(uv))  /* only closed upvalues matter to invariant */
+        checkvalref(g, clgc, uv->v);
+      lua_assert(uv->refcount > 0);
+    }
+  }
+}
+
+
+static int lua_checkpc (lua_State *L, CallInfo *ci) {
+  if (!isLua(ci)) return 1;
+  else {
+    Proto *p;
+    if (L->status != LUA_YIELD || ci != L->ci)
+      p = ci_func(ci)->p;
+    else  /* real 'func' was saved in 'extra' field */
+      p = clLvalue(restorestack(L, ci->extra))->p;
+    return p->code <= ci->u.l.savedpc &&
+           ci->u.l.savedpc <= p->code + p->sizecode;
+  }
+}
+
+
+static void checkstack (global_State *g, lua_State *L1) {
+  StkId o;
+  CallInfo *ci;
+  UpVal *uv;
+  lua_assert(!isdead(g, L1));
+  for (uv = L1->openupval; uv != NULL; uv = uv->u.open.next)
+    lua_assert(upisopen(uv));  /* must be open */
+  for (ci = L1->ci; ci != NULL; ci = ci->previous) {
+    lua_assert(ci->top <= L1->stack_last);
+    lua_assert(lua_checkpc(L1, ci));
+  }
+  if (L1->stack) {  /* complete thread? */
+    for (o = L1->stack; o < L1->stack_last + EXTRA_STACK; o++)
+      checkliveness(g, o);  /* entire stack must have valid values */
+  }
+  else lua_assert(L1->stacksize == 0);
+}
+
+
+static void checkobject (global_State *g, GCObject *o, int maybedead) {
+  if (isdead(g, o))
+    lua_assert(maybedead);
+  else {
+    lua_assert(g->gcstate != GCSpause || iswhite(o));
+    switch (o->tt) {
+      case LUA_TUSERDATA: {
+        TValue uservalue;
+        Table *mt = gco2u(o)->metatable;
+        checkobjref(g, o, mt);
+        getuservalue(g->mainthread, gco2u(o), &uservalue);
+        checkvalref(g, o, &uservalue);
+        break;
+      }
+      case LUA_TTABLE: {
+        checktable(g, gco2t(o));
+        break;
+      }
+      case LUA_TTHREAD: {
+        checkstack(g, gco2th(o));
+        break;
+      }
+      case LUA_TLCL: {
+        checkLclosure(g, gco2lcl(o));
+        break;
+      }
+      case LUA_TCCL: {
+        checkCclosure(g, gco2ccl(o));
+        break;
+      }
+      case LUA_TPROTO: {
+        checkproto(g, gco2p(o));
+        break;
+      }
+      case LUA_TSHRSTR:
+      case LUA_TLNGSTR: {
+        lua_assert(!isgray(o));  /* strings are never gray */
+        break;
+      }
+      default: lua_assert(0);
+    }
+  }
+}
+
+
+#define TESTGRAYBIT		7
+
+static void checkgraylist (global_State *g, GCObject *o) {
+  ((void)g);  /* better to keep it available if we need to print an object */
+  while (o) {
+    lua_assert(isgray(o));
+    lua_assert(!testbit(o->marked, TESTGRAYBIT));
+    l_setbit(o->marked, TESTGRAYBIT);
+    switch (o->tt) {
+      case LUA_TTABLE: o = gco2t(o)->gclist; break;
+      case LUA_TLCL: o = gco2lcl(o)->gclist; break;
+      case LUA_TCCL: o = gco2ccl(o)->gclist; break;
+      case LUA_TTHREAD: o = gco2th(o)->gclist; break;
+      case LUA_TPROTO: o = gco2p(o)->gclist; break;
+      default: lua_assert(0);  /* other objects cannot be gray */
+    }
+  }
+}
+
+
+/*
+** mark all objects in gray lists with the TESTGRAYBIT, so that
+** 'checkmemory' can check that all gray objects are in a gray list
+*/
+static void markgrays (global_State *g) {
+  if (!keepinvariant(g)) return;
+  checkgraylist(g, g->gray);
+  checkgraylist(g, g->grayagain);
+  checkgraylist(g, g->weak);
+  checkgraylist(g, g->ephemeron);
+  checkgraylist(g, g->allweak);
+}
+
+
+static void checkgray (global_State *g, GCObject *o) {
+  for (; o != NULL; o = o->next) {
+    if (isgray(o)) {
+      lua_assert(!keepinvariant(g) || testbit(o->marked, TESTGRAYBIT));
+      resetbit(o->marked, TESTGRAYBIT);
+    }
+    lua_assert(!testbit(o->marked, TESTGRAYBIT));
+  }
+}
+
+
+int lua_checkmemory (lua_State *L) {
+  global_State *g = G(L);
+  GCObject *o;
+  int maybedead;
+  if (keepinvariant(g)) {
+    lua_assert(!iswhite(g->mainthread));
+    lua_assert(!iswhite(gcvalue(&g->l_registry)));
+  }
+  lua_assert(!isdead(g, gcvalue(&g->l_registry)));
+  checkstack(g, g->mainthread);
+  resetbit(g->mainthread->marked, TESTGRAYBIT);
+  lua_assert(g->sweepgc == NULL || issweepphase(g));
+  markgrays(g);
+  /* check 'fixedgc' list */
+  for (o = g->fixedgc; o != NULL; o = o->next) {
+    lua_assert(o->tt == LUA_TSHRSTR && isgray(o));
+  }
+  /* check 'allgc' list */
+  checkgray(g, g->allgc);
+  maybedead = (GCSatomic < g->gcstate && g->gcstate <= GCSswpallgc);
+  for (o = g->allgc; o != NULL; o = o->next) {
+    checkobject(g, o, maybedead);
+    lua_assert(!tofinalize(o));
+  }
+  /* check 'finobj' list */
+  checkgray(g, g->finobj);
+  for (o = g->finobj; o != NULL; o = o->next) {
+    checkobject(g, o, 0);
+    lua_assert(tofinalize(o));
+    lua_assert(o->tt == LUA_TUSERDATA || o->tt == LUA_TTABLE);
+  }
+  /* check 'tobefnz' list */
+  checkgray(g, g->tobefnz);
+  for (o = g->tobefnz; o != NULL; o = o->next) {
+    checkobject(g, o, 0);
+    lua_assert(tofinalize(o));
+    lua_assert(o->tt == LUA_TUSERDATA || o->tt == LUA_TTABLE);
+  }
+  return 0;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Disassembler
+** =======================================================
+*/
+
+
+static char *buildop (Proto *p, int pc, char *buff) {
+  Instruction i = p->code[pc];
+  OpCode o = GET_OPCODE(i);
+  const char *name = luaP_opnames[o];
+  int line = getfuncline(p, pc);
+  sprintf(buff, "(%4d) %4d - ", line, pc);
+  switch (getOpMode(o)) {
+    case iABC:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d %4d", name,
+              GETARG_A(i), GETARG_B(i), GETARG_C(i));
+      break;
+    case iABx:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d", name, GETARG_A(i), GETARG_Bx(i));
+      break;
+    case iAsBx:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d", name, GETARG_A(i), GETARG_sBx(i));
+      break;
+    case iAx:
+      sprintf(buff+strlen(buff), "%-12s%4d", name, GETARG_Ax(i));
+      break;
+  }
+  return buff;
+}
+
+
+#if 0
+void luaI_printcode (Proto *pt, int size) {
+  int pc;
+  for (pc=0; pc<size; pc++) {
+    char buff[100];
+    printf("%s\n", buildop(pt, pc, buff));
+  }
+  printf("-------\n");
+}
+
+
+void luaI_printinst (Proto *pt, int pc) {
+  char buff[100];
+  printf("%s\n", buildop(pt, pc, buff));
+}
+#endif
+
+
+static int listcode (lua_State *L) {
+  int pc;
+  Proto *p;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = getproto(obj_at(L, 1));
+  lua_newtable(L);
+  setnameval(L, "maxstack", p->maxstacksize);
+  setnameval(L, "numparams", p->numparams);
+  for (pc=0; pc<p->sizecode; pc++) {
+    char buff[100];
+    lua_pushinteger(L, pc+1);
+    lua_pushstring(L, buildop(p, pc, buff));
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listk (lua_State *L) {
+  Proto *p;
+  int i;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = getproto(obj_at(L, 1));
+  lua_createtable(L, p->sizek, 0);
+  for (i=0; i<p->sizek; i++) {
+    pushobject(L, p->k+i);
+    lua_rawseti(L, -2, i+1);
+  }
+  return 1;
+}
+
+
+static int listlocals (lua_State *L) {
+  Proto *p;
+  int pc = cast_int(luaL_checkinteger(L, 2)) - 1;
+  int i = 0;
+  const char *name;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = getproto(obj_at(L, 1));
+  while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)
+    lua_pushstring(L, name);
+  return i-1;
+}
+
+/* }====================================================== */
+
+
+
+static void printstack (lua_State *L) {
+  int i;
+  int n = lua_gettop(L);
+  for (i = 1; i <= n; i++) {
+    printf("%3d: %s\n", i, luaL_tolstring(L, i, NULL));
+    lua_pop(L, 1);
+  }
+  printf("\n");
+}
+
+
+static int get_limits (lua_State *L) {
+  lua_createtable(L, 0, 5);
+  setnameval(L, "BITS_INT", LUAI_BITSINT);
+  setnameval(L, "MAXARG_Ax", MAXARG_Ax);
+  setnameval(L, "MAXARG_Bx", MAXARG_Bx);
+  setnameval(L, "MAXARG_sBx", MAXARG_sBx);
+  setnameval(L, "BITS_INT", LUAI_BITSINT);
+  setnameval(L, "LFPF", LFIELDS_PER_FLUSH);
+  setnameval(L, "NUM_OPCODES", NUM_OPCODES);
+  return 1;
+}
+
+
+static int mem_query (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushinteger(L, l_memcontrol.total);
+    lua_pushinteger(L, l_memcontrol.numblocks);
+    lua_pushinteger(L, l_memcontrol.maxmem);
+    return 3;
+  }
+  else if (lua_isnumber(L, 1)) {
+    unsigned long limit = cast(unsigned long, luaL_checkinteger(L, 1));
+    if (limit == 0) limit = ULONG_MAX;
+    l_memcontrol.memlimit = limit;
+    return 0;
+  }
+  else {
+    const char *t = luaL_checkstring(L, 1);
+    int i;
+    for (i = LUA_NUMTAGS - 1; i >= 0; i--) {
+      if (strcmp(t, ttypename(i)) == 0) {
+        lua_pushinteger(L, l_memcontrol.objcount[i]);
+        return 1;
+      }
+    }
+    return luaL_error(L, "unkown type '%s'", t);
+  }
+}
+
+
+static int settrick (lua_State *L) {
+  if (ttisnil(obj_at(L, 1)))
+    l_Trick = NULL;
+  else
+    l_Trick = gcvalue(obj_at(L, 1));
+  return 0;
+}
+
+
+static int gc_color (lua_State *L) {
+  TValue *o;
+  luaL_checkany(L, 1);
+  o = obj_at(L, 1);
+  if (!iscollectable(o))
+    lua_pushstring(L, "no collectable");
+  else {
+    GCObject *obj = gcvalue(o);
+    lua_pushstring(L, isdead(G(L), obj) ? "dead" :
+                      iswhite(obj) ? "white" :
+                      isblack(obj) ? "black" : "grey");
+  }
+  return 1;
+}
+
+
+static int gc_state (lua_State *L) {
+  static const char *statenames[] = {"propagate", "atomic", "sweepallgc",
+      "sweepfinobj", "sweeptobefnz", "sweepend", "pause", ""};
+  static const int states[] = {GCSpropagate, GCSatomic, GCSswpallgc,
+      GCSswpfinobj, GCSswptobefnz, GCSswpend, GCSpause, -1};
+  int option = states[luaL_checkoption(L, 1, "", statenames)];
+  if (option == -1) {
+    lua_pushstring(L, statenames[G(L)->gcstate]);
+    return 1;
+  }
+  else {
+    global_State *g = G(L);
+    lua_lock(L);
+    if (option < g->gcstate) {  /* must cross 'pause'? */
+      luaC_runtilstate(L, bitmask(GCSpause));  /* run until pause */
+    }
+    luaC_runtilstate(L, bitmask(option));
+    lua_assert(G(L)->gcstate == option);
+    lua_unlock(L);
+    return 0;
+  }
+}
+
+
+static int hash_query (lua_State *L) {
+  if (lua_isnone(L, 2)) {
+    luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, "string expected");
+    lua_pushinteger(L, tsvalue(obj_at(L, 1))->hash);
+  }
+  else {
+    TValue *o = obj_at(L, 1);
+    Table *t;
+    luaL_checktype(L, 2, LUA_TTABLE);
+    t = hvalue(obj_at(L, 2));
+    lua_pushinteger(L, luaH_mainposition(t, o) - t->node);
+  }
+  return 1;
+}
+
+
+static int stacklevel (lua_State *L) {
+  unsigned long a = 0;
+  lua_pushinteger(L, (L->top - L->stack));
+  lua_pushinteger(L, (L->stack_last - L->stack));
+  lua_pushinteger(L, (unsigned long)&a);
+  return 3;
+}
+
+
+static int table_query (lua_State *L) {
+  const Table *t;
+  int i = cast_int(luaL_optinteger(L, 2, -1));
+  luaL_checktype(L, 1, LUA_TTABLE);
+  t = hvalue(obj_at(L, 1));
+  if (i == -1) {
+    lua_pushinteger(L, t->sizearray);
+    lua_pushinteger(L, luaH_isdummy(t->node) ? 0 : sizenode(t));
+    lua_pushinteger(L, t->lastfree - t->node);
+  }
+  else if ((unsigned int)i < t->sizearray) {
+    lua_pushinteger(L, i);
+    pushobject(L, &t->array[i]);
+    lua_pushnil(L);
+  }
+  else if ((i -= t->sizearray) < sizenode(t)) {
+    if (!ttisnil(gval(gnode(t, i))) ||
+        ttisnil(gkey(gnode(t, i))) ||
+        ttisnumber(gkey(gnode(t, i)))) {
+      pushobject(L, gkey(gnode(t, i)));
+    }
+    else
+      lua_pushliteral(L, "<undef>");
+    pushobject(L, gval(gnode(t, i)));
+    if (gnext(&t->node[i]) != 0)
+      lua_pushinteger(L, gnext(&t->node[i]));
+    else
+      lua_pushnil(L);
+  }
+  return 3;
+}
+
+
+static int string_query (lua_State *L) {
+  stringtable *tb = &G(L)->strt;
+  int s = cast_int(luaL_optinteger(L, 1, 0)) - 1;
+  if (s == -1) {
+    lua_pushinteger(L ,tb->size);
+    lua_pushinteger(L ,tb->nuse);
+    return 2;
+  }
+  else if (s < tb->size) {
+    TString *ts;
+    int n = 0;
+    for (ts = tb->hash[s]; ts != NULL; ts = ts->hnext) {
+      setsvalue2s(L, L->top, ts);
+      api_incr_top(L);
+      n++;
+    }
+    return n;
+  }
+  else return 0;
+}
+
+
+static int tref (lua_State *L) {
+  int level = lua_gettop(L);
+  luaL_checkany(L, 1);
+  lua_pushvalue(L, 1);
+  lua_pushinteger(L, luaL_ref(L, LUA_REGISTRYINDEX));
+  lua_assert(lua_gettop(L) == level+1);  /* +1 for result */
+  return 1;
+}
+
+static int getref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_rawgeti(L, LUA_REGISTRYINDEX, luaL_checkinteger(L, 1));
+  lua_assert(lua_gettop(L) == level+1);
+  return 1;
+}
+
+static int unref (lua_State *L) {
+  int level = lua_gettop(L);
+  luaL_unref(L, LUA_REGISTRYINDEX, cast_int(luaL_checkinteger(L, 1)));
+  lua_assert(lua_gettop(L) == level);
+  return 0;
+}
+
+
+static int upvalue (lua_State *L) {
+  int n = cast_int(luaL_checkinteger(L, 2));
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_isnone(L, 3)) {
+    const char *name = lua_getupvalue(L, 1, n);
+    if (name == NULL) return 0;
+    lua_pushstring(L, name);
+    return 2;
+  }
+  else {
+    const char *name = lua_setupvalue(L, 1, n);
+    lua_pushstring(L, name);
+    return 1;
+  }
+}
+
+
+static int newuserdata (lua_State *L) {
+  size_t size = cast(size_t, luaL_checkinteger(L, 1));
+  char *p = cast(char *, lua_newuserdata(L, size));
+  while (size--) *p++ = '\0';
+  return 1;
+}
+
+
+static int pushuserdata (lua_State *L) {
+  lua_Integer u = luaL_checkinteger(L, 1);
+  lua_pushlightuserdata(L, cast(void *, cast(size_t, u)));
+  return 1;
+}
+
+
+static int udataval (lua_State *L) {
+  lua_pushinteger(L, cast(long, lua_touserdata(L, 1)));
+  return 1;
+}
+
+
+static int doonnewstack (lua_State *L) {
+  lua_State *L1 = lua_newthread(L);
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int status = luaL_loadbuffer(L1, s, l, s);
+  if (status == LUA_OK)
+    status = lua_pcall(L1, 0, 0, 0);
+  lua_pushinteger(L, status);
+  return 1;
+}
+
+
+static int s2d (lua_State *L) {
+  lua_pushnumber(L, *cast(const double *, luaL_checkstring(L, 1)));
+  return 1;
+}
+
+
+static int d2s (lua_State *L) {
+  double d = luaL_checknumber(L, 1);
+  lua_pushlstring(L, cast(char *, &d), sizeof(d));
+  return 1;
+}
+
+
+static int num2int (lua_State *L) {
+  lua_pushinteger(L, lua_tointeger(L, 1));
+  return 1;
+}
+
+
+static int newstate (lua_State *L) {
+  void *ud;
+  lua_Alloc f = lua_getallocf(L, &ud);
+  lua_State *L1 = lua_newstate(f, ud);
+  if (L1) {
+    lua_atpanic(L1, tpanic);
+    lua_pushlightuserdata(L, L1);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+
+static lua_State *getstate (lua_State *L) {
+  lua_State *L1 = cast(lua_State *, lua_touserdata(L, 1));
+  luaL_argcheck(L, L1 != NULL, 1, "state expected");
+  return L1;
+}
+
+
+static int loadlib (lua_State *L) {
+  static const luaL_Reg libs[] = {
+    {"_G", luaopen_base},
+    {"coroutine", luaopen_coroutine},
+    {"debug", luaopen_debug},
+    {"io", luaopen_io},
+    {"os", luaopen_os},
+    {"math", luaopen_math},
+    {"string", luaopen_string},
+    {"table", luaopen_table},
+    {NULL, NULL}
+  };
+  lua_State *L1 = getstate(L);
+  int i;
+  luaL_requiref(L1, "package", luaopen_package, 0);
+  lua_assert(lua_type(L1, -1) == LUA_TTABLE);
+  /* 'requiref' should not reload module already loaded... */
+  luaL_requiref(L1, "package", NULL, 1);  /* seg. fault if it reloads */
+  /* ...but should return the same module */
+  lua_assert(lua_compare(L1, -1, -2, LUA_OPEQ));
+  luaL_getsubtable(L1, LUA_REGISTRYINDEX, "_PRELOAD");
+  for (i = 0; libs[i].name; i++) {
+    lua_pushcfunction(L1, libs[i].func);
+    lua_setfield(L1, -2, libs[i].name);
+  }
+  return 0;
+}
+
+static int closestate (lua_State *L) {
+  lua_State *L1 = getstate(L);
+  lua_close(L1);
+  return 0;
+}
+
+static int doremote (lua_State *L) {
+  lua_State *L1 = getstate(L);
+  size_t lcode;
+  const char *code = luaL_checklstring(L, 2, &lcode);
+  int status;
+  lua_settop(L1, 0);
+  status = luaL_loadbuffer(L1, code, lcode, code);
+  if (status == LUA_OK)
+    status = lua_pcall(L1, 0, LUA_MULTRET, 0);
+  if (status != LUA_OK) {
+    lua_pushnil(L);
+    lua_pushstring(L, lua_tostring(L1, -1));
+    lua_pushinteger(L, status);
+    return 3;
+  }
+  else {
+    int i = 0;
+    while (!lua_isnone(L1, ++i))
+      lua_pushstring(L, lua_tostring(L1, i));
+    lua_pop(L1, i-1);
+    return i-1;
+  }
+}
+
+
+static int int2fb_aux (lua_State *L) {
+  int b = luaO_int2fb((unsigned int)luaL_checkinteger(L, 1));
+  lua_pushinteger(L, b);
+  lua_pushinteger(L, luaO_fb2int(b));
+  return 2;
+}
+
+
+struct Aux { jmp_buf jb; const char *paniccode; lua_State *L; };
+
+/*
+** does a long-jump back to "main program".
+*/
+static int panicback (lua_State *L) {
+  struct Aux *b;
+  lua_checkstack(L, 1);  /* open space for 'Aux' struct */
+  lua_getfield(L, LUA_REGISTRYINDEX, "_jmpbuf");  /* get 'Aux' struct */
+  b = (struct Aux *)lua_touserdata(L, -1);
+  lua_pop(L, 1);  /* remove 'Aux' struct */
+  runC(b->L, L, b->paniccode);  /* run optional panic code */
+  longjmp(b->jb, 1);
+  return 1;  /* to avoid warnings */
+}
+
+static int checkpanic (lua_State *L) {
+  struct Aux b;
+  void *ud;
+  lua_State *L1;
+  const char *code = luaL_checkstring(L, 1);
+  lua_Alloc f = lua_getallocf(L, &ud);
+  b.paniccode = luaL_optstring(L, 2, "");
+  b.L = L;
+  L1 = lua_newstate(f, ud);  /* create new state */
+  if (L1 == NULL) {  /* error? */
+    lua_pushnil(L);
+    return 1;
+  }
+  lua_atpanic(L1, panicback);  /* set its panic function */
+  lua_pushlightuserdata(L1, &b);
+  lua_setfield(L1, LUA_REGISTRYINDEX, "_jmpbuf");  /* store 'Aux' struct */
+  if (setjmp(b.jb) == 0) {  /* set jump buffer */
+    runC(L, L1, code);  /* run code unprotected */
+    lua_pushliteral(L, "no errors");
+  }
+  else {  /* error handling */
+    /* move error message to original state */
+    lua_pushstring(L, lua_tostring(L1, -1));
+  }
+  lua_close(L1);
+  return 1;
+}
+
+
+
+/*
+** {====================================================================
+** function to test the API with C. It interprets a kind of assembler
+** language with calls to the API, so the test can be driven by Lua code
+** =====================================================================
+*/
+
+
+static void sethookaux (lua_State *L, int mask, int count, const char *code);
+
+static const char *const delimits = " \t\n,;";
+
+static void skip (const char **pc) {
+  for (;;) {
+    if (**pc != '\0' && strchr(delimits, **pc)) (*pc)++;
+    else if (**pc == '#') {
+      while (**pc != '\n' && **pc != '\0') (*pc)++;
+    }
+    else break;
+  }
+}
+
+static int getnum_aux (lua_State *L, lua_State *L1, const char **pc) {
+  int res = 0;
+  int sig = 1;
+  skip(pc);
+  if (**pc == '.') {
+    res = cast_int(lua_tointeger(L1, -1));
+    lua_pop(L1, 1);
+    (*pc)++;
+    return res;
+  }
+  else if (**pc == '-') {
+    sig = -1;
+    (*pc)++;
+  }
+  if (!lisdigit(cast_uchar(**pc)))
+    luaL_error(L, "number expected (%s)", *pc);
+  while (lisdigit(cast_uchar(**pc))) res = res*10 + (*(*pc)++) - '0';
+  return sig*res;
+}
+
+static const char *getstring_aux (lua_State *L, char *buff, const char **pc) {
+  int i = 0;
+  skip(pc);
+  if (**pc == '"' || **pc == '\'') {  /* quoted string? */
+    int quote = *(*pc)++;
+    while (**pc != quote) {
+      if (**pc == '\0') luaL_error(L, "unfinished string in C script");
+      buff[i++] = *(*pc)++;
+    }
+    (*pc)++;
+  }
+  else {
+    while (**pc != '\0' && !strchr(delimits, **pc))
+      buff[i++] = *(*pc)++;
+  }
+  buff[i] = '\0';
+  return buff;
+}
+
+
+static int getindex_aux (lua_State *L, lua_State *L1, const char **pc) {
+  skip(pc);
+  switch (*(*pc)++) {
+    case 'R': return LUA_REGISTRYINDEX;
+    case 'G': return luaL_error(L, "deprecated index 'G'");
+    case 'U': return lua_upvalueindex(getnum_aux(L, L1, pc));
+    default: (*pc)--; return getnum_aux(L, L1, pc);
+  }
+}
+
+
+static void pushcode (lua_State *L, int code) {
+  static const char *const codes[] = {"OK", "YIELD", "ERRRUN",
+                   "ERRSYNTAX", "ERRMEM", "ERRGCMM", "ERRERR"};
+  lua_pushstring(L, codes[code]);
+}
+
+
+#define EQ(s1)	(strcmp(s1, inst) == 0)
+
+#define getnum		(getnum_aux(L, L1, &pc))
+#define getstring	(getstring_aux(L, buff, &pc))
+#define getindex	(getindex_aux(L, L1, &pc))
+
+
+static int testC (lua_State *L);
+static int Cfunck (lua_State *L, int status, lua_KContext ctx);
+
+/*
+** arithmetic operation encoding for 'arith' instruction
+** LUA_OPIDIV  -> \
+** LUA_OPSHL   -> <
+** LUA_OPSHR   -> >
+** LUA_OPUNM   -> _
+** LUA_OPBNOT  -> !
+*/
+static const char ops[] = "+-*%^/\\&|~<>_!";
+
+static int runC (lua_State *L, lua_State *L1, const char *pc) {
+  char buff[300];
+  int status = 0;
+  if (pc == NULL) return luaL_error(L, "attempt to runC null script");
+  for (;;) {
+    const char *inst = getstring;
+    if EQ("") return 0;
+    else if EQ("absindex") {
+      lua_pushnumber(L1, lua_absindex(L1, getindex));
+    }
+    else if EQ("append") {
+      int t = getindex;
+      int i = lua_rawlen(L1, t);
+      lua_rawseti(L1, t, i + 1);
+    }
+    else if EQ("arith") {
+      int op;
+      skip(&pc);
+      op = strchr(ops, *pc++) - ops;
+      lua_arith(L1, op);
+    }
+    else if EQ("call") {
+      int narg = getnum;
+      int nres = getnum;
+      lua_call(L1, narg, nres);
+    }
+    else if EQ("callk") {
+      int narg = getnum;
+      int nres = getnum;
+      int i = getindex;
+      lua_callk(L1, narg, nres, i, Cfunck);
+    }
+    else if EQ("checkstack") {
+      int sz = getnum;
+      const char *msg = getstring;
+      if (*msg == '\0')
+        msg = NULL;  /* to test 'luaL_checkstack' with no message */
+      luaL_checkstack(L1, sz, msg);
+    }
+    else if EQ("compare") {
+      const char *opt = getstring;  /* EQ, LT, or LE */
+      int op = (opt[0] == 'E') ? LUA_OPEQ
+                               : (opt[1] == 'T') ? LUA_OPLT : LUA_OPLE;
+      int a = getindex;
+      int b = getindex;
+      lua_pushboolean(L1, lua_compare(L1, a, b, op));
+    }
+    else if EQ("concat") {
+      lua_concat(L1, getnum);
+    }
+    else if EQ("copy") {
+      int f = getindex;
+      lua_copy(L1, f, getindex);
+    }
+    else if EQ("func2num") {
+      lua_CFunction func = lua_tocfunction(L1, getindex);
+      lua_pushnumber(L1, cast(size_t, func));
+    }
+    else if EQ("getfield") {
+      int t = getindex;
+      lua_getfield(L1, t, getstring);
+    }
+    else if EQ("getglobal") {
+      lua_getglobal(L1, getstring);
+    }
+    else if EQ("getmetatable") {
+      if (lua_getmetatable(L1, getindex) == 0)
+        lua_pushnil(L1);
+    }
+    else if EQ("gettable") {
+      lua_gettable(L1, getindex);
+    }
+    else if EQ("gettop") {
+      lua_pushinteger(L1, lua_gettop(L1));
+    }
+    else if EQ("gsub") {
+      int a = getnum; int b = getnum; int c = getnum;
+      luaL_gsub(L1, lua_tostring(L1, a),
+                    lua_tostring(L1, b),
+                    lua_tostring(L1, c));
+    }
+    else if EQ("insert") {
+      lua_insert(L1, getnum);
+    }
+    else if EQ("iscfunction") {
+      lua_pushboolean(L1, lua_iscfunction(L1, getindex));
+    }
+    else if EQ("isfunction") {
+      lua_pushboolean(L1, lua_isfunction(L1, getindex));
+    }
+    else if EQ("isnil") {
+      lua_pushboolean(L1, lua_isnil(L1, getindex));
+    }
+    else if EQ("isnull") {
+      lua_pushboolean(L1, lua_isnone(L1, getindex));
+    }
+    else if EQ("isnumber") {
+      lua_pushboolean(L1, lua_isnumber(L1, getindex));
+    }
+    else if EQ("isstring") {
+      lua_pushboolean(L1, lua_isstring(L1, getindex));
+    }
+    else if EQ("istable") {
+      lua_pushboolean(L1, lua_istable(L1, getindex));
+    }
+    else if EQ("isudataval") {
+      lua_pushboolean(L1, lua_islightuserdata(L1, getindex));
+    }
+    else if EQ("isuserdata") {
+      lua_pushboolean(L1, lua_isuserdata(L1, getindex));
+    }
+    else if EQ("len") {
+      lua_len(L1, getindex);
+    }
+    else if EQ("Llen") {
+      lua_pushinteger(L1, luaL_len(L1, getindex));
+    }
+    else if EQ("loadfile") {
+      luaL_loadfile(L1, luaL_checkstring(L1, getnum));
+    }
+    else if EQ("loadstring") {
+      const char *s = luaL_checkstring(L1, getnum);
+      luaL_loadstring(L1, s);
+    }
+    else if EQ("newmetatable") {
+      lua_pushboolean(L1, luaL_newmetatable(L1, getstring));
+    }
+    else if EQ("newtable") {
+      lua_newtable(L1);
+    }
+    else if EQ("newthread") {
+      lua_newthread(L1);
+    }
+    else if EQ("newuserdata") {
+      lua_newuserdata(L1, getnum);
+    }
+    else if EQ("next") {
+      lua_next(L1, -2);
+    }
+    else if EQ("objsize") {
+      lua_pushinteger(L1, lua_rawlen(L1, getindex));
+    }
+    else if EQ("pcall") {
+      int narg = getnum;
+      int nres = getnum;
+      status = lua_pcall(L1, narg, nres, getnum);
+    }
+    else if EQ("pcallk") {
+      int narg = getnum;
+      int nres = getnum;
+      int i = getindex;
+      status = lua_pcallk(L1, narg, nres, 0, i, Cfunck);
+    }
+    else if EQ("pop") {
+      lua_pop(L1, getnum);
+    }
+    else if EQ("print") {
+      int n = getnum;
+      if (n != 0) {
+        printf("%s\n", luaL_tolstring(L1, n, NULL));
+        lua_pop(L1, 1);
+      }
+      else printstack(L1);
+    }
+    else if EQ("pushbool") {
+      lua_pushboolean(L1, getnum);
+    }
+    else if EQ("pushcclosure") {
+      lua_pushcclosure(L1, testC, getnum);
+    }
+    else if EQ("pushint") {
+      lua_pushinteger(L1, getnum);
+    }
+    else if EQ("pushnil") {
+      lua_pushnil(L1);
+    }
+    else if EQ("pushnum") {
+      lua_pushnumber(L1, (lua_Number)getnum);
+    }
+    else if EQ("pushstatus") {
+      pushcode(L1, status);
+    }
+    else if EQ("pushstring") {
+      lua_pushstring(L1, getstring);
+    }
+    else if EQ("pushupvalueindex") {
+      lua_pushinteger(L1, lua_upvalueindex(getnum));
+    }
+    else if EQ("pushvalue") {
+      lua_pushvalue(L1, getindex);
+    }
+    else if EQ("rawgeti") {
+      int t = getindex;
+      lua_rawgeti(L1, t, getnum);
+    }
+    else if EQ("rawgetp") {
+      int t = getindex;
+      lua_rawgetp(L1, t, cast(void *, cast(size_t, getnum)));
+    }
+    else if EQ("rawsetp") {
+      int t = getindex;
+      lua_rawsetp(L1, t, cast(void *, cast(size_t, getnum)));
+    }
+    else if EQ("remove") {
+      lua_remove(L1, getnum);
+    }
+    else if EQ("replace") {
+      lua_replace(L1, getindex);
+    }
+    else if EQ("resume") {
+      int i = getindex;
+      status = lua_resume(lua_tothread(L1, i), L, getnum);
+    }
+    else if EQ("return") {
+      int n = getnum;
+      if (L1 != L) {
+        int i;
+        for (i = 0; i < n; i++)
+          lua_pushstring(L, lua_tostring(L1, -(n - i)));
+      }
+      return n;
+    }
+    else if EQ("rotate") {
+      int i = getindex;
+      lua_rotate(L1, i, getnum);
+    }
+    else if EQ("setfield") {
+      int t = getindex;
+      lua_setfield(L1, t, getstring);
+    }
+    else if EQ("setglobal") {
+      lua_setglobal(L1, getstring);
+    }
+    else if EQ("sethook") {
+      int mask = getnum;
+      int count = getnum;
+      sethookaux(L1, mask, count, getstring);
+    }
+    else if EQ("setmetatable") {
+      lua_setmetatable(L1, getindex);
+    }
+    else if EQ("settable") {
+      lua_settable(L1, getindex);
+    }
+    else if EQ("settop") {
+      lua_settop(L1, getnum);
+    }
+    else if EQ("testudata") {
+      int i = getindex;
+      lua_pushboolean(L1, luaL_testudata(L1, i, getstring) != NULL);
+    }
+    else if EQ("error") {
+      lua_error(L1);
+    }
+    else if EQ("throw") {
+#if defined(__cplusplus)
+static struct X { int x; } x;
+      throw x;
+#else
+      luaL_error(L1, "C++");
+#endif
+      break;
+    }
+    else if EQ("tobool") {
+      lua_pushboolean(L1, lua_toboolean(L1, getindex));
+    }
+    else if EQ("tocfunction") {
+      lua_pushcfunction(L1, lua_tocfunction(L1, getindex));
+    }
+    else if EQ("tointeger") {
+      lua_pushinteger(L1, lua_tointeger(L1, getindex));
+    }
+    else if EQ("tonumber") {
+      lua_pushnumber(L1, lua_tonumber(L1, getindex));
+    }
+    else if EQ("topointer") {
+      lua_pushnumber(L1, cast(size_t, lua_topointer(L1, getindex)));
+    }
+    else if EQ("tostring") {
+      const char *s = lua_tostring(L1, getindex);
+      const char *s1 = lua_pushstring(L1, s);
+      lua_assert((s == NULL && s1 == NULL) || strcmp(s, s1) == 0);
+    }
+    else if EQ("type") {
+      lua_pushstring(L1, luaL_typename(L1, getnum));
+    }
+    else if EQ("xmove") {
+      int f = getindex;
+      int t = getindex;
+      lua_State *fs = (f == 0) ? L1 : lua_tothread(L1, f);
+      lua_State *ts = (t == 0) ? L1 : lua_tothread(L1, t);
+      int n = getnum;
+      if (n == 0) n = lua_gettop(fs);
+      lua_xmove(fs, ts, n);
+    }
+    else if EQ("yield") {
+      return lua_yield(L1, getnum);
+    }
+    else if EQ("yieldk") {
+      int nres = getnum;
+      int i = getindex;
+      return lua_yieldk(L1, nres, i, Cfunck);
+    }
+    else luaL_error(L, "unknown instruction %s", buff);
+  }
+  return 0;
+}
+
+
+static int testC (lua_State *L) {
+  lua_State *L1;
+  const char *pc;
+  if (lua_isuserdata(L, 1)) {
+    L1 = getstate(L);
+    pc = luaL_checkstring(L, 2);
+  }
+  else if (lua_isthread(L, 1)) {
+    L1 = lua_tothread(L, 1);
+    pc = luaL_checkstring(L, 2);
+  }
+  else {
+    L1 = L;
+    pc = luaL_checkstring(L, 1);
+  }
+  return runC(L, L1, pc);
+}
+
+
+static int Cfunc (lua_State *L) {
+  return runC(L, L, lua_tostring(L, lua_upvalueindex(1)));
+}
+
+
+static int Cfunck (lua_State *L, int status, lua_KContext ctx) {
+  pushcode(L, status);
+  lua_setglobal(L, "status");
+  lua_pushinteger(L, ctx);
+  lua_setglobal(L, "ctx");
+  return runC(L, L, lua_tostring(L, ctx));
+}
+
+
+static int makeCfunc (lua_State *L) {
+  luaL_checkstring(L, 1);
+  lua_pushcclosure(L, Cfunc, lua_gettop(L));
+  return 1;
+}
+
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** tests for C hooks
+** =======================================================
+*/
+
+/*
+** C hook that runs the C script stored in registry.C_HOOK[L]
+*/
+static void Chook (lua_State *L, lua_Debug *ar) {
+  const char *scpt;
+  const char *const events [] = {"call", "ret", "line", "count", "tailcall"};
+  lua_getfield(L, LUA_REGISTRYINDEX, "C_HOOK");
+  lua_pushlightuserdata(L, L);
+  lua_gettable(L, -2);  /* get C_HOOK[L] (script saved by sethookaux) */
+  scpt = lua_tostring(L, -1);  /* not very religious (string will be popped) */
+  lua_pop(L, 2);  /* remove C_HOOK and script */
+  lua_pushstring(L, events[ar->event]);  /* may be used by script */
+  lua_pushinteger(L, ar->currentline);  /* may be used by script */
+  runC(L, L, scpt);  /* run script from C_HOOK[L] */
+}
+
+
+/*
+** sets 'registry.C_HOOK[L] = scpt' and sets 'Chook' as a hook
+*/
+static void sethookaux (lua_State *L, int mask, int count, const char *scpt) {
+  if (*scpt == '\0') {  /* no script? */
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+    return;
+  }
+  lua_getfield(L, LUA_REGISTRYINDEX, "C_HOOK");  /* get C_HOOK table */
+  if (!lua_istable(L, -1)) {  /* no hook table? */
+    lua_pop(L, 1);  /* remove previous value */
+    lua_newtable(L);  /* create new C_HOOK table */
+    lua_pushvalue(L, -1);
+    lua_setfield(L, LUA_REGISTRYINDEX, "C_HOOK");  /* register it */
+  }
+  lua_pushlightuserdata(L, L);
+  lua_pushstring(L, scpt);
+  lua_settable(L, -3);  /* C_HOOK[L] = script */
+  lua_sethook(L, Chook, mask, count);
+}
+
+
+static int sethook (lua_State *L) {
+  if (lua_isnoneornil(L, 1))
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  else {
+    const char *scpt = luaL_checkstring(L, 1);
+    const char *smask = luaL_checkstring(L, 2);
+    int count = cast_int(luaL_optinteger(L, 3, 0));
+    int mask = 0;
+    if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+    if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+    if (count > 0) mask |= LUA_MASKCOUNT;
+    sethookaux(L, mask, count, scpt);
+  }
+  return 0;
+}
+
+
+static int coresume (lua_State *L) {
+  int status;
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  status = lua_resume(co, L, 0);
+  if (status != LUA_OK && status != LUA_YIELD) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+}
+
+/* }====================================================== */
+
+
+
+static const struct luaL_Reg tests_funcs[] = {
+  {"checkmemory", lua_checkmemory},
+  {"closestate", closestate},
+  {"d2s", d2s},
+  {"doonnewstack", doonnewstack},
+  {"doremote", doremote},
+  {"gccolor", gc_color},
+  {"gcstate", gc_state},
+  {"getref", getref},
+  {"hash", hash_query},
+  {"int2fb", int2fb_aux},
+  {"limits", get_limits},
+  {"listcode", listcode},
+  {"listk", listk},
+  {"listlocals", listlocals},
+  {"loadlib", loadlib},
+  {"checkpanic", checkpanic},
+  {"newstate", newstate},
+  {"newuserdata", newuserdata},
+  {"num2int", num2int},
+  {"pushuserdata", pushuserdata},
+  {"querystr", string_query},
+  {"querytab", table_query},
+  {"ref", tref},
+  {"resume", coresume},
+  {"s2d", s2d},
+  {"sethook", sethook},
+  {"stacklevel", stacklevel},
+  {"testC", testC},
+  {"makeCfunc", makeCfunc},
+  {"totalmem", mem_query},
+  {"trick", settrick},
+  {"udataval", udataval},
+  {"unref", unref},
+  {"upvalue", upvalue},
+  {NULL, NULL}
+};
+
+
+static void checkfinalmem (void) {
+  lua_assert(l_memcontrol.numblocks == 0);
+  lua_assert(l_memcontrol.total == 0);
+}
+
+
+int luaB_opentests (lua_State *L) {
+  void *ud;
+  lua_atpanic(L, &tpanic);
+  atexit(checkfinalmem);
+  lua_assert(lua_getallocf(L, &ud) == debug_realloc);
+  lua_assert(ud == cast(void *, &l_memcontrol));
+  lua_setallocf(L, lua_getallocf(L, NULL), ud);
+  luaL_newlib(L, tests_funcs);
+  return 1;
+}
+
+#endif
+
diff -urN rpm-5.4.15/lua/tests/ltests/ltests.h rpm-5.4-cvs/lua/tests/ltests/ltests.h
--- rpm-5.4.15/lua/tests/ltests/ltests.h	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/ltests/ltests.h	2015-04-19 13:25:00.000000000 -0500
@@ -0,0 +1,113 @@
+/*
+** $Id: ltests.h,v 1.1.2.1 2015/04/19 18:25:00 jbj Exp $
+** Internal Header for Debugging of the Lua Implementation
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltests_h
+#define ltests_h
+
+
+#include <stdlib.h>
+
+/* test Lua with no compatibility code */
+#undef LUA_COMPAT_MATHLIB
+#undef LUA_COMPAT_IPAIRS
+#undef LUA_COMPAT_BITLIB
+#undef LUA_COMPAT_APIINTCASTS
+#undef LUA_COMPAT_FLOATSTRING
+#undef LUA_COMPAT_UNPACK
+#undef LUA_COMPAT_LOADERS
+#undef LUA_COMPAT_LOG10
+#undef LUA_COMPAT_LOADSTRING
+#undef LUA_COMPAT_MAXN
+#undef LUA_COMPAT_MODULE
+
+
+#define LUA_DEBUG
+
+
+/* turn on assertions */
+#undef NDEBUG
+#include <assert.h>
+#define lua_assert(c)           assert(c)
+
+
+/* to avoid warnings, and to make sure value is really unused */
+#define UNUSED(x)       (x=0, (void)(x))
+
+
+/* memory-allocator control variables */
+typedef struct Memcontrol {
+  unsigned long numblocks;
+  unsigned long total;
+  unsigned long maxmem;
+  unsigned long memlimit;
+  unsigned long objcount[LUA_NUMTAGS];
+} Memcontrol;
+
+LUA_API Memcontrol l_memcontrol;
+
+
+/*
+** generic variable for debug tricks
+*/
+extern void *l_Trick;
+
+
+
+/*
+** Function to traverse and check all memory used by Lua
+*/
+int lua_checkmemory (lua_State *L);
+
+
+/* test for lock/unlock */
+
+struct L_EXTRA { int lock; int *plock; };
+#undef LUA_EXTRASPACE
+#define LUA_EXTRASPACE	sizeof(struct L_EXTRA)
+#define getlock(l)	cast(struct L_EXTRA*, lua_getextraspace(l))
+#define luai_userstateopen(l)  \
+	(getlock(l)->lock = 0, getlock(l)->plock = &(getlock(l)->lock))
+#define luai_userstateclose(l)  \
+  lua_assert(getlock(l)->lock == 1 && getlock(l)->plock == &(getlock(l)->lock))
+#define luai_userstatethread(l,l1) \
+  lua_assert(getlock(l1)->plock == getlock(l)->plock)
+#define luai_userstatefree(l,l1) \
+  lua_assert(getlock(l)->plock == getlock(l1)->plock)
+#define lua_lock(l)     lua_assert((*getlock(l)->plock)++ == 0)
+#define lua_unlock(l)   lua_assert(--(*getlock(l)->plock) == 0)
+
+
+
+LUA_API int luaB_opentests (lua_State *L);
+
+LUA_API void *debug_realloc (void *ud, void *block,
+                             size_t osize, size_t nsize);
+
+#if defined(lua_c)
+#define luaL_newstate()		lua_newstate(debug_realloc, &l_memcontrol)
+#define luaL_openlibs(L)  \
+  { (luaL_openlibs)(L); luaL_requiref(L, "T", luaB_opentests, 1); }
+#endif
+
+
+
+/* change some sizes to give some bugs a chance */
+
+#undef LUAL_BUFFERSIZE
+#define LUAL_BUFFERSIZE		23
+#define MINSTRTABSIZE		2
+
+
+/* make stack-overflow tests run faster */
+#undef LUAI_MAXSTACK
+#define LUAI_MAXSTACK   50000
+
+
+#undef LUAI_USER_ALIGNMENT_T
+#define LUAI_USER_ALIGNMENT_T   union { char b[sizeof(void*) * 8]; }
+
+#endif
+
diff -urN rpm-5.4.15/lua/tests/main.lua rpm-5.4-cvs/lua/tests/main.lua
--- rpm-5.4.15/lua/tests/main.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/main.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,378 @@
+# testing special comment on first line
+-- $Id: main.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+-- most (all?) tests here assume a reasonable "Unix-like" shell
+if _port then return end
+
+-- use only "double quotes" inside shell scripts (better change to
+-- run on Windows)
+
+
+print ("testing stand-alone interpreter")
+
+assert(os.execute())   -- machine has a system command
+
+local prog = os.tmpname()
+local otherprog = os.tmpname()
+local out = os.tmpname()
+
+local progname
+do
+  local i = 0
+  while arg[i] do i=i-1 end
+  progname = arg[i+1]
+end
+print("progname: "..progname)
+
+local prepfile = function (s, p)
+  p = p or prog
+  io.output(p)
+  io.write(s)
+  assert(io.close())
+end
+
+local function getoutput ()
+  io.input(out)
+  local t = io.read("a")
+  io.input():close()
+  assert(os.remove(out))
+  return t
+end
+
+local function checkprogout (s)
+  local t = getoutput()
+  for line in string.gmatch(s, ".-\n") do
+    assert(string.find(t, line, 1, true))
+  end
+end
+
+local function checkout (s)
+  local t = getoutput()
+  if s ~= t then print(string.format("'%s' - '%s'\n", s, t)) end
+  assert(s == t)
+  return t
+end
+
+
+local function RUN (p, ...)
+  p = string.gsub(p, "lua", '"'..progname..'"', 1)
+  local s = string.format(p, ...)
+  assert(os.execute(s))
+end
+
+local function NoRun (msg, p, ...)
+  p = string.gsub(p, "lua", '"'..progname..'"', 1)
+  local s = string.format(p, ...)
+  s = string.format("%s 2> %s", s, out)  -- will send error to 'out'
+  assert(not os.execute(s))
+  assert(string.find(getoutput(), msg, 1, true))  -- check error message
+end
+
+RUN('lua -v')
+
+print(string.format("(temporary program file used in these tests: %s)", prog))
+
+-- running stdin as a file
+prepfile""
+RUN('lua - < %s > %s', prog, out)
+checkout("")
+
+prepfile[[
+  print(
+1, a
+)
+]]
+RUN('lua - < %s > %s', prog, out)
+checkout("1\tnil\n")
+
+RUN('echo "print(10)\nprint(2)\n" | lua > %s', out)
+checkout("10\n2\n")
+
+
+-- test option '-'
+RUN('echo "print(arg[1])" | lua - -h > %s', out)
+checkout("-h\n")
+
+-- test environment variables used by Lua
+
+prepfile("print(package.path)")
+
+-- test LUA_PATH
+RUN('env LUA_INIT= LUA_PATH=x lua %s > %s', prog, out)
+checkout("x\n")
+
+-- test LUA_PATH_version
+RUN('env LUA_INIT= LUA_PATH_5_3=y LUA_PATH=x lua %s > %s', prog, out)
+checkout("y\n")
+
+-- test LUA_CPATH
+prepfile("print(package.cpath)")
+RUN('env LUA_INIT= LUA_CPATH=xuxu lua %s > %s', prog, out)
+checkout("xuxu\n")
+
+-- test LUA_CPATH_version
+RUN('env LUA_INIT= LUA_CPATH_5_3=yacc LUA_CPATH=x lua %s > %s', prog, out)
+checkout("yacc\n")
+
+-- test LUA_INIT (and its access to 'arg' table)
+prepfile("print(X)")
+RUN('env LUA_INIT="X=tonumber(arg[1])" lua %s 3.2 > %s', prog, out)
+checkout("3.2\n")
+
+-- test LUA_INIT_version
+prepfile("print(X)")
+RUN('env LUA_INIT_5_3="X=10" LUA_INIT="X=3" lua %s > %s', prog, out)
+checkout("10\n")
+
+-- test LUA_INIT for files
+prepfile("x = x or 10; print(x); x = x + 1")
+RUN('env LUA_INIT="@%s" lua %s > %s', prog, prog, out)
+checkout("10\n11\n")
+
+-- test errors in LUA_INIT
+NoRun('LUA_INIT:1: 10', 'env LUA_INIT="error(10)" lua')
+
+-- test option '-E'
+local defaultpath, defaultCpath
+
+do
+  prepfile("print(package.path, package.cpath)")
+  RUN('env LUA_INIT="error(10)" LUA_PATH=xxx LUA_CPATH=xxx lua -E %s > %s',
+       prog, out)
+  local out = getoutput()
+  defaultpath = string.match(out, "^(.-)\t")
+  defaultCpath = string.match(out, "\t(.-)$")
+end
+
+-- paths did not changed
+assert(not string.find(defaultpath, "xxx") and
+       string.find(defaultpath, "lua") and
+       not string.find(defaultCpath, "xxx") and
+       string.find(defaultCpath, "lua"))
+
+
+-- test replacement of ';;' to default path
+local function convert (p)
+  prepfile("print(package.path)")
+  RUN('env LUA_PATH="%s" lua %s > %s', p, prog, out)
+  local expected = getoutput()
+  expected = string.sub(expected, 1, -2)   -- cut final end of line
+  assert(string.gsub(p, ";;", ";"..defaultpath..";") == expected)
+end
+
+convert(";")
+convert(";;")
+convert(";;;")
+convert(";;;;")
+convert(";;;;;")
+convert(";;a;;;bc")
+
+
+-- test -l over multiple libraries
+prepfile("print(1); a=2; return {x=15}")
+prepfile(("print(a); print(_G['%s'].x)"):format(prog), otherprog)
+RUN('env LUA_PATH="?;;" lua -l %s -l%s -lstring -l io %s > %s', prog, otherprog, otherprog, out)
+checkout("1\n2\n15\n2\n15\n")
+
+-- test 'arg' table
+local a = [[
+  assert(#arg == 3 and arg[1] == 'a' and
+         arg[2] == 'b' and arg[3] == 'c')
+  assert(arg[-1] == '--' and arg[-2] == "-e " and arg[-3] == '%s')
+  assert(arg[4] == nil and arg[-4] == nil)
+  local a, b, c = ...
+  assert(... == 'a' and a == 'a' and b == 'b' and c == 'c')
+]]
+a = string.format(a, progname)
+prepfile(a)
+RUN('lua "-e " -- %s a b c', prog)   -- "-e " runs an empty command
+
+-- test 'arg' availability in libraries
+prepfile"assert(arg)"
+prepfile("assert(arg)", otherprog)
+RUN('env LUA_PATH="?;;" lua -l%s - < %s', prog, otherprog)
+
+-- test messing up the 'arg' table
+RUN('echo "print(...)" | lua -e "arg[1] = 100" - > %s', out)
+checkout("100\n")
+NoRun("'arg' is not a table", 'echo "" | lua -e "arg = 1" -')
+
+-- test error in 'print'
+RUN('echo 10 | lua -e "print=nil" -i > /dev/null 2> %s', out)
+assert(string.find(getoutput(), "error calling 'print'"))
+
+-- test 'debug.debug'
+RUN('echo "io.stderr:write(1000)\ncont" | lua -e "require\'debug\'.debug()" 2> %s', out)
+checkout("lua_debug> 1000lua_debug> ")
+
+-- test many arguments
+prepfile[[print(({...})[30])]]
+RUN('lua %s %s > %s', prog, string.rep(" a", 30), out)
+checkout("a\n")
+
+RUN([[lua "-eprint(1)" -ea=3 -e "print(a)" > %s]], out)
+checkout("1\n3\n")
+
+-- test iteractive mode
+prepfile[[
+(6*2-6) -- ===
+a =
+10
+print(a)
+a]]
+RUN([[lua -e"_PROMPT='' _PROMPT2=''" -i < %s > %s]], prog, out)
+checkprogout("6\n10\n10\n\n")
+
+prepfile("a = [[b\nc\nd\ne]]\n=a")
+RUN([[lua -e"_PROMPT='' _PROMPT2=''" -i < %s > %s]], prog, out)
+checkprogout("b\nc\nd\ne\n\n")
+
+prompt = "alo"
+prepfile[[ --
+a = 2
+]]
+RUN([[lua "-e_PROMPT='%s'" -i < %s > %s]], prompt, prog, out)
+local t = getoutput()
+assert(string.find(t, prompt .. ".*" .. prompt .. ".*" .. prompt))
+
+-- test for error objects
+prepfile[[
+debug = require "debug"
+m = {x=0}
+setmetatable(m, {__tostring = function(x)
+  return tostring(debug.getinfo(4).currentline + x.x)
+end})
+error(m)
+]]
+NoRun(progname .. ": 6\n", [[lua %s]], prog)
+
+prepfile("error{}")
+NoRun("error object is a table value", [[lua %s]], prog)
+
+
+-- chunk broken in many lines
+s = [=[ -- 
+function f ( x ) 
+  local a = [[
+xuxu
+]]
+  local b = "\
+xuxu\n"
+  if x == 11 then return 1 + 12 , 2 + 20 end  --[[ test multiple returns ]]
+  return x + 1 
+  --\\
+end
+return( f( 100 ) )
+assert( a == b )
+do return f( 11 ) end  ]=]
+s = string.gsub(s, ' ', '\n\n')   -- change all spaces for newlines
+prepfile(s)
+RUN([[lua -e"_PROMPT='' _PROMPT2=''" -i < %s > %s]], prog, out)
+checkprogout("101\n13\t22\n\n")
+  
+prepfile[[#comment in 1st line without \n at the end]]
+RUN('lua %s', prog)
+  
+prepfile[[#test line number when file starts with comment line
+debug = require"debug"
+print(debug.getinfo(1).currentline)
+]]
+RUN('lua %s > %s', prog, out)
+checkprogout('3')
+
+-- close Lua with an open file
+prepfile(string.format([[io.output(%q); io.write('alo')]], out))
+RUN('lua %s', prog)
+checkout('alo')
+
+-- bug in 5.2 beta (extra \0 after version line)
+RUN([[lua -v  -e"print'hello'" > %s]], out)
+t = getoutput()
+assert(string.find(t, "PUC%-Rio\nhello"))
+
+
+-- testing os.exit
+prepfile("os.exit(nil, true)")
+RUN('lua %s', prog)
+prepfile("os.exit(0, true)")
+RUN('lua %s', prog)
+prepfile("os.exit(true, true)")
+RUN('lua %s', prog)
+prepfile("os.exit(1, true)")
+NoRun("", "lua %s", prog)   -- no message
+prepfile("os.exit(false, true)")
+NoRun("", "lua %s", prog)   -- no message
+
+-- remove temporary files
+assert(os.remove(prog))
+assert(os.remove(otherprog))
+assert(not os.remove(out))
+
+-- invalid options
+NoRun("unrecognized option '-h'", "lua -h")
+NoRun("unrecognized option '---'", "lua ---")
+NoRun("unrecognized option '-Ex'", "lua -Ex")
+NoRun("unrecognized option '-vv'", "lua -vv")
+NoRun("unrecognized option '-iv'", "lua -iv")
+NoRun("'-e' needs argument", "lua -e")
+NoRun("syntax error", "lua -e a")
+NoRun("'-l' needs argument", "lua -l")
+
+
+if T then   -- auxiliary library?
+  print("testing 'not enough memory' to create a state")
+  NoRun("not enough memory", "env MEMLIMIT=100 lua")
+end
+print('+')
+
+print('testing Ctrl C')
+do
+  -- interrupt a script
+  local function kill (pid)
+    return os.execute(string.format('kill -INT %d 2> /dev/null', pid))
+  end
+
+  -- function to run a script in background, returning its output file
+  -- descriptor and its pid
+  local function runback (luaprg)
+    -- shell script to run 'luaprg' in background and echo its pid
+    local shellprg = string.format('%s -e "%s" & echo $!', progname, luaprg)
+    local f = io.popen(shellprg, "r")   -- run shell script
+    local pid = f:read()   -- get pid for Lua script
+    print("(if test fails now, it may leave a Lua script running in \z
+            background, pid " .. pid .. ")")
+    return f, pid
+  end
+
+  -- Lua script that runs protected infinite loop and then prints '42'
+  local f, pid = runback[[
+    pcall(function () print(12); while true do end end); print(42)]]
+  -- wait until script is inside 'pcall'
+  assert(f:read() == "12")
+  kill(pid)  -- send INT signal to Lua script
+  -- check that 'pcall' captured the exception and script continued running
+  assert(f:read() == "42")  -- expected output
+  assert(f:close())
+  print("done")
+
+  -- Lua script in a looooog unbreakable search
+  local f, pid = runback[[
+    print(15); string.find(string.rep('a', 1000), '.*.*.*.*.*b')]]
+  -- wait (so script can reach the loop)
+  assert(f:read() == "15")
+  assert(os.execute("sleep 1"))
+  -- must send at least two INT signals to stop this Lua script
+  local n = 100
+  for i = 0, 100 do   -- keep sending signals
+    if not kill(pid) then   -- until it fails
+      n = i   -- number of non-failed kills
+      break
+    end
+  end
+  assert(f:close())
+  assert(n >= 2)
+  print(string.format("done (with %d kills)", n))
+
+end
+
+print("OK")
diff -urN rpm-5.4.15/lua/tests/Makefile.am rpm-5.4-cvs/lua/tests/Makefile.am
--- rpm-5.4.15/lua/tests/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/Makefile.am	2015-04-19 13:24:57.000000000 -0500
@@ -0,0 +1,40 @@
+
+AUTOMAKE_OPTIONS = 1.4 foreign
+
+SUBDIRS = libs
+
+EXTRA_DIST = \
+	all.lua \
+	api.lua \
+	attrib.lua \
+	big.lua \
+	bitwise.lua \
+	calls.lua \
+	closure.lua \
+	code.lua \
+	constructs.lua \
+	coroutine.lua \
+	db.lua \
+	errors.lua \
+	events.lua \
+	files.lua \
+	gc.lua \
+	goto.lua \
+	literals.lua \
+	locals.lua \
+	main.lua \
+	math.lua \
+	nextvar.lua \
+	pm.lua \
+	sort.lua \
+	strings.lua \
+	tpack.lua \
+	utf8.lua \
+	vararg.lua \
+	verybig.lua \
+	time.txt \
+	ltests/ltests.c \
+	ltests/ltests.h
+
+check-local:
+	../rpmlua -e"_U=true" all.lua
diff -urN rpm-5.4.15/lua/tests/math.lua rpm-5.4-cvs/lua/tests/math.lua
--- rpm-5.4.15/lua/tests/math.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/math.lua	2015-04-19 13:24:58.000000000 -0500
@@ -0,0 +1,685 @@
+-- $Id: math.lua,v 1.1.2.1 2015/04/19 18:24:58 jbj Exp $
+
+print("testing numbers and math lib")
+
+local minint = math.mininteger
+local maxint = math.maxinteger
+
+local intbits = math.floor(math.log(maxint, 2) + 0.5) + 1
+assert((1 << intbits) == 0)
+
+assert(minint == 1 << (intbits - 1))
+assert(maxint == minint - 1)
+
+-- number of bits in the mantissa of a floating-point number
+local floatbits = 24
+do
+  local p = 2.0^floatbits
+  while p < p + 1.0 do
+    p = p * 2.0
+    floatbits = floatbits + 1
+  end
+end
+
+
+do
+  local x = 2.0^floatbits
+  assert(x > x - 1.0 and x == x + 1.0)
+
+  print(string.format("%d-bit integers, %d-bit (mantissa) floats",
+                       intbits, floatbits))
+end
+
+assert(math.type(0) == "integer" and math.type(0.0) == "float"
+       and math.type("10") == nil)
+
+
+local function checkerror (msg, f, ...)
+  local s, err = pcall(f, ...)
+  assert(not s and string.find(err, msg))
+end
+
+local msgf2i = "number.* has no integer representation"
+
+-- float equality
+function eq (a,b,limit)
+  if not limit then
+    if floatbits >= 50 then limit = 1E-11
+    else limit = 1E-5
+    end
+  end
+  -- a == b needed for +inf/-inf
+  return a == b or math.abs(a-b) <= limit
+end
+
+
+-- equality with types
+function eqT (a,b)
+  return a == b and math.type(a) == math.type(b)
+end
+
+
+-- basic float notation
+assert(0e12 == 0 and .0 == 0 and 0. == 0 and .2e2 == 20 and 2.E-1 == 0.2)
+
+do
+  local a,b,c = "2", " 3e0 ", " 10  "
+  assert(a+b == 5 and -b == -3 and b+"2" == 5 and "10"-c == 0)
+  assert(type(a) == 'string' and type(b) == 'string' and type(c) == 'string')
+  assert(a == "2" and b == " 3e0 " and c == " 10  " and -c == -"  10 ")
+  assert(c%a == 0 and a^b == 08)
+  a = 0
+  assert(a == -a and 0 == -0)
+end
+
+do
+  local x = -1
+  local mz = 0/x   -- minus zero
+  t = {[0] = 10, 20, 30, 40, 50}
+  assert(t[mz] == t[0] and t[-0] == t[0])
+end
+
+do   -- tests for 'modf'
+  local a,b = math.modf(3.5)
+  assert(a == 3.0 and b == 0.5)
+  a,b = math.modf(-2.5)
+  assert(a == -2.0 and b == -0.5)
+  a,b = math.modf(-3e23)
+  assert(a == -3e23 and b == 0.0)
+  a,b = math.modf(3e35)
+  assert(a == 3e35 and b == 0.0)
+  a,b = math.modf(-1/0)   -- -inf
+  assert(a == -1/0 and b == 0.0)
+  a,b = math.modf(1/0)   -- inf
+  assert(a == 1/0 and b == 0.0)
+  a,b = math.modf(0/0)   -- NaN
+  assert(a ~= a and b ~= b)
+  a,b = math.modf(3)  -- integer argument
+  assert(eqT(a, 3) and eqT(b, 0.0))
+  a,b = math.modf(minint)
+  assert(eqT(a, minint) and eqT(b, 0.0))
+end
+
+assert(math.huge > 10e30)
+assert(-math.huge < -10e30)
+
+
+-- integer arithmetic
+assert(minint < minint + 1)
+assert(maxint - 1 < maxint)
+assert(0 - minint == minint)
+assert(minint * minint == 0)
+assert(maxint * maxint * maxint == maxint)
+
+
+-- testing floor division and conversions
+
+for _, i in pairs{-16, -15, -3, -2, -1, 0, 1, 2, 3, 15} do
+  for _, j in pairs{-16, -15, -3, -2, -1, 1, 2, 3, 15} do
+    for _, ti in pairs{0, 0.0} do     -- try 'i' as integer and as float
+      for _, tj in pairs{0, 0.0} do   -- try 'j' as integer and as float
+        local x = i + ti
+        local y = j + tj
+          assert(i//j == math.floor(i/j))
+      end
+    end
+  end
+end
+
+assert(1//0.0 == 1/0)
+assert(-1 // 0.0 == -1/0)
+assert(eqT(3.5 // 1.5, 2.0))
+assert(eqT(3.5 // -1.5, -3.0))
+
+assert(maxint // maxint == 1)
+assert(maxint // 1 == maxint)
+assert((maxint - 1) // maxint == 0)
+assert(maxint // (maxint - 1) == 1)
+assert(minint // minint == 1)
+assert(minint // minint == 1)
+assert((minint + 1) // minint == 0)
+assert(minint // (minint + 1) == 1)
+assert(minint // 1 == minint)
+
+assert(minint // -1 == -minint)
+assert(minint // -2 == 2^(intbits - 2))
+assert(maxint // -1 == -maxint)
+
+
+-- negative exponents
+do
+  assert(2^-3 == 1 / 2^3)
+  assert(eq((-3)^-3, 1 / (-3)^3))
+  for i = -3, 3 do    -- variables avoid constant folding
+      for j = -3, 3 do
+        -- domain errors (0^(-n)) are not portable
+        if not _port or i ~= 0 or j > 0 then
+          assert(eq(i^j, 1 / i^(-j)))
+       end
+    end
+  end
+end
+
+
+assert(maxint + 0.0 == maxint)
+assert(maxint + 0.0 == 2.0^(intbits - 1) - 1.0)
+assert(minint + 0.0 == minint)
+assert(minint + 0.0 == -2.0^(intbits - 1))
+
+
+-- avoiding errors at compile time
+local function checkcompt (msg, code)
+  checkerror(msg, assert(load(code)))
+end
+checkcompt("divide by zero", "return 2 // 0")
+checkcompt(msgf2i, "return 2.3 >> 0")
+checkcompt(msgf2i, ("return 2.0^%d & 1"):format(intbits - 1))
+checkcompt("field 'huge'", "return math.huge << 1")
+checkcompt(msgf2i, ("return 1 | 2.0^%d"):format(intbits - 1))
+checkcompt(msgf2i, "return 2.3 ~ '0.0'")
+
+
+-- testing overflow errors when converting from float to integer (runtime)
+local function f2i (x) return x | x end
+checkerror(msgf2i, f2i, math.huge)     -- +inf
+checkerror(msgf2i, f2i, -math.huge)    -- -inf
+checkerror(msgf2i, f2i, 0/0)           -- NaN
+
+if floatbits < intbits then
+  -- conversion tests when float cannot represent all integers
+  assert(maxint + 1.0 == maxint)
+  assert(minint - 1.0 == minint)
+  checkerror(msgf2i, f2i, maxint + 0.0)
+  assert(f2i(2.0^(intbits - 2)) == 1 << (intbits - 2))
+  assert(f2i(-2.0^(intbits - 2)) == -(1 << (intbits - 2)))
+  assert((2.0^(floatbits - 1) + 1.0) // 1 == (1 << (floatbits - 1)) + 1)
+  -- maximum integer representable as a float
+  local mf = maxint - (1 << (floatbits - intbits)) + 1
+  assert(f2i(mf + 0.0) == mf)  -- OK up to here
+  mf = mf + 1
+  assert(f2i(mf + 0.0) ~= mf)   -- no more representable
+else
+  -- conversion tests when float can represent all integers
+  assert(maxint + 1.0 > maxint)
+  assert(minint - 1.0 < minint)
+  assert(f2i(maxint + 0.0) == maxint)
+  checkerror("no integer rep", f2i, maxint + 1.0)
+  checkerror("no integer rep", f2i, minint - 1.0)
+end
+
+-- 'minint' should be representable as a float no matter the precision
+assert(f2i(minint + 0.0) == minint)
+
+
+-- testing numeric strings
+
+assert("2" + 1 == 3)
+assert("2 " + 1 == 3)
+assert(" -2 " + 1 == -1)
+assert(" -0xa " + 1 == -9)
+
+
+-- testing 'tonumber'
+
+-- 'tonumber' with numbers
+assert(tonumber(3.4) == 3.4)
+assert(tonumber(3) == 3 and math.type(tonumber(3)) == "integer")
+assert(tonumber(maxint) == maxint and tonumber(minint) == minint)
+assert(tonumber(1/0) == 1/0)
+
+-- 'tonumber' with strings
+assert(tonumber("0") == 0)
+assert(tonumber("") == nil)
+assert(tonumber("  ") == nil)
+assert(tonumber("-") == nil)
+assert(tonumber("  -0x ") == nil)
+assert(tonumber{} == nil)
+assert(tonumber'+0.01' == 1/100 and tonumber'+.01' == 0.01 and
+       tonumber'.01' == 0.01    and tonumber'-1.' == -1 and
+       tonumber'+1.' == 1)
+assert(tonumber'+ 0.01' == nil and tonumber'+.e1' == nil and
+       tonumber'1e' == nil     and tonumber'1.0e+' == nil and
+       tonumber'.' == nil)
+assert(tonumber('-012') == -010-2)
+assert(tonumber('-1.2e2') == - - -120)
+
+assert(tonumber("0xffffffffffff") == (1 << (4*12)) - 1)
+assert(tonumber("0x"..string.rep("f", (intbits//4))) == -1)
+assert(tonumber("-0x"..string.rep("f", (intbits//4))) == 1)
+
+-- testing 'tonumber' with base
+assert(tonumber('  001010  ', 2) == 10)
+assert(tonumber('  001010  ', 10) == 001010)
+assert(tonumber('  -1010  ', 2) == -10)
+assert(tonumber('10', 36) == 36)
+assert(tonumber('  -10  ', 36) == -36)
+assert(tonumber('  +1Z  ', 36) == 36 + 35)
+assert(tonumber('  -1z  ', 36) == -36 + -35)
+assert(tonumber('-fFfa', 16) == -(10+(16*(15+(16*(15+(16*15)))))))
+assert(tonumber(string.rep('1', (intbits - 2)), 2) + 1 == 2^(intbits - 2))
+assert(tonumber('ffffFFFF', 16)+1 == (1 << 32))
+assert(tonumber('0ffffFFFF', 16)+1 == (1 << 32))
+assert(tonumber('-0ffffffFFFF', 16) - 1 == -(1 << 40))
+for i = 2,36 do
+  local i2 = i * i
+  local i10 = i2 * i2 * i2 * i2 * i2      -- i^10
+  assert(tonumber('\t10000000000\t', i) == i10)
+end
+
+if not _soft then
+  -- tests with very long numerals
+  assert(tonumber("0x"..string.rep("f", 13)..".0") == 2.0^(4*13) - 1)
+  assert(tonumber("0x"..string.rep("f", 150)..".0") == 2.0^(4*150) - 1)
+  assert(tonumber("0x"..string.rep("f", 300)..".0") == 2.0^(4*300) - 1)
+  assert(tonumber("0x"..string.rep("f", 500)..".0") == 2.0^(4*500) - 1)
+  assert(tonumber('0x3.' .. string.rep('0', 1000)) == 3)
+  assert(tonumber('0x' .. string.rep('0', 1000) .. 'a') == 10)
+  assert(tonumber('0x0.' .. string.rep('0', 13).."1") == 2.0^(-4*14))
+  assert(tonumber('0x0.' .. string.rep('0', 150).."1") == 2.0^(-4*151))
+  assert(tonumber('0x0.' .. string.rep('0', 300).."1") == 2.0^(-4*301))
+  assert(tonumber('0x0.' .. string.rep('0', 500).."1") == 2.0^(-4*501))
+
+  assert(tonumber('0xe03' .. string.rep('0', 1000) .. 'p-4000') == 3587.0)
+  assert(tonumber('0x.' .. string.rep('0', 1000) .. '74p4004') == 0x7.4)
+end
+
+-- testing 'tonumber' for invalid formats
+
+local function f (...)
+  if select('#', ...) == 1 then
+    return (...)
+  else
+    return "***"
+  end
+end
+
+assert(f(tonumber('fFfa', 15)) == nil)
+assert(f(tonumber('099', 8)) == nil)
+assert(f(tonumber('1\0', 2)) == nil)
+assert(f(tonumber('', 8)) == nil)
+assert(f(tonumber('  ', 9)) == nil)
+assert(f(tonumber('  ', 9)) == nil)
+assert(f(tonumber('0xf', 10)) == nil)
+
+assert(f(tonumber('inf')) == nil)
+assert(f(tonumber(' INF ')) == nil)
+assert(f(tonumber('Nan')) == nil)
+assert(f(tonumber('nan')) == nil)
+
+assert(f(tonumber('  ')) == nil)
+assert(f(tonumber('')) == nil)
+assert(f(tonumber('1  a')) == nil)
+assert(f(tonumber('1  a', 2)) == nil)
+assert(f(tonumber('1\0')) == nil)
+assert(f(tonumber('1 \0')) == nil)
+assert(f(tonumber('1\0 ')) == nil)
+assert(f(tonumber('e1')) == nil)
+assert(f(tonumber('e  1')) == nil)
+assert(f(tonumber(' 3.4.5 ')) == nil)
+
+
+-- testing 'tonumber' for invalid hexadecimal formats
+
+assert(tonumber('0x') == nil)
+assert(tonumber('x') == nil)
+assert(tonumber('x3') == nil)
+assert(tonumber('0x3.3.3') == nil)   -- two decimal points
+assert(tonumber('00x2') == nil)
+assert(tonumber('0x 2') == nil)
+assert(tonumber('0 x2') == nil)
+assert(tonumber('23x') == nil)
+assert(tonumber('- 0xaa') == nil)
+assert(tonumber('-0xaaP ') == nil)   -- no exponent
+assert(tonumber('0x0.51p') == nil)
+assert(tonumber('0x5p+-2') == nil)
+
+
+-- testing hexadecimal numerals
+
+assert(0x10 == 16 and 0xfff == 2^12 - 1 and 0XFB == 251)
+assert(0x0p12 == 0 and 0x.0p-3 == 0)
+assert(0xFFFFFFFF == (1 << 32) - 1)
+assert(tonumber('+0x2') == 2)
+assert(tonumber('-0xaA') == -170)
+assert(tonumber('-0xffFFFfff') == -(1 << 32) + 1)
+
+-- possible confusion with decimal exponent
+assert(0E+1 == 0 and 0xE+1 == 15 and 0xe-1 == 13)
+
+
+-- floating hexas
+
+assert(tonumber('  0x2.5  ') == 0x25/16)
+assert(tonumber('  -0x2.5  ') == -0x25/16)
+assert(tonumber('  +0x0.51p+8  ') == 0x51)
+assert(0x.FfffFFFF == 1 - '0x.00000001')
+assert('0xA.a' + 0 == 10 + 10/16)
+assert(0xa.aP4 == 0XAA)
+assert(0x4P-2 == 1)
+assert(0x1.1 == '0x1.' + '+0x.1')
+assert(0Xabcdef.0 == 0x.ABCDEFp+24)
+
+
+assert(1.1 == 1.+.1)
+assert(100.0 == 1E2 and .01 == 1e-2)
+assert(1111111111111111-1111111111111110== 1000.00e-03)
+--     1234567890123456
+assert(1.1 == '1.'+'.1')
+assert(tonumber'1111111111111111'-tonumber'1111111111111110' ==
+       tonumber"  +0.001e+3 \n\t")
+
+assert(0.1e-30 > 0.9E-31 and 0.9E30 < 0.1e31)
+
+assert(0.123456 > 0.123455)
+
+assert(tonumber('+1.23E18') == 1.23*10.0^18)
+
+-- testing order operators
+assert(not(1<1) and (1<2) and not(2<1))
+assert(not('a'<'a') and ('a'<'b') and not('b'<'a'))
+assert((1<=1) and (1<=2) and not(2<=1))
+assert(('a'<='a') and ('a'<='b') and not('b'<='a'))
+assert(not(1>1) and not(1>2) and (2>1))
+assert(not('a'>'a') and not('a'>'b') and ('b'>'a'))
+assert((1>=1) and not(1>=2) and (2>=1))
+assert(('a'>='a') and not('a'>='b') and ('b'>='a'))
+
+-- testing mod operator
+assert(eqT(-4 % 3, 2))
+assert(eqT(4 % -3, -2))
+assert(eqT(-4.0 % 3, 2.0))
+assert(eqT(4 % -3.0, -2.0))
+assert(math.pi - math.pi % 1 == 3)
+assert(math.pi - math.pi % 0.001 == 3.141)
+
+assert(eqT(minint % minint, 0))
+assert(eqT(maxint % maxint, 0))
+assert((minint + 1) % minint == minint + 1)
+assert((maxint - 1) % maxint == maxint - 1)
+assert(minint % maxint == maxint - 1)
+
+assert(minint % -1 == 0)
+assert(minint % -2 == 0)
+assert(maxint % -2 == -1)
+
+-- non-portable tests because Windows C library cannot compute 
+-- fmod(1, huge) correctly
+if not _port then
+  local function anan (x) assert(x ~= x) end   -- assert Not a Number
+  anan(0.0 % 0)
+  anan(1.3 % 0)
+  anan(math.huge % 1)
+  anan(math.huge % 1e30)
+  anan(-math.huge % 1e30)
+  anan(-math.huge % -1e30)
+  assert(1 % math.huge == 1)
+  assert(1e30 % math.huge == 1e30)
+  assert(1e30 % -math.huge == -math.huge)
+  assert(-1 % math.huge == math.huge)
+  assert(-1 % -math.huge == -1)
+end
+
+
+-- testing unsigned comparisons
+assert(math.ult(3, 4))
+assert(not math.ult(4, 4))
+assert(math.ult(-2, -1))
+assert(math.ult(2, -1))
+assert(not math.ult(-2, -2))
+assert(math.ult(maxint, minint))
+assert(not math.ult(minint, maxint))
+
+
+assert(eq(math.sin(-9.8)^2 + math.cos(-9.8)^2, 1))
+assert(eq(math.tan(math.pi/4), 1))
+assert(eq(math.sin(math.pi/2), 1) and eq(math.cos(math.pi/2), 0))
+assert(eq(math.atan(1), math.pi/4) and eq(math.acos(0), math.pi/2) and
+       eq(math.asin(1), math.pi/2))
+assert(eq(math.deg(math.pi/2), 90) and eq(math.rad(90), math.pi/2))
+assert(math.abs(-10.43) == 10.43)
+assert(eqT(math.abs(minint), minint))
+assert(eqT(math.abs(maxint), maxint))
+assert(eqT(math.abs(-maxint), maxint))
+assert(eq(math.atan(1,0), math.pi/2))
+assert(math.fmod(10,3) == 1)
+assert(eq(math.sqrt(10)^2, 10))
+assert(eq(math.log(2, 10), math.log(2)/math.log(10)))
+assert(eq(math.log(2, 2), 1))
+assert(eq(math.log(9, 3), 2))
+assert(eq(math.exp(0), 1))
+assert(eq(math.sin(10), math.sin(10%(2*math.pi))))
+
+
+assert(tonumber(' 1.3e-2 ') == 1.3e-2)
+assert(tonumber(' -1.00000000000001 ') == -1.00000000000001)
+
+-- testing constant limits
+-- 2^23 = 8388608
+assert(8388609 + -8388609 == 0)
+assert(8388608 + -8388608 == 0)
+assert(8388607 + -8388607 == 0)
+
+
+
+do   -- testing floor & ceil
+  assert(eqT(math.floor(3.4), 3))
+  assert(eqT(math.ceil(3.4), 4))
+  assert(eqT(math.floor(-3.4), -4))
+  assert(eqT(math.ceil(-3.4), -3))
+  assert(eqT(math.floor(maxint), maxint))
+  assert(eqT(math.ceil(maxint), maxint))
+  assert(eqT(math.floor(minint), minint))
+  assert(eqT(math.floor(minint + 0.0), minint))
+  assert(eqT(math.ceil(minint), minint))
+  assert(eqT(math.ceil(minint + 0.0), minint))
+  assert(math.floor(1e50) == 1e50)
+  assert(math.ceil(1e50) == 1e50)
+  assert(math.floor(-1e50) == -1e50)
+  assert(math.ceil(-1e50) == -1e50)
+  for _, p in pairs{31,32,63,64} do
+    assert(math.floor(2^p) == 2^p)
+    assert(math.floor(2^p + 0.5) == 2^p)
+    assert(math.ceil(2^p) == 2^p)
+    assert(math.ceil(2^p - 0.5) == 2^p)
+  end
+  checkerror("number expected", math.floor, {})
+  checkerror("number expected", math.ceil, print)
+  assert(eqT(math.tointeger(minint), minint))
+  assert(eqT(math.tointeger(minint .. ""), minint))
+  assert(eqT(math.tointeger(maxint), maxint))
+  assert(eqT(math.tointeger(maxint .. ""), maxint))
+  assert(eqT(math.tointeger(minint + 0.0), minint))
+  assert(math.tointeger(0.0 - minint) == nil)
+  assert(math.tointeger(math.pi) == nil)
+  assert(math.tointeger(-math.pi) == nil)
+  assert(math.floor(math.huge) == math.huge)
+  assert(math.ceil(math.huge) == math.huge)
+  assert(math.tointeger(math.huge) == nil)
+  assert(math.floor(-math.huge) == -math.huge)
+  assert(math.ceil(-math.huge) == -math.huge)
+  assert(math.tointeger(-math.huge) == nil)
+  assert(math.tointeger("34.0") == 34)
+  assert(math.tointeger("34.3") == nil)
+  assert(math.tointeger({}) == nil)
+  assert(math.tointeger(0/0) == nil)    -- NaN
+end
+
+
+-- testing fmod for integers
+for i = -6, 6 do
+  for j = -6, 6 do
+    if j ~= 0 then
+      local mi = math.fmod(i, j)
+      local mf = math.fmod(i + 0.0, j)
+      assert(mi == mf)
+      assert(math.type(mi) == 'integer' and math.type(mf) == 'float')
+      if (i >= 0 and j >= 0) or (i <= 0 and j <= 0) or mi == 0 then
+        assert(eqT(mi, i % j))
+      end
+    end
+  end
+end
+assert(eqT(math.fmod(minint, minint), 0))
+assert(eqT(math.fmod(maxint, maxint), 0))
+assert(eqT(math.fmod(minint + 1, minint), minint + 1))
+assert(eqT(math.fmod(maxint - 1, maxint), maxint - 1))
+
+checkerror("zero", math.fmod, 3, 0)
+
+
+do    -- testing max/min
+  checkerror("value expected", math.max)
+  checkerror("value expected", math.min)
+  assert(eqT(math.max(3), 3))
+  assert(eqT(math.max(3, 5, 9, 1), 9))
+  assert(math.max(maxint, 10e60) == 10e60)
+  assert(eqT(math.max(minint, minint + 1), minint + 1))
+  assert(eqT(math.min(3), 3))
+  assert(eqT(math.min(3, 5, 9, 1), 1))
+  assert(math.min(3.2, 5.9, -9.2, 1.1) == -9.2)
+  assert(math.min(1.9, 1.7, 1.72) == 1.7)
+  assert(math.min(-10e60, minint) == -10e60)
+  assert(eqT(math.min(maxint, maxint - 1), maxint - 1))
+  assert(eqT(math.min(maxint - 2, maxint, maxint - 1), maxint - 2))
+end
+-- testing implicit convertions
+
+local a,b = '10', '20'
+assert(a*b == 200 and a+b == 30 and a-b == -10 and a/b == 0.5 and -b == -20)
+assert(a == '10' and b == '20')
+
+
+do
+  print("testing -0 and NaN")
+  local mz, z = -0.0, 0.0
+  assert(mz == z)
+  assert(1/mz < 0 and 0 < 1/z)
+  local a = {[mz] = 1}
+  assert(a[z] == 1 and a[mz] == 1)
+  a[z] = 2
+  assert(a[z] == 2 and a[mz] == 2)
+  local inf = math.huge * 2 + 1
+  mz, z = -1/inf, 1/inf
+  assert(mz == z)
+  assert(1/mz < 0 and 0 < 1/z)
+  local NaN = inf - inf
+  assert(NaN ~= NaN)
+  assert(not (NaN < NaN))
+  assert(not (NaN <= NaN))
+  assert(not (NaN > NaN))
+  assert(not (NaN >= NaN))
+  assert(not (0 < NaN) and not (NaN < 0))
+  local NaN1 = 0/0
+  assert(NaN ~= NaN1 and not (NaN <= NaN1) and not (NaN1 <= NaN))
+  local a = {}
+  assert(not pcall(rawset, a, NaN, 1))
+  assert(a[NaN] == nil)
+  a[1] = 1
+  assert(not pcall(rawset, a, NaN, 1))
+  assert(a[NaN] == nil)
+  -- strings with same binary representation as 0.0 (might create problems
+  -- for constant manipulation in the pre-compiler)
+  local a1, a2, a3, a4, a5 = 0, 0, "\0\0\0\0\0\0\0\0", 0, "\0\0\0\0\0\0\0\0"
+  assert(a1 == a2 and a2 == a4 and a1 ~= a3)
+  assert(a3 == a5)
+end
+
+
+print("testing 'math.random'")
+math.randomseed(0)
+
+do   -- test random for floats
+  local max = -math.huge
+  local min = math.huge
+  for i = 0, 20000 do
+    local t = math.random()
+    assert(0 <= t and t < 1)
+    max = math.max(max, t)
+    min = math.min(min, t)
+    if eq(max, 1, 0.001) and eq(min, 0, 0.001) then
+      goto ok
+    end
+  end
+  -- loop ended without satisfing condition
+  assert(false)
+ ::ok::
+end
+
+do
+  local function aux (p, lim)   -- test random for small intervals
+    local x1, x2
+    if #p == 1 then x1 = 1; x2 = p[1]
+    else x1 = p[1]; x2 = p[2]
+    end
+    local mark = {}; local count = 0   -- to check that all values appeared
+    for i = 0, lim or 2000 do
+      local t = math.random(table.unpack(p))
+      assert(x1 <= t and t <= x2)
+      if not mark[t] then  -- new value
+        mark[t] = true
+        count = count + 1
+      end
+      if count == x2 - x1 + 1 then   -- all values appeared; OK
+        goto ok
+      end
+    end
+    -- loop ended without satisfing condition
+    assert(false)
+   ::ok::
+  end
+
+  aux({-10,0})
+  aux({6})
+  aux({-10, 10})
+  aux({minint, minint})
+  aux({maxint, maxint})
+  aux({minint, minint + 9})
+  aux({maxint - 3, maxint})
+end
+
+do
+  local function aux(p1, p2)       -- test random for large intervals
+    local max = minint
+    local min = maxint
+    local n = 200
+    local mark = {}; local count = 0   -- to count how many different values
+    for _ = 1, n do
+      local t = math.random(p1, p2)
+      max = math.max(max, t)
+      min = math.min(min, t)
+      if not mark[t] then  -- new value
+        mark[t] = true
+        count = count + 1
+      end
+    end
+    -- at least 80% of values are different
+    assert(count >= n * 0.8)
+    -- min and max not too far from formal min and max
+    local diff = (p2 - p1) // 8
+    assert(min < p1 + diff and max > p2 - diff)
+  end
+  aux(0, maxint)
+  aux(1, maxint)
+  aux(minint, -1)
+  aux(minint // 2, maxint // 2)
+end
+
+for i=1,100 do
+  assert(math.random(maxint) > 0)
+  assert(math.random(minint, -1) < 0)
+end
+
+assert(not pcall(math.random, 1, 2, 3))    -- too many arguments
+
+-- empty interval
+assert(not pcall(math.random, minint + 1, minint))
+assert(not pcall(math.random, maxint, maxint - 1))
+assert(not pcall(math.random, maxint, minint))
+
+-- interval too large
+assert(not pcall(math.random, minint, 0))
+assert(not pcall(math.random, -1, maxint))
+assert(not pcall(math.random, minint // 2, maxint // 2 + 1))
+
+
+print('OK')
diff -urN rpm-5.4.15/lua/tests/nextvar.lua rpm-5.4-cvs/lua/tests/nextvar.lua
--- rpm-5.4.15/lua/tests/nextvar.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/nextvar.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,611 @@
+-- $Id: nextvar.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+print('testing tables, next, and for')
+
+local a = {}
+
+-- make sure table has lots of space in hash part
+for i=1,100 do a[i.."+"] = true end
+for i=1,100 do a[i.."+"] = nil end
+-- fill hash part with numeric indices testing size operator
+for i=1,100 do
+  a[i] = true
+  assert(#a == i)
+end
+
+-- testing ipairs
+local x = 0
+for k,v in ipairs{10,20,30;x=12} do
+  x = x + 1
+  assert(k == x and v == x * 10)
+end
+
+for _ in ipairs{x=12, y=24} do assert(nil) end
+
+-- test for 'false' x ipair
+x = false
+local i = 0
+for k,v in ipairs{true,false,true,false} do
+  i = i + 1
+  x = not x
+  assert(x == v)
+end
+assert(i == 4)
+
+-- iterator function is always the same
+assert(type(ipairs{}) == 'function' and ipairs{} == ipairs{})
+
+
+if not T then
+  (Message or print)
+    ('\n >>> testC not active: skipping tests for table sizes <<<\n')
+else --[
+-- testing table sizes
+
+local function log2 (x) return math.log(x, 2) end
+
+local function mp2 (n)   -- minimum power of 2 >= n
+  local mp = 2^math.ceil(log2(n))
+  assert(n == 0 or (mp/2 < n and n <= mp))
+  return mp
+end
+
+local function fb (n)
+  local r, nn = T.int2fb(n)
+  assert(r < 256)
+  return nn
+end
+
+-- test fb function
+local a = 1
+local lim = 2^30
+while a < lim do
+  local n = fb(a)
+  assert(a <= n and n <= a*1.125)
+  a = math.ceil(a*1.3)
+end
+
+ 
+local function check (t, na, nh)
+  local a, h = T.querytab(t)
+  if a ~= na or h ~= nh then
+    print(na, nh, a, h)
+    assert(nil)
+  end
+end
+
+
+-- testing C library sizes
+do
+  local s = 0
+  for _ in pairs(math) do s = s + 1 end
+  check(math, 0, mp2(s))
+end
+
+
+-- testing constructor sizes
+local lim = 40
+local s = 'return {'
+for i=1,lim do
+  s = s..i..','
+  local s = s
+  for k=0,lim do 
+    local t = load(s..'}')()
+    assert(#t == i)
+    check(t, fb(i), mp2(k))
+    s = string.format('%sa%d=%d,', s, k, k)
+  end
+end
+
+
+-- tests with unknown number of elements
+local a = {}
+for i=1,lim do a[i] = i end   -- build auxiliary table
+for k=0,lim do
+  local a = {table.unpack(a,1,k)}
+  assert(#a == k)
+  check(a, k, 0)
+  a = {1,2,3,table.unpack(a,1,k)}
+  check(a, k+3, 0)
+  assert(#a == k + 3)
+end
+
+
+-- testing tables dynamically built
+local lim = 130
+local a = {}; a[2] = 1; check(a, 0, 1)
+a = {}; a[0] = 1; check(a, 0, 1); a[2] = 1; check(a, 0, 2)
+a = {}; a[0] = 1; a[1] = 1; check(a, 1, 1)
+a = {}
+for i = 1,lim do
+  a[i] = 1
+  assert(#a == i)
+  check(a, mp2(i), 0)
+end
+
+a = {}
+for i = 1,lim do
+  a['a'..i] = 1
+  assert(#a == 0)
+  check(a, 0, mp2(i))
+end
+
+a = {}
+for i=1,16 do a[i] = i end
+check(a, 16, 0)
+do
+  for i=1,11 do a[i] = nil end
+  for i=30,50 do a[i] = nil end   -- force a rehash (?)
+  check(a, 0, 8)   -- only 5 elements in the table
+  a[10] = 1
+  for i=30,50 do a[i] = nil end   -- force a rehash (?)
+  check(a, 0, 8)   -- only 6 elements in the table
+  for i=1,14 do a[i] = nil end
+  for i=18,50 do a[i] = nil end   -- force a rehash (?)
+  check(a, 0, 4)   -- only 2 elements ([15] and [16])
+end
+
+-- reverse filling
+for i=1,lim do
+  local a = {}
+  for i=i,1,-1 do a[i] = i end   -- fill in reverse
+  check(a, mp2(i), 0)
+end
+
+-- size tests for vararg
+lim = 35
+function foo (n, ...)
+  local arg = {...}
+  check(arg, n, 0)
+  assert(select('#', ...) == n)
+  arg[n+1] = true
+  check(arg, mp2(n+1), 0)
+  arg.x = true
+  check(arg, mp2(n+1), 1)
+end
+local a = {}
+for i=1,lim do a[i] = true; foo(i, table.unpack(a)) end
+
+end  --]
+
+
+-- test size operation on empty tables
+assert(#{} == 0)
+assert(#{nil} == 0)
+assert(#{nil, nil} == 0)
+assert(#{nil, nil, nil} == 0)
+assert(#{nil, nil, nil, nil} == 0)
+print'+'
+
+
+local nofind = {}
+
+a,b,c = 1,2,3
+a,b,c = nil
+
+
+-- next uses always the same iteraction function
+assert(next{} == next{})
+
+local function find (name)
+  local n,v
+  while 1 do
+    n,v = next(_G, n)
+    if not n then return nofind end
+    assert(v ~= nil)
+    if n == name then return v end
+  end
+end
+
+local function find1 (name)
+  for n,v in pairs(_G) do
+    if n==name then return v end
+  end
+  return nil  -- not found
+end
+
+
+assert(print==find("print") and print == find1("print"))
+assert(_G["print"]==find("print"))
+assert(assert==find1("assert"))
+assert(nofind==find("return"))
+assert(not find1("return"))
+_G["ret" .. "urn"] = nil
+assert(nofind==find("return"))
+_G["xxx"] = 1
+assert(xxx==find("xxx"))
+
+-- invalid key to 'next'
+assert(string.find(select(2, pcall(next, {10,20}, 3)), "invalid key"))
+
+-- both 'pairs' and 'ipairs' need an argument
+assert(string.find(select(2, pcall(pairs)), "bad argument"))
+assert(string.find(select(2, pcall(ipairs)), "bad argument"))
+
+print('+')
+
+a = {}
+for i=0,10000 do
+  if math.fmod(i,10) ~= 0 then
+    a['x'..i] = i
+  end
+end
+
+n = {n=0}
+for i,v in pairs(a) do
+  n.n = n.n+1
+  assert(i and v and a[i] == v)
+end
+assert(n.n == 9000)
+a = nil
+
+do   -- clear global table
+  local a = {}
+  for n,v in pairs(_G) do a[n]=v end
+  for n,v in pairs(a) do
+    if not package.loaded[n] and type(v) ~= "function" and
+       not string.find(n, "^[%u_]") then
+     _G[n] = nil
+    end
+    collectgarbage()
+  end
+end
+
+
+-- 
+
+local function checknext (a)
+  local b = {}
+  do local k,v = next(a); while k do b[k] = v; k,v = next(a,k) end end
+  for k,v in pairs(b) do assert(a[k] == v) end
+  for k,v in pairs(a) do assert(b[k] == v) end
+end
+
+checknext{1,x=1,y=2,z=3}
+checknext{1,2,x=1,y=2,z=3}
+checknext{1,2,3,x=1,y=2,z=3}
+checknext{1,2,3,4,x=1,y=2,z=3}
+checknext{1,2,3,4,5,x=1,y=2,z=3}
+
+assert(#{} == 0)
+assert(#{[-1] = 2} == 0)
+assert(#{1,2,3,nil,nil} == 3)
+for i=0,40 do
+  local a = {}
+  for j=1,i do a[j]=j end
+  assert(#a == i)
+end
+
+-- 'maxn' is now deprecated, but it is easily defined in Lua
+function table.maxn (t)
+  local max = 0
+  for k in pairs(t) do
+    max = (type(k) == 'number') and math.max(max, k) or max
+  end
+  return max
+end
+
+assert(table.maxn{} == 0)
+assert(table.maxn{["1000"] = true} == 0)
+assert(table.maxn{["1000"] = true, [24.5] = 3} == 24.5)
+assert(table.maxn{[1000] = true} == 1000)
+assert(table.maxn{[10] = true, [100*math.pi] = print} == 100*math.pi)
+
+table.maxn = nil
+
+-- int overflow
+a = {}
+for i=0,50 do a[2^i] = true end
+assert(a[#a])
+
+print('+')
+
+
+-- erasing values
+local t = {[{1}] = 1, [{2}] = 2, [string.rep("x ", 4)] = 3,
+           [100.3] = 4, [4] = 5}
+
+local n = 0
+for k, v in pairs( t ) do
+  n = n+1
+  assert(t[k] == v)
+  t[k] = nil
+  collectgarbage()
+  assert(t[k] == nil)
+end
+assert(n == 5)
+
+
+local function test (a)
+  assert(not pcall(table.insert, a, 2, 20));
+  table.insert(a, 10); table.insert(a, 2, 20);
+  table.insert(a, 1, -1); table.insert(a, 40);
+  table.insert(a, #a+1, 50)
+  table.insert(a, 2, -2)
+  assert(not pcall(table.insert, a, 0, 20));
+  assert(not pcall(table.insert, a, #a + 2, 20));
+  assert(table.remove(a,1) == -1)
+  assert(table.remove(a,1) == -2)
+  assert(table.remove(a,1) == 10)
+  assert(table.remove(a,1) == 20)
+  assert(table.remove(a,1) == 40)
+  assert(table.remove(a,1) == 50)
+  assert(table.remove(a,1) == nil)
+  assert(table.remove(a) == nil)
+  assert(table.remove(a, #a) == nil)
+end
+
+a = {n=0, [-7] = "ban"}
+test(a)
+assert(a.n == 0 and a[-7] == "ban")
+
+a = {[-7] = "ban"};
+test(a)
+assert(a.n == nil and #a == 0 and a[-7] == "ban")
+
+a = {[-1] = "ban"}
+test(a)
+assert(#a == 0 and table.remove(a) == nil and a[-1] == "ban")
+
+a = {[0] = "ban"}
+assert(#a == 0 and table.remove(a) == "ban" and a[0] == nil)
+
+table.insert(a, 1, 10); table.insert(a, 1, 20); table.insert(a, 1, -1)
+assert(table.remove(a) == 10)
+assert(table.remove(a) == 20)
+assert(table.remove(a) == -1)
+assert(table.remove(a) == nil)
+
+a = {'c', 'd'}
+table.insert(a, 3, 'a')
+table.insert(a, 'b')
+assert(table.remove(a, 1) == 'c')
+assert(table.remove(a, 1) == 'd')
+assert(table.remove(a, 1) == 'a')
+assert(table.remove(a, 1) == 'b')
+assert(table.remove(a, 1) == nil)
+assert(#a == 0 and a.n == nil)
+
+a = {10,20,30,40}
+assert(table.remove(a, #a + 1) == nil)
+assert(not pcall(table.remove, a, 0))
+assert(a[#a] == 40)
+assert(table.remove(a, #a) == 40)
+assert(a[#a] == 30)
+assert(table.remove(a, 2) == 20)
+assert(a[#a] == 30 and #a == 2)
+
+do   -- testing table library with metamethods
+  local function test (proxy, t)
+    for i = 1, 10 do
+      table.insert(proxy, 1, i)
+    end
+    assert(#proxy == 10 and #t == 10)
+    for i = 1, 10 do
+      assert(t[i] == 11 - i)
+    end
+    table.sort(proxy)
+    for i = 1, 10 do
+      assert(t[i] == i and proxy[i] == i)
+    end
+    assert(table.concat(proxy, ",") == "1,2,3,4,5,6,7,8,9,10")
+    for i = 1, 8 do
+      assert(table.remove(proxy, 1) == i)
+    end
+    assert(#proxy == 2 and #t == 2)
+    local a, b, c = table.unpack(proxy)
+    assert(a == 9 and b == 10 and c == nil)
+  end
+
+  -- all virtual
+  local t = {}
+  local proxy = setmetatable({}, {
+    __len = function () return #t end,
+    __index = t,
+    __newindex = t,
+  })
+  test(proxy, t)
+
+  -- only __newindex
+  local count = 0
+  t = setmetatable({}, {
+    __newindex = function (t,k,v) count = count + 1; rawset(t,k,v) end})
+  test(t, t)
+  assert(count == 10)   -- after first 10, all other sets are not new
+
+  -- no __newindex
+  t = setmetatable({}, {
+    __index = function (_,k) return k + 1 end,
+    __len = function (_) return 5 end})
+  assert(table.concat(t, ";") == "2;3;4;5;6")
+
+end
+
+do
+  -- Test to ensure that, when there are no metamethods,
+  -- library uses raw access.
+  -- (tricky: assumes undocumented behavior that test for presence of
+  --  metamethods is done before getting the length of the table)
+  local t = setmetatable({}, {
+    -- once 'len' is called, only raw access will work
+    __len = function (t)
+              getmetatable(t).__index = error
+              getmetatable(t).__newindex = error
+              return 10
+            end
+  })
+  table.insert(t, 1, 10)  -- work
+  assert(rawget(t, 1) == 10)
+  assert(not pcall(table.insert, t, 20))  -- does not work any more
+
+  -- still does not work
+  assert(not pcall(table.sort, t, function (_,_) return false end))
+  -- reset access
+  getmetatable(t).__index = nil
+  getmetatable(t).__newindex = nil
+  -- now it works again
+  assert(pcall(table.sort, t, function (_,_) return false end))
+  -- not any more
+  assert(not pcall(table.sort, t, function (_,_) return false end))
+end
+      
+print('+')
+
+a = {}
+for i=1,1000 do
+  a[i] = i; a[i-1] = nil
+end
+assert(next(a,nil) == 1000 and next(a,1000) == nil)
+
+assert(next({}) == nil)
+assert(next({}, nil) == nil)
+
+for a,b in pairs{} do error"not here" end
+for i=1,0 do error'not here' end
+for i=0,1,-1 do error'not here' end
+a = nil; for i=1,1 do assert(not a); a=1 end; assert(a)
+a = nil; for i=1,1,-1 do assert(not a); a=1 end; assert(a)
+
+do
+  print("testing floats in numeric for")
+  local a
+  -- integer count
+  a = 0; for i=1, 1, 1 do a=a+1 end; assert(a==1)
+  a = 0; for i=10000, 1e4, -1 do a=a+1 end; assert(a==1)
+  a = 0; for i=1, 0.99999, 1 do a=a+1 end; assert(a==0)
+  a = 0; for i=9999, 1e4, -1 do a=a+1 end; assert(a==0)
+  a = 0; for i=1, 0.99999, -1 do a=a+1 end; assert(a==1)
+
+  -- float count
+  a = 0; for i=0, 0.999999999, 0.1 do a=a+1 end; assert(a==10)
+  a = 0; for i=1.0, 1, 1 do a=a+1 end; assert(a==1)
+  a = 0; for i=-1.5, -1.5, 1 do a=a+1 end; assert(a==1)
+  a = 0; for i=1e6, 1e6, -1 do a=a+1 end; assert(a==1)
+  a = 0; for i=1.0, 0.99999, 1 do a=a+1 end; assert(a==0)
+  a = 0; for i=99999, 1e5, -1.0 do a=a+1 end; assert(a==0)
+  a = 0; for i=1.0, 0.99999, -1 do a=a+1 end; assert(a==1)
+end
+
+-- conversion
+a = 0; for i="10","1","-2" do a=a+1 end; assert(a==5)
+
+do  -- checking types
+  local c
+  local function checkfloat (i)
+    assert(math.type(i) == "float")
+    c = c + 1
+  end
+
+  c = 0; for i = 1.0, 10 do checkfloat(i) end
+  assert(c == 10)
+
+  c = 0; for i = -1, -10, -1.0 do checkfloat(i) end
+  assert(c == 10)
+
+  local function checkint (i)
+    assert(math.type(i) == "integer")
+    c = c + 1
+  end
+
+  local m = math.maxinteger
+  c = 0; for i = m, m - 10, -1 do checkint(i) end
+  assert(c == 11)
+
+  c = 0; for i = 1, 10.9 do checkint(i) end
+  assert(c == 10)
+
+  c = 0; for i = 10, 0.001, -1 do checkint(i) end
+  assert(c == 10)
+
+  c = 0; for i = 1, "10.8" do checkint(i) end
+  assert(c == 10)
+
+  c = 0; for i = 9, "3.4", -1 do checkint(i) end
+  assert(c == 6)
+
+  c = 0; for i = 0, " -3.4  ", -1 do checkint(i) end
+  assert(c == 4)
+
+  c = 0; for i = 100, "96.3", -2 do checkint(i) end
+  assert(c == 2)
+
+  c = 0; for i = 1, math.huge do if i > 10 then break end; checkint(i) end
+  assert(c == 10)
+
+  c = 0; for i = -1, -math.huge, -1 do
+           if i < -10 then break end; checkint(i)
+          end
+  assert(c == 10)
+
+
+  for i = math.mininteger, -10e100 do assert(false) end
+  for i = math.maxinteger, 10e100, -1 do assert(false) end
+
+end
+
+collectgarbage()
+
+
+-- testing generic 'for'
+
+local function f (n, p)
+  local t = {}; for i=1,p do t[i] = i*10 end
+  return function (_,n)
+           if n > 0 then
+             n = n-1
+             return n, table.unpack(t)
+           end
+         end, nil, n
+end
+
+local x = 0
+for n,a,b,c,d in f(5,3) do
+  x = x+1
+  assert(a == 10 and b == 20 and c == 30 and d == nil)
+end
+assert(x == 5)
+
+
+
+-- testing __pairs and __ipairs metamethod
+a = {}
+do
+  local x,y,z = pairs(a)
+  assert(type(x) == 'function' and y == a and z == nil)
+end
+
+local function foo (e,i)
+  assert(e == a)
+  if i <= 10 then return i+1, i+2 end
+end
+
+local function foo1 (e,i)
+  i = i + 1
+  assert(e == a)
+  if i <= e.n then return i,a[i] end
+end
+
+setmetatable(a, {__pairs = function (x) return foo, x, 0 end})
+
+local i = 0
+for k,v in pairs(a) do
+  i = i + 1
+  assert(k == i and v == k+1)
+end
+
+a.n = 5
+a[3] = 30
+
+-- testing ipairs with metamethods
+a = {n=10}
+setmetatable(a, { __index = function (t,k)
+                     if k <= t.n then return k * 10 end 
+                  end})
+i = 0
+for k,v in ipairs(a) do
+  i = i + 1
+  assert(k == i and v == i * 10)
+end
+assert(i == a.n)
+
+print"OK"
diff -urN rpm-5.4.15/lua/tests/pm.lua rpm-5.4-cvs/lua/tests/pm.lua
--- rpm-5.4.15/lua/tests/pm.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/pm.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,358 @@
+-- $Id: pm.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+print('testing pattern matching')
+
+local function checkerror (msg, f, ...)
+  local s, err = pcall(f, ...)
+  assert(not s and string.find(err, msg))
+end
+
+
+function f(s, p)
+  local i,e = string.find(s, p)
+  if i then return string.sub(s, i, e) end
+end
+
+a,b = string.find('', '')    -- empty patterns are tricky
+assert(a == 1 and b == 0);
+a,b = string.find('alo', '')
+assert(a == 1 and b == 0)
+a,b = string.find('a\0o a\0o a\0o', 'a', 1)   -- first position
+assert(a == 1 and b == 1)
+a,b = string.find('a\0o a\0o a\0o', 'a\0o', 2)   -- starts in the midle
+assert(a == 5 and b == 7)
+a,b = string.find('a\0o a\0o a\0o', 'a\0o', 9)   -- starts in the midle
+assert(a == 9 and b == 11)
+a,b = string.find('a\0a\0a\0a\0\0ab', '\0ab', 2);  -- finds at the end
+assert(a == 9 and b == 11);
+a,b = string.find('a\0a\0a\0a\0\0ab', 'b')    -- last position
+assert(a == 11 and b == 11)
+assert(string.find('a\0a\0a\0a\0\0ab', 'b\0') == nil)   -- check ending
+assert(string.find('', '\0') == nil)
+assert(string.find('alo123alo', '12') == 4)
+assert(string.find('alo123alo', '^12') == nil)
+
+assert(string.match("aaab", ".*b") == "aaab")
+assert(string.match("aaa", ".*a") == "aaa")
+assert(string.match("b", ".*b") == "b")
+
+assert(string.match("aaab", ".+b") == "aaab")
+assert(string.match("aaa", ".+a") == "aaa")
+assert(not string.match("b", ".+b"))
+
+assert(string.match("aaab", ".?b") == "ab")
+assert(string.match("aaa", ".?a") == "aa")
+assert(string.match("b", ".?b") == "b")
+
+assert(f('aloALO', '%l*') == 'alo')
+assert(f('aLo_ALO', '%a*') == 'aLo')
+
+assert(f("  \n\r*&\n\r   xuxu  \n\n", "%g%g%g+") == "xuxu")
+
+assert(f('aaab', 'a*') == 'aaa');
+assert(f('aaa', '^.*$') == 'aaa');
+assert(f('aaa', 'b*') == '');
+assert(f('aaa', 'ab*a') == 'aa')
+assert(f('aba', 'ab*a') == 'aba')
+assert(f('aaab', 'a+') == 'aaa')
+assert(f('aaa', '^.+$') == 'aaa')
+assert(f('aaa', 'b+') == nil)
+assert(f('aaa', 'ab+a') == nil)
+assert(f('aba', 'ab+a') == 'aba')
+assert(f('a$a', '.$') == 'a')
+assert(f('a$a', '.%$') == 'a$')
+assert(f('a$a', '.$.') == 'a$a')
+assert(f('a$a', '$$') == nil)
+assert(f('a$b', 'a$') == nil)
+assert(f('a$a', '$') == '')
+assert(f('', 'b*') == '')
+assert(f('aaa', 'bb*') == nil)
+assert(f('aaab', 'a-') == '')
+assert(f('aaa', '^.-$') == 'aaa')
+assert(f('aabaaabaaabaaaba', 'b.*b') == 'baaabaaabaaab')
+assert(f('aabaaabaaabaaaba', 'b.-b') == 'baaab')
+assert(f('alo xo', '.o$') == 'xo')
+assert(f(' \n isto  assim', '%S%S*') == 'isto')
+assert(f(' \n isto  assim', '%S*$') == 'assim')
+assert(f(' \n isto  assim', '[a-z]*$') == 'assim')
+assert(f('um caracter ? extra', '[^%sa-z]') == '?')
+assert(f('', 'a?') == '')
+assert(f('', '?') == '')
+assert(f('bl', '?b?l?') == 'bl')
+assert(f('  bl', '?b?l?') == '')
+assert(f('aa', '^aa?a?a') == 'aa')
+assert(f(']]]b', '[^]]') == '')
+assert(f("0alo alo", "%x*") == "0a")
+assert(f("alo alo", "%C+") == "alo alo")
+print('+')
+
+
+function f1(s, p)
+  p = string.gsub(p, "%%([0-9])", function (s)
+        return "%" .. (tonumber(s)+1)
+       end)
+  p = string.gsub(p, "^(^?)", "%1()", 1)
+  p = string.gsub(p, "($?)$", "()%1", 1)
+  local t = {string.match(s, p)}
+  return string.sub(s, t[1], t[#t] - 1)
+end
+
+assert(f1('alo alx 123 b\0o b\0o', '(..*) %1') == "b\0o b\0o")
+assert(f1('axz123= 4= 4 34', '(.+)=(.*)=%2 %1') == '3= 4= 4 3')
+assert(f1('=======', '^(=*)=%1$') == '=======')
+assert(string.match('==========', '^([=]*)=%1$') == nil)
+
+local function range (i, j)
+  if i <= j then
+    return i, range(i+1, j)
+  end
+end
+
+local abc = string.char(range(0, 255));
+
+assert(string.len(abc) == 256)
+
+function strset (p)
+  local res = {s=''}
+  string.gsub(abc, p, function (c) res.s = res.s .. c end)
+  return res.s
+end;
+
+assert(string.len(strset('[\200-\210]')) == 11)
+
+assert(strset('[a-z]') == "abcdefghijklmnopqrstuvwxyz")
+assert(strset('[a-z%d]') == strset('[%da-uu-z]'))
+assert(strset('[a-]') == "-a")
+assert(strset('[^%W]') == strset('[%w]'))
+assert(strset('[]%%]') == '%]')
+assert(strset('[a%-z]') == '-az')
+assert(strset('[%^%[%-a%]%-b]') == '-[]^ab')
+assert(strset('%Z') == strset('[\1-\255]'))
+assert(strset('.') == strset('[\1-\255%z]'))
+print('+');
+
+assert(string.match("alo xyzK", "(%w+)K") == "xyz")
+assert(string.match("254 K", "(%d*)K") == "")
+assert(string.match("alo ", "(%w*)$") == "")
+assert(string.match("alo ", "(%w+)$") == nil)
+assert(string.find("(lo)", "%(") == 1)
+local a, b, c, d, e = string.match("lo alo", "^(((.).).* (%w*))$")
+assert(a == 'lo alo' and b == 'l' and c == '' and d == 'alo' and e == nil)
+a, b, c, d  = string.match('0123456789', '(.+(.?)())')
+assert(a == '0123456789' and b == '' and c == 11 and d == nil)
+print('+')
+
+assert(string.gsub('lo lo', '', 'x') == 'xlo xlo')
+assert(string.gsub('alo lo  ', ' +$', '') == 'alo lo')  -- trim
+assert(string.gsub('  alo alo  ', '^%s*(.-)%s*$', '%1') == 'alo alo')  -- double trim
+assert(string.gsub('alo  alo  \n 123\n ', '%s+', ' ') == 'alo alo 123 ')
+t = "ab d"
+a, b = string.gsub(t, '(.)', '%1@')
+assert('@'..a == string.gsub(t, '', '@') and b == 5)
+a, b = string.gsub('abd', '(.)', '%0@', 2)
+assert(a == 'a@b@d' and b == 2)
+assert(string.gsub('alo alo', '()[al]', '%1') == '12o 56o')
+assert(string.gsub("abc=xyz", "(%w*)(%p)(%w+)", "%3%2%1-%0") ==
+              "xyz=abc-abc=xyz")
+assert(string.gsub("abc", "%w", "%1%0") == "aabbcc")
+assert(string.gsub("abc", "%w+", "%0%1") == "abcabc")
+assert(string.gsub('', '$', '\0') == '\0')
+assert(string.gsub('', '^', 'r') == 'r')
+assert(string.gsub('', '$', 'r') == 'r')
+print('+')
+
+assert(string.gsub("um (dois) tres (quatro)", "(%(%w+%))", string.upper) ==
+            "um (DOIS) tres (QUATRO)")
+
+do
+  local function setglobal (n,v) rawset(_G, n, v) end
+  string.gsub("a=roberto,roberto=a", "(%w+)=(%w%w*)", setglobal)
+  assert(_G.a=="roberto" and _G.roberto=="a")
+end
+
+function f(a,b) return string.gsub(a,'.',b) end
+assert(string.gsub("trocar tudo em |teste|b|  |beleza|al|", "|([^|]*)|([^|]*)|", f) ==
+            "trocar tudo em bbbbb  alalalalalal")
+
+local function dostring (s) return load(s)() or "" end
+assert(string.gsub("alo $a='x'$ novamente $return a$",
+                   "$([^$]*)%$",
+                   dostring) == "alo  novamente x")
+
+x = string.gsub("$x=string.gsub('alo', '.', string.upper)$ assim vai para $return x$",
+         "$([^$]*)%$", dostring)
+assert(x == ' assim vai para ALO')
+
+t = {}
+s = 'a alo jose  joao'
+r = string.gsub(s, '()(%w+)()', function (a,w,b)
+      assert(string.len(w) == b-a);
+      t[a] = b-a;
+    end)
+assert(s == r and t[1] == 1 and t[3] == 3 and t[7] == 4 and t[13] == 4)
+
+
+function isbalanced (s)
+  return string.find(string.gsub(s, "%b()", ""), "[()]") == nil
+end
+
+assert(isbalanced("(9 ((8))(\0) 7) \0\0 a b ()(c)() a"))
+assert(not isbalanced("(9 ((8) 7) a b (\0 c) a"))
+assert(string.gsub("alo 'oi' alo", "%b''", '"') == 'alo " alo')
+
+
+local t = {"apple", "orange", "lime"; n=0}
+assert(string.gsub("x and x and x", "x", function () t.n=t.n+1; return t[t.n] end)
+        == "apple and orange and lime")
+
+t = {n=0}
+string.gsub("first second word", "%w%w*", function (w) t.n=t.n+1; t[t.n] = w end)
+assert(t[1] == "first" and t[2] == "second" and t[3] == "word" and t.n == 3)
+
+t = {n=0}
+assert(string.gsub("first second word", "%w+",
+         function (w) t.n=t.n+1; t[t.n] = w end, 2) == "first second word")
+assert(t[1] == "first" and t[2] == "second" and t[3] == nil)
+
+checkerror("invalid replacement value %(a table%)",
+            string.gsub, "alo", ".", {a = {}})
+checkerror("invalid capture index %%2", string.gsub, "alo", ".", "%2")
+checkerror("invalid capture index %%0", string.gsub, "alo", "(%0)", "a")
+checkerror("invalid capture index %%1", string.gsub, "alo", "(%1)", "a")
+checkerror("invalid use of '%%'", string.gsub, "alo", ".", "%x")
+
+-- bug since 2.5 (C-stack overflow)
+do
+  local function f (size)
+    local s = string.rep("a", size)
+    local p = string.rep(".?", size)
+    return pcall(string.match, s, p)
+  end
+  local r, m = f(80)
+  assert(r and #m == 80)
+  r, m = f(200000)
+  assert(not r and string.find(m, "too complex"))
+end
+
+if not _soft then
+  -- big strings
+  local a = string.rep('a', 300000)
+  assert(string.find(a, '^a*.?$'))
+  assert(not string.find(a, '^a*.?b$'))
+  assert(string.find(a, '^a-.?$'))
+
+  -- bug in 5.1.2
+  a = string.rep('a', 10000) .. string.rep('b', 10000)
+  assert(not pcall(string.gsub, a, 'b'))
+end
+
+-- recursive nest of gsubs
+function rev (s)
+  return string.gsub(s, "(.)(.+)", function (c,s1) return rev(s1)..c end)
+end
+
+local x = "abcdef"
+assert(rev(rev(x)) == x)
+
+
+-- gsub with tables
+assert(string.gsub("alo alo", ".", {}) == "alo alo")
+assert(string.gsub("alo alo", "(.)", {a="AA", l=""}) == "AAo AAo")
+assert(string.gsub("alo alo", "(.).", {a="AA", l="K"}) == "AAo AAo")
+assert(string.gsub("alo alo", "((.)(.?))", {al="AA", o=false}) == "AAo AAo")
+
+assert(string.gsub("alo alo", "().", {'x','yy','zzz'}) == "xyyzzz alo")
+
+t = {}; setmetatable(t, {__index = function (t,s) return string.upper(s) end})
+assert(string.gsub("a alo b hi", "%w%w+", t) == "a ALO b HI")
+
+
+-- tests for gmatch
+local a = 0
+for i in string.gmatch('abcde', '()') do assert(i == a+1); a=i end
+assert(a==6)
+
+t = {n=0}
+for w in string.gmatch("first second word", "%w+") do
+      t.n=t.n+1; t[t.n] = w
+end
+assert(t[1] == "first" and t[2] == "second" and t[3] == "word")
+
+t = {3, 6, 9}
+for i in string.gmatch ("xuxx uu ppar r", "()(.)%2") do
+  assert(i == table.remove(t, 1))
+end
+assert(#t == 0)
+
+t = {}
+for i,j in string.gmatch("13 14 10 = 11, 15= 16, 22=23", "(%d+)%s*=%s*(%d+)") do
+  t[tonumber(i)] = tonumber(j)
+end
+a = 0
+for k,v in pairs(t) do assert(k+1 == v+0); a=a+1 end
+assert(a == 3)
+
+
+-- tests for `%f' (`frontiers')
+
+assert(string.gsub("aaa aa a aaa a", "%f[%w]a", "x") == "xaa xa x xaa x")
+assert(string.gsub("[[]] [][] [[[[", "%f[[].", "x") == "x[]] x]x] x[[[")
+assert(string.gsub("01abc45de3", "%f[%d]", ".") == ".01abc.45de.3")
+assert(string.gsub("01abc45 de3x", "%f[%D]%w", ".") == "01.bc45 de3.")
+assert(string.gsub("function", "%f[\1-\255]%w", ".") == ".unction")
+assert(string.gsub("function", "%f[^\1-\255]", ".") == "function.")
+
+assert(string.find("a", "%f[a]") == 1)
+assert(string.find("a", "%f[^%z]") == 1)
+assert(string.find("a", "%f[^%l]") == 2)
+assert(string.find("aba", "%f[a%z]") == 3)
+assert(string.find("aba", "%f[%z]") == 4)
+assert(not string.find("aba", "%f[%l%z]"))
+assert(not string.find("aba", "%f[^%l%z]"))
+
+local i, e = string.find(" alo aalo allo", "%f[%S].-%f[%s].-%f[%S]")
+assert(i == 2 and e == 5)
+local k = string.match(" alo aalo allo", "%f[%S](.-%f[%s].-%f[%S])")
+assert(k == 'alo ')
+
+local a = {1, 5, 9, 14, 17,}
+for k in string.gmatch("alo alo th02 is 1hat", "()%f[%w%d]") do
+  assert(table.remove(a, 1) == k)
+end
+assert(#a == 0)
+
+
+-- malformed patterns
+local function malform (p, m)
+  m = m or "malformed"
+  local r, msg = pcall(string.find, "a", p)
+  assert(not r and string.find(msg, m))
+end
+
+malform("(.", "unfinished capture")
+malform(".)", "invalid pattern capture")
+malform("[a")
+malform("[]")
+malform("[^]")
+malform("[a%]")
+malform("[a%")
+malform("%b")
+malform("%ba")
+malform("%")
+malform("%f", "missing")
+
+-- \0 in patterns
+assert(string.match("ab\0\1\2c", "[\0-\2]+") == "\0\1\2")
+assert(string.match("ab\0\1\2c", "[\0-\0]+") == "\0")
+assert(string.find("b$a", "$\0?") == 2)
+assert(string.find("abc\0efg", "%\0") == 4)
+assert(string.match("abc\0efg\0\1e\1g", "%b\0\1") == "\0efg\0\1e\1")
+assert(string.match("abc\0\0\0", "%\0+") == "\0\0\0")
+assert(string.match("abc\0\0\0", "%\0%\0?") == "\0\0")
+
+-- magic char after \0
+assert(string.find("abc\0\0","\0.") == 4)
+assert(string.find("abcx\0\0abc\0abc","x\0\0abc\0a.") == 4)
+
+print('OK')
+
diff -urN rpm-5.4.15/lua/tests/sort.lua rpm-5.4-cvs/lua/tests/sort.lua
--- rpm-5.4.15/lua/tests/sort.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/sort.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,243 @@
+-- $Id: sort.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+print "testing (parts of) table library"
+
+print "testing unpack"
+
+local unpack = table.unpack
+
+
+local function checkerror (msg, f, ...)
+  local s, err = pcall(f, ...)
+  assert(not s and string.find(err, msg))
+end
+
+
+checkerror("wrong number of arguments", table.insert, {}, 2, 3, 4)
+
+local x,y,z,a,n
+a = {}; lim = _soft and 200 or 2000
+for i=1, lim do a[i]=i end
+assert(select(lim, unpack(a)) == lim and select('#', unpack(a)) == lim)
+x = unpack(a)
+assert(x == 1)
+x = {unpack(a)}
+assert(#x == lim and x[1] == 1 and x[lim] == lim)
+x = {unpack(a, lim-2)}
+assert(#x == 3 and x[1] == lim-2 and x[3] == lim)
+x = {unpack(a, 10, 6)}
+assert(next(x) == nil)   -- no elements
+x = {unpack(a, 11, 10)}
+assert(next(x) == nil)   -- no elements
+x,y = unpack(a, 10, 10)
+assert(x == 10 and y == nil)
+x,y,z = unpack(a, 10, 11)
+assert(x == 10 and y == 11 and z == nil)
+a,x = unpack{1}
+assert(a==1 and x==nil)
+a,x = unpack({1,2}, 1, 1)
+assert(a==1 and x==nil)
+
+do
+  local maxI = math.maxinteger
+  local minI = math.mininteger
+  local maxi = (1 << 31) - 1          -- maximum value for an int (usually)
+  local mini = -(1 << 31)             -- minimum value for an int (usually)
+  checkerror("too many results", unpack, {}, 0, maxi)
+  checkerror("too many results", unpack, {}, 1, maxi)
+  checkerror("too many results", unpack, {}, 0, maxI)
+  checkerror("too many results", unpack, {}, 1, maxI)
+  checkerror("too many results", unpack, {}, mini, maxi)
+  checkerror("too many results", unpack, {}, -maxi, maxi)
+  checkerror("too many results", unpack, {}, minI, maxI)
+  unpack({}, maxi, 0)
+  unpack({}, maxi, 1)
+  unpack({}, maxI, minI)
+  pcall(unpack, {}, 1, maxi + 1)
+  local a, b = unpack({[maxi] = 20}, maxi, maxi)
+  assert(a == 20 and b == nil)
+  a, b = unpack({[maxi] = 20}, maxi - 1, maxi)
+  assert(a == nil and b == 20)
+  local t = {[maxI - 1] = 12, [maxI] = 23}
+  a, b = unpack(t, maxI - 1, maxI); assert(a == 12 and b == 23)
+  a, b = unpack(t, maxI, maxI); assert(a == 23 and b == nil)
+  a, b = unpack(t, maxI, maxI - 1); assert(a == nil and b == nil)
+  t = {[minI] = 12.3, [minI + 1] = 23.5}
+  a, b = unpack(t, minI, minI + 1); assert(a == 12.3 and b == 23.5)
+  a, b = unpack(t, minI, minI); assert(a == 12.3 and b == nil)
+  a, b = unpack(t, minI + 1, minI); assert(a == nil and b == nil)
+end
+
+do   -- length is not an integer
+  local t = setmetatable({}, {__len = function () return 'abc' end})
+  assert(#t == 'abc')
+  checkerror("object length is not an integer", table.insert, t, 1)
+end
+
+print "testing pack"
+
+a = table.pack()
+assert(a[1] == nil and a.n == 0) 
+
+a = table.pack(table)
+assert(a[1] == table and a.n == 1)
+
+a = table.pack(nil, nil, nil, nil)
+assert(a[1] == nil and a.n == 4)
+
+
+-- testing move
+do
+  local function eqT (a, b)
+    for k, v in pairs(a) do assert(b[k] == v) end 
+    for k, v in pairs(b) do assert(a[k] == v) end 
+  end
+
+  local a = table.move({10,20,30}, 1, 3, 2)  -- move forward
+  eqT(a, {10,10,20,30})
+
+  a = table.move({10,20,30}, 2, 3, 1)   -- move backward
+  eqT(a, {20,30,30})
+
+  a = table.move({10,20,30}, 1, 3, 1, {})   -- move
+  eqT(a, {10,20,30})
+
+  a = table.move({10,20,30}, 1, 0, 3)   -- do not move
+  eqT(a, {10,20,30})
+
+  local max = math.maxinteger
+  a = table.move({[max - 2] = 1, [max - 1] = 2, [max] = 3},
+        max - 2, max, -10, {})
+  eqT(a, {[-10] = 1, [-9] = 2, [-8] = 3})
+
+  a = setmetatable({}, {
+        __index = function (_,k) return k * 10 end,
+        __newindex = error})
+  local b = table.move(a, 1, 10, 3, {})
+  eqT(a, {})
+  eqT(b, {nil,nil,10,20,30,40,50,60,70,80,90,100})
+
+  b = setmetatable({""}, {
+        __index = error,
+        __newindex = function (t,k,v)
+          t[1] = string.format("%s(%d,%d)", t[1], k, v)
+      end})
+  table.move(a, 10, 13, 3, b)
+  assert(b[1] == "(3,100)(4,110)(5,120)(6,130)")
+  local stat, msg = pcall(table.move, b, 10, 13, 3, b)
+  assert(not stat and msg == b)
+end
+
+checkerror("must be positive", table.move, {}, -1, 1, 1)
+
+print"testing sort"
+
+
+-- test checks for invalid order functions
+local function check (t)
+  local function f(a, b) assert(a and b); return true end
+  checkerror("invalid order function", table.sort, t, f)
+end
+
+check{1,2,3,4}
+check{1,2,3,4,5}
+check{1,2,3,4,5,6}
+
+
+function check (a, f)
+  f = f or function (x,y) return x<y end;
+  for n = #a, 2, -1 do
+    assert(not f(a[n], a[n-1]))
+  end
+end
+
+a = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
+     "Oct", "Nov", "Dec"}
+
+table.sort(a)
+check(a)
+
+function perm (s, n)
+  n = n or #s
+  if n == 1 then
+    local t = {unpack(s)}
+    table.sort(t)
+    check(t)
+  else
+    for i = 1, n do
+      s[i], s[n] = s[n], s[i]
+      perm(s, n - 1)
+      s[i], s[n] = s[n], s[i]
+    end
+  end
+end
+
+perm{}
+perm{1}
+perm{1,2}
+perm{1,2,3}
+perm{1,2,3,4}
+perm{2,2,3,4}
+perm{1,2,3,4,5}
+perm{1,2,3,3,5}
+perm{1,2,3,4,5,6}
+perm{2,2,3,3,5,6}
+
+limit = 30000
+if _soft then limit = 5000 end
+
+a = {}
+for i=1,limit do
+  a[i] = math.random()
+end
+
+local x = os.clock()
+table.sort(a)
+print(string.format("Sorting %d elements in %.2f sec.", limit, os.clock()-x))
+check(a)
+
+x = os.clock()
+table.sort(a)
+print(string.format("Re-sorting %d elements in %.2f sec.", limit, os.clock()-x))
+check(a)
+
+a = {}
+for i=1,limit do
+  a[i] = math.random()
+end
+
+x = os.clock(); i=0
+table.sort(a, function(x,y) i=i+1; return y<x end)
+print(string.format("Invert-sorting other %d elements in %.2f sec., with %i comparisons",
+      limit, os.clock()-x, i))
+check(a, function(x,y) return y<x end)
+
+
+table.sort{}  -- empty array
+
+for i=1,limit do a[i] = false end
+x = os.clock();
+table.sort(a, function(x,y) return nil end)
+print(string.format("Sorting %d equal elements in %.2f sec.", limit, os.clock()-x))
+check(a, function(x,y) return nil end)
+for i,v in pairs(a) do assert(not v or i=='n' and v==limit) end
+
+A = {"lo", "\0first :-)", "alo", "then this one", "45", "and a new"}
+table.sort(A)
+check(A)
+
+table.sort(A, function (x, y)
+          load(string.format("A[%q] = ''", x))()
+          collectgarbage()
+          return x<y
+        end)
+
+
+tt = {__lt = function (a,b) return a.val < b.val end}
+a = {}
+for i=1,10 do  a[i] = {val=math.random(100)}; setmetatable(a[i], tt); end
+table.sort(a)
+check(a, tt.__lt)
+check(a)
+
+print"OK"
diff -urN rpm-5.4.15/lua/tests/strings.lua rpm-5.4-cvs/lua/tests/strings.lua
--- rpm-5.4.15/lua/tests/strings.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/strings.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,314 @@
+-- $Id: strings.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+print('testing strings and string library')
+
+local maxi, mini = math.maxinteger, math.mininteger
+
+
+local function checkerror (msg, f, ...)
+  local s, err = pcall(f, ...)
+  assert(not s and string.find(err, msg))
+end
+
+
+-- testing string comparisons
+assert('alo' < 'alo1')
+assert('' < 'a')
+assert('alo\0alo' < 'alo\0b')
+assert('alo\0alo\0\0' > 'alo\0alo\0')
+assert('alo' < 'alo\0')
+assert('alo\0' > 'alo')
+assert('\0' < '\1')
+assert('\0\0' < '\0\1')
+assert('\1\0a\0a' <= '\1\0a\0a')
+assert(not ('\1\0a\0b' <= '\1\0a\0a'))
+assert('\0\0\0' < '\0\0\0\0')
+assert(not('\0\0\0\0' < '\0\0\0'))
+assert('\0\0\0' <= '\0\0\0\0')
+assert(not('\0\0\0\0' <= '\0\0\0'))
+assert('\0\0\0' <= '\0\0\0')
+assert('\0\0\0' >= '\0\0\0')
+assert(not ('\0\0b' < '\0\0a\0'))
+
+-- testing string.sub
+assert(string.sub("123456789",2,4) == "234")
+assert(string.sub("123456789",7) == "789")
+assert(string.sub("123456789",7,6) == "")
+assert(string.sub("123456789",7,7) == "7")
+assert(string.sub("123456789",0,0) == "")
+assert(string.sub("123456789",-10,10) == "123456789")
+assert(string.sub("123456789",1,9) == "123456789")
+assert(string.sub("123456789",-10,-20) == "")
+assert(string.sub("123456789",-1) == "9")
+assert(string.sub("123456789",-4) == "6789")
+assert(string.sub("123456789",-6, -4) == "456")
+assert(string.sub("123456789", mini, -4) == "123456")
+assert(string.sub("123456789", mini, maxi) == "123456789")
+assert(string.sub("123456789", mini, mini) == "")
+assert(string.sub("\000123456789",3,5) == "234")
+assert(("\000123456789"):sub(8) == "789")
+
+-- testing string.find
+assert(string.find("123456789", "345") == 3)
+a,b = string.find("123456789", "345")
+assert(string.sub("123456789", a, b) == "345")
+assert(string.find("1234567890123456789", "345", 3) == 3)
+assert(string.find("1234567890123456789", "345", 4) == 13)
+assert(string.find("1234567890123456789", "346", 4) == nil)
+assert(string.find("1234567890123456789", ".45", -9) == 13)
+assert(string.find("abcdefg", "\0", 5, 1) == nil)
+assert(string.find("", "") == 1)
+assert(string.find("", "", 1) == 1)
+assert(not string.find("", "", 2))
+assert(string.find('', 'aaa', 1) == nil)
+assert(('alo(.)alo'):find('(.)', 1, 1) == 4)
+
+assert(string.len("") == 0)
+assert(string.len("\0\0\0") == 3)
+assert(string.len("1234567890") == 10)
+
+assert(#"" == 0)
+assert(#"\0\0\0" == 3)
+assert(#"1234567890" == 10)
+
+-- testing string.byte/string.char
+assert(string.byte("a") == 97)
+assert(string.byte("\xe4") > 127)
+assert(string.byte(string.char(255)) == 255)
+assert(string.byte(string.char(0)) == 0)
+assert(string.byte("\0") == 0)
+assert(string.byte("\0\0alo\0x", -1) == string.byte('x'))
+assert(string.byte("ba", 2) == 97)
+assert(string.byte("\n\n", 2, -1) == 10)
+assert(string.byte("\n\n", 2, 2) == 10)
+assert(string.byte("") == nil)
+assert(string.byte("hi", -3) == nil)
+assert(string.byte("hi", 3) == nil)
+assert(string.byte("hi", 9, 10) == nil)
+assert(string.byte("hi", 2, 1) == nil)
+assert(string.char() == "")
+assert(string.char(0, 255, 0) == "\0\255\0")
+assert(string.char(0, string.byte("\xe4"), 0) == "\0\xe4\0")
+assert(string.char(string.byte("\xe4l\0u", 1, -1)) == "\xe4l\0u")
+assert(string.char(string.byte("\xe4l\0u", 1, 0)) == "")
+assert(string.char(string.byte("\xe4l\0u", -10, 100)) == "\xe4l\0u")
+
+assert(string.upper("ab\0c") == "AB\0C")
+assert(string.lower("\0ABCc%$") == "\0abcc%$")
+assert(string.rep('teste', 0) == '')
+assert(string.rep('ts\00t', 2) == 'ts\0tts\000t')
+assert(string.rep('', 10) == '')
+
+if string.packsize("i") == 4 then
+  -- result length would be 2^31 (int overflow)
+  checkerror("too large", string.rep, 'aa', (1 << 30))
+  checkerror("too large", string.rep, 'a', (1 << 30), ',')
+end
+
+-- repetitions with separator
+assert(string.rep('teste', 0, 'xuxu') == '')
+assert(string.rep('teste', 1, 'xuxu') == 'teste')
+assert(string.rep('\1\0\1', 2, '\0\0') == '\1\0\1\0\0\1\0\1')
+assert(string.rep('', 10, '.') == string.rep('.', 9))
+assert(not pcall(string.rep, "aa", maxi // 2))
+assert(not pcall(string.rep, "", maxi // 2, "aa"))
+
+assert(string.reverse"" == "")
+assert(string.reverse"\0\1\2\3" == "\3\2\1\0")
+assert(string.reverse"\0001234" == "4321\0")
+
+for i=0,30 do assert(string.len(string.rep('a', i)) == i) end
+
+assert(type(tostring(nil)) == 'string')
+assert(type(tostring(12)) == 'string')
+assert(string.find(tostring{}, 'table:'))
+assert(string.find(tostring(print), 'function:'))
+assert(#tostring('\0') == 1)
+assert(tostring(true) == "true")
+assert(tostring(false) == "false")
+assert(tostring(-1203) == "-1203")
+assert(tostring(1203.125) == "1203.125")
+assert(tostring(-0.5) == "-0.5")
+assert(tostring(-32767) == "-32767")
+if 2147483647 > 0 then   -- no overflow? (32 bits)
+  assert(tostring(-2147483647) == "-2147483647")
+end
+if 4611686018427387904 > 0 then   -- no overflow? (64 bits)
+  assert(tostring(4611686018427387904) == "4611686018427387904")
+  assert(tostring(-4611686018427387904) == "-4611686018427387904")
+end
+
+if tostring(0.0) == "0.0" then   -- "standard" coercion float->string
+  assert('' .. 12 == '12' and 12.0 .. '' == '12.0')
+  assert(tostring(-1203 + 0.0) == "-1203.0")
+else   -- compatible coercion
+  assert(tostring(0.0) == "0")
+  assert('' .. 12 == '12' and 12.0 .. '' == '12')
+  assert(tostring(-1203 + 0.0) == "-1203")
+end
+
+
+x = '"lo"\n\\'
+assert(string.format('%q%s', x, x) == '"\\"lo\\"\\\n\\\\""lo"\n\\')
+assert(string.format('%q', "\0") == [["\0"]])
+assert(load(string.format('return %q', x))() == x)
+x = "\0\1\0023\5\0009"
+assert(load(string.format('return %q', x))() == x)
+assert(string.format("\0%c\0%c%x\0", string.byte("\xe4"), string.byte("b"), 140) ==
+              "\0\xe4\0b8c\0")
+assert(string.format('') == "")
+assert(string.format("%c",34)..string.format("%c",48)..string.format("%c",90)..string.format("%c",100) ==
+       string.format("%c%c%c%c", 34, 48, 90, 100))
+assert(string.format("%s\0 is not \0%s", 'not be', 'be') == 'not be\0 is not \0be')
+assert(string.format("%%%d %010d", 10, 23) == "%10 0000000023")
+assert(tonumber(string.format("%f", 10.3)) == 10.3)
+x = string.format('"%-50s"', 'a')
+assert(#x == 52)
+assert(string.sub(x, 1, 4) == '"a  ')
+
+assert(string.format("-%.20s.20s", string.rep("%", 2000)) ==
+                     "-"..string.rep("%", 20)..".20s")
+assert(string.format('"-%20s.20s"', string.rep("%", 2000)) ==
+       string.format("%q", "-"..string.rep("%", 2000)..".20s"))
+
+-- format x tostring
+assert(string.format("%s %s", nil, true) == "nil true")
+assert(string.format("%s %.4s", false, true) == "false true")
+assert(string.format("%.3s %.3s", false, true) == "fal tru")
+local m = setmetatable({}, {__tostring = function () return "hello" end})
+assert(string.format("%s %.10s", m, m) == "hello hello")
+
+
+assert(string.format("%x", 0.0) == "0")
+assert(string.format("%02x", 0.0) == "00")
+assert(string.format("%08X", 4294967295) == "FFFFFFFF")
+assert(string.format("%+08d", 31501) == "+0031501")
+assert(string.format("%+08d", -30927) == "-0030927")
+
+
+-- longest number that can be formated
+local largefinite = (string.packsize("n") >= 8) and 1e308 or 1e38
+assert(string.len(string.format('%99.99f', -largefinite)) >= 100)
+
+
+-- testing large numbers for format
+do   -- assume at least 32 bits
+  local max, min = 0x7fffffff, -0x80000000    -- "large" for 32 bits
+  assert(string.sub(string.format("%8x", -1), -8) == "ffffffff")
+  assert(string.format("%x", max) == "7fffffff")
+  assert(string.sub(string.format("%x", min), -8) == "80000000")
+  assert(string.format("%d", max) ==  "2147483647")
+  assert(string.format("%d", min) == "-2147483648")
+  assert(string.format("%u", 0xffffffff) == "4294967295")
+  assert(string.format("%o", 0xABCD) == "125715")
+
+  max, min = 0x7fffffffffffffff, -0x8000000000000000
+  if max > 2.0^53 then  -- only for 64 bits
+    assert(string.format("%x", (2^52 | 0) - 1) == "fffffffffffff")
+    assert(string.format("0x%8X", 0x8f000003) == "0x8F000003")
+    assert(string.format("%d", 2^53) == "9007199254740992")
+    assert(string.format("%i", -2^53) == "-9007199254740992")
+    assert(string.format("%x", max) == "7fffffffffffffff")
+    assert(string.format("%x", min) == "8000000000000000")
+    assert(string.format("%d", max) ==  "9223372036854775807")
+    assert(string.format("%d", min) == "-9223372036854775808")
+    assert(string.format("%u", ~(-1 << 64)) == "18446744073709551615")
+    assert(tostring(1234567890123) == '1234567890123')
+  end
+end
+
+if not pcall(string.format, "%a", 0) then
+  (Message or print)("\n >>> format '%a' not available <<<\n")
+else
+  print("testing 'format %a %A'")
+  local s = string.format("%.2a", 0.5)
+  -- ISO C does not enforce a unique format...
+  assert(string.find(s, "^0x%x%.%x%xp[-+]%d$"))
+  assert(tonumber(s) == 0.5)
+  s = string.format("%.4A", -3)
+  assert(string.find(s, "^%-0X%x%.%x%x%x%xP[-+]%d$"))
+  assert(tonumber(s) == -3.0)
+  assert(tonumber(string.format("%A", 0x1fffff.0)) == 0X1.FFFFFP+20)
+  assert(tonumber(string.format("%.30a", -0.1)) == -0.1)
+  assert(tonumber(string.format("%a", -3^12)) == -3^12)
+end
+
+
+-- errors in format
+
+local function check (fmt, msg)
+  checkerror(msg, string.format, fmt, 10)
+end
+
+local aux = string.rep('0', 600)
+check("%100.3d", "too long")
+check("%1"..aux..".3d", "too long")
+check("%1.100d", "too long")
+check("%10.1"..aux.."004d", "too long")
+check("%t", "invalid option")
+check("%"..aux.."d", "repeated flags")
+check("%d %d", "no value")
+
+
+assert(load("return 1\n--comment without ending EOL")() == 1)
+
+
+assert(table.concat{} == "")
+assert(table.concat({}, 'x') == "")
+assert(table.concat({'\0', '\0\1', '\0\1\2'}, '.\0.') == "\0.\0.\0\1.\0.\0\1\2")
+local a = {}; for i=1,300 do a[i] = "xuxu" end
+assert(table.concat(a, "123").."123" == string.rep("xuxu123", 300))
+assert(table.concat(a, "b", 20, 20) == "xuxu")
+assert(table.concat(a, "", 20, 21) == "xuxuxuxu")
+assert(table.concat(a, "x", 22, 21) == "")
+assert(table.concat(a, "3", 299) == "xuxu3xuxu")
+assert(table.concat({}, "x", maxi, maxi - 1) == "")
+assert(table.concat({}, "x", mini + 1, mini) == "")
+assert(table.concat({}, "x", maxi, mini) == "")
+assert(table.concat({[maxi] = "alo"}, "x", maxi, maxi) == "alo")
+assert(table.concat({[maxi] = "alo", [maxi - 1] = "y"}, "-", maxi - 1, maxi)
+       == "y-alo")
+
+assert(not pcall(table.concat, {"a", "b", {}}))
+
+a = {"a","b","c"}
+assert(table.concat(a, ",", 1, 0) == "")
+assert(table.concat(a, ",", 1, 1) == "a")
+assert(table.concat(a, ",", 1, 2) == "a,b")
+assert(table.concat(a, ",", 2) == "b,c")
+assert(table.concat(a, ",", 3) == "c")
+assert(table.concat(a, ",", 4) == "")
+
+if not _port then
+
+  local locales = { "ptb", "ISO-8859-1", "pt_BR" }
+  local function trylocale (w)
+    for i = 1, #locales do
+      if os.setlocale(locales[i], w) then return true end
+    end
+    return false
+  end
+
+  if not trylocale("collate")  then
+    print("locale not supported")
+  else
+    assert("alo" < "lo" and "lo" < "amo")
+  end
+
+  if not trylocale("ctype") then
+    print("locale not supported")
+  else
+    assert(string.gsub("", "%a", "x") == "xxxxx")
+    assert(string.gsub("", "%l", "x") == "xx")
+    assert(string.gsub("", "%u", "x") == "xx")
+    assert(string.upper"{xuxu}o" == "{XUXU}O")
+  end
+
+  os.setlocale("C")
+  assert(os.setlocale() == 'C')
+  assert(os.setlocale(nil, "numeric") == 'C')
+
+end
+
+print('OK')
+
diff -urN rpm-5.4.15/lua/tests/time.txt rpm-5.4-cvs/lua/tests/time.txt
--- rpm-5.4.15/lua/tests/time.txt	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/time.txt	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1 @@
+9.239175
\ No newline at end of file
diff -urN rpm-5.4.15/lua/tests/tpack.lua rpm-5.4-cvs/lua/tests/tpack.lua
--- rpm-5.4.15/lua/tests/tpack.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/tpack.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,317 @@
+-- $Id: tpack.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+local pack = string.pack
+local packsize = string.packsize
+local unpack = string.unpack
+
+print "testing pack/unpack"
+
+-- maximum size for integers
+local NB = 16
+
+local sizeshort = packsize("h")
+local sizeint = packsize("i")
+local sizelong = packsize("l")
+local sizesize_t = packsize("T")
+local sizeLI = packsize("j")
+local sizefloat = packsize("f")
+local sizedouble = packsize("d")
+local sizenumber = packsize("n")
+local little = (pack("i2", 1) == "\1\0")
+local align = packsize("!xXi16")
+
+assert(1 <= sizeshort and sizeshort <= sizeint and sizeint <= sizelong and
+       sizefloat <= sizedouble)
+
+print("platform:")
+print(string.format(
+  "\tshort %d, int %d, long %d, size_t %d, float %d, double %d,\n\z
+   \tlua Integer %d, lua Number %d",
+   sizeshort, sizeint, sizelong, sizesize_t, sizefloat, sizedouble,
+   sizeLI, sizenumber))
+print("\t" .. (little and "little" or "big") .. " endian")
+print("\talignment: " .. align)
+
+
+-- check errors in arguments
+function checkerror (msg, f, ...)
+  local status, err = pcall(f, ...)
+  -- print(status, err, msg)
+  assert(not status and string.find(err, msg))
+end
+
+-- minimum behavior for integer formats
+assert(unpack("B", pack("B", 0xff)) == 0xff)
+assert(unpack("b", pack("b", 0x7f)) == 0x7f)
+assert(unpack("b", pack("b", -0x80)) == -0x80)
+
+assert(unpack("H", pack("H", 0xffff)) == 0xffff)
+assert(unpack("h", pack("h", 0x7fff)) == 0x7fff)
+assert(unpack("h", pack("h", -0x8000)) == -0x8000)
+
+assert(unpack("L", pack("L", 0xffffffff)) == 0xffffffff)
+assert(unpack("l", pack("l", 0x7fffffff)) == 0x7fffffff)
+assert(unpack("l", pack("l", -0x80000000)) == -0x80000000)
+
+
+for i = 1, NB do
+  -- small numbers with signal extension ("\xFF...")
+  local s = string.rep("\xff", i)
+  assert(pack("i" .. i, -1) == s)
+  assert(packsize("i" .. i) == #s)
+  assert(unpack("i" .. i, s) == -1)
+
+  -- small unsigned number ("\0...\xAA")
+  s = "\xAA" .. string.rep("\0", i - 1)
+  assert(pack("<I" .. i, 0xAA) == s)
+  assert(unpack("<I" .. i, s) == 0xAA)
+  assert(pack(">I" .. i, 0xAA) == s:reverse())
+  assert(unpack(">I" .. i, s:reverse()) == 0xAA)
+end
+
+do
+  local lnum = 0x13121110090807060504030201
+  local s = pack("<j", lnum)
+  assert(unpack("<j", s) == lnum)
+  assert(unpack("<i" .. sizeLI + 1, s .. "\0") == lnum)
+  assert(unpack("<i" .. sizeLI + 1, s .. "\0") == lnum)
+
+  for i = sizeLI + 1, NB do
+    local s = pack("<j", -lnum)
+    assert(unpack("<j", s) == -lnum)
+    -- strings with (correct) extra bytes
+    assert(unpack("<i" .. i, s .. ("\xFF"):rep(i - sizeLI)) == -lnum)
+    assert(unpack(">i" .. i, ("\xFF"):rep(i - sizeLI) .. s:reverse()) == -lnum)
+    assert(unpack("<I" .. i, s .. ("\0"):rep(i - sizeLI)) == -lnum)
+
+    -- overflows
+    checkerror("does not fit", unpack, "<I" .. i, ("\x00"):rep(i - 1) .. "\1")
+    checkerror("does not fit", unpack, ">i" .. i, "\1" .. ("\x00"):rep(i - 1))
+  end
+end
+
+for i = 1, sizeLI do
+  local lstr = "\1\2\3\4\5\6\7\8\9\10\11\12\13"
+  local lnum = 0x13121110090807060504030201
+  local n = lnum & (~(-1 << (i * 8)))
+  local s = string.sub(lstr, 1, i)
+  assert(pack("<i" .. i, n) == s)
+  assert(pack(">i" .. i, n) == s:reverse())
+  assert(unpack(">i" .. i, s:reverse()) == n)
+end
+
+-- sign extension
+do
+  local u = 0xf0
+  for i = 1, sizeLI - 1 do
+    assert(unpack("<i"..i, "\xf0"..("\xff"):rep(i - 1)) == -16)
+    assert(unpack(">I"..i, "\xf0"..("\xff"):rep(i - 1)) == u)
+    u = u * 256 + 0xff
+  end
+end
+
+-- mixed endianness
+do
+  assert(pack(">i2 <i2", 10, 20) == "\0\10\20\0")
+  local a, b = unpack("<i2 >i2", "\10\0\0\20")
+  assert(a == 10 and b == 20)
+  assert(pack("=i4", 2001) == pack("i4", 2001))
+end
+
+print("testing invalid formats")
+
+checkerror("out of limits", pack, "i0", 0)
+checkerror("out of limits", pack, "i" .. NB + 1, 0)
+checkerror("out of limits", pack, "!" .. NB + 1, 0)
+checkerror("%(17%) out of limits %[1,16%]", pack, "Xi" .. NB + 1)
+checkerror("invalid format option 'r'", pack, "i3r", 0)
+checkerror("16%-byte integer", unpack, "i16", string.rep('\3', 16))
+checkerror("not power of 2", pack, "!4i3", 0);
+checkerror("missing size", pack, "c", "")
+checkerror("variable%-length format", packsize, "s")
+checkerror("variable%-length format", packsize, "z")
+
+-- overflow in option size  (error will be in digit after limit)
+checkerror("invalid format", packsize, "c1" .. string.rep("0", 40))
+
+if packsize("i") == 4 then
+  -- result would be 2^31  (2^3 repetitions of 2^28 strings)
+  local s = string.rep("c268435456", 2^3)
+  checkerror("too large", packsize, s)
+  -- one less is OK
+  s = string.rep("c268435456", 2^3 - 1) .. "c268435455"
+  assert(packsize(s) == 0x7fffffff)
+end
+
+-- overflow in packing
+for i = 1, sizeLI - 1 do
+  local umax = (1 << (i * 8)) - 1
+  local max = umax >> 1
+  local min = ~max
+  checkerror("overflow", pack, "<I" .. i, -1)
+  checkerror("overflow", pack, "<I" .. i, min)
+  checkerror("overflow", pack, ">I" .. i, umax + 1)
+
+  checkerror("overflow", pack, ">i" .. i, umax)
+  checkerror("overflow", pack, ">i" .. i, max + 1)
+  checkerror("overflow", pack, "<i" .. i, min - 1)
+
+  assert(unpack(">i" .. i, pack(">i" .. i, max)) == max)
+  assert(unpack("<i" .. i, pack("<i" .. i, min)) == min)
+  assert(unpack(">I" .. i, pack(">I" .. i, umax)) == umax)
+end
+
+-- Lua integer size
+assert(unpack(">j", pack(">j", math.maxinteger)) == math.maxinteger)
+assert(unpack("<j", pack("<j", math.mininteger)) == math.mininteger)
+assert(unpack("<J", pack("<j", -1)) == -1)   -- maximum unsigned integer
+
+if little then
+  assert(pack("f", 24) == pack("<f", 24))
+else
+  assert(pack("f", 24) == pack(">f", 24))
+end
+
+print "testing pack/unpack of floating-point numbers" 
+
+for _, n in ipairs{0, -1.1, 1.9, 1/0, -1/0, 1e20, -1e20, 0.1, 2000.7} do
+    assert(unpack("n", pack("n", n)) == n)
+    assert(unpack("<n", pack("<n", n)) == n)
+    assert(unpack(">n", pack(">n", n)) == n)
+    assert(pack("<f", n) == pack(">f", n):reverse())
+    assert(pack(">d", n) == pack("<d", n):reverse())
+end
+
+-- for non-native precisions, test only with "round" numbers
+for _, n in ipairs{0, -1.5, 1/0, -1/0, 1e10, -1e9, 0.5, 2000.25} do
+  assert(unpack("<f", pack("<f", n)) == n)
+  assert(unpack(">f", pack(">f", n)) == n)
+  assert(unpack("<d", pack("<d", n)) == n)
+  assert(unpack(">d", pack(">d", n)) == n)
+end
+
+print "testing pack/unpack of strings"
+do
+  local s = string.rep("abc", 1000)
+  assert(pack("zB", s, 247) == s .. "\0\xF7")
+  local s1, b = unpack("zB", s .. "\0\xF9")
+  assert(b == 249 and s1 == s)
+  s1 = pack("s", s)
+  assert(unpack("s", s1) == s)
+
+  checkerror("does not fit", pack, "s1", s)
+
+  checkerror("contains zeros", pack, "z", "alo\0");
+
+  for i = 2, NB do
+    local s1 = pack("s" .. i, s)
+    assert(unpack("s" .. i, s1) == s and #s1 == #s + i)
+  end
+end
+
+do
+  local x = pack("s", "alo")
+  checkerror("too short", unpack, "s", x:sub(1, -2))
+  checkerror("too short", unpack, "c5", "abcd")
+  checkerror("out of limits", pack, "s100", "alo")
+end
+
+do
+  assert(pack("c0", "") == "")
+  assert(packsize("c0") == 0)
+  assert(unpack("c0", "") == "")
+  assert(pack("<! c3", "abc") == "abc")
+  assert(packsize("<! c3") == 3)
+  assert(pack(">!4 c6", "abcdef") == "abcdef")
+  checkerror("wrong length", pack, "c3", "ab")
+  checkerror("2", pack, "c5", "123456")
+  local a, b, c = unpack("!4 z c3", "abcdefghi\0xyz")
+  assert(a == "abcdefghi" and b == "xyz" and c == 14)
+end
+
+
+-- testing multiple types and sequence
+do
+  local x = pack("<b h b f d f n i", 1, 2, 3, 4, 5, 6, 7, 8)
+  assert(#x == packsize("<b h b f d f n i"))
+  local a, b, c, d, e, f, g, h = unpack("<b h b f d f n i", x)
+  assert(a == 1 and b == 2 and c == 3 and d == 4 and e == 5 and f == 6 and
+         g == 7 and h == 8) 
+end
+
+print "testing alignment"
+do
+  assert(pack(" < i1 i2 ", 2, 3) == "\2\3\0")   -- no alignment by default
+  local x = pack(">!8 b Xh i4 i8 c1 Xi8", -12, 100, 200, "\xEC")
+  assert(#x == packsize(">!8 b Xh i4 i8 c1 Xi8"))
+  assert(x == "\xf4" .. "\0\0\0" ..
+              "\0\0\0\100" ..
+              "\0\0\0\0\0\0\0\xC8" .. 
+              "\xEC" .. "\0\0\0\0\0\0\0")
+  local a, b, c, d, pos = unpack(">!8 c1 Xh i4 i8 b Xi8 XI XH", x)
+  assert(a == "\xF4" and b == 100 and c == 200 and d == -20 and (pos - 1) == #x)
+
+  x = pack(">!4 c3 c4 c2 z i4 c5 c2 Xi4",
+                  "abc", "abcd", "xz", "hello", 5, "world", "xy")
+  assert(x == "abcabcdxzhello\0\0\0\0\0\5worldxy\0")
+  local a, b, c, d, e, f, g, pos = unpack(">!4 c3 c4 c2 z i4 c5 c2 Xh Xi4", x)
+  assert(a == "abc" and b == "abcd" and c == "xz" and d == "hello" and
+         e == 5 and f == "world" and g == "xy" and (pos - 1) % 4 == 0)
+
+  x = pack(" b b Xd b Xb x", 1, 2, 3)
+  assert(packsize(" b b Xd b Xb x") == 4)
+  assert(x == "\1\2\3\0")
+  a, b, c, pos = unpack("bbXdb", x)
+  assert(a == 1 and b == 2 and c == 3 and pos == #x)
+
+  -- only alignment
+  assert(packsize("!8 xXi8") == 8)
+  local pos = unpack("!8 xXi8", "0123456701234567"); assert(pos == 9)
+  assert(packsize("!8 xXi2") == 2)
+  local pos = unpack("!8 xXi2", "0123456701234567"); assert(pos == 3)
+  assert(packsize("!2 xXi2") == 2)
+  local pos = unpack("!2 xXi2", "0123456701234567"); assert(pos == 3)
+  assert(packsize("!2 xXi8") == 2)
+  local pos = unpack("!2 xXi8", "0123456701234567"); assert(pos == 3)
+  assert(packsize("!16 xXi16") == 16)
+  local pos = unpack("!16 xXi16", "0123456701234567"); assert(pos == 17)
+
+  checkerror("invalid next option", pack, "X")
+  checkerror("invalid next option", unpack, "XXi", "")
+  checkerror("invalid next option", unpack, "X i", "")
+  checkerror("invalid next option", pack, "Xc1")
+end
+
+do    -- testing initial position
+  local x = pack("i4i4i4i4", 1, 2, 3, 4)
+  for pos = 1, 16, 4 do
+    local i, p = unpack("i4", x, pos)
+    assert(i == pos//4 + 1 and p == pos + 4)
+  end
+
+  -- with alignment
+  for pos = 0, 12 do    -- will always round position to power of 2
+    local i, p = unpack("!4 i4", x, pos + 1)
+    assert(i == (pos + 3)//4 + 1 and p == i*4 + 1)
+  end
+
+  -- negative indices
+  local i, p = unpack("!4 i4", x, -4)
+  assert(i == 4 and p == 17)
+  local i, p = unpack("!4 i4", x, -7)
+  assert(i == 4 and p == 17)
+  local i, p = unpack("!4 i4", x, -#x)
+  assert(i == 1 and p == 5)
+
+  -- limits
+  for i = 1, #x + 1 do
+    assert(unpack("c0", x, i) == "")
+  end
+  checkerror("out of string", unpack, "c0", x, 0)
+  checkerror("out of string", unpack, "c0", x, #x + 2)
+  checkerror("out of string", unpack, "c0", x, -(#x + 1))
+ 
+end
+
+print "OK"
+
diff -urN rpm-5.4.15/lua/tests/utf8.lua rpm-5.4-cvs/lua/tests/utf8.lua
--- rpm-5.4.15/lua/tests/utf8.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/utf8.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,209 @@
+-- $Id: utf8.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+print "testing UTF-8 library"
+
+local utf8 = require'utf8'
+
+
+local function checkerror (msg, f, ...)
+  local s, err = pcall(f, ...)
+  assert(not s and string.find(err, msg))
+end
+
+
+local function len (s)
+  return #string.gsub(s, "[\x80-\xBF]", "")
+end
+
+
+local justone = "^" .. utf8.charpattern .. "$"
+
+-- 't' is the list of codepoints of 's'
+local function checksyntax (s, t)
+  local ts = {"return '"}
+  for i = 1, #t do ts[i + 1] = string.format("\\u{%x}", t[i]) end
+  ts[#t + 2] = "'"
+  ts = table.concat(ts)
+  assert(assert(load(ts))() == s)
+end
+
+assert(utf8.offset("alo", 5) == nil)
+assert(utf8.offset("alo", -4) == nil)
+
+-- 't' is the list of codepoints of 's'
+local function check (s, t)
+  local l = utf8.len(s) 
+  assert(#t == l and len(s) == l)
+  assert(utf8.char(table.unpack(t)) == s)
+
+  assert(utf8.offset(s, 0) == 1)
+
+  checksyntax(s, t)
+
+  local t1 = {utf8.codepoint(s, 1, -1)}
+  assert(#t == #t1)
+  for i = 1, #t do assert(t[i] == t1[i]) end
+
+  for i = 1, l do
+    local pi = utf8.offset(s, i)        -- position of i-th char
+    local pi1 = utf8.offset(s, 2, pi)   -- position of next char
+    assert(string.find(string.sub(s, pi, pi1 - 1), justone))
+    assert(utf8.offset(s, -1, pi1) == pi)
+    assert(utf8.offset(s, i - l - 1) == pi)
+    assert(pi1 - pi == #utf8.char(utf8.codepoint(s, pi)))
+    for j = pi, pi1 - 1 do 
+      assert(utf8.offset(s, 0, j) == pi)
+    end
+    for j = pi + 1, pi1 - 1 do
+      assert(not utf8.len(s, j))
+    end
+   assert(utf8.len(s, pi, pi) == 1)
+   assert(utf8.len(s, pi, pi1 - 1) == 1)
+   assert(utf8.len(s, pi) == l - i + 1)
+   assert(utf8.len(s, pi1) == l - i)
+   assert(utf8.len(s, 1, pi) == i)
+  end
+
+  local i = 0
+  for p, c in utf8.codes(s) do
+    i = i + 1
+    assert(c == t[i] and p == utf8.offset(s, i))
+    assert(utf8.codepoint(s, p) == c)
+  end
+  assert(i == #t)
+
+  i = 0
+  for p, c in utf8.codes(s) do
+    i = i + 1
+    assert(c == t[i] and p == utf8.offset(s, i)) 
+  end
+  assert(i == #t)
+
+  i = 0
+  for c in string.gmatch(s, utf8.charpattern) do
+    i = i + 1
+    assert(c == utf8.char(t[i]))
+  end
+  assert(i == #t)
+
+  for i = 1, l do
+    assert(utf8.offset(s, i) == utf8.offset(s, i - l - 1, #s + 1))
+  end
+
+end
+
+
+do    -- error indication in utf8.len
+  local function check (s, p)
+    local a, b = utf8.len(s)
+    assert(not a and b == p)
+  end
+  check("abc\xE3def", 4)
+  check("\x80", #("") + 1)
+  check("\xF4\x9F\xBF", 1)
+  check("\xF4\x9F\xBF\xBF", 1)
+end
+
+-- error in utf8.codes
+checkerror("invalid UTF%-8 code",
+  function ()
+    local s = "ab\xff"
+    for c in utf8.codes(s) do assert(c) end
+  end)
+
+
+-- error in initial position for offset
+checkerror("position out of range", utf8.offset, "abc", 1, 5)
+checkerror("position out of range", utf8.offset, "abc", 1, -4)
+checkerror("position out of range", utf8.offset, "", 1, 2)
+checkerror("position out of range", utf8.offset, "", 1, -1)
+checkerror("continuation byte", utf8.offset, "", 1, 2)
+checkerror("continuation byte", utf8.offset, "", 1, 2)
+checkerror("continuation byte", utf8.offset, "\x80", 1)
+
+
+
+local s = "hello World"
+local t = {string.byte(s, 1, -1)}
+for i = 1, utf8.len(s) do assert(t[i] == string.byte(s, i)) end
+check(s, t)
+
+check("/", {27721, 23383, 47, 28450, 23383,})
+
+do
+  local s = "\128"
+  local t = {utf8.codepoint(s,1,#s - 1)}
+  assert(#t == 3 and t[1] == 225 and t[2] == 233 and t[3] == 237)
+  checkerror("invalid UTF%-8 code", utf8.codepoint, s, 1, #s)
+  checkerror("out of range", utf8.codepoint, s, #s + 1)
+  t = {utf8.codepoint(s, 4, 3)}
+  assert(#t == 0)
+  checkerror("out of range", utf8.codepoint, s, -(#s + 1), 1)
+  checkerror("out of range", utf8.codepoint, s, 1, #s + 1)
+end
+
+assert(utf8.char() == "")
+assert(utf8.char(97, 98, 99) == "abc")
+
+assert(utf8.codepoint(utf8.char(0x10FFFF)) == 0x10FFFF)
+
+checkerror("value out of range", utf8.char, 0x10FFFF + 1)
+
+local function invalid (s)
+  checkerror("invalid UTF%-8 code", utf8.codepoint, s)
+  assert(not utf8.len(s))
+end
+
+-- UTF-8 representation for 0x11ffff (value out of valid range)
+invalid("\xF4\x9F\xBF\xBF")
+
+-- overlong sequences
+invalid("\xC0\x80")          -- zero
+invalid("\xC1\xBF")          -- 0x7F (should be coded in 1 byte)
+invalid("\xE0\x9F\xBF")      -- 0x7FF (should be coded in 2 bytes)
+invalid("\xF0\x8F\xBF\xBF")  -- 0xFFFF (should be coded in 3 bytes)
+
+
+-- invalid bytes
+invalid("\x80")  -- continuation byte
+invalid("\xBF")  -- continuation byte
+invalid("\xFE")  -- invalid byte
+invalid("\xFF")  -- invalid byte
+
+
+-- empty string
+check("", {})
+
+-- minimum and maximum values for each sequence size
+s = "\0 \x7F\z
+     \xC2\x80 \xDF\xBF\z
+     \xE0\xA0\x80 \xEF\xBF\xBF\z
+     \xF0\x90\x80\x80  \xF4\x8F\xBF\xBF"
+s = string.gsub(s, " ", "")
+check(s, {0,0x7F, 0x80,0x7FF, 0x800,0xFFFF, 0x10000,0x10FFFF})
+
+x = "a-4\0"
+check(x, {26085, 26412, 35486, 97, 45, 52, 0, 233, 243})
+
+
+-- Supplementary Characters
+check("ab",
+      {0x23CB7, 0x2070E, 0x20C53, 0x2107B, 0x20D7C, 0x61, 0x62, 0x20EA2,})
+
+check("\xF4\x8F\xBF\xBF",
+      {0x28CCA, 0x29D98, 0x269FA, 0x28CD2, 0x2512B, 0x244D3, 0x10ffff})
+
+
+local i = 0
+for p, c in string.gmatch(x, "()(" .. utf8.charpattern .. ")") do
+  i = i + 1
+  assert(utf8.offset(x, i) == p)
+  assert(utf8.len(x, p) == utf8.len(x) - i + 1)
+  assert(utf8.len(c) == 1)
+  for j = 1, #c - 1 do
+    assert(utf8.offset(x, 0, p + j - 1) == p)
+  end
+end
+
+print'ok'
+
diff -urN rpm-5.4.15/lua/tests/vararg.lua rpm-5.4-cvs/lua/tests/vararg.lua
--- rpm-5.4.15/lua/tests/vararg.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/vararg.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,143 @@
+-- $Id: vararg.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+print('testing vararg')
+
+_G.arg = nil
+
+function f(a, ...)
+  local arg = {n = select('#', ...), ...}
+  for i=1,arg.n do assert(a[i]==arg[i]) end
+  return arg.n
+end
+
+function c12 (...)
+  assert(arg == nil)
+  local x = {...}; x.n = #x
+  local res = (x.n==2 and x[1] == 1 and x[2] == 2)
+  if res then res = 55 end
+  return res, 2
+end
+
+function vararg (...) return {n = select('#', ...), ...} end
+
+local call = function (f, args) return f(table.unpack(args, 1, args.n)) end
+
+assert(f() == 0)
+assert(f({1,2,3}, 1, 2, 3) == 3)
+assert(f({"alo", nil, 45, f, nil}, "alo", nil, 45, f, nil) == 5)
+
+assert(c12(1,2)==55)
+a,b = assert(call(c12, {1,2}))
+assert(a == 55 and b == 2)
+a = call(c12, {1,2;n=2})
+assert(a == 55 and b == 2)
+a = call(c12, {1,2;n=1})
+assert(not a)
+assert(c12(1,2,3) == false)
+local a = vararg(call(next, {_G,nil;n=2}))
+local b,c = next(_G)
+assert(a[1] == b and a[2] == c and a.n == 2)
+a = vararg(call(call, {c12, {1,2}}))
+assert(a.n == 2 and a[1] == 55 and a[2] == 2)
+a = call(print, {'+'})
+assert(a == nil)
+
+local t = {1, 10}
+function t:f (...) local arg = {...}; return self[...]+#arg end
+assert(t:f(1,4) == 3 and t:f(2) == 11)
+print('+')
+
+lim = 20
+local i, a = 1, {}
+while i <= lim do a[i] = i+0.3; i=i+1 end
+
+function f(a, b, c, d, ...)
+  local more = {...}
+  assert(a == 1.3 and more[1] == 5.3 and
+         more[lim-4] == lim+0.3 and not more[lim-3])
+end
+
+function g(a,b,c)
+  assert(a == 1.3 and b == 2.3 and c == 3.3)
+end
+
+call(f, a)
+call(g, a)
+
+a = {}
+i = 1
+while i <= lim do a[i] = i; i=i+1 end
+assert(call(math.max, a) == lim)
+
+print("+")
+
+
+-- new-style varargs
+
+function oneless (a, ...) return ... end
+
+function f (n, a, ...)
+  local b
+  assert(arg == nil)
+  if n == 0 then
+    local b, c, d = ...
+    return a, b, c, d, oneless(oneless(oneless(...)))
+  else
+    n, b, a = n-1, ..., a
+    assert(b == ...)
+    return f(n, a, ...)
+  end
+end
+
+a,b,c,d,e = assert(f(10,5,4,3,2,1))
+assert(a==5 and b==4 and c==3 and d==2 and e==1)
+
+a,b,c,d,e = f(4)
+assert(a==nil and b==nil and c==nil and d==nil and e==nil)
+
+
+-- varargs for main chunks
+f = load[[ return {...} ]]
+x = f(2,3)
+assert(x[1] == 2 and x[2] == 3 and x[3] == nil)
+
+
+f = load[[
+  local x = {...}
+  for i=1,select('#', ...) do assert(x[i] == select(i, ...)) end
+  assert(x[select('#', ...)+1] == nil)
+  return true
+]]
+
+assert(f("a", "b", nil, {}, assert))
+assert(f())
+
+a = {select(3, table.unpack{10,20,30,40})}
+assert(#a == 2 and a[1] == 30 and a[2] == 40)
+a = {select(1)}
+assert(next(a) == nil)
+a = {select(-1, 3, 5, 7)}
+assert(a[1] == 7 and a[2] == nil)
+a = {select(-2, 3, 5, 7)}
+assert(a[1] == 5 and a[2] == 7 and a[3] == nil)
+pcall(select, 10000)
+pcall(select, -10000)
+
+
+-- bug in 5.2.2
+
+function f(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
+p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
+p21, p22, p23, p24, p25, p26, p27, p28, p29, p30,
+p31, p32, p33, p34, p35, p36, p37, p38, p39, p40,
+p41, p42, p43, p44, p45, p46, p48, p49, p50, ...)
+  local a1,a2,a3,a4,a5,a6,a7
+  local a8,a9,a10,a11,a12,a13,a14
+end
+
+-- assertion fail here
+f()
+
+
+print('OK')
+
diff -urN rpm-5.4.15/lua/tests/verybig.lua rpm-5.4-cvs/lua/tests/verybig.lua
--- rpm-5.4.15/lua/tests/verybig.lua	1969-12-31 18:00:00.000000000 -0600
+++ rpm-5.4-cvs/lua/tests/verybig.lua	2015-04-19 13:24:59.000000000 -0500
@@ -0,0 +1,151 @@
+-- $Id: verybig.lua,v 1.1.2.1 2015/04/19 18:24:59 jbj Exp $
+
+print "testing RK"
+
+-- testing opcodes with RK arguments larger than K limit
+local function foo ()
+  local dummy = {
+     -- fill first 256 entries in table of constants
+     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
+     17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
+     33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
+     49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
+     65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
+     81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
+     97, 98, 99, 100, 101, 102, 103, 104,
+     105, 106, 107, 108, 109, 110, 111, 112,
+     113, 114, 115, 116, 117, 118, 119, 120,
+     121, 122, 123, 124, 125, 126, 127, 128,
+     129, 130, 131, 132, 133, 134, 135, 136,
+     137, 138, 139, 140, 141, 142, 143, 144,
+     145, 146, 147, 148, 149, 150, 151, 152,
+     153, 154, 155, 156, 157, 158, 159, 160,
+     161, 162, 163, 164, 165, 166, 167, 168,
+     169, 170, 171, 172, 173, 174, 175, 176,
+     177, 178, 179, 180, 181, 182, 183, 184,
+     185, 186, 187, 188, 189, 190, 191, 192,
+     193, 194, 195, 196, 197, 198, 199, 200,
+     201, 202, 203, 204, 205, 206, 207, 208,
+     209, 210, 211, 212, 213, 214, 215, 216,
+     217, 218, 219, 220, 221, 222, 223, 224,
+     225, 226, 227, 228, 229, 230, 231, 232,
+     233, 234, 235, 236, 237, 238, 239, 240,
+     241, 242, 243, 244, 245, 246, 247, 248,
+     249, 250, 251, 252, 253, 254, 255, 256,
+  }
+  assert(24.5 + 0.6 == 25.1)
+  local t = {foo = function (self, x) return x + self.x end, x = 10}
+  t.t = t
+  assert(t:foo(1.5) == 11.5)
+  assert(t.t:foo(0.5) == 10.5)   -- bug in 5.2 alpha
+  assert(24.3 == 24.3)
+  assert((function () return t.x end)() == 10)
+end
+
+
+foo()
+foo = nil
+
+if _soft then return 10 end
+
+print "testing large programs (>64k)"
+
+-- template to create a very big test file
+prog = [[$
+
+local a,b
+
+b = {$1$
+  b30009 = 65534,
+  b30010 = 65535,
+  b30011 = 65536,
+  b30012 = 65537,
+  b30013 = 16777214,
+  b30014 = 16777215,
+  b30015 = 16777216,
+  b30016 = 16777217,
+  b30017 = 0x7fffff,
+  b30018 = -0x7fffff,
+  b30019 = 0x1ffffff,
+  b30020 = -0x1ffffd,
+  b30021 = -65534,
+  b30022 = -65535,
+  b30023 = -65536,
+  b30024 = -0xffffff,
+  b30025 = 15012.5,
+  $2$
+};
+
+assert(b.a50008 == 25004 and b["a11"] == -5.5)
+assert(b.a33007 == -16503.5 and b.a50009 == -25004.5)
+assert(b["b"..30024] == -0xffffff)
+
+function b:xxx (a,b) return a+b end
+assert(b:xxx(10, 12) == 22)   -- pushself with non-constant index
+b.xxx = nil
+
+s = 0; n=0
+for a,b in pairs(b) do s=s+b; n=n+1 end
+-- with 32-bit floats, exact value of 's' depends on summation order
+assert(81800000.0 < s and s < 81860000 and n == 70001)
+
+a = nil; b = nil
+print'+'
+
+function f(x) b=x end
+
+a = f{$3$} or 10
+
+assert(a==10)
+assert(b[1] == "a10" and b[2] == 5 and b[#b-1] == "a50009")
+
+
+function xxxx (x) return b[x] end
+
+assert(xxxx(3) == "a11")
+
+a = nil; b=nil
+xxxx = nil
+
+return 10
+
+]]
+
+-- functions to fill in the $n$
+
+local function sig (x)
+  return (x % 2 == 0) and '' or '-'
+end
+
+F = {
+function ()   -- $1$
+  for i=10,50009 do
+    io.write('a', i, ' = ', sig(i), 5+((i-10)/2), ',\n')
+  end
+end,
+
+function ()   -- $2$
+  for i=30026,50009 do
+    io.write('b', i, ' = ', sig(i), 15013+((i-30026)/2), ',\n')
+  end
+end,
+
+function ()   -- $3$
+  for i=10,50009 do
+    io.write('"a', i, '", ', sig(i), 5+((i-10)/2), ',\n')
+  end
+end,
+}
+
+file = os.tmpname()
+io.output(file)
+for s in string.gmatch(prog, "$([^$]+)") do
+  local n = tonumber(s)
+  if not n then io.write(s) else F[n]() end
+end
+io.close()
+result = dofile(file)
+assert(os.remove(file))
+print'OK'
+return result
+
