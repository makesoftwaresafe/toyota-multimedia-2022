/* concurrentset.c generated by valac 0.27.1.26-9b1a5, the Vala compiler
 * generated from concurrentset.vala, do not modify */

/* concurrentset.vala
 *
 * Copyright (C) 2012-2014  Maciej Piechotka
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Maciej Piechotka <uzytkownik2@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <misc.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define GEE_TYPE_TRAVERSABLE (gee_traversable_get_type ())
#define GEE_TRAVERSABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TRAVERSABLE, GeeTraversable))
#define GEE_IS_TRAVERSABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TRAVERSABLE))
#define GEE_TRAVERSABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_TRAVERSABLE, GeeTraversableIface))

typedef struct _GeeTraversable GeeTraversable;
typedef struct _GeeTraversableIface GeeTraversableIface;

#define GEE_TRAVERSABLE_TYPE_STREAM (gee_traversable_stream_get_type ())

#define GEE_TYPE_LAZY (gee_lazy_get_type ())
#define GEE_LAZY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_LAZY, GeeLazy))
#define GEE_LAZY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_LAZY, GeeLazyClass))
#define GEE_IS_LAZY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_LAZY))
#define GEE_IS_LAZY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_LAZY))
#define GEE_LAZY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_LAZY, GeeLazyClass))

typedef struct _GeeLazy GeeLazy;
typedef struct _GeeLazyClass GeeLazyClass;

#define GEE_TYPE_ITERATOR (gee_iterator_get_type ())
#define GEE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ITERATOR, GeeIterator))
#define GEE_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ITERATOR))
#define GEE_ITERATOR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_ITERATOR, GeeIteratorIface))

typedef struct _GeeIterator GeeIterator;
typedef struct _GeeIteratorIface GeeIteratorIface;

#define GEE_TYPE_ITERABLE (gee_iterable_get_type ())
#define GEE_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ITERABLE, GeeIterable))
#define GEE_IS_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ITERABLE))
#define GEE_ITERABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_ITERABLE, GeeIterableIface))

typedef struct _GeeIterable GeeIterable;
typedef struct _GeeIterableIface GeeIterableIface;

#define GEE_TYPE_COLLECTION (gee_collection_get_type ())
#define GEE_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_COLLECTION, GeeCollection))
#define GEE_IS_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_COLLECTION))
#define GEE_COLLECTION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_COLLECTION, GeeCollectionIface))

typedef struct _GeeCollection GeeCollection;
typedef struct _GeeCollectionIface GeeCollectionIface;

#define GEE_TYPE_ABSTRACT_COLLECTION (gee_abstract_collection_get_type ())
#define GEE_ABSTRACT_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollection))
#define GEE_ABSTRACT_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollectionClass))
#define GEE_IS_ABSTRACT_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_COLLECTION))
#define GEE_IS_ABSTRACT_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_COLLECTION))
#define GEE_ABSTRACT_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollectionClass))

typedef struct _GeeAbstractCollection GeeAbstractCollection;
typedef struct _GeeAbstractCollectionClass GeeAbstractCollectionClass;
typedef struct _GeeAbstractCollectionPrivate GeeAbstractCollectionPrivate;

#define GEE_TYPE_SET (gee_set_get_type ())
#define GEE_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_SET, GeeSet))
#define GEE_IS_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_SET))
#define GEE_SET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_SET, GeeSetIface))

typedef struct _GeeSet GeeSet;
typedef struct _GeeSetIface GeeSetIface;

#define GEE_TYPE_ABSTRACT_SET (gee_abstract_set_get_type ())
#define GEE_ABSTRACT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_SET, GeeAbstractSet))
#define GEE_ABSTRACT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_SET, GeeAbstractSetClass))
#define GEE_IS_ABSTRACT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_SET))
#define GEE_IS_ABSTRACT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_SET))
#define GEE_ABSTRACT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_SET, GeeAbstractSetClass))

typedef struct _GeeAbstractSet GeeAbstractSet;
typedef struct _GeeAbstractSetClass GeeAbstractSetClass;
typedef struct _GeeAbstractSetPrivate GeeAbstractSetPrivate;

#define GEE_TYPE_SORTED_SET (gee_sorted_set_get_type ())
#define GEE_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_SORTED_SET, GeeSortedSet))
#define GEE_IS_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_SORTED_SET))
#define GEE_SORTED_SET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_SORTED_SET, GeeSortedSetIface))

typedef struct _GeeSortedSet GeeSortedSet;
typedef struct _GeeSortedSetIface GeeSortedSetIface;

#define GEE_TYPE_ABSTRACT_SORTED_SET (gee_abstract_sorted_set_get_type ())
#define GEE_ABSTRACT_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_SORTED_SET, GeeAbstractSortedSet))
#define GEE_ABSTRACT_SORTED_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_SORTED_SET, GeeAbstractSortedSetClass))
#define GEE_IS_ABSTRACT_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_SORTED_SET))
#define GEE_IS_ABSTRACT_SORTED_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_SORTED_SET))
#define GEE_ABSTRACT_SORTED_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_SORTED_SET, GeeAbstractSortedSetClass))

typedef struct _GeeAbstractSortedSet GeeAbstractSortedSet;
typedef struct _GeeAbstractSortedSetClass GeeAbstractSortedSetClass;
typedef struct _GeeAbstractSortedSetPrivate GeeAbstractSortedSetPrivate;

#define GEE_TYPE_CONCURRENT_SET (gee_concurrent_set_get_type ())
#define GEE_CONCURRENT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet))
#define GEE_CONCURRENT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSetClass))
#define GEE_IS_CONCURRENT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_CONCURRENT_SET))
#define GEE_IS_CONCURRENT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_CONCURRENT_SET))
#define GEE_CONCURRENT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSetClass))

typedef struct _GeeConcurrentSet GeeConcurrentSet;
typedef struct _GeeConcurrentSetClass GeeConcurrentSetClass;
typedef struct _GeeConcurrentSetPrivate GeeConcurrentSetPrivate;

#define GEE_CONCURRENT_SET_TYPE_TOWER (gee_concurrent_set_tower_get_type ())
#define GEE_CONCURRENT_SET_TOWER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTower))
#define GEE_CONCURRENT_SET_TOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerClass))
#define GEE_CONCURRENT_SET_IS_TOWER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_TOWER))
#define GEE_CONCURRENT_SET_IS_TOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_TOWER))
#define GEE_CONCURRENT_SET_TOWER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerClass))

typedef struct _GeeConcurrentSetTower GeeConcurrentSetTower;
typedef struct _GeeConcurrentSetTowerClass GeeConcurrentSetTowerClass;
typedef struct _GeeHazardPointerContext GeeHazardPointerContext;

#define GEE_HAZARD_POINTER_TYPE_POLICY (gee_hazard_pointer_policy_get_type ())
#define _gee_concurrent_set_tower_unref0(var) ((var == NULL) ? NULL : (var = (gee_concurrent_set_tower_unref (var), NULL)))
#define _gee_hazard_pointer_context_free0(var) ((var == NULL) ? NULL : (var = (gee_hazard_pointer_context_free (var), NULL)))

#define GEE_CONCURRENT_SET_TYPE_RANGE_TYPE (gee_concurrent_set_range_type_get_type ())

#define GEE_CONCURRENT_SET_TYPE_STATE (gee_concurrent_set_state_get_type ())

#define GEE_CONCURRENT_SET_TYPE_ITERATOR (gee_concurrent_set_iterator_get_type ())
#define GEE_CONCURRENT_SET_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator))
#define GEE_CONCURRENT_SET_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorClass))
#define GEE_CONCURRENT_SET_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR))
#define GEE_CONCURRENT_SET_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_ITERATOR))
#define GEE_CONCURRENT_SET_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorClass))

typedef struct _GeeConcurrentSetIterator GeeConcurrentSetIterator;
typedef struct _GeeConcurrentSetIteratorClass GeeConcurrentSetIteratorClass;

#define GEE_CONCURRENT_SET_TYPE_TOWER_ITER (gee_concurrent_set_tower_iter_get_type ())
typedef struct _GeeConcurrentSetTowerIter GeeConcurrentSetTowerIter;
typedef struct _GeeConcurrentSetTowerPrivate GeeConcurrentSetTowerPrivate;

#define GEE_CONCURRENT_SET_TYPE_TOWER_NODE (gee_concurrent_set_tower_node_get_type ())
typedef struct _GeeConcurrentSetTowerNode GeeConcurrentSetTowerNode;

#define GEE_CONCURRENT_SET_TYPE_RANGE (gee_concurrent_set_range_get_type ())
#define GEE_CONCURRENT_SET_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRange))
#define GEE_CONCURRENT_SET_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangeClass))
#define GEE_CONCURRENT_SET_IS_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_RANGE))
#define GEE_CONCURRENT_SET_IS_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_RANGE))
#define GEE_CONCURRENT_SET_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangeClass))

typedef struct _GeeConcurrentSetRange GeeConcurrentSetRange;
typedef struct _GeeConcurrentSetRangeClass GeeConcurrentSetRangeClass;

#define GEE_CONCURRENT_SET_TYPE_SUB_SET (gee_concurrent_set_sub_set_get_type ())
#define GEE_CONCURRENT_SET_SUB_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet))
#define GEE_CONCURRENT_SET_SUB_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetClass))
#define GEE_CONCURRENT_SET_IS_SUB_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET))
#define GEE_CONCURRENT_SET_IS_SUB_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_SUB_SET))
#define GEE_CONCURRENT_SET_SUB_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetClass))

typedef struct _GeeConcurrentSetSubSet GeeConcurrentSetSubSet;
typedef struct _GeeConcurrentSetSubSetClass GeeConcurrentSetSubSetClass;
#define _gee_concurrent_set_range_unref0(var) ((var == NULL) ? NULL : (var = (gee_concurrent_set_range_unref (var), NULL)))
typedef struct _GeeConcurrentSetIteratorPrivate GeeConcurrentSetIteratorPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _GeeConcurrentSetSubSetPrivate GeeConcurrentSetSubSetPrivate;

#define GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR (gee_concurrent_set_sub_iterator_get_type ())
#define GEE_CONCURRENT_SET_SUB_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator))
#define GEE_CONCURRENT_SET_SUB_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorClass))
#define GEE_CONCURRENT_SET_IS_SUB_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR))
#define GEE_CONCURRENT_SET_IS_SUB_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR))
#define GEE_CONCURRENT_SET_SUB_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorClass))

typedef struct _GeeConcurrentSetSubIterator GeeConcurrentSetSubIterator;
typedef struct _GeeConcurrentSetSubIteratorClass GeeConcurrentSetSubIteratorClass;
typedef struct _GeeConcurrentSetRangePrivate GeeConcurrentSetRangePrivate;

#define GEE_CONCURRENT_SET_RANGE_TYPE_POSITION (gee_concurrent_set_range_position_get_type ())
typedef struct _GeeConcurrentSetSubIteratorPrivate GeeConcurrentSetSubIteratorPrivate;
#define _g_destroy_func0(var) (((var == NULL) || (g_destroy_func == NULL)) ? NULL : (var = (g_destroy_func (var), NULL)))
typedef struct _GeeConcurrentSetParamSpecRange GeeConcurrentSetParamSpecRange;
typedef struct _GeeConcurrentSetParamSpecTower GeeConcurrentSetParamSpecTower;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

typedef gboolean (*GeeForallFunc) (gpointer g, void* user_data);
typedef enum  {
	GEE_TRAVERSABLE_STREAM_YIELD,
	GEE_TRAVERSABLE_STREAM_CONTINUE,
	GEE_TRAVERSABLE_STREAM_END,
	GEE_TRAVERSABLE_STREAM_WAIT
} GeeTraversableStream;

typedef GeeTraversableStream (*GeeStreamFunc) (GeeTraversableStream state, GeeLazy* g, GeeLazy** lazy, void* user_data);
struct _GeeIteratorIface {
	GTypeInterface parent_iface;
	gboolean (*next) (GeeIterator* self);
	gboolean (*has_next) (GeeIterator* self);
	gpointer (*get) (GeeIterator* self);
	void (*remove) (GeeIterator* self);
	gboolean (*get_valid) (GeeIterator* self);
	gboolean (*get_read_only) (GeeIterator* self);
};

typedef gpointer (*GeeFoldFunc) (gpointer g, gpointer a, void* user_data);
typedef gpointer (*GeeMapFunc) (gpointer g, void* user_data);
typedef gboolean (*GeePredicate) (gconstpointer g, void* user_data);
typedef GeeIterator* (*GeeFlatMapFunc) (gpointer g, void* user_data);
struct _GeeTraversableIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeTraversable* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeTraversable* self);
	GDestroyNotify (*get_g_destroy_func) (GeeTraversable* self);
	gboolean (*foreach) (GeeTraversable* self, GeeForallFunc f, void* f_target);
	GeeIterator* (*stream) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeStreamFunc f, void* f_target, GDestroyNotify f_target_destroy_notify);
	gpointer (*fold) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeFoldFunc f, void* f_target, gpointer seed);
	GeeIterator* (*map) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeMapFunc f, void* f_target);
	GeeIterator* (*scan) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeFoldFunc f, void* f_target, gpointer seed);
	GeeIterator* (*filter) (GeeTraversable* self, GeePredicate pred, void* pred_target, GDestroyNotify pred_target_destroy_notify);
	GeeIterator* (*chop) (GeeTraversable* self, gint offset, gint length);
	GType (*get_element_type) (GeeTraversable* self);
	GeeIterator* (*flat_map) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeFlatMapFunc f, void* f_target, GDestroyNotify f_target_destroy_notify);
	GeeIterator** (*tee) (GeeTraversable* self, guint forks, int* result_length1);
};

struct _GeeIterableIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeIterable* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeIterable* self);
	GDestroyNotify (*get_g_destroy_func) (GeeIterable* self);
	GeeIterator* (*iterator) (GeeIterable* self);
};

struct _GeeCollectionIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeCollection* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeCollection* self);
	GDestroyNotify (*get_g_destroy_func) (GeeCollection* self);
	gboolean (*contains) (GeeCollection* self, gconstpointer item);
	gboolean (*add) (GeeCollection* self, gconstpointer item);
	gboolean (*remove) (GeeCollection* self, gconstpointer item);
	void (*clear) (GeeCollection* self);
	gboolean (*add_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*contains_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*remove_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*retain_all) (GeeCollection* self, GeeCollection* collection);
	gpointer* (*to_array) (GeeCollection* self, int* result_length1);
	gint (*get_size) (GeeCollection* self);
	gboolean (*get_is_empty) (GeeCollection* self);
	gboolean (*get_read_only) (GeeCollection* self);
	GeeCollection* (*get_read_only_view) (GeeCollection* self);
	gboolean (*add_all_array) (GeeCollection* self, gpointer* array, int array_length1);
	gboolean (*contains_all_array) (GeeCollection* self, gpointer* array, int array_length1);
	gboolean (*remove_all_array) (GeeCollection* self, gpointer* array, int array_length1);
	gboolean (*add_all_iterator) (GeeCollection* self, GeeIterator* iter);
	gboolean (*contains_all_iterator) (GeeCollection* self, GeeIterator* iter);
	gboolean (*remove_all_iterator) (GeeCollection* self, GeeIterator* iter);
};

struct _GeeAbstractCollection {
	GObject parent_instance;
	GeeAbstractCollectionPrivate * priv;
};

struct _GeeAbstractCollectionClass {
	GObjectClass parent_class;
	gboolean (*contains) (GeeAbstractCollection* self, gconstpointer item);
	gboolean (*add) (GeeAbstractCollection* self, gconstpointer item);
	gboolean (*remove) (GeeAbstractCollection* self, gconstpointer item);
	void (*clear) (GeeAbstractCollection* self);
	GeeIterator* (*iterator) (GeeAbstractCollection* self);
	gboolean (*foreach) (GeeAbstractCollection* self, GeeForallFunc f, void* f_target);
	void (*reserved0) (GeeAbstractCollection* self);
	void (*reserved1) (GeeAbstractCollection* self);
	void (*reserved2) (GeeAbstractCollection* self);
	void (*reserved3) (GeeAbstractCollection* self);
	void (*reserved4) (GeeAbstractCollection* self);
	void (*reserved5) (GeeAbstractCollection* self);
	void (*reserved6) (GeeAbstractCollection* self);
	void (*reserved7) (GeeAbstractCollection* self);
	void (*reserved8) (GeeAbstractCollection* self);
	void (*reserved9) (GeeAbstractCollection* self);
	gint (*get_size) (GeeAbstractCollection* self);
	gboolean (*get_read_only) (GeeAbstractCollection* self);
	GeeCollection* (*get_read_only_view) (GeeAbstractCollection* self);
};

struct _GeeSetIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeSet* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeSet* self);
	GDestroyNotify (*get_g_destroy_func) (GeeSet* self);
	GeeSet* (*get_read_only_view) (GeeSet* self);
};

struct _GeeAbstractSet {
	GeeAbstractCollection parent_instance;
	GeeAbstractSetPrivate * priv;
};

struct _GeeAbstractSetClass {
	GeeAbstractCollectionClass parent_class;
	void (*reserved0) (GeeAbstractSet* self);
	void (*reserved1) (GeeAbstractSet* self);
	void (*reserved2) (GeeAbstractSet* self);
	void (*reserved3) (GeeAbstractSet* self);
	void (*reserved4) (GeeAbstractSet* self);
	void (*reserved5) (GeeAbstractSet* self);
	void (*reserved6) (GeeAbstractSet* self);
	void (*reserved7) (GeeAbstractSet* self);
	void (*reserved8) (GeeAbstractSet* self);
	void (*reserved9) (GeeAbstractSet* self);
	GeeSet* (*get_read_only_view) (GeeAbstractSet* self);
};

struct _GeeSortedSetIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeSortedSet* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeSortedSet* self);
	GDestroyNotify (*get_g_destroy_func) (GeeSortedSet* self);
	gpointer (*first) (GeeSortedSet* self);
	gpointer (*last) (GeeSortedSet* self);
	GeeIterator* (*iterator_at) (GeeSortedSet* self, gconstpointer element);
	gpointer (*lower) (GeeSortedSet* self, gconstpointer element);
	gpointer (*higher) (GeeSortedSet* self, gconstpointer element);
	gpointer (*floor) (GeeSortedSet* self, gconstpointer element);
	gpointer (*ceil) (GeeSortedSet* self, gconstpointer element);
	GeeSortedSet* (*head_set) (GeeSortedSet* self, gconstpointer before);
	GeeSortedSet* (*tail_set) (GeeSortedSet* self, gconstpointer after);
	GeeSortedSet* (*sub_set) (GeeSortedSet* self, gconstpointer from, gconstpointer to);
	GeeSortedSet* (*get_read_only_view) (GeeSortedSet* self);
};

struct _GeeAbstractSortedSet {
	GeeAbstractSet parent_instance;
	GeeAbstractSortedSetPrivate * priv;
};

struct _GeeAbstractSortedSetClass {
	GeeAbstractSetClass parent_class;
	gpointer (*first) (GeeAbstractSortedSet* self);
	gpointer (*last) (GeeAbstractSortedSet* self);
	GeeIterator* (*iterator_at) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*lower) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*higher) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*floor) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*ceil) (GeeAbstractSortedSet* self, gconstpointer element);
	GeeSortedSet* (*head_set) (GeeAbstractSortedSet* self, gconstpointer before);
	GeeSortedSet* (*tail_set) (GeeAbstractSortedSet* self, gconstpointer after);
	GeeSortedSet* (*sub_set) (GeeAbstractSortedSet* self, gconstpointer from, gconstpointer to);
	void (*reserved0) (GeeAbstractSortedSet* self);
	void (*reserved1) (GeeAbstractSortedSet* self);
	void (*reserved2) (GeeAbstractSortedSet* self);
	void (*reserved3) (GeeAbstractSortedSet* self);
	void (*reserved4) (GeeAbstractSortedSet* self);
	void (*reserved5) (GeeAbstractSortedSet* self);
	void (*reserved6) (GeeAbstractSortedSet* self);
	void (*reserved7) (GeeAbstractSortedSet* self);
	void (*reserved8) (GeeAbstractSortedSet* self);
	void (*reserved9) (GeeAbstractSortedSet* self);
	GeeSortedSet* (*get_read_only_view) (GeeAbstractSortedSet* self);
};

struct _GeeConcurrentSet {
	GeeAbstractSortedSet parent_instance;
	GeeConcurrentSetPrivate * priv;
};

struct _GeeConcurrentSetClass {
	GeeAbstractSortedSetClass parent_class;
};

struct _GeeConcurrentSetPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gint _size;
	GeeConcurrentSetTower* _head;
	GCompareDataFunc _cmp;
	gpointer _cmp_target;
	GDestroyNotify _cmp_target_destroy_notify;
};

typedef enum  {
	GEE_HAZARD_POINTER_POLICY_DEFAULT,
	GEE_HAZARD_POINTER_POLICY_THREAD_EXIT,
	GEE_HAZARD_POINTER_POLICY_TRY_FREE,
	GEE_HAZARD_POINTER_POLICY_FREE,
	GEE_HAZARD_POINTER_POLICY_TRY_RELEASE,
	GEE_HAZARD_POINTER_POLICY_RELEASE
} GeeHazardPointerPolicy;

typedef enum  {
	GEE_CONCURRENT_SET_RANGE_TYPE_HEAD,
	GEE_CONCURRENT_SET_RANGE_TYPE_TAIL,
	GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED,
	GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY
} GeeConcurrentSetRangeType;

typedef enum  {
	GEE_CONCURRENT_SET_STATE_NONE = 0,
	GEE_CONCURRENT_SET_STATE_MARKED = 1,
	GEE_CONCURRENT_SET_STATE_FLAGGED = 2
} GeeConcurrentSetState;

struct _GeeConcurrentSetTowerIter {
	GeeConcurrentSetTower* _iter[31];
};

struct _GeeConcurrentSetTowerNode {
	GeeConcurrentSetTower* _succ;
	GeeConcurrentSetTower* _backlink;
};

struct _GeeConcurrentSetTower {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeeConcurrentSetTowerPrivate * priv;
	GeeConcurrentSetTowerNode* _nodes;
	gpointer _data;
	gint _height;
};

struct _GeeConcurrentSetTowerClass {
	GTypeClass parent_class;
	void (*finalize) (GeeConcurrentSetTower *self);
};

struct _GeeConcurrentSetIterator {
	GObject parent_instance;
	GeeConcurrentSetIteratorPrivate * priv;
	gboolean _removed;
	GeeConcurrentSet* _set;
	GeeConcurrentSetTowerIter _prev;
	GeeConcurrentSetTower* _curr;
};

struct _GeeConcurrentSetIteratorClass {
	GObjectClass parent_class;
};

struct _GeeConcurrentSetIteratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetSubSet {
	GeeAbstractSortedSet parent_instance;
	GeeConcurrentSetSubSetPrivate * priv;
};

struct _GeeConcurrentSetSubSetClass {
	GeeAbstractSortedSetClass parent_class;
};

struct _GeeConcurrentSetSubSetPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	GeeConcurrentSetRange* _range;
};

struct _GeeConcurrentSetRange {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeeConcurrentSetRangePrivate * priv;
	gpointer _start;
	gpointer _end;
	GeeConcurrentSetRangeType _type;
	GeeConcurrentSetTowerIter _bookmark;
	GeeConcurrentSet* _set;
};

struct _GeeConcurrentSetRangeClass {
	GTypeClass parent_class;
	void (*finalize) (GeeConcurrentSetRange *self);
};

typedef enum  {
	GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE = -1,
	GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE = 0,
	GEE_CONCURRENT_SET_RANGE_POSITION_AFTER = 1,
	GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY
} GeeConcurrentSetRangePosition;

struct _GeeConcurrentSetSubIterator {
	GObject parent_instance;
	GeeConcurrentSetSubIteratorPrivate * priv;
	GeeConcurrentSetRange* _range;
	GeeConcurrentSetTowerIter _prev;
	GeeConcurrentSetTower* _curr;
	gboolean _removed;
};

struct _GeeConcurrentSetSubIteratorClass {
	GObjectClass parent_class;
};

struct _GeeConcurrentSetSubIteratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetRangePrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetParamSpecRange {
	GParamSpec parent_instance;
};

struct _GeeConcurrentSetTowerPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetParamSpecTower {
	GParamSpec parent_instance;
};


static gpointer gee_concurrent_set_parent_class = NULL;
static GPrivate* gee_concurrent_set_rand;
static GPrivate* gee_concurrent_set_rand = NULL;
static gpointer gee_concurrent_set_iterator_parent_class = NULL;
static GeeTraversableIface* gee_concurrent_set_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface* gee_concurrent_set_iterator_gee_iterator_parent_iface = NULL;
static gpointer gee_concurrent_set_sub_set_parent_class = NULL;
static gpointer gee_concurrent_set_sub_iterator_parent_class = NULL;
static GeeTraversableIface* gee_concurrent_set_sub_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface* gee_concurrent_set_sub_iterator_gee_iterator_parent_iface = NULL;
static gpointer gee_concurrent_set_range_parent_class = NULL;
static gpointer gee_concurrent_set_tower_parent_class = NULL;

GType gee_traversable_stream_get_type (void) G_GNUC_CONST;
gpointer gee_lazy_ref (gpointer instance);
void gee_lazy_unref (gpointer instance);
GParamSpec* gee_param_spec_lazy (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gee_value_set_lazy (GValue* value, gpointer v_object);
void gee_value_take_lazy (GValue* value, gpointer v_object);
gpointer gee_value_get_lazy (const GValue* value);
GType gee_lazy_get_type (void) G_GNUC_CONST;
GType gee_iterator_get_type (void) G_GNUC_CONST;
GType gee_traversable_get_type (void) G_GNUC_CONST;
GType gee_iterable_get_type (void) G_GNUC_CONST;
GType gee_collection_get_type (void) G_GNUC_CONST;
GType gee_abstract_collection_get_type (void) G_GNUC_CONST;
GType gee_set_get_type (void) G_GNUC_CONST;
GType gee_abstract_set_get_type (void) G_GNUC_CONST;
GType gee_sorted_set_get_type (void) G_GNUC_CONST;
GType gee_abstract_sorted_set_get_type (void) G_GNUC_CONST;
GType gee_concurrent_set_get_type (void) G_GNUC_CONST;
static gpointer gee_concurrent_set_tower_ref (gpointer instance);
static void gee_concurrent_set_tower_unref (gpointer instance);
static GParamSpec* gee_concurrent_set_param_spec_tower (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void gee_concurrent_set_value_set_tower (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void gee_concurrent_set_value_take_tower (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer gee_concurrent_set_value_get_tower (const GValue* value) G_GNUC_UNUSED;
static GType gee_concurrent_set_tower_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define GEE_CONCURRENT_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSetPrivate))
enum  {
	GEE_CONCURRENT_SET_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_G_TYPE,
	GEE_CONCURRENT_SET_G_DUP_FUNC,
	GEE_CONCURRENT_SET_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SIZE,
	GEE_CONCURRENT_SET_READ_ONLY
};
void gee_hazard_pointer_context_free (GeeHazardPointerContext* self);
GType gee_hazard_pointer_policy_get_type (void) G_GNUC_CONST;
GeeHazardPointerContext* gee_hazard_pointer_context_new (GeeHazardPointerPolicy* policy);
GeeHazardPointerContext* gee_hazard_pointer_context_new (GeeHazardPointerPolicy* policy);
GType gee_concurrent_set_range_type_get_type (void) G_GNUC_CONST;
static GType gee_concurrent_set_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeConcurrentSetTower* gee_concurrent_set_tower_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
static GeeConcurrentSetTower* gee_concurrent_set_tower_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
static void _gee_concurrent_set_rand_lambda52_ (void* ptr);
static void __gee_concurrent_set_rand_lambda52__gdestroy_notify (void* data);
#define GEE_CONCURRENT_SET__MAX_HEIGHT 31
GeeConcurrentSet* gee_concurrent_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify);
GeeConcurrentSet* gee_concurrent_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify);
GeeAbstractSortedSet* gee_abstract_sorted_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
GCompareDataFunc gee_functions_get_compare_func_for (GType t, void** result_target, GDestroyNotify* result_target_destroy_notify);
static GeeIterator* gee_concurrent_set_real_iterator (GeeAbstractCollection* base);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head);
static GType gee_concurrent_set_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean gee_concurrent_set_real_contains (GeeAbstractCollection* base, gconstpointer key);
static inline gboolean gee_concurrent_set_tower_search (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 to_level, guint8 from_level);
static gboolean gee_concurrent_set_real_add (GeeAbstractCollection* base, gconstpointer key);
static GType gee_concurrent_set_tower_iter_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeConcurrentSetTowerIter* gee_concurrent_set_tower_iter_dup (const GeeConcurrentSetTowerIter* self);
static void gee_concurrent_set_tower_iter_free (GeeConcurrentSetTowerIter* self);
static void gee_concurrent_set_tower_iter_copy (const GeeConcurrentSetTowerIter* self, GeeConcurrentSetTowerIter* dest);
static void gee_concurrent_set_tower_iter_destroy (GeeConcurrentSetTowerIter* self);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level);
static gboolean gee_concurrent_set_real_remove (GeeAbstractCollection* base, gconstpointer item);
static inline gboolean gee_concurrent_set_tower_remove_key (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 from_level);
static void gee_concurrent_set_real_clear (GeeAbstractCollection* base);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_next (GeeConcurrentSetTower* self, guint8 level);
gboolean gee_abstract_collection_remove (GeeAbstractCollection* self, gconstpointer item);
static GType gee_concurrent_set_tower_node_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeConcurrentSetTowerNode* gee_concurrent_set_tower_node_dup (const GeeConcurrentSetTowerNode* self);
static void gee_concurrent_set_tower_node_free (GeeConcurrentSetTowerNode* self);
static gpointer gee_concurrent_set_real_first (GeeAbstractSortedSet* base);
static inline gboolean gee_concurrent_set_tower_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** arg_prev, GeeConcurrentSetTower** arg_curr, guint8 level, gboolean force);
static gpointer gee_concurrent_set_real_last (GeeAbstractSortedSet* base);
static GeeIterator* gee_concurrent_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element);
static inline gboolean gee_concurrent_set_tower_search_from_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTowerIter* next, guint8 to_level, guint8 from_level);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static gpointer gee_concurrent_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element);
static gpointer gee_concurrent_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element);
static gpointer gee_concurrent_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element);
static gpointer gee_concurrent_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element);
static GeeSortedSet* gee_concurrent_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before);
static GeeConcurrentSetRange* gee_concurrent_set_range_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end);
static gpointer gee_concurrent_set_range_ref (gpointer instance);
static void gee_concurrent_set_range_unref (gpointer instance);
static GParamSpec* gee_concurrent_set_param_spec_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void gee_concurrent_set_value_set_range (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void gee_concurrent_set_value_take_range (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer gee_concurrent_set_value_get_range (const GValue* value) G_GNUC_UNUSED;
static GType gee_concurrent_set_range_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GType gee_concurrent_set_sub_set_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeSortedSet* gee_concurrent_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after);
static GeeConcurrentSetRange* gee_concurrent_set_range_new_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_tail (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start);
static GeeSortedSet* gee_concurrent_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to);
static GeeConcurrentSetRange* gee_concurrent_set_range_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end);
static gconstpointer gee_concurrent_set_max (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed);
static gconstpointer gee_concurrent_set_min (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed);
#define GEE_CONCURRENT_SET_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorPrivate))
enum  {
	GEE_CONCURRENT_SET_ITERATOR_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_ITERATOR_G_TYPE,
	GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC,
	GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_ITERATOR_VALID,
	GEE_CONCURRENT_SET_ITERATOR_READ_ONLY
};
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_from_iterator (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetIterator* iter);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_from_iterator (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetIterator* iter);
static gboolean gee_concurrent_set_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target);
static inline gint gee_concurrent_set_tower_get_height (GeeConcurrentSetTower* self);
static GeeIterator** gee_concurrent_set_iterator_real_tee (GeeTraversable* base, guint forks, int* result_length1);
static gboolean gee_concurrent_set_iterator_real_next (GeeIterator* base);
static gboolean gee_concurrent_set_iterator_real_has_next (GeeIterator* base);
static gpointer gee_concurrent_set_iterator_real_get (GeeIterator* base);
gboolean gee_iterator_get_valid (GeeIterator* self);
static void gee_concurrent_set_iterator_real_remove (GeeIterator* base);
static inline gboolean gee_concurrent_set_tower_remove (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static void gee_concurrent_set_iterator_finalize (GObject* obj);
gboolean gee_iterator_get_read_only (GeeIterator* self);
static void _vala_gee_concurrent_set_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_CONCURRENT_SET_SUB_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetPrivate))
enum  {
	GEE_CONCURRENT_SET_SUB_SET_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_SUB_SET_G_TYPE,
	GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC,
	GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SUB_SET_SIZE,
	GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY,
	GEE_CONCURRENT_SET_SUB_SET_READ_ONLY
};
static GeeIterator* gee_concurrent_set_sub_set_real_iterator (GeeAbstractCollection* base);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GType gee_concurrent_set_sub_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean gee_concurrent_set_sub_set_real_contains (GeeAbstractCollection* base, gconstpointer item);
static gboolean gee_concurrent_set_range_inside (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val);
static void gee_concurrent_set_range_improve_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** out_curr, GeeConcurrentSetTowerIter* prev);
static gboolean gee_concurrent_set_sub_set_real_add (GeeAbstractCollection* base, gconstpointer key);
static gboolean gee_concurrent_set_sub_set_real_remove (GeeAbstractCollection* base, gconstpointer key);
static void gee_concurrent_set_sub_set_real_clear (GeeAbstractCollection* base);
static gpointer gee_concurrent_set_sub_set_real_first (GeeAbstractSortedSet* base);
static gpointer gee_concurrent_set_sub_set_real_last (GeeAbstractSortedSet* base);
static gboolean gee_concurrent_set_range_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** curr, guint8 level);
static GeeIterator* gee_concurrent_set_sub_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static gpointer gee_concurrent_set_sub_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element);
static gint gee_concurrent_set_range_cmp (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val);
static GType gee_concurrent_set_range_position_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
gpointer gee_abstract_sorted_set_last (GeeAbstractSortedSet* self);
static gpointer gee_concurrent_set_sub_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element);
gpointer gee_abstract_sorted_set_first (GeeAbstractSortedSet* self);
static gpointer gee_concurrent_set_sub_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element);
static inline gboolean gee_concurrent_set_tower_is_head (GeeConcurrentSetTower* self);
static gpointer gee_concurrent_set_sub_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element);
static GeeSortedSet* gee_concurrent_set_sub_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer end);
static GeeSortedSet* gee_concurrent_set_sub_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start);
static GeeSortedSet* gee_concurrent_set_sub_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start, gconstpointer end);
gpointer gee_hazard_pointer_get_pointer (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer** aptr, gsize mask, gsize* mask_out);
static gboolean gee_concurrent_set_sub_set_get_is_empty (GeeConcurrentSetSubSet* self);
static void gee_concurrent_set_sub_set_finalize (GObject* obj);
gint gee_abstract_collection_get_size (GeeAbstractCollection* self);
gboolean gee_abstract_collection_get_read_only (GeeAbstractCollection* self);
static void _vala_gee_concurrent_set_sub_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_sub_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_CONCURRENT_SET_SUB_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorPrivate))
enum  {
	GEE_CONCURRENT_SET_SUB_ITERATOR_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SUB_ITERATOR_VALID,
	GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY
};
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_from_iterator (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetSubIterator* iter);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_from_iterator (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetSubIterator* iter);
static gboolean gee_concurrent_set_sub_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target);
static gboolean gee_concurrent_set_sub_iterator_begin (GeeConcurrentSetSubIterator* self);
static GeeIterator** gee_concurrent_set_sub_iterator_real_tee (GeeTraversable* base, guint forks, int* result_length1);
static gboolean gee_concurrent_set_sub_iterator_real_next (GeeIterator* base);
static gboolean gee_concurrent_set_sub_iterator_real_has_next (GeeIterator* base);
static gboolean gee_concurrent_set_range_beyond (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower* tw);
static gpointer gee_concurrent_set_sub_iterator_real_get (GeeIterator* base);
static void gee_concurrent_set_sub_iterator_real_remove (GeeIterator* base);
static void gee_concurrent_set_sub_iterator_finalize (GObject* obj);
static void _vala_gee_concurrent_set_sub_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_sub_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_CONCURRENT_SET_RANGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangePrivate))
enum  {
	GEE_CONCURRENT_SET_RANGE_DUMMY_PROPERTY
};
static GeeConcurrentSetRange* gee_concurrent_set_range_new_empty (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_empty (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset);
static void gee_concurrent_set_range_copy_bookmark (GeeConcurrentSetRange* self, GeeConcurrentSetRange* range);
static inline void gee_concurrent_set_tower_backtrace (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetTower** curr, guint8 level);
static inline gint gee_concurrent_set_tower_compare (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, GeeConcurrentSetTower* b);
gboolean gee_hazard_pointer_compare_and_exchange_pointer (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer** aptr, gconstpointer old_ptr, gpointer _new_ptr, gsize mask, gsize old_mask, gsize new_mask);
static inline gint gee_concurrent_set_tower_compare_data (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, gconstpointer b);
static void gee_concurrent_set_range_finalize (GeeConcurrentSetRange* obj);
#define GEE_CONCURRENT_SET_TOWER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerPrivate))
enum  {
	GEE_CONCURRENT_SET_TOWER_DUMMY_PROPERTY
};
static inline void gee_concurrent_set_tower_set_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level);
static inline void gee_concurrent_set_tower_set_backlink (GeeConcurrentSetTower* self, GeeConcurrentSetTower* backlink, guint8 level);
static GeeConcurrentSetTower* gee_concurrent_set_tower_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height);
static GeeConcurrentSetTower* gee_concurrent_set_tower_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height);
static inline gboolean gee_concurrent_set_tower_search_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level, guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_succ (GeeConcurrentSetTower* self, GeeConcurrentSetState* state, guint8 level);
static inline void gee_concurrent_set_tower_help_flagged (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev, guint8 level);
static inline gboolean gee_concurrent_set_tower_compare_and_exchange (GeeConcurrentSetTower* self, GeeConcurrentSetTower* old_tower, GeeConcurrentSetState old_state, GeeConcurrentSetTower* new_tower, GeeConcurrentSetState new_state, guint8 level);
static inline GeeConcurrentSetState gee_concurrent_set_tower_get_state (GeeConcurrentSetTower* self, guint8 level);
static inline gboolean gee_concurrent_set_tower_remove_level (GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev, GeeConcurrentSetTower* curr, guint8 level);
static inline gboolean gee_concurrent_set_tower_try_flag (GeeConcurrentSetTower* self, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev_tower, gboolean* status, guint8 level);
static inline void gee_concurrent_set_tower_help_marked (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev_tower, guint8 level);
static inline void gee_concurrent_set_tower_try_mark (GeeConcurrentSetTower* self, guint8 level);
static inline gboolean gee_concurrent_set_tower_compare_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_backlink (GeeConcurrentSetTower* self, guint8 level);
void gee_hazard_pointer_set_pointer (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer** aptr, gpointer new_ptr, gsize mask, gsize new_mask);
static void gee_concurrent_set_tower_finalize (GeeConcurrentSetTower* obj);
static void _vala_array_copy1 (GeeConcurrentSetTower** self, GeeConcurrentSetTower** dest);
static void gee_concurrent_set_finalize (GObject* obj);
static void _vala_gee_concurrent_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GType gee_concurrent_set_range_type_get_type (void) {
	static volatile gsize gee_concurrent_set_range_type_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_type_type_id__volatile)) {
		static const GEnumValue values[] = {{GEE_CONCURRENT_SET_RANGE_TYPE_HEAD, "GEE_CONCURRENT_SET_RANGE_TYPE_HEAD", "head"}, {GEE_CONCURRENT_SET_RANGE_TYPE_TAIL, "GEE_CONCURRENT_SET_RANGE_TYPE_TAIL", "tail"}, {GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED, "GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED", "bounded"}, {GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY, "GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY", "empty"}, {0, NULL, NULL}};
		GType gee_concurrent_set_range_type_type_id;
		gee_concurrent_set_range_type_type_id = g_enum_register_static ("GeeConcurrentSetRangeType", values);
		g_once_init_leave (&gee_concurrent_set_range_type_type_id__volatile, gee_concurrent_set_range_type_type_id);
	}
	return gee_concurrent_set_range_type_type_id__volatile;
}


static GType gee_concurrent_set_state_get_type (void) {
	static volatile gsize gee_concurrent_set_state_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_state_type_id__volatile)) {
		static const GEnumValue values[] = {{GEE_CONCURRENT_SET_STATE_NONE, "GEE_CONCURRENT_SET_STATE_NONE", "none"}, {GEE_CONCURRENT_SET_STATE_MARKED, "GEE_CONCURRENT_SET_STATE_MARKED", "marked"}, {GEE_CONCURRENT_SET_STATE_FLAGGED, "GEE_CONCURRENT_SET_STATE_FLAGGED", "flagged"}, {0, NULL, NULL}};
		GType gee_concurrent_set_state_type_id;
		gee_concurrent_set_state_type_id = g_enum_register_static ("GeeConcurrentSetState", values);
		g_once_init_leave (&gee_concurrent_set_state_type_id__volatile, gee_concurrent_set_state_type_id);
	}
	return gee_concurrent_set_state_type_id__volatile;
}


static void _gee_concurrent_set_rand_lambda52_ (void* ptr) {
	GRand* rnd = NULL;
	void* _tmp0_ = NULL;
	GRand* _tmp1_ = NULL;
	_tmp0_ = ptr;
	rnd = (GRand*) _tmp0_;
	_tmp1_ = rnd;
	g_rand_free (_tmp1_);
}


static void __gee_concurrent_set_rand_lambda52__gdestroy_notify (void* data) {
	_gee_concurrent_set_rand_lambda52_ (data);
}


GeeConcurrentSet* gee_concurrent_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify) {
	GeeConcurrentSet * self = NULL;
	GCompareDataFunc _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	GCompareDataFunc _tmp4_ = NULL;
	void* _tmp4__target = NULL;
	GDestroyNotify _tmp4__target_destroy_notify = NULL;
	self = (GeeConcurrentSet*) gee_abstract_sorted_set_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = compare_func;
	_tmp0__target = compare_func_target;
	if (_tmp0_ == NULL) {
		void* _tmp1_ = NULL;
		GDestroyNotify _tmp2_ = NULL;
		GCompareDataFunc _tmp3_ = NULL;
		_tmp3_ = gee_functions_get_compare_func_for (g_type, &_tmp1_, &_tmp2_);
		(compare_func_target_destroy_notify == NULL) ? NULL : (compare_func_target_destroy_notify (compare_func_target), NULL);
		compare_func = NULL;
		compare_func_target = NULL;
		compare_func_target_destroy_notify = NULL;
		compare_func = _tmp3_;
		compare_func_target = _tmp1_;
		compare_func_target_destroy_notify = _tmp2_;
	}
	_tmp4_ = compare_func;
	_tmp4__target = compare_func_target;
	_tmp4__target_destroy_notify = compare_func_target_destroy_notify;
	compare_func_target_destroy_notify = NULL;
	(self->priv->_cmp_target_destroy_notify == NULL) ? NULL : (self->priv->_cmp_target_destroy_notify (self->priv->_cmp_target), NULL);
	self->priv->_cmp = NULL;
	self->priv->_cmp_target = NULL;
	self->priv->_cmp_target_destroy_notify = NULL;
	self->priv->_cmp = _tmp4_;
	self->priv->_cmp_target = _tmp4__target;
	self->priv->_cmp_target_destroy_notify = _tmp4__target_destroy_notify;
	(compare_func_target_destroy_notify == NULL) ? NULL : (compare_func_target_destroy_notify (compare_func_target), NULL);
	compare_func = NULL;
	compare_func_target = NULL;
	compare_func_target_destroy_notify = NULL;
	return self;
}


GeeConcurrentSet* gee_concurrent_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify) {
	return gee_concurrent_set_construct (GEE_TYPE_CONCURRENT_SET, g_type, g_dup_func, g_destroy_func, compare_func, compare_func_target, compare_func_target_destroy_notify);
}


static GeeIterator* gee_concurrent_set_real_iterator (GeeAbstractCollection* base) {
	GeeConcurrentSet * self;
	GeeIterator* result = NULL;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	GeeConcurrentSetIterator* _tmp1_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = self->priv->_head;
	_tmp1_ = gee_concurrent_set_iterator_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp0_);
	result = (GeeIterator*) _tmp1_;
	return result;
}


static gpointer _gee_concurrent_set_tower_ref0 (gpointer self) {
	return self ? gee_concurrent_set_tower_ref (self) : NULL;
}


static gboolean gee_concurrent_set_real_contains (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GCompareDataFunc _tmp3_ = NULL;
	void* _tmp3__target = NULL;
	gconstpointer _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	prev = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = key;
	_tmp5_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, _tmp3__target, _tmp4_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	result = _tmp5_;
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_real_add (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GRand* rnd = NULL;
	GPrivate* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	GRand* _tmp4_ = NULL;
	guint32 rand_int = 0U;
	GRand* _tmp8_ = NULL;
	gint32 _tmp9_ = 0;
	guint8 height = 0U;
	guint32 _tmp10_ = 0U;
	gint _tmp11_ = 0;
	GeeConcurrentSetTowerIter prev = {0};
	guint8 _tmp12_ = 0U;
	GeeConcurrentSetTower* _tmp13_ = NULL;
	GeeConcurrentSetTower* _tmp14_ = NULL;
	GeeConcurrentSetTower* _tmp15_ = NULL;
	GCompareDataFunc _tmp16_ = NULL;
	void* _tmp16__target = NULL;
	gconstpointer _tmp17_ = NULL;
	guint8 _tmp18_ = 0U;
	guint8 _tmp19_ = 0U;
	gboolean _tmp20_ = FALSE;
	GeeConcurrentSetTower* _result_ = NULL;
	GCompareDataFunc _tmp31_ = NULL;
	void* _tmp31__target = NULL;
	gconstpointer _tmp32_ = NULL;
	guint8 _tmp33_ = 0U;
	GeeConcurrentSetTower* _tmp34_ = NULL;
	GeeConcurrentSetTower* _tmp35_ = NULL;
	GeeConcurrentSetTower* _tmp36_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = gee_concurrent_set_rand;
	_tmp3_ = g_private_get (_tmp2_);
	rnd = _tmp3_;
	_tmp4_ = rnd;
	if (_tmp4_ == NULL) {
		GPrivate* _tmp5_ = NULL;
		GRand* _tmp6_ = NULL;
		GRand* _tmp7_ = NULL;
		_tmp5_ = gee_concurrent_set_rand;
		_tmp6_ = g_rand_new ();
		rnd = _tmp6_;
		_tmp7_ = rnd;
		g_private_set (_tmp5_, _tmp7_);
	}
	_tmp8_ = rnd;
	_tmp9_ = g_rand_int_range (_tmp8_, (gint32) 0, G_MAXINT32);
	rand_int = (guint32) _tmp9_;
	_tmp10_ = rand_int;
	_tmp11_ = g_bit_nth_lsf ((gulong) (~_tmp10_), -1);
	height = (guint8) (1 + ((guint8) _tmp11_));
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	_tmp12_ = height;
	_tmp13_ = self->priv->_head;
	_tmp14_ = _gee_concurrent_set_tower_ref0 (_tmp13_);
	_gee_concurrent_set_tower_unref0 (prev._iter[_tmp12_ - 1]);
	prev._iter[_tmp12_ - 1] = _tmp14_;
	_tmp15_ = prev._iter[_tmp12_ - 1];
	_tmp16_ = self->priv->_cmp;
	_tmp16__target = self->priv->_cmp_target;
	_tmp17_ = key;
	_tmp18_ = height;
	_tmp19_ = height;
	_tmp20_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp16_, _tmp16__target, _tmp17_, &prev._iter[_tmp18_ - 1], NULL, (guint8) (_tmp19_ - 1), (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	if (_tmp20_) {
		result = FALSE;
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	{
		gint i = 0;
		guint8 _tmp21_ = 0U;
		_tmp21_ = height;
		i = _tmp21_ - 2;
		{
			gboolean _tmp22_ = FALSE;
			_tmp22_ = TRUE;
			while (TRUE) {
				gint _tmp24_ = 0;
				gint _tmp25_ = 0;
				GeeConcurrentSetTowerIter _tmp26_ = {0};
				guint8 _tmp27_ = 0U;
				GeeConcurrentSetTower* _tmp28_ = NULL;
				GeeConcurrentSetTower* _tmp29_ = NULL;
				GeeConcurrentSetTower* _tmp30_ = NULL;
				if (!_tmp22_) {
					gint _tmp23_ = 0;
					_tmp23_ = i;
					i = _tmp23_ - 1;
				}
				_tmp22_ = FALSE;
				_tmp24_ = i;
				if (!(_tmp24_ >= 0)) {
					break;
				}
				_tmp25_ = i;
				_tmp26_ = prev;
				_tmp27_ = height;
				_tmp28_ = _tmp26_._iter[_tmp27_ - 1];
				_tmp29_ = _gee_concurrent_set_tower_ref0 (_tmp28_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp25_]);
				prev._iter[_tmp25_] = _tmp29_;
				_tmp30_ = prev._iter[_tmp25_];
			}
		}
	}
	_tmp31_ = self->priv->_cmp;
	_tmp31__target = self->priv->_cmp_target;
	_tmp32_ = key;
	_tmp33_ = height;
	_tmp34_ = gee_concurrent_set_tower_insert (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp31_, _tmp31__target, &prev, _tmp32_, (guint8) (_tmp33_ - 1));
	_result_ = _tmp34_;
	_tmp35_ = _result_;
	if (_tmp35_ != NULL) {
		g_atomic_int_inc ((volatile gint *) (&self->priv->_size));
	}
	_tmp36_ = _result_;
	result = _tmp36_ != NULL;
	_gee_concurrent_set_tower_unref0 (_result_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_real_remove (GeeAbstractCollection* base, gconstpointer item) {
	GeeConcurrentSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTowerIter prev = {0};
	gboolean _result_ = FALSE;
	GCompareDataFunc _tmp9_ = NULL;
	void* _tmp9__target = NULL;
	gconstpointer _tmp10_ = NULL;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_ = FALSE;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				gint _tmp5_ = 0;
				GeeConcurrentSetTower* _tmp6_ = NULL;
				GeeConcurrentSetTower* _tmp7_ = NULL;
				GeeConcurrentSetTower* _tmp8_ = NULL;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = self->priv->_head;
				_tmp7_ = _gee_concurrent_set_tower_ref0 (_tmp6_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp5_]);
				prev._iter[_tmp5_] = _tmp7_;
				_tmp8_ = prev._iter[_tmp5_];
			}
		}
	}
	_tmp9_ = self->priv->_cmp;
	_tmp9__target = self->priv->_cmp_target;
	_tmp10_ = item;
	_tmp11_ = gee_concurrent_set_tower_remove_key (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, &prev, _tmp10_, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_result_ = _tmp11_;
	_tmp12_ = _result_;
	if (_tmp12_) {
		g_atomic_int_dec_and_test ((volatile gint *) (&self->priv->_size));
	}
	result = _result_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static void gee_concurrent_set_real_clear (GeeAbstractCollection* base) {
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* first = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	while (TRUE) {
		GeeConcurrentSetTower* _tmp2_ = NULL;
		GeeConcurrentSetTower* _tmp3_ = NULL;
		GeeConcurrentSetTower* _tmp4_ = NULL;
		GeeConcurrentSetTower* _tmp5_ = NULL;
		gconstpointer _tmp6_ = NULL;
		_tmp2_ = self->priv->_head;
		_tmp3_ = gee_concurrent_set_tower_get_next (_tmp2_, (guint8) 0);
		_gee_concurrent_set_tower_unref0 (first);
		first = _tmp3_;
		_tmp4_ = first;
		if (!(_tmp4_ != NULL)) {
			break;
		}
		_tmp5_ = first;
		_tmp6_ = _tmp5_->_data;
		gee_abstract_collection_remove ((GeeAbstractCollection*) self, _tmp6_);
	}
	_gee_concurrent_set_tower_unref0 (first);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_real_first (GeeAbstractSortedSet* base) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GCompareDataFunc _tmp4_ = NULL;
	void* _tmp4__target = NULL;
	gboolean _tmp5_ = FALSE;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	prev = NULL;
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	curr = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp5_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, _tmp4__target, &prev, &curr, (guint8) 0, FALSE);
	if (_tmp5_) {
		GeeConcurrentSetTower* _tmp6_ = NULL;
		gconstpointer _tmp7_ = NULL;
		gpointer _tmp8_ = NULL;
		_tmp6_ = curr;
		_tmp7_ = _tmp6_->_data;
		_tmp8_ = ((_tmp7_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp7_) : ((gpointer) _tmp7_);
		result = _tmp8_;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_real_last (GeeAbstractSortedSet* base) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	gboolean found = FALSE;
	gboolean _tmp9_ = FALSE;
	GeeConcurrentSetTower* _tmp10_ = NULL;
	gconstpointer _tmp11_ = NULL;
	gpointer _tmp12_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	prev = NULL;
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	curr = _tmp3_;
	found = FALSE;
	{
		gint i = 0;
		i = GEE_CONCURRENT_SET__MAX_HEIGHT;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				gint _tmp6_ = 0;
				if (!_tmp4_) {
					gint _tmp5_ = 0;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp4_ = FALSE;
				_tmp6_ = i;
				if (!(_tmp6_ >= 0)) {
					break;
				}
				while (TRUE) {
					GCompareDataFunc _tmp7_ = NULL;
					void* _tmp7__target = NULL;
					gboolean _tmp8_ = FALSE;
					_tmp7_ = self->priv->_cmp;
					_tmp7__target = self->priv->_cmp_target;
					_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, &curr, (guint8) 0, FALSE);
					if (!_tmp8_) {
						break;
					}
					found = TRUE;
				}
			}
		}
	}
	_tmp9_ = found;
	if (!_tmp9_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp10_ = curr;
	_tmp11_ = _tmp10_->_data;
	_tmp12_ = ((_tmp11_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp11_) : ((gpointer) _tmp11_);
	result = _tmp12_;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeIterator* gee_concurrent_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	GeeIterator* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTowerIter curr = {0};
	GCompareDataFunc _tmp9_ = NULL;
	void* _tmp9__target = NULL;
	gconstpointer _tmp10_ = NULL;
	GeeConcurrentSetTowerIter _tmp11_ = {0};
	gboolean _tmp12_ = FALSE;
	GeeConcurrentSetTowerIter _tmp13_ = {0};
	GeeConcurrentSetTower* _tmp14_ = NULL;
	GeeConcurrentSetIterator* _tmp15_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				gint _tmp5_ = 0;
				GeeConcurrentSetTower* _tmp6_ = NULL;
				GeeConcurrentSetTower* _tmp7_ = NULL;
				GeeConcurrentSetTower* _tmp8_ = NULL;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = self->priv->_head;
				_tmp7_ = _gee_concurrent_set_tower_ref0 (_tmp6_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp5_]);
				prev._iter[_tmp5_] = _tmp7_;
				_tmp8_ = prev._iter[_tmp5_];
			}
		}
	}
	_tmp9_ = self->priv->_cmp;
	_tmp9__target = self->priv->_cmp_target;
	_tmp10_ = element;
	_tmp12_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, &_tmp11_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	gee_concurrent_set_tower_iter_destroy (&curr);
	curr = _tmp11_;
	if (!_tmp12_) {
		result = NULL;
		gee_concurrent_set_tower_iter_destroy (&curr);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp13_ = curr;
	_tmp14_ = _tmp13_._iter[0];
	_tmp15_ = gee_concurrent_set_iterator_new_point_at (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, &prev, _tmp14_);
	result = (GeeIterator*) _tmp15_;
	gee_concurrent_set_tower_iter_destroy (&curr);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GCompareDataFunc _tmp4_ = NULL;
	void* _tmp4__target = NULL;
	gconstpointer _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_ = NULL;
	GeeConcurrentSetTower* _tmp7_ = NULL;
	GeeConcurrentSetTower* _tmp8_ = NULL;
	gconstpointer _tmp9_ = NULL;
	gpointer _tmp10_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp5_ = element;
	gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, _tmp4__target, _tmp5_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_tmp6_ = prev;
	_tmp7_ = self->priv->_head;
	if (_tmp6_ == _tmp7_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp8_ = prev;
	_tmp9_ = _tmp8_->_data;
	_tmp10_ = ((_tmp9_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
	result = _tmp10_;
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp4_ = NULL;
	void* _tmp4__target = NULL;
	gconstpointer _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	GeeConcurrentSetTower* _tmp10_ = NULL;
	GeeConcurrentSetTower* _tmp11_ = NULL;
	gconstpointer _tmp12_ = NULL;
	gpointer _tmp13_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp5_ = element;
	_tmp7_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, _tmp4__target, _tmp5_, &prev, &_tmp6_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp6_;
	if (_tmp7_) {
		GCompareDataFunc _tmp8_ = NULL;
		void* _tmp8__target = NULL;
		gboolean _tmp9_ = FALSE;
		_tmp8_ = self->priv->_cmp;
		_tmp8__target = self->priv->_cmp_target;
		_tmp9_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, &prev, &next, (guint8) 0, FALSE);
		if (!_tmp9_) {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp10_ = next;
	if (_tmp10_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp11_ = next;
	_tmp12_ = _tmp11_->_data;
	_tmp13_ = ((_tmp12_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp12_) : ((gpointer) _tmp12_);
	result = _tmp13_;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp4_ = NULL;
	void* _tmp4__target = NULL;
	gconstpointer _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp5_ = element;
	_tmp7_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, _tmp4__target, _tmp5_, &prev, &_tmp6_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp6_;
	if (_tmp7_) {
		GeeConcurrentSetTower* _tmp8_ = NULL;
		gconstpointer _tmp9_ = NULL;
		gpointer _tmp10_ = NULL;
		_tmp8_ = next;
		_tmp9_ = _tmp8_->_data;
		_tmp10_ = ((_tmp9_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
		result = _tmp10_;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTower* _tmp11_ = NULL;
		GeeConcurrentSetTower* _tmp12_ = NULL;
		_tmp11_ = prev;
		_tmp12_ = self->priv->_head;
		if (_tmp11_ != _tmp12_) {
			GeeConcurrentSetTower* _tmp13_ = NULL;
			gconstpointer _tmp14_ = NULL;
			gpointer _tmp15_ = NULL;
			_tmp13_ = prev;
			_tmp14_ = _tmp13_->_data;
			_tmp15_ = ((_tmp14_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp14_) : ((gpointer) _tmp14_);
			result = _tmp15_;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		} else {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp4_ = NULL;
	void* _tmp4__target = NULL;
	gconstpointer _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_ = NULL;
	GeeConcurrentSetTower* _tmp7_ = NULL;
	GeeConcurrentSetTower* _tmp8_ = NULL;
	gconstpointer _tmp9_ = NULL;
	gpointer _tmp10_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_head;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_cmp;
	_tmp4__target = self->priv->_cmp_target;
	_tmp5_ = element;
	gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, _tmp4__target, _tmp5_, &prev, &_tmp6_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp6_;
	_tmp7_ = next;
	if (_tmp7_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp8_ = next;
	_tmp9_ = _tmp8_->_data;
	_tmp10_ = ((_tmp9_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
	result = _tmp10_;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before) {
	GeeConcurrentSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	gconstpointer _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetSubSet* _tmp4_ = NULL;
	GeeSortedSet* _tmp5_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = before;
	_tmp2_ = gee_concurrent_set_range_new_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_);
	_tmp5_ = (GeeSortedSet*) _tmp4_;
	_gee_concurrent_set_range_unref0 (_tmp3_);
	result = _tmp5_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after) {
	GeeConcurrentSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	gconstpointer _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetSubSet* _tmp4_ = NULL;
	GeeSortedSet* _tmp5_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = after;
	_tmp2_ = gee_concurrent_set_range_new_tail (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_);
	_tmp5_ = (GeeSortedSet*) _tmp4_;
	_gee_concurrent_set_range_unref0 (_tmp3_);
	result = _tmp5_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to) {
	GeeConcurrentSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	gconstpointer _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSetSubSet* _tmp5_ = NULL;
	GeeSortedSet* _tmp6_ = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = from;
	_tmp2_ = to;
	_tmp3_ = gee_concurrent_set_range_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_);
	_tmp6_ = (GeeSortedSet*) _tmp5_;
	_gee_concurrent_set_range_unref0 (_tmp4_);
	result = _tmp6_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gconstpointer gee_concurrent_set_max (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed) {
	gboolean _vala_changed = FALSE;
	gconstpointer result = NULL;
	GCompareDataFunc _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	gconstpointer _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gconstpointer _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_cmp;
	_tmp0__target = self->priv->_cmp_target;
	_tmp1_ = a;
	_tmp2_ = b;
	_tmp3_ = _tmp0_ (_tmp1_, _tmp2_, _tmp0__target);
	_vala_changed = _tmp3_ < 0;
	_tmp5_ = _vala_changed;
	if (_tmp5_) {
		gconstpointer _tmp6_ = NULL;
		_tmp6_ = b;
		_tmp4_ = _tmp6_;
	} else {
		gconstpointer _tmp7_ = NULL;
		_tmp7_ = a;
		_tmp4_ = _tmp7_;
	}
	result = _tmp4_;
	if (changed) {
		*changed = _vala_changed;
	}
	return result;
}


static gconstpointer gee_concurrent_set_min (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed) {
	gboolean _vala_changed = FALSE;
	gconstpointer result = NULL;
	GCompareDataFunc _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	gconstpointer _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gconstpointer _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_cmp;
	_tmp0__target = self->priv->_cmp_target;
	_tmp1_ = a;
	_tmp2_ = b;
	_tmp3_ = _tmp0_ (_tmp1_, _tmp2_, _tmp0__target);
	_vala_changed = _tmp3_ > 0;
	_tmp5_ = _vala_changed;
	if (_tmp5_) {
		gconstpointer _tmp6_ = NULL;
		_tmp6_ = b;
		_tmp4_ = _tmp6_;
	} else {
		gconstpointer _tmp7_ = NULL;
		_tmp7_ = a;
		_tmp4_ = _tmp7_;
	}
	result = _tmp4_;
	if (changed) {
		*changed = _vala_changed;
	}
	return result;
}


static gint gee_concurrent_set_real_get_size (GeeAbstractCollection* base) {
	gint result;
	GeeConcurrentSet* self;
	gint _tmp0_ = 0;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->priv->_size));
	result = _tmp0_;
	return result;
}


static gboolean gee_concurrent_set_real_get_read_only (GeeAbstractCollection* base) {
	gboolean result;
	GeeConcurrentSet* self;
	self = (GeeConcurrentSet*) base;
	result = FALSE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head) {
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	GeeConcurrentSet* _tmp2_ = NULL;
	GeeConcurrentSet* _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	g_return_val_if_fail (cset != NULL, NULL);
	g_return_val_if_fail (head != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = head;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (_tmp0_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp1_;
	_tmp2_ = cset;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp3_;
	_tmp4_ = self->_curr;
	_vala_assert (_tmp4_ != NULL, "_curr != null");
	return self;
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head) {
	return gee_concurrent_set_iterator_construct (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, cset, head);
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	GeeConcurrentSet* _tmp2_ = NULL;
	GeeConcurrentSet* _tmp3_ = NULL;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GeeConcurrentSetTower* _tmp6_ = NULL;
	g_return_val_if_fail (cset != NULL, NULL);
	g_return_val_if_fail (prev != NULL, NULL);
	g_return_val_if_fail (curr != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = curr;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (_tmp0_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp1_;
	_tmp2_ = cset;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp3_;
	_tmp4_ = *prev;
	gee_concurrent_set_tower_iter_copy (&_tmp4_, &_tmp5_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp5_;
	_tmp6_ = self->_curr;
	_vala_assert (_tmp6_ != NULL, "_curr != null");
	return self;
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	return gee_concurrent_set_iterator_construct_point_at (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, cset, prev, curr);
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_from_iterator (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetIterator* iter) {
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetIterator* _tmp0_ = NULL;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetIterator* _tmp3_ = NULL;
	GeeConcurrentSet* _tmp4_ = NULL;
	GeeConcurrentSet* _tmp5_ = NULL;
	GeeConcurrentSetIterator* _tmp6_ = NULL;
	GeeConcurrentSetTowerIter _tmp7_ = {0};
	GeeConcurrentSetTowerIter _tmp8_ = {0};
	GeeConcurrentSetIterator* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	g_return_val_if_fail (iter != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = iter;
	_tmp1_ = _tmp0_->_curr;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp2_;
	_tmp3_ = iter;
	_tmp4_ = _tmp3_->_set;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp5_;
	_tmp6_ = iter;
	_tmp7_ = _tmp6_->_prev;
	gee_concurrent_set_tower_iter_copy (&_tmp7_, &_tmp8_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp8_;
	_tmp9_ = iter;
	_tmp10_ = _tmp9_->_removed;
	self->_removed = _tmp10_;
	return self;
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_from_iterator (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetIterator* iter) {
	return gee_concurrent_set_iterator_construct_from_iterator (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, iter);
}


static gboolean gee_concurrent_set_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target) {
	GeeConcurrentSetIterator * self;
	gboolean result = FALSE;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeHazardPointerContext* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTower* _tmp5_ = NULL;
	GeeConcurrentSetTower* new_prev = NULL;
	GeeConcurrentSetTowerIter _tmp13_ = {0};
	GeeConcurrentSetTower* _tmp14_ = NULL;
	GeeConcurrentSetTower* _tmp15_ = NULL;
	GeeConcurrentSetTower* new_curr = NULL;
	GeeConcurrentSetTower* _tmp16_ = NULL;
	GeeConcurrentSetTower* _tmp17_ = NULL;
	GeeConcurrentSetTower* _tmp46_ = NULL;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = self->_curr;
	_vala_assert (_tmp0_ != NULL, "_curr != null");
	_tmp1_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp1_;
	_tmp2_ = ctx;
	gee_utils_misc_unused (_tmp2_);
	_tmp4_ = self->_prev;
	_tmp5_ = _tmp4_._iter[0];
	if (_tmp5_ != NULL) {
		gboolean _tmp6_ = FALSE;
		_tmp6_ = self->_removed;
		_tmp3_ = !_tmp6_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		GeeForallFunc _tmp7_ = NULL;
		void* _tmp7__target = NULL;
		GeeConcurrentSetTower* _tmp8_ = NULL;
		gconstpointer _tmp9_ = NULL;
		gpointer _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp7_ = f;
		_tmp7__target = f_target;
		_tmp8_ = self->_curr;
		_tmp9_ = _tmp8_->_data;
		_tmp10_ = ((_tmp9_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
		_tmp11_ = _tmp7_ (_tmp10_, _tmp7__target);
		if (!_tmp11_) {
			GeeConcurrentSetTower* _tmp12_ = NULL;
			_tmp12_ = self->_curr;
			_vala_assert (_tmp12_ != NULL, "_curr != null");
			result = FALSE;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp13_ = self->_prev;
	_tmp14_ = _tmp13_._iter[0];
	_tmp15_ = _gee_concurrent_set_tower_ref0 (_tmp14_);
	new_prev = _tmp15_;
	_tmp16_ = self->_curr;
	_tmp17_ = _gee_concurrent_set_tower_ref0 (_tmp16_);
	new_curr = _tmp17_;
	while (TRUE) {
		GeeConcurrentSet* _tmp18_ = NULL;
		GCompareDataFunc _tmp19_ = NULL;
		void* _tmp19__target = NULL;
		gboolean _tmp20_ = FALSE;
		GeeConcurrentSetTower* _tmp21_ = NULL;
		gboolean _tmp22_ = FALSE;
		GeeConcurrentSetTower* _tmp38_ = NULL;
		GeeConcurrentSetTower* _tmp39_ = NULL;
		GeeForallFunc _tmp40_ = NULL;
		void* _tmp40__target = NULL;
		GeeConcurrentSetTower* _tmp41_ = NULL;
		gconstpointer _tmp42_ = NULL;
		gpointer _tmp43_ = NULL;
		gboolean _tmp44_ = FALSE;
		_tmp18_ = self->_set;
		_tmp19_ = _tmp18_->priv->_cmp;
		_tmp19__target = _tmp18_->priv->_cmp_target;
		_tmp20_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp19_, _tmp19__target, &new_prev, &new_curr, (guint8) 0, FALSE);
		if (!_tmp20_) {
			break;
		}
		_tmp21_ = self->_curr;
		_vala_assert (_tmp21_ != NULL, "_curr != null");
		_tmp22_ = self->_removed;
		if (!_tmp22_) {
			GeeConcurrentSetTower* _tmp23_ = NULL;
			GeeConcurrentSetTower* _tmp24_ = NULL;
			GeeConcurrentSetTower* _tmp25_ = NULL;
			gint prev_height = 0;
			GeeConcurrentSetTowerIter _tmp26_ = {0};
			GeeConcurrentSetTower* _tmp27_ = NULL;
			gint _tmp28_ = 0;
			_tmp23_ = new_prev;
			_tmp24_ = _gee_concurrent_set_tower_ref0 (_tmp23_);
			_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
			self->_prev._iter[0] = _tmp24_;
			_tmp25_ = self->_prev._iter[0];
			_tmp26_ = self->_prev;
			_tmp27_ = _tmp26_._iter[0];
			_tmp28_ = gee_concurrent_set_tower_get_height (_tmp27_);
			prev_height = _tmp28_;
			{
				gint i = 0;
				i = 1;
				{
					gboolean _tmp29_ = FALSE;
					_tmp29_ = TRUE;
					while (TRUE) {
						gint _tmp31_ = 0;
						gint _tmp32_ = 0;
						gint _tmp33_ = 0;
						GeeConcurrentSetTowerIter _tmp34_ = {0};
						GeeConcurrentSetTower* _tmp35_ = NULL;
						GeeConcurrentSetTower* _tmp36_ = NULL;
						GeeConcurrentSetTower* _tmp37_ = NULL;
						if (!_tmp29_) {
							gint _tmp30_ = 0;
							_tmp30_ = i;
							i = _tmp30_ + 1;
						}
						_tmp29_ = FALSE;
						_tmp31_ = i;
						_tmp32_ = prev_height;
						if (!(_tmp31_ < _tmp32_)) {
							break;
						}
						_tmp33_ = i;
						_tmp34_ = self->_prev;
						_tmp35_ = _tmp34_._iter[0];
						_tmp36_ = _gee_concurrent_set_tower_ref0 (_tmp35_);
						_gee_concurrent_set_tower_unref0 (self->_prev._iter[_tmp33_]);
						self->_prev._iter[_tmp33_] = _tmp36_;
						_tmp37_ = self->_prev._iter[_tmp33_];
					}
				}
			}
		}
		_tmp38_ = new_curr;
		_tmp39_ = _gee_concurrent_set_tower_ref0 (_tmp38_);
		_gee_concurrent_set_tower_unref0 (self->_curr);
		self->_curr = _tmp39_;
		self->_removed = FALSE;
		_tmp40_ = f;
		_tmp40__target = f_target;
		_tmp41_ = self->_curr;
		_tmp42_ = _tmp41_->_data;
		_tmp43_ = ((_tmp42_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp42_) : ((gpointer) _tmp42_);
		_tmp44_ = _tmp40_ (_tmp43_, _tmp40__target);
		if (!_tmp44_) {
			GeeConcurrentSetTower* _tmp45_ = NULL;
			_tmp45_ = self->_curr;
			_vala_assert (_tmp45_ != NULL, "_curr != null");
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp46_ = self->_curr;
	_vala_assert (_tmp46_ != NULL, "_curr != null");
	result = TRUE;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeIterator** gee_concurrent_set_iterator_real_tee (GeeTraversable* base, guint forks, int* result_length1) {
	GeeConcurrentSetIterator * self;
	GeeIterator** result = NULL;
	guint _tmp0_ = 0U;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = forks;
	if (_tmp0_ == ((guint) 0)) {
		GeeIterator** _tmp1_ = NULL;
		GeeIterator** _tmp2_ = NULL;
		gint _tmp2__length1 = 0;
		_tmp1_ = g_new0 (GeeIterator*, 0 + 1);
		_tmp2_ = _tmp1_;
		_tmp2__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp2__length1;
		}
		result = _tmp2_;
		return result;
	} else {
		GeeIterator** _result_ = NULL;
		guint _tmp3_ = 0U;
		GeeIterator** _tmp4_ = NULL;
		gint _result__length1 = 0;
		gint __result__size_ = 0;
		GeeIterator** _tmp5_ = NULL;
		gint _tmp5__length1 = 0;
		GeeIterator* _tmp6_ = NULL;
		GeeIterator* _tmp7_ = NULL;
		GeeIterator** _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		_tmp3_ = forks;
		_tmp4_ = g_new0 (GeeIterator*, _tmp3_ + 1);
		_result_ = _tmp4_;
		_result__length1 = _tmp3_;
		__result__size_ = _result__length1;
		_tmp5_ = _result_;
		_tmp5__length1 = _result__length1;
		_tmp6_ = _g_object_ref0 ((GeeIterator*) self);
		_g_object_unref0 (_tmp5_[0]);
		_tmp5_[0] = _tmp6_;
		_tmp7_ = _tmp5_[0];
		{
			guint i = 0U;
			i = (guint) 1;
			{
				gboolean _tmp8_ = FALSE;
				_tmp8_ = TRUE;
				while (TRUE) {
					guint _tmp10_ = 0U;
					guint _tmp11_ = 0U;
					GeeIterator** _tmp12_ = NULL;
					gint _tmp12__length1 = 0;
					guint _tmp13_ = 0U;
					GeeConcurrentSetIterator* _tmp14_ = NULL;
					GeeIterator* _tmp15_ = NULL;
					if (!_tmp8_) {
						guint _tmp9_ = 0U;
						_tmp9_ = i;
						i = _tmp9_ + 1;
					}
					_tmp8_ = FALSE;
					_tmp10_ = i;
					_tmp11_ = forks;
					if (!(_tmp10_ < _tmp11_)) {
						break;
					}
					_tmp12_ = _result_;
					_tmp12__length1 = _result__length1;
					_tmp13_ = i;
					_tmp14_ = gee_concurrent_set_iterator_new_from_iterator (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self);
					_g_object_unref0 (_tmp12_[_tmp13_]);
					_tmp12_[_tmp13_] = (GeeIterator*) _tmp14_;
					_tmp15_ = _tmp12_[_tmp13_];
				}
			}
		}
		_tmp16_ = _result_;
		_tmp16__length1 = _result__length1;
		if (result_length1) {
			*result_length1 = _tmp16__length1;
		}
		result = _tmp16_;
		return result;
	}
}


static gboolean gee_concurrent_set_iterator_real_next (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* new_prev = NULL;
	GeeConcurrentSetTowerIter _tmp2_ = {0};
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	GeeConcurrentSetTower* new_curr = NULL;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_ = NULL;
	gboolean success = FALSE;
	GeeConcurrentSet* _tmp7_ = NULL;
	GCompareDataFunc _tmp8_ = NULL;
	void* _tmp8__target = NULL;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_ = FALSE;
	GeeConcurrentSetTower* _tmp27_ = NULL;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->_prev;
	_tmp3_ = _tmp2_._iter[0];
	_tmp4_ = _gee_concurrent_set_tower_ref0 (_tmp3_);
	new_prev = _tmp4_;
	_tmp5_ = self->_curr;
	_tmp6_ = _gee_concurrent_set_tower_ref0 (_tmp5_);
	new_curr = _tmp6_;
	_tmp7_ = self->_set;
	_tmp8_ = _tmp7_->priv->_cmp;
	_tmp8__target = _tmp7_->priv->_cmp_target;
	_tmp9_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, &new_prev, &new_curr, (guint8) 0, FALSE);
	success = _tmp9_;
	_tmp10_ = success;
	if (_tmp10_) {
		gboolean _tmp11_ = FALSE;
		GeeConcurrentSetTower* _tmp26_ = NULL;
		_tmp11_ = self->_removed;
		if (!_tmp11_) {
			GeeConcurrentSetTower* _tmp12_ = NULL;
			GeeConcurrentSetTower* _tmp13_ = NULL;
			gint prev_height = 0;
			GeeConcurrentSetTowerIter _tmp14_ = {0};
			GeeConcurrentSetTower* _tmp15_ = NULL;
			gint _tmp16_ = 0;
			_tmp12_ = new_prev;
			new_prev = NULL;
			_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
			self->_prev._iter[0] = _tmp12_;
			_tmp13_ = self->_prev._iter[0];
			_tmp14_ = self->_prev;
			_tmp15_ = _tmp14_._iter[0];
			_tmp16_ = gee_concurrent_set_tower_get_height (_tmp15_);
			prev_height = _tmp16_;
			{
				gint i = 0;
				i = 1;
				{
					gboolean _tmp17_ = FALSE;
					_tmp17_ = TRUE;
					while (TRUE) {
						gint _tmp19_ = 0;
						gint _tmp20_ = 0;
						gint _tmp21_ = 0;
						GeeConcurrentSetTowerIter _tmp22_ = {0};
						GeeConcurrentSetTower* _tmp23_ = NULL;
						GeeConcurrentSetTower* _tmp24_ = NULL;
						GeeConcurrentSetTower* _tmp25_ = NULL;
						if (!_tmp17_) {
							gint _tmp18_ = 0;
							_tmp18_ = i;
							i = _tmp18_ + 1;
						}
						_tmp17_ = FALSE;
						_tmp19_ = i;
						_tmp20_ = prev_height;
						if (!(_tmp19_ < _tmp20_)) {
							break;
						}
						_tmp21_ = i;
						_tmp22_ = self->_prev;
						_tmp23_ = _tmp22_._iter[0];
						_tmp24_ = _gee_concurrent_set_tower_ref0 (_tmp23_);
						_gee_concurrent_set_tower_unref0 (self->_prev._iter[_tmp21_]);
						self->_prev._iter[_tmp21_] = _tmp24_;
						_tmp25_ = self->_prev._iter[_tmp21_];
					}
				}
			}
		}
		_tmp26_ = new_curr;
		new_curr = NULL;
		_gee_concurrent_set_tower_unref0 (self->_curr);
		self->_curr = _tmp26_;
		self->_removed = FALSE;
	}
	_tmp27_ = self->_curr;
	_vala_assert (_tmp27_ != NULL, "_curr != null");
	result = success;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_iterator_real_has_next (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeConcurrentSetTower* prev = NULL;
	GeeConcurrentSetTowerIter _tmp1_ = {0};
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	GeeConcurrentSet* _tmp6_ = NULL;
	GCompareDataFunc _tmp7_ = NULL;
	void* _tmp7__target = NULL;
	gboolean _tmp8_ = FALSE;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->_prev;
	_tmp2_ = _tmp1_._iter[0];
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->_curr;
	_tmp5_ = _gee_concurrent_set_tower_ref0 (_tmp4_);
	curr = _tmp5_;
	_tmp6_ = self->_set;
	_tmp7_ = _tmp6_->priv->_cmp;
	_tmp7__target = _tmp6_->priv->_cmp_target;
	_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, &curr, (guint8) 0, FALSE);
	result = _tmp8_;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_iterator_real_get (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	gpointer result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gpointer _tmp4_ = NULL;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = self->_curr;
	_tmp3_ = _tmp2_->_data;
	_tmp4_ = ((_tmp3_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp3_) : ((gpointer) _tmp3_);
	result = _tmp4_;
	return result;
}


static void gee_concurrent_set_iterator_real_remove (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSet* _tmp4_ = NULL;
	GCompareDataFunc _tmp5_ = NULL;
	void* _tmp5__target = NULL;
	GeeConcurrentSetTower* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_, "valid");
	_tmp4_ = self->_set;
	_tmp5_ = _tmp4_->priv->_cmp;
	_tmp5__target = _tmp4_->priv->_cmp_target;
	_tmp6_ = self->_curr;
	_tmp7_ = gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, _tmp5__target, &self->_prev, _tmp6_);
	if (_tmp7_) {
		GeeConcurrentSet* _tmp8_ = NULL;
		_tmp8_ = self->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp8_->priv->_size));
	}
	self->_removed = TRUE;
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_iterator_real_get_valid (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetIterator* self;
	gboolean _tmp0_ = FALSE;
	GeeConcurrentSetTowerIter _tmp1_ = {0};
	GeeConcurrentSetTower* _tmp2_ = NULL;
	self = (GeeConcurrentSetIterator*) base;
	_tmp1_ = self->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ != NULL) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = self->_removed;
		_tmp0_ = !_tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


static gboolean gee_concurrent_set_iterator_real_get_read_only (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetIterator* self;
	self = (GeeConcurrentSetIterator*) base;
	result = TRUE;
	return result;
}


static void gee_concurrent_set_iterator_class_init (GeeConcurrentSetIteratorClass * klass) {
	gee_concurrent_set_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_VALID, g_param_spec_boolean ("valid", "valid", "valid", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static GType gee_concurrent_set_iterator_gee_traversable_get_g_type (GeeConcurrentSetIterator* self) {
	return self->priv->g_type;
}


static GBoxedCopyFunc gee_concurrent_set_iterator_gee_traversable_get_g_dup_func (GeeConcurrentSetIterator* self) {
	return self->priv->g_dup_func;
}


static GDestroyNotify gee_concurrent_set_iterator_gee_traversable_get_g_destroy_func (GeeConcurrentSetIterator* self) {
	return self->priv->g_destroy_func;
}


static void gee_concurrent_set_iterator_gee_traversable_interface_init (GeeTraversableIface * iface) {
	gee_concurrent_set_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*)(GeeTraversable*, GeeForallFunc, void*)) gee_concurrent_set_iterator_real_foreach;
	iface->tee = (GeeIterator** (*)(GeeTraversable*, guint, int*)) gee_concurrent_set_iterator_real_tee;
	iface->get_g_type = (GType(*)(GeeTraversable*)) gee_concurrent_set_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc(*)(GeeTraversable*)) gee_concurrent_set_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify(*)(GeeTraversable*)) gee_concurrent_set_iterator_gee_traversable_get_g_destroy_func;
}


static void gee_concurrent_set_iterator_gee_iterator_interface_init (GeeIteratorIface * iface) {
	gee_concurrent_set_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_iterator_real_next;
	iface->has_next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_iterator_real_has_next;
	iface->get = (gpointer (*)(GeeIterator*)) gee_concurrent_set_iterator_real_get;
	iface->remove = (void (*)(GeeIterator*)) gee_concurrent_set_iterator_real_remove;
	iface->get_valid = gee_concurrent_set_iterator_real_get_valid;
	iface->get_read_only = gee_concurrent_set_iterator_real_get_read_only;
}


static void gee_concurrent_set_iterator_instance_init (GeeConcurrentSetIterator * self) {
	self->priv = GEE_CONCURRENT_SET_ITERATOR_GET_PRIVATE (self);
	self->_removed = FALSE;
}


static void gee_concurrent_set_iterator_finalize (GObject* obj) {
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	_g_object_unref0 (self->_set);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	G_OBJECT_CLASS (gee_concurrent_set_iterator_parent_class)->finalize (obj);
}


static GType gee_concurrent_set_iterator_get_type (void) {
	static volatile gsize gee_concurrent_set_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetIterator), 0, (GInstanceInitFunc) gee_concurrent_set_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_concurrent_set_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_concurrent_set_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_concurrent_set_iterator_type_id;
		gee_concurrent_set_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeConcurrentSetIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_concurrent_set_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
		g_type_add_interface_static (gee_concurrent_set_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
		g_once_init_leave (&gee_concurrent_set_iterator_type_id__volatile, gee_concurrent_set_iterator_type_id);
	}
	return gee_concurrent_set_iterator_type_id__volatile;
}


static void _vala_gee_concurrent_set_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_ITERATOR_VALID:
		g_value_set_boolean (value, gee_iterator_get_valid ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_ITERATOR_READ_ONLY:
		g_value_set_boolean (value, gee_iterator_get_read_only ((GeeIterator*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_ITERATOR_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gpointer _gee_concurrent_set_range_ref0 (gpointer self) {
	return self ? gee_concurrent_set_range_ref (self) : NULL;
}


static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	GeeConcurrentSetSubSet * self = NULL;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	g_return_val_if_fail (range != NULL, NULL);
	self = (GeeConcurrentSetSubSet*) gee_abstract_sorted_set_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = range;
	_tmp1_ = _gee_concurrent_set_range_ref0 (_tmp0_);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	self->priv->_range = _tmp1_;
	return self;
}


static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	return gee_concurrent_set_sub_set_construct (GEE_CONCURRENT_SET_TYPE_SUB_SET, g_type, g_dup_func, g_destroy_func, range);
}


static GeeIterator* gee_concurrent_set_sub_set_real_iterator (GeeAbstractCollection* base) {
	GeeConcurrentSetSubSet * self;
	GeeIterator* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	GeeConcurrentSetSubIterator* _tmp2_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = gee_concurrent_set_sub_iterator_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_);
	result = (GeeIterator*) _tmp2_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_contains (GeeAbstractCollection* base, gconstpointer item) {
	GeeConcurrentSetSubSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp5_ = NULL;
	GeeConcurrentSetTowerIter _tmp6_ = {0};
	GeeConcurrentSetRange* _tmp7_ = NULL;
	GeeConcurrentSet* _tmp8_ = NULL;
	GCompareDataFunc _tmp9_ = NULL;
	void* _tmp9__target = NULL;
	gconstpointer _tmp10_ = NULL;
	gboolean _tmp11_ = FALSE;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = item;
	_tmp4_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	if (!_tmp4_) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp5_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp6_;
	_tmp7_ = self->priv->_range;
	_tmp8_ = _tmp7_->_set;
	_tmp9_ = _tmp8_->priv->_cmp;
	_tmp9__target = _tmp8_->priv->_cmp_target;
	_tmp10_ = item;
	_tmp11_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	result = _tmp11_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_add (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSetSubSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp5_ = NULL;
	GeeConcurrentSetTowerIter _tmp6_ = {0};
	GRand* rnd = NULL;
	GPrivate* _tmp7_ = NULL;
	void* _tmp8_ = NULL;
	GRand* _tmp9_ = NULL;
	guint32 rand_int = 0U;
	GRand* _tmp13_ = NULL;
	gint32 _tmp14_ = 0;
	guint8 height = 0U;
	guint32 _tmp15_ = 0U;
	gint _tmp16_ = 0;
	GeeConcurrentSetRange* _tmp17_ = NULL;
	GeeConcurrentSet* _tmp18_ = NULL;
	GCompareDataFunc _tmp19_ = NULL;
	void* _tmp19__target = NULL;
	gconstpointer _tmp20_ = NULL;
	guint8 _tmp21_ = 0U;
	gboolean _tmp22_ = FALSE;
	GeeConcurrentSetTower* _result_ = NULL;
	GeeConcurrentSetRange* _tmp33_ = NULL;
	GeeConcurrentSet* _tmp34_ = NULL;
	GCompareDataFunc _tmp35_ = NULL;
	void* _tmp35__target = NULL;
	gconstpointer _tmp36_ = NULL;
	guint8 _tmp37_ = 0U;
	GeeConcurrentSetTower* _tmp38_ = NULL;
	GeeConcurrentSetTower* _tmp39_ = NULL;
	GeeConcurrentSetTower* _tmp42_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = key;
	_tmp4_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	if (!_tmp4_) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp5_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp6_;
	_tmp7_ = gee_concurrent_set_rand;
	_tmp8_ = g_private_get (_tmp7_);
	rnd = _tmp8_;
	_tmp9_ = rnd;
	if (_tmp9_ == NULL) {
		GPrivate* _tmp10_ = NULL;
		GRand* _tmp11_ = NULL;
		GRand* _tmp12_ = NULL;
		_tmp10_ = gee_concurrent_set_rand;
		_tmp11_ = g_rand_new ();
		rnd = _tmp11_;
		_tmp12_ = rnd;
		g_private_set (_tmp10_, _tmp12_);
	}
	_tmp13_ = rnd;
	_tmp14_ = g_rand_int_range (_tmp13_, (gint32) 0, G_MAXINT32);
	rand_int = (guint32) _tmp14_;
	_tmp15_ = rand_int;
	_tmp16_ = g_bit_nth_lsf ((gulong) (~_tmp15_), -1);
	height = (guint8) (1 + ((guint8) _tmp16_));
	_tmp17_ = self->priv->_range;
	_tmp18_ = _tmp17_->_set;
	_tmp19_ = _tmp18_->priv->_cmp;
	_tmp19__target = _tmp18_->priv->_cmp_target;
	_tmp20_ = key;
	_tmp21_ = height;
	_tmp22_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp19_, _tmp19__target, _tmp20_, &prev, NULL, (guint8) (_tmp21_ - 1), (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	if (_tmp22_) {
		result = FALSE;
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	{
		gint i = 0;
		guint8 _tmp23_ = 0U;
		_tmp23_ = height;
		i = _tmp23_ - 2;
		{
			gboolean _tmp24_ = FALSE;
			_tmp24_ = TRUE;
			while (TRUE) {
				gint _tmp26_ = 0;
				gint _tmp27_ = 0;
				GeeConcurrentSetTowerIter _tmp28_ = {0};
				guint8 _tmp29_ = 0U;
				GeeConcurrentSetTower* _tmp30_ = NULL;
				GeeConcurrentSetTower* _tmp31_ = NULL;
				GeeConcurrentSetTower* _tmp32_ = NULL;
				if (!_tmp24_) {
					gint _tmp25_ = 0;
					_tmp25_ = i;
					i = _tmp25_ - 1;
				}
				_tmp24_ = FALSE;
				_tmp26_ = i;
				if (!(_tmp26_ >= 0)) {
					break;
				}
				_tmp27_ = i;
				_tmp28_ = prev;
				_tmp29_ = height;
				_tmp30_ = _tmp28_._iter[_tmp29_ - 1];
				_tmp31_ = _gee_concurrent_set_tower_ref0 (_tmp30_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp27_]);
				prev._iter[_tmp27_] = _tmp31_;
				_tmp32_ = prev._iter[_tmp27_];
			}
		}
	}
	_tmp33_ = self->priv->_range;
	_tmp34_ = _tmp33_->_set;
	_tmp35_ = _tmp34_->priv->_cmp;
	_tmp35__target = _tmp34_->priv->_cmp_target;
	_tmp36_ = key;
	_tmp37_ = height;
	_tmp38_ = gee_concurrent_set_tower_insert (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp35_, _tmp35__target, &prev, _tmp36_, (guint8) (_tmp37_ - 1));
	_result_ = _tmp38_;
	_tmp39_ = _result_;
	if (_tmp39_ != NULL) {
		GeeConcurrentSetRange* _tmp40_ = NULL;
		GeeConcurrentSet* _tmp41_ = NULL;
		_tmp40_ = self->priv->_range;
		_tmp41_ = _tmp40_->_set;
		g_atomic_int_inc ((volatile gint *) (&_tmp41_->priv->_size));
	}
	_tmp42_ = _result_;
	result = _tmp42_ != NULL;
	_gee_concurrent_set_tower_unref0 (_result_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_remove (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSetSubSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp5_ = NULL;
	GeeConcurrentSetTowerIter _tmp6_ = {0};
	gboolean _result_ = FALSE;
	GeeConcurrentSetRange* _tmp7_ = NULL;
	GeeConcurrentSet* _tmp8_ = NULL;
	GCompareDataFunc _tmp9_ = NULL;
	void* _tmp9__target = NULL;
	gconstpointer _tmp10_ = NULL;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_ = FALSE;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = key;
	_tmp4_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	if (!_tmp4_) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp5_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp6_;
	_tmp7_ = self->priv->_range;
	_tmp8_ = _tmp7_->_set;
	_tmp9_ = _tmp8_->priv->_cmp;
	_tmp9__target = _tmp8_->priv->_cmp_target;
	_tmp10_ = key;
	_tmp11_ = gee_concurrent_set_tower_remove_key (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, &prev, _tmp10_, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_result_ = _tmp11_;
	_tmp12_ = _result_;
	if (_tmp12_) {
		GeeConcurrentSetRange* _tmp13_ = NULL;
		GeeConcurrentSet* _tmp14_ = NULL;
		_tmp13_ = self->priv->_range;
		_tmp14_ = _tmp13_->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp14_->priv->_size));
	}
	result = _result_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static void gee_concurrent_set_sub_set_real_clear (GeeAbstractCollection* base) {
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTower* first = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, &_tmp3_, &_tmp4_);
	_gee_concurrent_set_tower_unref0 (first);
	first = _tmp3_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp4_;
	while (TRUE) {
		GeeConcurrentSetTower* _tmp5_ = NULL;
		GeeConcurrentSetRange* _tmp6_ = NULL;
		GeeConcurrentSet* _tmp7_ = NULL;
		GCompareDataFunc _tmp8_ = NULL;
		void* _tmp8__target = NULL;
		GeeConcurrentSetTower* _tmp9_ = NULL;
		GeeConcurrentSetRange* _tmp10_ = NULL;
		GeeConcurrentSetTower* _tmp11_ = NULL;
		GeeConcurrentSetTowerIter _tmp12_ = {0};
		_tmp5_ = first;
		if (!(_tmp5_ != NULL)) {
			break;
		}
		_tmp6_ = self->priv->_range;
		_tmp7_ = _tmp6_->_set;
		_tmp8_ = _tmp7_->priv->_cmp;
		_tmp8__target = _tmp7_->priv->_cmp_target;
		_tmp9_ = first;
		gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, &prev, _tmp9_);
		_tmp10_ = self->priv->_range;
		gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp10_, &_tmp11_, &_tmp12_);
		_gee_concurrent_set_tower_unref0 (first);
		first = _tmp11_;
		gee_concurrent_set_tower_iter_destroy (&prev);
		prev = _tmp12_;
	}
	_gee_concurrent_set_tower_unref0 (first);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_first (GeeAbstractSortedSet* base) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* first = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	gconstpointer _tmp6_ = NULL;
	gpointer _tmp7_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, &_tmp3_, NULL);
	_gee_concurrent_set_tower_unref0 (first);
	first = _tmp3_;
	_tmp4_ = first;
	if (_tmp4_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (first);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp5_ = first;
	_tmp6_ = _tmp5_->_data;
	_tmp7_ = ((_tmp6_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp6_) : ((gpointer) _tmp6_);
	result = _tmp7_;
	_gee_concurrent_set_tower_unref0 (first);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_sub_set_real_last (GeeAbstractSortedSet* base) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetTowerIter _tmp3_ = {0};
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp32_ = NULL;
	GeeConcurrentSetTower* _tmp33_ = NULL;
	gconstpointer _tmp34_ = NULL;
	gpointer _tmp35_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, NULL, &_tmp3_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp3_;
	curr = NULL;
	{
		gint i = 0;
		i = GEE_CONCURRENT_SET__MAX_HEIGHT - 1;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				gint _tmp6_ = 0;
				GeeConcurrentSetTower* _tmp7_ = NULL;
				gboolean improved = FALSE;
				gboolean _tmp23_ = FALSE;
				gboolean _tmp24_ = FALSE;
				if (!_tmp4_) {
					gint _tmp5_ = 0;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp4_ = FALSE;
				_tmp6_ = i;
				if (!(_tmp6_ >= 0)) {
					break;
				}
				_tmp7_ = curr;
				if (_tmp7_ == NULL) {
					GeeConcurrentSetTowerIter _tmp8_ = {0};
					gint _tmp9_ = 0;
					GeeConcurrentSetTower* _tmp10_ = NULL;
					gint _tmp11_ = 0;
					GeeConcurrentSetTower* _tmp12_ = NULL;
					gboolean _tmp13_ = FALSE;
					GeeConcurrentSetTower* _tmp14_ = NULL;
					_tmp8_ = prev;
					_tmp9_ = i;
					_tmp10_ = _tmp8_._iter[_tmp9_];
					_tmp11_ = i;
					_tmp12_ = gee_concurrent_set_tower_get_next (_tmp10_, (guint8) _tmp11_);
					_gee_concurrent_set_tower_unref0 (curr);
					curr = _tmp12_;
					_tmp14_ = curr;
					if (_tmp14_ == NULL) {
						_tmp13_ = TRUE;
					} else {
						GeeConcurrentSetRange* _tmp15_ = NULL;
						GeeConcurrentSetTower* _tmp16_ = NULL;
						gconstpointer _tmp17_ = NULL;
						gboolean _tmp18_ = FALSE;
						_tmp15_ = self->priv->_range;
						_tmp16_ = curr;
						_tmp17_ = _tmp16_->_data;
						_tmp18_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp15_, _tmp17_);
						_tmp13_ = !_tmp18_;
					}
					if (_tmp13_) {
						_gee_concurrent_set_tower_unref0 (curr);
						curr = NULL;
						continue;
					}
				}
				improved = FALSE;
				while (TRUE) {
					GeeConcurrentSetRange* _tmp19_ = NULL;
					gint _tmp20_ = 0;
					gint _tmp21_ = 0;
					gboolean _tmp22_ = FALSE;
					_tmp19_ = self->priv->_range;
					_tmp20_ = i;
					_tmp21_ = i;
					_tmp22_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp19_, &prev._iter[_tmp20_], &curr, (guint8) _tmp21_);
					if (!_tmp22_) {
						break;
					}
					improved = TRUE;
				}
				_tmp24_ = improved;
				if (_tmp24_) {
					gint _tmp25_ = 0;
					_tmp25_ = i;
					_tmp23_ = _tmp25_ > 0;
				} else {
					_tmp23_ = FALSE;
				}
				if (_tmp23_) {
					gint _tmp26_ = 0;
					GeeConcurrentSetTowerIter _tmp27_ = {0};
					gint _tmp28_ = 0;
					GeeConcurrentSetTower* _tmp29_ = NULL;
					GeeConcurrentSetTower* _tmp30_ = NULL;
					GeeConcurrentSetTower* _tmp31_ = NULL;
					_tmp26_ = i;
					_tmp27_ = prev;
					_tmp28_ = i;
					_tmp29_ = _tmp27_._iter[_tmp28_];
					_tmp30_ = _gee_concurrent_set_tower_ref0 (_tmp29_);
					_gee_concurrent_set_tower_unref0 (prev._iter[_tmp26_ - 1]);
					prev._iter[_tmp26_ - 1] = _tmp30_;
					_tmp31_ = prev._iter[_tmp26_ - 1];
				}
			}
		}
	}
	_tmp32_ = curr;
	if (_tmp32_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp33_ = curr;
	_tmp34_ = _tmp33_->_data;
	_tmp35_ = ((_tmp34_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp34_) : ((gpointer) _tmp34_);
	result = _tmp35_;
	_gee_concurrent_set_tower_unref0 (curr);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeIterator* gee_concurrent_set_sub_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	GeeIterator* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTowerIter next = {0};
	GeeConcurrentSetRange* _tmp5_ = NULL;
	GeeConcurrentSetTowerIter _tmp6_ = {0};
	GeeConcurrentSetRange* _tmp7_ = NULL;
	GeeConcurrentSet* _tmp8_ = NULL;
	GCompareDataFunc _tmp9_ = NULL;
	void* _tmp9__target = NULL;
	gconstpointer _tmp10_ = NULL;
	GeeConcurrentSetTowerIter _tmp11_ = {0};
	gboolean _tmp12_ = FALSE;
	GeeConcurrentSetRange* _tmp13_ = NULL;
	GeeConcurrentSetTowerIter _tmp14_ = {0};
	GeeConcurrentSetTower* _tmp15_ = NULL;
	GeeConcurrentSetTower* _tmp16_ = NULL;
	GeeConcurrentSetSubIterator* _tmp17_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = element;
	_tmp4_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	if (!_tmp4_) {
		result = NULL;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp5_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp6_;
	_tmp7_ = self->priv->_range;
	_tmp8_ = _tmp7_->_set;
	_tmp9_ = _tmp8_->priv->_cmp;
	_tmp9__target = _tmp8_->priv->_cmp_target;
	_tmp10_ = element;
	_tmp12_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, &_tmp11_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	gee_concurrent_set_tower_iter_destroy (&next);
	next = _tmp11_;
	if (!_tmp12_) {
		result = NULL;
		gee_concurrent_set_tower_iter_destroy (&next);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp13_ = self->priv->_range;
	_tmp14_ = next;
	_tmp15_ = _tmp14_._iter[0];
	_tmp16_ = _gee_concurrent_set_tower_ref0 (_tmp15_);
	_tmp17_ = gee_concurrent_set_sub_iterator_new_point_at (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp13_, &prev, _tmp16_);
	result = (GeeIterator*) _tmp17_;
	gee_concurrent_set_tower_iter_destroy (&next);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_sub_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gint _tmp4_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = element;
	_tmp4_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp5_ = NULL;
			GeeConcurrentSetTowerIter _tmp6_ = {0};
			GeeConcurrentSetRange* _tmp7_ = NULL;
			GeeConcurrentSet* _tmp8_ = NULL;
			GCompareDataFunc _tmp9_ = NULL;
			void* _tmp9__target = NULL;
			gconstpointer _tmp10_ = NULL;
			gboolean _tmp11_ = FALSE;
			GeeConcurrentSetTowerIter _tmp12_ = {0};
			GeeConcurrentSetTower* _tmp13_ = NULL;
			GeeConcurrentSetRange* _tmp14_ = NULL;
			GeeConcurrentSet* _tmp15_ = NULL;
			GeeConcurrentSetTower* _tmp16_ = NULL;
			GeeConcurrentSetTowerIter _tmp22_ = {0};
			GeeConcurrentSetTower* _tmp23_ = NULL;
			gconstpointer _tmp24_ = NULL;
			gpointer _tmp25_ = NULL;
			_tmp5_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp6_;
			_tmp7_ = self->priv->_range;
			_tmp8_ = _tmp7_->_set;
			_tmp9_ = _tmp8_->priv->_cmp;
			_tmp9__target = _tmp8_->priv->_cmp_target;
			_tmp10_ = element;
			gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			_tmp12_ = prev;
			_tmp13_ = _tmp12_._iter[0];
			_tmp14_ = self->priv->_range;
			_tmp15_ = _tmp14_->_set;
			_tmp16_ = _tmp15_->priv->_head;
			if (_tmp13_ == _tmp16_) {
				_tmp11_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp17_ = NULL;
				GeeConcurrentSetTowerIter _tmp18_ = {0};
				GeeConcurrentSetTower* _tmp19_ = NULL;
				gconstpointer _tmp20_ = NULL;
				gboolean _tmp21_ = FALSE;
				_tmp17_ = self->priv->_range;
				_tmp18_ = prev;
				_tmp19_ = _tmp18_._iter[0];
				_tmp20_ = _tmp19_->_data;
				_tmp21_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp17_, _tmp20_);
				_tmp11_ = !_tmp21_;
			}
			if (_tmp11_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp22_ = prev;
			_tmp23_ = _tmp22_._iter[0];
			_tmp24_ = _tmp23_->_data;
			_tmp25_ = ((_tmp24_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp24_) : ((gpointer) _tmp24_);
			result = _tmp25_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		{
			gpointer _tmp26_ = NULL;
			_tmp26_ = gee_abstract_sorted_set_last ((GeeAbstractSortedSet*) self);
			result = _tmp26_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gint _tmp4_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = element;
	_tmp4_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		{
			gpointer _tmp5_ = NULL;
			_tmp5_ = gee_abstract_sorted_set_first ((GeeAbstractSortedSet*) self);
			result = _tmp5_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetRange* _tmp6_ = NULL;
			GeeConcurrentSetTowerIter _tmp7_ = {0};
			GeeConcurrentSetRange* _tmp8_ = NULL;
			GeeConcurrentSet* _tmp9_ = NULL;
			GCompareDataFunc _tmp10_ = NULL;
			void* _tmp10__target = NULL;
			gconstpointer _tmp11_ = NULL;
			GeeConcurrentSetTowerIter _tmp12_ = {0};
			gboolean _tmp13_ = FALSE;
			gboolean _tmp18_ = FALSE;
			GeeConcurrentSetTowerIter _tmp19_ = {0};
			GeeConcurrentSetTower* _tmp20_ = NULL;
			GeeConcurrentSetTowerIter _tmp26_ = {0};
			GeeConcurrentSetTower* _tmp27_ = NULL;
			gconstpointer _tmp28_ = NULL;
			gpointer _tmp29_ = NULL;
			_tmp6_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp6_, NULL, &_tmp7_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp7_;
			_tmp8_ = self->priv->_range;
			_tmp9_ = _tmp8_->_set;
			_tmp10_ = _tmp9_->priv->_cmp;
			_tmp10__target = _tmp9_->priv->_cmp_target;
			_tmp11_ = element;
			_tmp13_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp10_, _tmp10__target, _tmp11_, &prev, &_tmp12_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp12_;
			if (_tmp13_) {
				GeeConcurrentSetRange* _tmp14_ = NULL;
				GeeConcurrentSet* _tmp15_ = NULL;
				GCompareDataFunc _tmp16_ = NULL;
				void* _tmp16__target = NULL;
				gboolean _tmp17_ = FALSE;
				_tmp14_ = self->priv->_range;
				_tmp15_ = _tmp14_->_set;
				_tmp16_ = _tmp15_->priv->_cmp;
				_tmp16__target = _tmp15_->priv->_cmp_target;
				_tmp17_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp16_, _tmp16__target, &prev._iter[0], &curr._iter[0], (guint8) 0, FALSE);
				if (!_tmp17_) {
					result = NULL;
					gee_concurrent_set_tower_iter_destroy (&curr);
					gee_concurrent_set_tower_iter_destroy (&prev);
					_gee_hazard_pointer_context_free0 (ctx);
					return result;
				}
			}
			_tmp19_ = curr;
			_tmp20_ = _tmp19_._iter[0];
			if (_tmp20_ == NULL) {
				_tmp18_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp21_ = NULL;
				GeeConcurrentSetTowerIter _tmp22_ = {0};
				GeeConcurrentSetTower* _tmp23_ = NULL;
				gconstpointer _tmp24_ = NULL;
				gboolean _tmp25_ = FALSE;
				_tmp21_ = self->priv->_range;
				_tmp22_ = curr;
				_tmp23_ = _tmp22_._iter[0];
				_tmp24_ = _tmp23_->_data;
				_tmp25_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp21_, _tmp24_);
				_tmp18_ = !_tmp25_;
			}
			if (_tmp18_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&curr);
				gee_concurrent_set_tower_iter_destroy (&prev);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp26_ = curr;
			_tmp27_ = _tmp26_._iter[0];
			_tmp28_ = _tmp27_->_data;
			_tmp29_ = ((_tmp28_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp28_) : ((gpointer) _tmp28_);
			result = _tmp29_;
			gee_concurrent_set_tower_iter_destroy (&curr);
			gee_concurrent_set_tower_iter_destroy (&prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gint _tmp4_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = element;
	_tmp4_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp5_ = NULL;
			GeeConcurrentSetTowerIter _tmp6_ = {0};
			GeeConcurrentSetRange* _tmp7_ = NULL;
			GeeConcurrentSet* _tmp8_ = NULL;
			GCompareDataFunc _tmp9_ = NULL;
			void* _tmp9__target = NULL;
			gconstpointer _tmp10_ = NULL;
			GeeConcurrentSetTowerIter _tmp11_ = {0};
			gboolean _tmp12_ = FALSE;
			gboolean _tmp15_ = FALSE;
			gboolean _tmp16_ = FALSE;
			GeeConcurrentSetTowerIter _tmp17_ = {0};
			GeeConcurrentSetTower* _tmp18_ = NULL;
			GeeConcurrentSetTowerIter _tmp27_ = {0};
			GeeConcurrentSetTower* _tmp28_ = NULL;
			gconstpointer _tmp29_ = NULL;
			gpointer _tmp30_ = NULL;
			_tmp5_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp6_;
			_tmp7_ = self->priv->_range;
			_tmp8_ = _tmp7_->_set;
			_tmp9_ = _tmp8_->priv->_cmp;
			_tmp9__target = _tmp8_->priv->_cmp_target;
			_tmp10_ = element;
			_tmp12_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, &_tmp11_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp11_;
			if (!_tmp12_) {
				GeeConcurrentSetTower* _tmp13_ = NULL;
				GeeConcurrentSetTower* _tmp14_ = NULL;
				_tmp13_ = prev._iter[0];
				prev._iter[0] = NULL;
				_gee_concurrent_set_tower_unref0 (curr._iter[0]);
				curr._iter[0] = _tmp13_;
				_tmp14_ = curr._iter[0];
			}
			_tmp17_ = curr;
			_tmp18_ = _tmp17_._iter[0];
			if (_tmp18_ == NULL) {
				_tmp16_ = TRUE;
			} else {
				GeeConcurrentSetTowerIter _tmp19_ = {0};
				GeeConcurrentSetTower* _tmp20_ = NULL;
				gboolean _tmp21_ = FALSE;
				_tmp19_ = curr;
				_tmp20_ = _tmp19_._iter[0];
				_tmp21_ = gee_concurrent_set_tower_is_head (_tmp20_);
				_tmp16_ = _tmp21_;
			}
			if (_tmp16_) {
				_tmp15_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp22_ = NULL;
				GeeConcurrentSetTowerIter _tmp23_ = {0};
				GeeConcurrentSetTower* _tmp24_ = NULL;
				gconstpointer _tmp25_ = NULL;
				gboolean _tmp26_ = FALSE;
				_tmp22_ = self->priv->_range;
				_tmp23_ = curr;
				_tmp24_ = _tmp23_._iter[0];
				_tmp25_ = _tmp24_->_data;
				_tmp26_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp22_, _tmp25_);
				_tmp15_ = !_tmp26_;
			}
			if (_tmp15_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				gee_concurrent_set_tower_iter_destroy (&curr);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp27_ = curr;
			_tmp28_ = _tmp27_._iter[0];
			_tmp29_ = _tmp28_->_data;
			_tmp30_ = ((_tmp29_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp29_) : ((gpointer) _tmp29_);
			result = _tmp30_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			gee_concurrent_set_tower_iter_destroy (&curr);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		{
			gpointer _tmp31_ = NULL;
			_tmp31_ = gee_abstract_sorted_set_last ((GeeAbstractSortedSet*) self);
			result = _tmp31_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gint _tmp4_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	_tmp3_ = element;
	_tmp4_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, _tmp3_);
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		{
			gpointer _tmp5_ = NULL;
			_tmp5_ = gee_abstract_sorted_set_first ((GeeAbstractSortedSet*) self);
			result = _tmp5_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp6_ = NULL;
			GeeConcurrentSetTowerIter _tmp7_ = {0};
			GeeConcurrentSetRange* _tmp8_ = NULL;
			GeeConcurrentSet* _tmp9_ = NULL;
			GCompareDataFunc _tmp10_ = NULL;
			void* _tmp10__target = NULL;
			gconstpointer _tmp11_ = NULL;
			GeeConcurrentSetTowerIter _tmp12_ = {0};
			gboolean _tmp13_ = FALSE;
			GeeConcurrentSetTowerIter _tmp14_ = {0};
			GeeConcurrentSetTower* _tmp15_ = NULL;
			GeeConcurrentSetTowerIter _tmp21_ = {0};
			GeeConcurrentSetTower* _tmp22_ = NULL;
			gconstpointer _tmp23_ = NULL;
			gpointer _tmp24_ = NULL;
			_tmp6_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp6_, NULL, &_tmp7_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp7_;
			_tmp8_ = self->priv->_range;
			_tmp9_ = _tmp8_->_set;
			_tmp10_ = _tmp9_->priv->_cmp;
			_tmp10__target = _tmp9_->priv->_cmp_target;
			_tmp11_ = element;
			gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp10_, _tmp10__target, _tmp11_, &prev, &_tmp12_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp12_;
			_tmp14_ = curr;
			_tmp15_ = _tmp14_._iter[0];
			if (_tmp15_ == NULL) {
				_tmp13_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp16_ = NULL;
				GeeConcurrentSetTowerIter _tmp17_ = {0};
				GeeConcurrentSetTower* _tmp18_ = NULL;
				gconstpointer _tmp19_ = NULL;
				gboolean _tmp20_ = FALSE;
				_tmp16_ = self->priv->_range;
				_tmp17_ = curr;
				_tmp18_ = _tmp17_._iter[0];
				_tmp19_ = _tmp18_->_data;
				_tmp20_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp16_, _tmp19_);
				_tmp13_ = !_tmp20_;
			}
			if (_tmp13_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				gee_concurrent_set_tower_iter_destroy (&curr);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp21_ = curr;
			_tmp22_ = _tmp21_._iter[0];
			_tmp23_ = _tmp22_->_data;
			_tmp24_ = ((_tmp23_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp23_) : ((gpointer) _tmp23_);
			result = _tmp24_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			gee_concurrent_set_tower_iter_destroy (&curr);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static GeeSortedSet* gee_concurrent_set_sub_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before) {
	GeeConcurrentSetSubSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSetSubSet* _tmp5_ = NULL;
	GeeSortedSet* _tmp6_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = before;
	_tmp3_ = gee_concurrent_set_range_cut_tail (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_);
	_tmp6_ = (GeeSortedSet*) _tmp5_;
	_gee_concurrent_set_range_unref0 (_tmp4_);
	result = _tmp6_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_sub_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after) {
	GeeConcurrentSetSubSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSetSubSet* _tmp5_ = NULL;
	GeeSortedSet* _tmp6_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = after;
	_tmp3_ = gee_concurrent_set_range_cut_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_);
	_tmp6_ = (GeeSortedSet*) _tmp5_;
	_gee_concurrent_set_range_unref0 (_tmp4_);
	result = _tmp6_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_sub_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to) {
	GeeConcurrentSetSubSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSetRange* _tmp5_ = NULL;
	GeeConcurrentSetSubSet* _tmp6_ = NULL;
	GeeSortedSet* _tmp7_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	_tmp2_ = from;
	_tmp3_ = to;
	_tmp4_ = gee_concurrent_set_range_cut (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_, _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_);
	_tmp7_ = (GeeSortedSet*) _tmp6_;
	_gee_concurrent_set_range_unref0 (_tmp5_);
	result = _tmp7_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gint gee_concurrent_set_sub_set_real_get_size (GeeAbstractCollection* base) {
	gint result;
	GeeConcurrentSetSubSet* self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, &_tmp3_, NULL);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp3_;
	_tmp4_ = curr;
	if (_tmp4_ != NULL) {
		gint acc = 0;
		GeeConcurrentSetTower* prev = NULL;
		GeeConcurrentSetRange* _tmp5_ = NULL;
		gpointer _tmp6_ = NULL;
		gint _tmp10_ = 0;
		acc = 1;
		_tmp5_ = self->priv->_range;
		_tmp6_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp5_->_bookmark._iter[0], (gsize) 0, NULL);
		prev = (GeeConcurrentSetTower*) _tmp6_;
		while (TRUE) {
			GeeConcurrentSetRange* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			gint _tmp9_ = 0;
			_tmp7_ = self->priv->_range;
			_tmp8_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, &prev, &curr, (guint8) 0);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = acc;
			acc = _tmp9_ + 1;
		}
		_tmp10_ = acc;
		result = _tmp10_;
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		result = 0;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_sub_set_get_is_empty (GeeConcurrentSetSubSet* self) {
	gboolean result;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	gee_utils_misc_unused (ctx);
	_tmp1_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, &_tmp2_, NULL);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp2_;
	result = curr != NULL;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_get_read_only (GeeAbstractCollection* base) {
	gboolean result;
	GeeConcurrentSetSubSet* self;
	self = (GeeConcurrentSetSubSet*) base;
	result = FALSE;
	return result;
}


static void gee_concurrent_set_sub_set_class_init (GeeConcurrentSetSubSetClass * klass) {
	gee_concurrent_set_sub_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetSubSetPrivate));
	((GeeAbstractCollectionClass *) klass)->iterator = gee_concurrent_set_sub_set_real_iterator;
	((GeeAbstractCollectionClass *) klass)->contains = gee_concurrent_set_sub_set_real_contains;
	((GeeAbstractCollectionClass *) klass)->add = gee_concurrent_set_sub_set_real_add;
	((GeeAbstractCollectionClass *) klass)->remove = gee_concurrent_set_sub_set_real_remove;
	((GeeAbstractCollectionClass *) klass)->clear = gee_concurrent_set_sub_set_real_clear;
	((GeeAbstractSortedSetClass *) klass)->first = gee_concurrent_set_sub_set_real_first;
	((GeeAbstractSortedSetClass *) klass)->last = gee_concurrent_set_sub_set_real_last;
	((GeeAbstractSortedSetClass *) klass)->iterator_at = gee_concurrent_set_sub_set_real_iterator_at;
	((GeeAbstractSortedSetClass *) klass)->lower = gee_concurrent_set_sub_set_real_lower;
	((GeeAbstractSortedSetClass *) klass)->higher = gee_concurrent_set_sub_set_real_higher;
	((GeeAbstractSortedSetClass *) klass)->floor = gee_concurrent_set_sub_set_real_floor;
	((GeeAbstractSortedSetClass *) klass)->ceil = gee_concurrent_set_sub_set_real_ceil;
	((GeeAbstractSortedSetClass *) klass)->head_set = gee_concurrent_set_sub_set_real_head_set;
	((GeeAbstractSortedSetClass *) klass)->tail_set = gee_concurrent_set_sub_set_real_tail_set;
	((GeeAbstractSortedSetClass *) klass)->sub_set = gee_concurrent_set_sub_set_real_sub_set;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_concurrent_set_sub_set_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_concurrent_set_sub_set_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_sub_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_sub_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_sub_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY, g_param_spec_boolean ("is-empty", "is-empty", "is-empty", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void gee_concurrent_set_sub_set_instance_init (GeeConcurrentSetSubSet * self) {
	self->priv = GEE_CONCURRENT_SET_SUB_SET_GET_PRIVATE (self);
}


static void gee_concurrent_set_sub_set_finalize (GObject* obj) {
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	G_OBJECT_CLASS (gee_concurrent_set_sub_set_parent_class)->finalize (obj);
}


static GType gee_concurrent_set_sub_set_get_type (void) {
	static volatile gsize gee_concurrent_set_sub_set_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_sub_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetSubSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_sub_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetSubSet), 0, (GInstanceInitFunc) gee_concurrent_set_sub_set_instance_init, NULL };
		GType gee_concurrent_set_sub_set_type_id;
		gee_concurrent_set_sub_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SORTED_SET, "GeeConcurrentSetSubSet", &g_define_type_info, 0);
		g_once_init_leave (&gee_concurrent_set_sub_set_type_id__volatile, gee_concurrent_set_sub_set_type_id);
	}
	return gee_concurrent_set_sub_set_type_id__volatile;
}


static void _vala_gee_concurrent_set_sub_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_SET_SIZE:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY:
		g_value_set_boolean (value, gee_concurrent_set_sub_set_get_is_empty (self));
		break;
		case GEE_CONCURRENT_SET_SUB_SET_READ_ONLY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_sub_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_SET_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	g_return_val_if_fail (range != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = range;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, NULL, NULL);
	_tmp1_ = range;
	_tmp2_ = _gee_concurrent_set_range_ref0 (_tmp1_);
	_gee_concurrent_set_range_unref0 (self->_range);
	self->_range = _tmp2_;
	return self;
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	return gee_concurrent_set_sub_iterator_construct (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, range);
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetTowerIter _tmp3_ = {0};
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTower* _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_ = NULL;
	g_return_val_if_fail (range != NULL, NULL);
	g_return_val_if_fail (prev != NULL, NULL);
	g_return_val_if_fail (curr != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = range;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, NULL, NULL);
	_tmp1_ = range;
	_tmp2_ = _gee_concurrent_set_range_ref0 (_tmp1_);
	_gee_concurrent_set_range_unref0 (self->_range);
	self->_range = _tmp2_;
	_tmp3_ = *prev;
	gee_concurrent_set_tower_iter_copy (&_tmp3_, &_tmp4_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp4_;
	_tmp5_ = curr;
	_tmp6_ = _gee_concurrent_set_tower_ref0 (_tmp5_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp6_;
	_gee_concurrent_set_tower_unref0 (curr);
	return self;
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	return gee_concurrent_set_sub_iterator_construct_point_at (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, range, prev, curr);
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_from_iterator (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetSubIterator* iter) {
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetSubIterator* _tmp0_ = NULL;
	GeeConcurrentSetRange* _tmp1_ = NULL;
	GeeConcurrentSetSubIterator* _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSetSubIterator* _tmp5_ = NULL;
	GeeConcurrentSetTowerIter _tmp6_ = {0};
	GeeConcurrentSetTowerIter _tmp7_ = {0};
	GeeConcurrentSetSubIterator* _tmp8_ = NULL;
	GeeConcurrentSetTower* _tmp9_ = NULL;
	GeeConcurrentSetTower* _tmp10_ = NULL;
	GeeConcurrentSetSubIterator* _tmp11_ = NULL;
	gboolean _tmp12_ = FALSE;
	g_return_val_if_fail (iter != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = iter;
	_tmp1_ = _tmp0_->_range;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp1_, NULL, NULL);
	_tmp2_ = iter;
	_tmp3_ = _tmp2_->_range;
	_tmp4_ = _gee_concurrent_set_range_ref0 (_tmp3_);
	_gee_concurrent_set_range_unref0 (self->_range);
	self->_range = _tmp4_;
	_tmp5_ = iter;
	_tmp6_ = _tmp5_->_prev;
	gee_concurrent_set_tower_iter_copy (&_tmp6_, &_tmp7_);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp7_;
	_tmp8_ = iter;
	_tmp9_ = _tmp8_->_curr;
	_tmp10_ = _gee_concurrent_set_tower_ref0 (_tmp9_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp10_;
	_tmp11_ = iter;
	_tmp12_ = _tmp11_->_removed;
	self->_removed = _tmp12_;
	return self;
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_from_iterator (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetSubIterator* iter) {
	return gee_concurrent_set_sub_iterator_construct_from_iterator (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, iter);
}


static gboolean gee_concurrent_set_sub_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target) {
	GeeConcurrentSetSubIterator * self;
	gboolean result = FALSE;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeHazardPointerContext* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GeeConcurrentSetTower* _tmp6_ = NULL;
	GeeConcurrentSetTower* new_prev = NULL;
	GeeConcurrentSetTowerIter _tmp14_ = {0};
	GeeConcurrentSetTower* _tmp15_ = NULL;
	GeeConcurrentSetTower* _tmp16_ = NULL;
	GeeConcurrentSetTower* new_curr = NULL;
	GeeConcurrentSetTower* _tmp17_ = NULL;
	GeeConcurrentSetTower* _tmp18_ = NULL;
	GeeConcurrentSetTower* _tmp44_ = NULL;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = self->_curr;
	_vala_assert (_tmp0_ != NULL, "_curr != null");
	_tmp1_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp1_;
	_tmp2_ = ctx;
	gee_utils_misc_unused (_tmp2_);
	_tmp3_ = gee_concurrent_set_sub_iterator_begin (self);
	if (!_tmp3_) {
		result = TRUE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp5_ = self->_prev;
	_tmp6_ = _tmp5_._iter[0];
	if (_tmp6_ != NULL) {
		gboolean _tmp7_ = FALSE;
		_tmp7_ = self->_removed;
		_tmp4_ = !_tmp7_;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		GeeForallFunc _tmp8_ = NULL;
		void* _tmp8__target = NULL;
		GeeConcurrentSetTower* _tmp9_ = NULL;
		gconstpointer _tmp10_ = NULL;
		gpointer _tmp11_ = NULL;
		gboolean _tmp12_ = FALSE;
		_tmp8_ = f;
		_tmp8__target = f_target;
		_tmp9_ = self->_curr;
		_tmp10_ = _tmp9_->_data;
		_tmp11_ = ((_tmp10_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp10_) : ((gpointer) _tmp10_);
		_tmp12_ = _tmp8_ (_tmp11_, _tmp8__target);
		if (!_tmp12_) {
			GeeConcurrentSetTower* _tmp13_ = NULL;
			_tmp13_ = self->_curr;
			_vala_assert (_tmp13_ != NULL, "_curr != null");
			result = FALSE;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp14_ = self->_prev;
	_tmp15_ = _tmp14_._iter[0];
	_tmp16_ = _gee_concurrent_set_tower_ref0 (_tmp15_);
	new_prev = _tmp16_;
	_tmp17_ = self->_curr;
	_tmp18_ = _gee_concurrent_set_tower_ref0 (_tmp17_);
	new_curr = _tmp18_;
	while (TRUE) {
		GeeConcurrentSetRange* _tmp19_ = NULL;
		gboolean _tmp20_ = FALSE;
		GeeConcurrentSetTower* _tmp21_ = NULL;
		GeeForallFunc _tmp22_ = NULL;
		void* _tmp22__target = NULL;
		GeeConcurrentSetTower* _tmp23_ = NULL;
		gconstpointer _tmp24_ = NULL;
		gpointer _tmp25_ = NULL;
		gboolean _tmp26_ = FALSE;
		gboolean _tmp28_ = FALSE;
		GeeConcurrentSetTower* _tmp43_ = NULL;
		_tmp19_ = self->_range;
		_tmp20_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp19_, &new_prev, &new_curr, (guint8) 0);
		if (!_tmp20_) {
			break;
		}
		_tmp21_ = self->_curr;
		_vala_assert (_tmp21_ != NULL, "_curr != null");
		_tmp22_ = f;
		_tmp22__target = f_target;
		_tmp23_ = self->_curr;
		_tmp24_ = _tmp23_->_data;
		_tmp25_ = ((_tmp24_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp24_) : ((gpointer) _tmp24_);
		_tmp26_ = _tmp22_ (_tmp25_, _tmp22__target);
		if (!_tmp26_) {
			GeeConcurrentSetTower* _tmp27_ = NULL;
			_tmp27_ = self->_curr;
			_vala_assert (_tmp27_ != NULL, "_curr != null");
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		_tmp28_ = self->_removed;
		if (!_tmp28_) {
			GeeConcurrentSetTower* _tmp29_ = NULL;
			GeeConcurrentSetTower* _tmp30_ = NULL;
			gint prev_height = 0;
			GeeConcurrentSetTowerIter _tmp31_ = {0};
			GeeConcurrentSetTower* _tmp32_ = NULL;
			gint _tmp33_ = 0;
			_tmp29_ = new_prev;
			new_prev = NULL;
			_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
			self->_prev._iter[0] = _tmp29_;
			_tmp30_ = self->_prev._iter[0];
			_tmp31_ = self->_prev;
			_tmp32_ = _tmp31_._iter[0];
			_tmp33_ = gee_concurrent_set_tower_get_height (_tmp32_);
			prev_height = _tmp33_;
			{
				gint i = 0;
				i = 1;
				{
					gboolean _tmp34_ = FALSE;
					_tmp34_ = TRUE;
					while (TRUE) {
						gint _tmp36_ = 0;
						gint _tmp37_ = 0;
						gint _tmp38_ = 0;
						GeeConcurrentSetTowerIter _tmp39_ = {0};
						GeeConcurrentSetTower* _tmp40_ = NULL;
						GeeConcurrentSetTower* _tmp41_ = NULL;
						GeeConcurrentSetTower* _tmp42_ = NULL;
						if (!_tmp34_) {
							gint _tmp35_ = 0;
							_tmp35_ = i;
							i = _tmp35_ + 1;
						}
						_tmp34_ = FALSE;
						_tmp36_ = i;
						_tmp37_ = prev_height;
						if (!(_tmp36_ < _tmp37_)) {
							break;
						}
						_tmp38_ = i;
						_tmp39_ = self->_prev;
						_tmp40_ = _tmp39_._iter[0];
						_tmp41_ = _gee_concurrent_set_tower_ref0 (_tmp40_);
						_gee_concurrent_set_tower_unref0 (self->_prev._iter[_tmp38_]);
						self->_prev._iter[_tmp38_] = _tmp41_;
						_tmp42_ = self->_prev._iter[_tmp38_];
					}
				}
			}
		}
		_tmp43_ = new_curr;
		new_curr = NULL;
		_gee_concurrent_set_tower_unref0 (self->_curr);
		self->_curr = _tmp43_;
		self->_removed = FALSE;
	}
	_tmp44_ = self->_curr;
	_vala_assert (_tmp44_ != NULL, "_curr != null");
	result = TRUE;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeIterator** gee_concurrent_set_sub_iterator_real_tee (GeeTraversable* base, guint forks, int* result_length1) {
	GeeConcurrentSetSubIterator * self;
	GeeIterator** result = NULL;
	guint _tmp0_ = 0U;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = forks;
	if (_tmp0_ == ((guint) 0)) {
		GeeIterator** _tmp1_ = NULL;
		GeeIterator** _tmp2_ = NULL;
		gint _tmp2__length1 = 0;
		_tmp1_ = g_new0 (GeeIterator*, 0 + 1);
		_tmp2_ = _tmp1_;
		_tmp2__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp2__length1;
		}
		result = _tmp2_;
		return result;
	} else {
		GeeIterator** _result_ = NULL;
		guint _tmp3_ = 0U;
		GeeIterator** _tmp4_ = NULL;
		gint _result__length1 = 0;
		gint __result__size_ = 0;
		GeeIterator** _tmp5_ = NULL;
		gint _tmp5__length1 = 0;
		GeeIterator* _tmp6_ = NULL;
		GeeIterator* _tmp7_ = NULL;
		GeeIterator** _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		_tmp3_ = forks;
		_tmp4_ = g_new0 (GeeIterator*, _tmp3_ + 1);
		_result_ = _tmp4_;
		_result__length1 = _tmp3_;
		__result__size_ = _result__length1;
		_tmp5_ = _result_;
		_tmp5__length1 = _result__length1;
		_tmp6_ = _g_object_ref0 ((GeeIterator*) self);
		_g_object_unref0 (_tmp5_[0]);
		_tmp5_[0] = _tmp6_;
		_tmp7_ = _tmp5_[0];
		{
			guint i = 0U;
			i = (guint) 1;
			{
				gboolean _tmp8_ = FALSE;
				_tmp8_ = TRUE;
				while (TRUE) {
					guint _tmp10_ = 0U;
					guint _tmp11_ = 0U;
					GeeIterator** _tmp12_ = NULL;
					gint _tmp12__length1 = 0;
					guint _tmp13_ = 0U;
					GeeConcurrentSetSubIterator* _tmp14_ = NULL;
					GeeIterator* _tmp15_ = NULL;
					if (!_tmp8_) {
						guint _tmp9_ = 0U;
						_tmp9_ = i;
						i = _tmp9_ + 1;
					}
					_tmp8_ = FALSE;
					_tmp10_ = i;
					_tmp11_ = forks;
					if (!(_tmp10_ < _tmp11_)) {
						break;
					}
					_tmp12_ = _result_;
					_tmp12__length1 = _result__length1;
					_tmp13_ = i;
					_tmp14_ = gee_concurrent_set_sub_iterator_new_from_iterator (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self);
					_g_object_unref0 (_tmp12_[_tmp13_]);
					_tmp12_[_tmp13_] = (GeeIterator*) _tmp14_;
					_tmp15_ = _tmp12_[_tmp13_];
				}
			}
		}
		_tmp16_ = _result_;
		_tmp16__length1 = _result__length1;
		if (result_length1) {
			*result_length1 = _tmp16__length1;
		}
		result = _tmp16_;
		return result;
	}
}


static gboolean gee_concurrent_set_sub_iterator_real_next (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTowerIter _tmp2_ = {0};
	GeeConcurrentSetTower* _tmp3_ = NULL;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->_prev;
	_tmp3_ = _tmp2_._iter[0];
	if (_tmp3_ == NULL) {
		gboolean _tmp4_ = FALSE;
		_tmp4_ = gee_concurrent_set_sub_iterator_begin (self);
		result = _tmp4_;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTower* new_prev = NULL;
		GeeConcurrentSetTowerIter _tmp5_ = {0};
		GeeConcurrentSetTower* _tmp6_ = NULL;
		GeeConcurrentSetTower* _tmp7_ = NULL;
		GeeConcurrentSetTower* new_curr = NULL;
		GeeConcurrentSetTower* _tmp8_ = NULL;
		GeeConcurrentSetTower* _tmp9_ = NULL;
		GeeConcurrentSetRange* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp5_ = self->_prev;
		_tmp6_ = _tmp5_._iter[0];
		_tmp7_ = _gee_concurrent_set_tower_ref0 (_tmp6_);
		new_prev = _tmp7_;
		_tmp8_ = self->_curr;
		_tmp9_ = _gee_concurrent_set_tower_ref0 (_tmp8_);
		new_curr = _tmp9_;
		_tmp10_ = self->_range;
		_tmp11_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp10_, &new_prev, &new_curr, (guint8) 0);
		if (_tmp11_) {
			gboolean _tmp12_ = FALSE;
			GeeConcurrentSetTower* _tmp27_ = NULL;
			_tmp12_ = self->_removed;
			if (!_tmp12_) {
				GeeConcurrentSetTower* _tmp13_ = NULL;
				GeeConcurrentSetTower* _tmp14_ = NULL;
				gint prev_height = 0;
				GeeConcurrentSetTowerIter _tmp15_ = {0};
				GeeConcurrentSetTower* _tmp16_ = NULL;
				gint _tmp17_ = 0;
				_tmp13_ = new_prev;
				new_prev = NULL;
				_gee_concurrent_set_tower_unref0 (self->_prev._iter[0]);
				self->_prev._iter[0] = _tmp13_;
				_tmp14_ = self->_prev._iter[0];
				_tmp15_ = self->_prev;
				_tmp16_ = _tmp15_._iter[0];
				_tmp17_ = gee_concurrent_set_tower_get_height (_tmp16_);
				prev_height = _tmp17_;
				{
					gint i = 0;
					i = 1;
					{
						gboolean _tmp18_ = FALSE;
						_tmp18_ = TRUE;
						while (TRUE) {
							gint _tmp20_ = 0;
							gint _tmp21_ = 0;
							gint _tmp22_ = 0;
							GeeConcurrentSetTowerIter _tmp23_ = {0};
							GeeConcurrentSetTower* _tmp24_ = NULL;
							GeeConcurrentSetTower* _tmp25_ = NULL;
							GeeConcurrentSetTower* _tmp26_ = NULL;
							if (!_tmp18_) {
								gint _tmp19_ = 0;
								_tmp19_ = i;
								i = _tmp19_ + 1;
							}
							_tmp18_ = FALSE;
							_tmp20_ = i;
							_tmp21_ = prev_height;
							if (!(_tmp20_ < _tmp21_)) {
								break;
							}
							_tmp22_ = i;
							_tmp23_ = self->_prev;
							_tmp24_ = _tmp23_._iter[0];
							_tmp25_ = _gee_concurrent_set_tower_ref0 (_tmp24_);
							_gee_concurrent_set_tower_unref0 (self->_prev._iter[_tmp22_]);
							self->_prev._iter[_tmp22_] = _tmp25_;
							_tmp26_ = self->_prev._iter[_tmp22_];
						}
					}
				}
			}
			_tmp27_ = new_curr;
			new_curr = NULL;
			_gee_concurrent_set_tower_unref0 (self->_curr);
			self->_curr = _tmp27_;
			self->_removed = FALSE;
			result = TRUE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		} else {
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		_gee_concurrent_set_tower_unref0 (new_curr);
		_gee_concurrent_set_tower_unref0 (new_prev);
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_sub_iterator_real_has_next (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	GeeConcurrentSetTowerIter _tmp2_ = {0};
	GeeConcurrentSetTower* _tmp3_ = NULL;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = self->_prev;
	_tmp3_ = _tmp2_._iter[0];
	if (_tmp3_ == NULL) {
		GeeConcurrentSetTower* next = NULL;
		GeeConcurrentSetRange* _tmp4_ = NULL;
		GeeConcurrentSetTower* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		GeeConcurrentSetTower* _tmp7_ = NULL;
		GeeConcurrentSetTower* _tmp11_ = NULL;
		_tmp4_ = self->_range;
		gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, &_tmp5_, NULL);
		_gee_concurrent_set_tower_unref0 (next);
		next = _tmp5_;
		_tmp7_ = next;
		if (_tmp7_ != NULL) {
			GeeConcurrentSetRange* _tmp8_ = NULL;
			GeeConcurrentSetTower* _tmp9_ = NULL;
			gboolean _tmp10_ = FALSE;
			_tmp8_ = self->_range;
			_tmp9_ = next;
			_tmp10_ = gee_concurrent_set_range_beyond (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp9_);
			_tmp6_ = _tmp10_;
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			_gee_concurrent_set_tower_unref0 (next);
			next = NULL;
		}
		_tmp11_ = next;
		result = _tmp11_ != NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTower* new_prev = NULL;
		GeeConcurrentSetTowerIter _tmp12_ = {0};
		GeeConcurrentSetTower* _tmp13_ = NULL;
		GeeConcurrentSetTower* _tmp14_ = NULL;
		GeeConcurrentSetTower* new_curr = NULL;
		GeeConcurrentSetTower* _tmp15_ = NULL;
		GeeConcurrentSetTower* _tmp16_ = NULL;
		GeeConcurrentSetRange* _tmp17_ = NULL;
		gboolean _tmp18_ = FALSE;
		_tmp12_ = self->_prev;
		_tmp13_ = _tmp12_._iter[0];
		_tmp14_ = _gee_concurrent_set_tower_ref0 (_tmp13_);
		new_prev = _tmp14_;
		_tmp15_ = self->_curr;
		_tmp16_ = _gee_concurrent_set_tower_ref0 (_tmp15_);
		new_curr = _tmp16_;
		_tmp17_ = self->_range;
		_tmp18_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp17_, &new_prev, &new_curr, (guint8) 0);
		result = _tmp18_;
		_gee_concurrent_set_tower_unref0 (new_curr);
		_gee_concurrent_set_tower_unref0 (new_prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_iterator_real_get (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	gpointer result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gpointer _tmp4_ = NULL;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = self->_curr;
	_tmp3_ = _tmp2_->_data;
	_tmp4_ = ((_tmp3_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp3_) : ((gpointer) _tmp3_);
	result = _tmp4_;
	return result;
}


static void gee_concurrent_set_sub_iterator_real_remove (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSet* _tmp5_ = NULL;
	GCompareDataFunc _tmp6_ = NULL;
	void* _tmp6__target = NULL;
	GeeConcurrentSetTower* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_tmp2_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_, "valid");
	_tmp4_ = self->_range;
	_tmp5_ = _tmp4_->_set;
	_tmp6_ = _tmp5_->priv->_cmp;
	_tmp6__target = _tmp5_->priv->_cmp_target;
	_tmp7_ = self->_curr;
	_tmp8_ = gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp6_, _tmp6__target, &self->_prev, _tmp7_);
	if (_tmp8_) {
		GeeConcurrentSetRange* _tmp9_ = NULL;
		GeeConcurrentSet* _tmp10_ = NULL;
		_tmp9_ = self->_range;
		_tmp10_ = _tmp9_->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp10_->priv->_size));
	}
	self->_removed = TRUE;
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_sub_iterator_begin (GeeConcurrentSetSubIterator* self) {
	gboolean result = FALSE;
	GeeConcurrentSetTowerIter _tmp0_ = {0};
	GeeConcurrentSetTower* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTower* _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp11_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_prev;
	_tmp1_ = _tmp0_._iter[0];
	if (_tmp1_ != NULL) {
		result = TRUE;
		return result;
	}
	_tmp2_ = self->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, &_tmp3_, &_tmp4_);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	self->_curr = _tmp3_;
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	self->_prev = _tmp4_;
	_tmp5_ = self->_curr;
	if (_tmp5_ == NULL) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp6_ = FALSE;
				_tmp6_ = TRUE;
				while (TRUE) {
					gint _tmp8_ = 0;
					gint _tmp9_ = 0;
					GeeConcurrentSetTower* _tmp10_ = NULL;
					if (!_tmp6_) {
						gint _tmp7_ = 0;
						_tmp7_ = i;
						i = _tmp7_ + 1;
					}
					_tmp6_ = FALSE;
					_tmp8_ = i;
					if (!(_tmp8_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
						break;
					}
					_tmp9_ = i;
					_gee_concurrent_set_tower_unref0 (self->_prev._iter[_tmp9_]);
					self->_prev._iter[_tmp9_] = NULL;
					_tmp10_ = self->_prev._iter[_tmp9_];
				}
			}
		}
	}
	_tmp11_ = self->_curr;
	result = _tmp11_ != NULL;
	return result;
}


static gboolean gee_concurrent_set_sub_iterator_real_get_valid (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetSubIterator* self;
	gboolean _tmp0_ = FALSE;
	GeeConcurrentSetTowerIter _tmp1_ = {0};
	GeeConcurrentSetTower* _tmp2_ = NULL;
	gboolean is_valid = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp7_ = FALSE;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp1_ = self->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ != NULL) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = self->_removed;
		_tmp0_ = !_tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	is_valid = _tmp0_;
	_tmp5_ = is_valid;
	if (!_tmp5_) {
		_tmp4_ = TRUE;
	} else {
		GeeConcurrentSetTower* _tmp6_ = NULL;
		_tmp6_ = self->_curr;
		_tmp4_ = _tmp6_ != NULL;
	}
	_vala_assert (_tmp4_, "!is_valid || _curr != null");
	_tmp7_ = is_valid;
	result = _tmp7_;
	return result;
}


static gboolean gee_concurrent_set_sub_iterator_real_get_read_only (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetSubIterator* self;
	self = (GeeConcurrentSetSubIterator*) base;
	result = FALSE;
	return result;
}


static void gee_concurrent_set_sub_iterator_class_init (GeeConcurrentSetSubIteratorClass * klass) {
	gee_concurrent_set_sub_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetSubIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_sub_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_sub_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_sub_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_VALID, g_param_spec_boolean ("valid", "valid", "valid", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static GType gee_concurrent_set_sub_iterator_gee_traversable_get_g_type (GeeConcurrentSetSubIterator* self) {
	return self->priv->g_type;
}


static GBoxedCopyFunc gee_concurrent_set_sub_iterator_gee_traversable_get_g_dup_func (GeeConcurrentSetSubIterator* self) {
	return self->priv->g_dup_func;
}


static GDestroyNotify gee_concurrent_set_sub_iterator_gee_traversable_get_g_destroy_func (GeeConcurrentSetSubIterator* self) {
	return self->priv->g_destroy_func;
}


static void gee_concurrent_set_sub_iterator_gee_traversable_interface_init (GeeTraversableIface * iface) {
	gee_concurrent_set_sub_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*)(GeeTraversable*, GeeForallFunc, void*)) gee_concurrent_set_sub_iterator_real_foreach;
	iface->tee = (GeeIterator** (*)(GeeTraversable*, guint, int*)) gee_concurrent_set_sub_iterator_real_tee;
	iface->get_g_type = (GType(*)(GeeTraversable*)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc(*)(GeeTraversable*)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify(*)(GeeTraversable*)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_destroy_func;
}


static void gee_concurrent_set_sub_iterator_gee_iterator_interface_init (GeeIteratorIface * iface) {
	gee_concurrent_set_sub_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_next;
	iface->has_next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_has_next;
	iface->get = (gpointer (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_get;
	iface->remove = (void (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_remove;
	iface->get_valid = gee_concurrent_set_sub_iterator_real_get_valid;
	iface->get_read_only = gee_concurrent_set_sub_iterator_real_get_read_only;
}


static void gee_concurrent_set_sub_iterator_instance_init (GeeConcurrentSetSubIterator * self) {
	self->priv = GEE_CONCURRENT_SET_SUB_ITERATOR_GET_PRIVATE (self);
	self->_curr = NULL;
	self->_removed = FALSE;
}


static void gee_concurrent_set_sub_iterator_finalize (GObject* obj) {
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	_gee_concurrent_set_range_unref0 (self->_range);
	gee_concurrent_set_tower_iter_destroy (&self->_prev);
	_gee_concurrent_set_tower_unref0 (self->_curr);
	G_OBJECT_CLASS (gee_concurrent_set_sub_iterator_parent_class)->finalize (obj);
}


static GType gee_concurrent_set_sub_iterator_get_type (void) {
	static volatile gsize gee_concurrent_set_sub_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_sub_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetSubIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_sub_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetSubIterator), 0, (GInstanceInitFunc) gee_concurrent_set_sub_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_concurrent_set_sub_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_concurrent_set_sub_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_concurrent_set_sub_iterator_type_id;
		gee_concurrent_set_sub_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeConcurrentSetSubIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_concurrent_set_sub_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
		g_type_add_interface_static (gee_concurrent_set_sub_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
		g_once_init_leave (&gee_concurrent_set_sub_iterator_type_id__volatile, gee_concurrent_set_sub_iterator_type_id);
	}
	return gee_concurrent_set_sub_iterator_type_id__volatile;
}


static void _vala_gee_concurrent_set_sub_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_ITERATOR_VALID:
		g_value_set_boolean (value, gee_iterator_get_valid ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY:
		g_value_set_boolean (value, gee_iterator_get_read_only ((GeeIterator*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_sub_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GType gee_concurrent_set_range_position_get_type (void) {
	static volatile gsize gee_concurrent_set_range_position_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_position_type_id__volatile)) {
		static const GEnumValue values[] = {{GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE, "GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE", "before"}, {GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE, "GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE", "inside"}, {GEE_CONCURRENT_SET_RANGE_POSITION_AFTER, "GEE_CONCURRENT_SET_RANGE_POSITION_AFTER", "after"}, {GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY, "GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY", "empty"}, {0, NULL, NULL}};
		GType gee_concurrent_set_range_position_type_id;
		gee_concurrent_set_range_position_type_id = g_enum_register_static ("GeeConcurrentSetRangePosition", values);
		g_once_init_leave (&gee_concurrent_set_range_position_type_id__volatile, gee_concurrent_set_range_position_type_id);
	}
	return gee_concurrent_set_range_position_type_id__volatile;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end) {
	GeeConcurrentSetRange* self = NULL;
	gconstpointer _tmp0_ = NULL;
	gpointer _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	gpointer _tmp3_ = NULL;
	GeeConcurrentSet* _tmp4_ = NULL;
	GCompareDataFunc _tmp5_ = NULL;
	void* _tmp5__target = NULL;
	gconstpointer _tmp6_ = NULL;
	gconstpointer _tmp7_ = NULL;
	gint _tmp8_ = 0;
	GeeConcurrentSet* _tmp17_ = NULL;
	GeeConcurrentSet* _tmp18_ = NULL;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = start;
	_tmp1_ = ((_tmp0_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_g_destroy_func0 (self->_start);
	self->_start = _tmp1_;
	_tmp2_ = end;
	_tmp3_ = ((_tmp2_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp2_) : ((gpointer) _tmp2_);
	_g_destroy_func0 (self->_end);
	self->_end = _tmp3_;
	_tmp4_ = cset;
	_tmp5_ = _tmp4_->priv->_cmp;
	_tmp5__target = _tmp4_->priv->_cmp_target;
	_tmp6_ = start;
	_tmp7_ = end;
	_tmp8_ = _tmp5_ (_tmp6_, _tmp7_, _tmp5__target);
	if (_tmp8_ < 0) {
		self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp9_ = FALSE;
				_tmp9_ = TRUE;
				while (TRUE) {
					gint _tmp11_ = 0;
					gint _tmp12_ = 0;
					GeeConcurrentSet* _tmp13_ = NULL;
					GeeConcurrentSetTower* _tmp14_ = NULL;
					GeeConcurrentSetTower* _tmp15_ = NULL;
					GeeConcurrentSetTower* _tmp16_ = NULL;
					if (!_tmp9_) {
						gint _tmp10_ = 0;
						_tmp10_ = i;
						i = _tmp10_ + 1;
					}
					_tmp9_ = FALSE;
					_tmp11_ = i;
					if (!(_tmp11_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
						break;
					}
					_tmp12_ = i;
					_tmp13_ = cset;
					_tmp14_ = _tmp13_->priv->_head;
					_tmp15_ = _gee_concurrent_set_tower_ref0 (_tmp14_);
					_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp12_]);
					self->_bookmark._iter[_tmp12_] = _tmp15_;
					_tmp16_ = self->_bookmark._iter[_tmp12_];
				}
			}
		}
	} else {
		self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	}
	_tmp17_ = cset;
	_tmp18_ = _g_object_ref0 (_tmp17_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp18_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end) {
	return gee_concurrent_set_range_construct (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, start, end);
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end) {
	GeeConcurrentSetRange* self = NULL;
	gconstpointer _tmp0_ = NULL;
	gpointer _tmp1_ = NULL;
	GeeConcurrentSet* _tmp10_ = NULL;
	GeeConcurrentSet* _tmp11_ = NULL;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = end;
	_tmp1_ = ((_tmp0_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_g_destroy_func0 (self->_end);
	self->_end = _tmp1_;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_HEAD;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				gint _tmp5_ = 0;
				GeeConcurrentSet* _tmp6_ = NULL;
				GeeConcurrentSetTower* _tmp7_ = NULL;
				GeeConcurrentSetTower* _tmp8_ = NULL;
				GeeConcurrentSetTower* _tmp9_ = NULL;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = cset;
				_tmp7_ = _tmp6_->priv->_head;
				_tmp8_ = _gee_concurrent_set_tower_ref0 (_tmp7_);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp5_]);
				self->_bookmark._iter[_tmp5_] = _tmp8_;
				_tmp9_ = self->_bookmark._iter[_tmp5_];
			}
		}
	}
	_tmp10_ = cset;
	_tmp11_ = _g_object_ref0 (_tmp10_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp11_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end) {
	return gee_concurrent_set_range_construct_head (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, end);
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct_tail (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start) {
	GeeConcurrentSetRange* self = NULL;
	gconstpointer _tmp0_ = NULL;
	gpointer _tmp1_ = NULL;
	GeeConcurrentSet* _tmp10_ = NULL;
	GeeConcurrentSet* _tmp11_ = NULL;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = start;
	_tmp1_ = ((_tmp0_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_g_destroy_func0 (self->_start);
	self->_start = _tmp1_;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_TAIL;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				gint _tmp5_ = 0;
				GeeConcurrentSet* _tmp6_ = NULL;
				GeeConcurrentSetTower* _tmp7_ = NULL;
				GeeConcurrentSetTower* _tmp8_ = NULL;
				GeeConcurrentSetTower* _tmp9_ = NULL;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = cset;
				_tmp7_ = _tmp6_->priv->_head;
				_tmp8_ = _gee_concurrent_set_tower_ref0 (_tmp7_);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp5_]);
				self->_bookmark._iter[_tmp5_] = _tmp8_;
				_tmp9_ = self->_bookmark._iter[_tmp5_];
			}
		}
	}
	_tmp10_ = cset;
	_tmp11_ = _g_object_ref0 (_tmp10_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp11_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start) {
	return gee_concurrent_set_range_construct_tail (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, start);
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct_empty (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset) {
	GeeConcurrentSetRange* self = NULL;
	GeeConcurrentSet* _tmp0_ = NULL;
	GeeConcurrentSet* _tmp1_ = NULL;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	_tmp0_ = cset;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp1_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new_empty (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset) {
	return gee_concurrent_set_range_construct_empty (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset);
}


static void gee_concurrent_set_range_copy_bookmark (GeeConcurrentSetRange* self, GeeConcurrentSetRange* range) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (range != NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_ = 0;
				gint _tmp3_ = 0;
				GeeConcurrentSetRange* _tmp4_ = NULL;
				gint _tmp5_ = 0;
				gpointer _tmp6_ = NULL;
				GeeConcurrentSetTower* _tmp7_ = NULL;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				if (!(_tmp2_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp3_ = i;
				_tmp4_ = range;
				_tmp5_ = i;
				_tmp6_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp4_->_bookmark._iter[_tmp5_], (gsize) 0, NULL);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp3_]);
				self->_bookmark._iter[_tmp3_] = (GeeConcurrentSetTower*) _tmp6_;
				_tmp7_ = self->_bookmark._iter[_tmp3_];
			}
		}
	}
}


static GeeConcurrentSetRange* gee_concurrent_set_range_cut_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start) {
	GeeConcurrentSetRange* result = NULL;
	GeeConcurrentSetRange* _result_ = NULL;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSet* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRangeType _tmp4_ = 0;
	GeeConcurrentSetRange* _tmp52_ = NULL;
	GeeConcurrentSetRangeType _tmp53_ = 0;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from;
	_tmp1_ = _tmp0_->_set;
	_tmp2_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = from;
	_tmp4_ = _tmp3_->_type;
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp5_ = NULL;
			GeeConcurrentSet* _tmp6_ = NULL;
			GCompareDataFunc _tmp7_ = NULL;
			void* _tmp7__target = NULL;
			gconstpointer _tmp8_ = NULL;
			GeeConcurrentSetRange* _tmp9_ = NULL;
			gconstpointer _tmp10_ = NULL;
			gint _tmp11_ = 0;
			_tmp5_ = from;
			_tmp6_ = _tmp5_->_set;
			_tmp7_ = _tmp6_->priv->_cmp;
			_tmp7__target = _tmp6_->priv->_cmp_target;
			_tmp8_ = start;
			_tmp9_ = from;
			_tmp10_ = _tmp9_->_end;
			_tmp11_ = _tmp7_ (_tmp8_, _tmp10_, _tmp7__target);
			if (_tmp11_ < 0) {
				GeeConcurrentSetRange* _tmp12_ = NULL;
				gconstpointer _tmp13_ = NULL;
				gpointer _tmp14_ = NULL;
				GeeConcurrentSetRange* _tmp15_ = NULL;
				GeeConcurrentSetRange* _tmp16_ = NULL;
				gconstpointer _tmp17_ = NULL;
				gpointer _tmp18_ = NULL;
				GeeConcurrentSetRange* _tmp19_ = NULL;
				_tmp12_ = _result_;
				_tmp13_ = start;
				_tmp14_ = ((_tmp13_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp13_) : ((gpointer) _tmp13_);
				_g_destroy_func0 (_tmp12_->_start);
				_tmp12_->_start = _tmp14_;
				_tmp15_ = _result_;
				_tmp16_ = from;
				_tmp17_ = _tmp16_->_end;
				_tmp18_ = ((_tmp17_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp17_) : ((gpointer) _tmp17_);
				_g_destroy_func0 (_tmp15_->_end);
				_tmp15_->_end = _tmp18_;
				_tmp19_ = _result_;
				_tmp19_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp20_ = NULL;
				_tmp20_ = _result_;
				_tmp20_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp21_ = NULL;
			GeeConcurrentSetRange* _tmp22_ = NULL;
			GeeConcurrentSet* _tmp23_ = NULL;
			GeeConcurrentSetRange* _tmp24_ = NULL;
			gconstpointer _tmp25_ = NULL;
			gconstpointer _tmp26_ = NULL;
			gconstpointer _tmp27_ = NULL;
			gpointer _tmp28_ = NULL;
			GeeConcurrentSetRange* _tmp29_ = NULL;
			_tmp21_ = _result_;
			_tmp22_ = from;
			_tmp23_ = _tmp22_->_set;
			_tmp24_ = from;
			_tmp25_ = _tmp24_->_start;
			_tmp26_ = start;
			_tmp27_ = gee_concurrent_set_max (_tmp23_, _tmp25_, _tmp26_, NULL);
			_tmp28_ = ((_tmp27_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp27_) : ((gpointer) _tmp27_);
			_g_destroy_func0 (_tmp21_->_start);
			_tmp21_->_start = _tmp28_;
			_tmp29_ = _result_;
			_tmp29_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_TAIL;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp30_ = NULL;
			GeeConcurrentSet* _tmp31_ = NULL;
			GCompareDataFunc _tmp32_ = NULL;
			void* _tmp32__target = NULL;
			GeeConcurrentSetRange* _tmp33_ = NULL;
			gconstpointer _tmp34_ = NULL;
			gconstpointer _tmp35_ = NULL;
			gint _tmp36_ = 0;
			_tmp30_ = from;
			_tmp31_ = _tmp30_->_set;
			_tmp32_ = _tmp31_->priv->_cmp;
			_tmp32__target = _tmp31_->priv->_cmp_target;
			_tmp33_ = from;
			_tmp34_ = _tmp33_->_start;
			_tmp35_ = start;
			_tmp36_ = _tmp32_ (_tmp34_, _tmp35_, _tmp32__target);
			if (_tmp36_ < 0) {
				GeeConcurrentSetRange* _tmp37_ = NULL;
				GeeConcurrentSetRange* _tmp38_ = NULL;
				GeeConcurrentSet* _tmp39_ = NULL;
				GeeConcurrentSetRange* _tmp40_ = NULL;
				gconstpointer _tmp41_ = NULL;
				gconstpointer _tmp42_ = NULL;
				gconstpointer _tmp43_ = NULL;
				gpointer _tmp44_ = NULL;
				GeeConcurrentSetRange* _tmp45_ = NULL;
				GeeConcurrentSetRange* _tmp46_ = NULL;
				gconstpointer _tmp47_ = NULL;
				gpointer _tmp48_ = NULL;
				GeeConcurrentSetRange* _tmp49_ = NULL;
				_tmp37_ = _result_;
				_tmp38_ = from;
				_tmp39_ = _tmp38_->_set;
				_tmp40_ = from;
				_tmp41_ = _tmp40_->_start;
				_tmp42_ = start;
				_tmp43_ = gee_concurrent_set_max (_tmp39_, _tmp41_, _tmp42_, NULL);
				_tmp44_ = ((_tmp43_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp43_) : ((gpointer) _tmp43_);
				_g_destroy_func0 (_tmp37_->_start);
				_tmp37_->_start = _tmp44_;
				_tmp45_ = _result_;
				_tmp46_ = from;
				_tmp47_ = _tmp46_->_end;
				_tmp48_ = ((_tmp47_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp47_) : ((gpointer) _tmp47_);
				_g_destroy_func0 (_tmp45_->_end);
				_tmp45_->_end = _tmp48_;
				_tmp49_ = _result_;
				_tmp49_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp50_ = NULL;
				_tmp50_ = _result_;
				_tmp50_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp51_ = NULL;
			_tmp51_ = _result_;
			_tmp51_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp52_ = _result_;
	_tmp53_ = _tmp52_->_type;
	if (_tmp53_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp54_ = NULL;
		GeeConcurrentSetRange* _tmp55_ = NULL;
		GeeConcurrentSetRange* _tmp56_ = NULL;
		GeeConcurrentSetRange* _tmp57_ = NULL;
		_tmp54_ = from;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp54_, NULL, NULL);
		_tmp55_ = _result_;
		_tmp56_ = from;
		gee_concurrent_set_range_copy_bookmark (_tmp55_, _tmp56_);
		_tmp57_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp57_, NULL, NULL);
	}
	result = _result_;
	return result;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_cut_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer end) {
	GeeConcurrentSetRange* result = NULL;
	GeeConcurrentSetRange* _result_ = NULL;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSet* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRangeType _tmp4_ = 0;
	GeeConcurrentSetRange* _tmp52_ = NULL;
	GeeConcurrentSetRangeType _tmp53_ = 0;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from;
	_tmp1_ = _tmp0_->_set;
	_tmp2_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = from;
	_tmp4_ = _tmp3_->_type;
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp5_ = NULL;
			GeeConcurrentSetRange* _tmp6_ = NULL;
			GeeConcurrentSet* _tmp7_ = NULL;
			GeeConcurrentSetRange* _tmp8_ = NULL;
			gconstpointer _tmp9_ = NULL;
			gconstpointer _tmp10_ = NULL;
			gconstpointer _tmp11_ = NULL;
			gpointer _tmp12_ = NULL;
			GeeConcurrentSetRange* _tmp13_ = NULL;
			_tmp5_ = _result_;
			_tmp6_ = from;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = from;
			_tmp9_ = _tmp8_->_end;
			_tmp10_ = end;
			_tmp11_ = gee_concurrent_set_min (_tmp7_, _tmp9_, _tmp10_, NULL);
			_tmp12_ = ((_tmp11_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp11_) : ((gpointer) _tmp11_);
			_g_destroy_func0 (_tmp5_->_end);
			_tmp5_->_end = _tmp12_;
			_tmp13_ = _result_;
			_tmp13_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_HEAD;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp14_ = NULL;
			GeeConcurrentSet* _tmp15_ = NULL;
			GCompareDataFunc _tmp16_ = NULL;
			void* _tmp16__target = NULL;
			GeeConcurrentSetRange* _tmp17_ = NULL;
			gconstpointer _tmp18_ = NULL;
			gconstpointer _tmp19_ = NULL;
			gint _tmp20_ = 0;
			_tmp14_ = from;
			_tmp15_ = _tmp14_->_set;
			_tmp16_ = _tmp15_->priv->_cmp;
			_tmp16__target = _tmp15_->priv->_cmp_target;
			_tmp17_ = from;
			_tmp18_ = _tmp17_->_start;
			_tmp19_ = end;
			_tmp20_ = _tmp16_ (_tmp18_, _tmp19_, _tmp16__target);
			if (_tmp20_ < 0) {
				GeeConcurrentSetRange* _tmp21_ = NULL;
				GeeConcurrentSetRange* _tmp22_ = NULL;
				gconstpointer _tmp23_ = NULL;
				gpointer _tmp24_ = NULL;
				GeeConcurrentSetRange* _tmp25_ = NULL;
				gconstpointer _tmp26_ = NULL;
				gpointer _tmp27_ = NULL;
				GeeConcurrentSetRange* _tmp28_ = NULL;
				_tmp21_ = _result_;
				_tmp22_ = from;
				_tmp23_ = _tmp22_->_start;
				_tmp24_ = ((_tmp23_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp23_) : ((gpointer) _tmp23_);
				_g_destroy_func0 (_tmp21_->_start);
				_tmp21_->_start = _tmp24_;
				_tmp25_ = _result_;
				_tmp26_ = end;
				_tmp27_ = ((_tmp26_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp26_) : ((gpointer) _tmp26_);
				_g_destroy_func0 (_tmp25_->_end);
				_tmp25_->_end = _tmp27_;
				_tmp28_ = _result_;
				_tmp28_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp29_ = NULL;
				_tmp29_ = _result_;
				_tmp29_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp30_ = NULL;
			GeeConcurrentSet* _tmp31_ = NULL;
			GCompareDataFunc _tmp32_ = NULL;
			void* _tmp32__target = NULL;
			GeeConcurrentSetRange* _tmp33_ = NULL;
			gconstpointer _tmp34_ = NULL;
			gconstpointer _tmp35_ = NULL;
			gint _tmp36_ = 0;
			_tmp30_ = from;
			_tmp31_ = _tmp30_->_set;
			_tmp32_ = _tmp31_->priv->_cmp;
			_tmp32__target = _tmp31_->priv->_cmp_target;
			_tmp33_ = from;
			_tmp34_ = _tmp33_->_start;
			_tmp35_ = end;
			_tmp36_ = _tmp32_ (_tmp34_, _tmp35_, _tmp32__target);
			if (_tmp36_ < 0) {
				GeeConcurrentSetRange* _tmp37_ = NULL;
				GeeConcurrentSetRange* _tmp38_ = NULL;
				gconstpointer _tmp39_ = NULL;
				gpointer _tmp40_ = NULL;
				GeeConcurrentSetRange* _tmp41_ = NULL;
				GeeConcurrentSetRange* _tmp42_ = NULL;
				GeeConcurrentSet* _tmp43_ = NULL;
				GeeConcurrentSetRange* _tmp44_ = NULL;
				gconstpointer _tmp45_ = NULL;
				gconstpointer _tmp46_ = NULL;
				gconstpointer _tmp47_ = NULL;
				gpointer _tmp48_ = NULL;
				GeeConcurrentSetRange* _tmp49_ = NULL;
				_tmp37_ = _result_;
				_tmp38_ = from;
				_tmp39_ = _tmp38_->_start;
				_tmp40_ = ((_tmp39_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp39_) : ((gpointer) _tmp39_);
				_g_destroy_func0 (_tmp37_->_start);
				_tmp37_->_start = _tmp40_;
				_tmp41_ = _result_;
				_tmp42_ = from;
				_tmp43_ = _tmp42_->_set;
				_tmp44_ = from;
				_tmp45_ = _tmp44_->_end;
				_tmp46_ = end;
				_tmp47_ = gee_concurrent_set_min (_tmp43_, _tmp45_, _tmp46_, NULL);
				_tmp48_ = ((_tmp47_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp47_) : ((gpointer) _tmp47_);
				_g_destroy_func0 (_tmp41_->_end);
				_tmp41_->_end = _tmp48_;
				_tmp49_ = _result_;
				_tmp49_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp50_ = NULL;
				_tmp50_ = _result_;
				_tmp50_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp51_ = NULL;
			_tmp51_ = _result_;
			_tmp51_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp52_ = _result_;
	_tmp53_ = _tmp52_->_type;
	if (_tmp53_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp54_ = NULL;
		GeeConcurrentSetRange* _tmp55_ = NULL;
		GeeConcurrentSetRange* _tmp56_ = NULL;
		GeeConcurrentSetRange* _tmp57_ = NULL;
		_tmp54_ = from;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp54_, NULL, NULL);
		_tmp55_ = _result_;
		_tmp56_ = from;
		gee_concurrent_set_range_copy_bookmark (_tmp55_, _tmp56_);
		_tmp57_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp57_, NULL, NULL);
	}
	result = _result_;
	return result;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_cut (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start, gconstpointer end) {
	GeeConcurrentSetRange* result = NULL;
	GeeConcurrentSetRange* _result_ = NULL;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSet* _tmp1_ = NULL;
	GeeConcurrentSetRange* _tmp2_ = NULL;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSetRangeType _tmp5_ = 0;
	gboolean _tmp31_ = FALSE;
	GeeConcurrentSetRange* _tmp32_ = NULL;
	GeeConcurrentSetRangeType _tmp33_ = 0;
	GeeConcurrentSetRange* _tmp48_ = NULL;
	GeeConcurrentSetRangeType _tmp49_ = 0;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from;
	_tmp1_ = _tmp0_->_set;
	_tmp2_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	_tmp3_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
	_tmp4_ = from;
	_tmp5_ = _tmp4_->_type;
	switch (_tmp5_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp6_ = NULL;
			GeeConcurrentSet* _tmp7_ = NULL;
			GeeConcurrentSetRange* _tmp8_ = NULL;
			gconstpointer _tmp9_ = NULL;
			gconstpointer _tmp10_ = NULL;
			gconstpointer _tmp11_ = NULL;
			_tmp6_ = from;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = from;
			_tmp9_ = _tmp8_->_end;
			_tmp10_ = end;
			_tmp11_ = gee_concurrent_set_min (_tmp7_, _tmp9_, _tmp10_, NULL);
			end = _tmp11_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp12_ = NULL;
			GeeConcurrentSet* _tmp13_ = NULL;
			GeeConcurrentSetRange* _tmp14_ = NULL;
			gconstpointer _tmp15_ = NULL;
			gconstpointer _tmp16_ = NULL;
			gconstpointer _tmp17_ = NULL;
			_tmp12_ = from;
			_tmp13_ = _tmp12_->_set;
			_tmp14_ = from;
			_tmp15_ = _tmp14_->_start;
			_tmp16_ = start;
			_tmp17_ = gee_concurrent_set_max (_tmp13_, _tmp15_, _tmp16_, NULL);
			start = _tmp17_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp18_ = NULL;
			GeeConcurrentSet* _tmp19_ = NULL;
			GeeConcurrentSetRange* _tmp20_ = NULL;
			gconstpointer _tmp21_ = NULL;
			gconstpointer _tmp22_ = NULL;
			gconstpointer _tmp23_ = NULL;
			GeeConcurrentSetRange* _tmp24_ = NULL;
			GeeConcurrentSet* _tmp25_ = NULL;
			GeeConcurrentSetRange* _tmp26_ = NULL;
			gconstpointer _tmp27_ = NULL;
			gconstpointer _tmp28_ = NULL;
			gconstpointer _tmp29_ = NULL;
			_tmp18_ = from;
			_tmp19_ = _tmp18_->_set;
			_tmp20_ = from;
			_tmp21_ = _tmp20_->_start;
			_tmp22_ = start;
			_tmp23_ = gee_concurrent_set_max (_tmp19_, _tmp21_, _tmp22_, NULL);
			start = _tmp23_;
			_tmp24_ = from;
			_tmp25_ = _tmp24_->_set;
			_tmp26_ = from;
			_tmp27_ = _tmp26_->_end;
			_tmp28_ = end;
			_tmp29_ = gee_concurrent_set_min (_tmp25_, _tmp27_, _tmp28_, NULL);
			end = _tmp29_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp30_ = NULL;
			_tmp30_ = _result_;
			_tmp30_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp32_ = _result_;
	_tmp33_ = _tmp32_->_type;
	if (_tmp33_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp34_ = NULL;
		GeeConcurrentSet* _tmp35_ = NULL;
		GCompareDataFunc _tmp36_ = NULL;
		void* _tmp36__target = NULL;
		gconstpointer _tmp37_ = NULL;
		gconstpointer _tmp38_ = NULL;
		gint _tmp39_ = 0;
		_tmp34_ = from;
		_tmp35_ = _tmp34_->_set;
		_tmp36_ = _tmp35_->priv->_cmp;
		_tmp36__target = _tmp35_->priv->_cmp_target;
		_tmp37_ = start;
		_tmp38_ = end;
		_tmp39_ = _tmp36_ (_tmp37_, _tmp38_, _tmp36__target);
		_tmp31_ = _tmp39_ < 0;
	} else {
		_tmp31_ = FALSE;
	}
	if (_tmp31_) {
		GeeConcurrentSetRange* _tmp40_ = NULL;
		gconstpointer _tmp41_ = NULL;
		gpointer _tmp42_ = NULL;
		GeeConcurrentSetRange* _tmp43_ = NULL;
		gconstpointer _tmp44_ = NULL;
		gpointer _tmp45_ = NULL;
		GeeConcurrentSetRange* _tmp46_ = NULL;
		_tmp40_ = _result_;
		_tmp41_ = start;
		_tmp42_ = ((_tmp41_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp41_) : ((gpointer) _tmp41_);
		_g_destroy_func0 (_tmp40_->_start);
		_tmp40_->_start = _tmp42_;
		_tmp43_ = _result_;
		_tmp44_ = end;
		_tmp45_ = ((_tmp44_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp44_) : ((gpointer) _tmp44_);
		_g_destroy_func0 (_tmp43_->_end);
		_tmp43_->_end = _tmp45_;
		_tmp46_ = _result_;
		_tmp46_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
	} else {
		GeeConcurrentSetRange* _tmp47_ = NULL;
		_tmp47_ = _result_;
		_tmp47_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	}
	_tmp48_ = _result_;
	_tmp49_ = _tmp48_->_type;
	if (_tmp49_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp50_ = NULL;
		GeeConcurrentSetRange* _tmp51_ = NULL;
		GeeConcurrentSetRange* _tmp52_ = NULL;
		GeeConcurrentSetRange* _tmp53_ = NULL;
		_tmp50_ = from;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp50_, NULL, NULL);
		_tmp51_ = _result_;
		_tmp52_ = from;
		gee_concurrent_set_range_copy_bookmark (_tmp51_, _tmp52_);
		_tmp53_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp53_, NULL, NULL);
	}
	result = _result_;
	return result;
}


static void gee_concurrent_set_range_improve_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** out_curr, GeeConcurrentSetTowerIter* prev) {
	GeeConcurrentSetTower* _vala_out_curr = NULL;
	GeeConcurrentSetTowerIter _vala_prev = {0};
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRangeType _tmp1_ = 0;
	gboolean _tmp103_ = FALSE;
	gboolean _tmp104_ = FALSE;
	g_return_if_fail (range != NULL);
	gee_concurrent_set_tower_iter_destroy (&_vala_prev);
	memset (&_vala_prev, 0, sizeof (GeeConcurrentSetTowerIter));
	_gee_concurrent_set_tower_unref0 (_vala_out_curr);
	_vala_out_curr = NULL;
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			if ((&_vala_out_curr) != NULL) {
				GeeConcurrentSetRange* _tmp2_ = NULL;
				gpointer _tmp3_ = NULL;
				_tmp2_ = range;
				_tmp3_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp2_->_bookmark._iter[0], (gsize) 0, NULL);
				_gee_concurrent_set_tower_unref0 (_vala_out_curr);
				_vala_out_curr = (GeeConcurrentSetTower*) _tmp3_;
				if ((&_vala_prev) != NULL) {
					GeeConcurrentSetTower* _tmp4_ = NULL;
					GeeConcurrentSetTower* _tmp5_ = NULL;
					GeeConcurrentSetTowerIter _tmp6_ = {0};
					GeeConcurrentSetTower* _tmp7_ = NULL;
					GeeConcurrentSetTower* _tmp8_ = NULL;
					_tmp4_ = _vala_out_curr;
					_vala_out_curr = NULL;
					_gee_concurrent_set_tower_unref0 (_vala_prev._iter[0]);
					_vala_prev._iter[0] = _tmp4_;
					_tmp5_ = _vala_prev._iter[0];
					_tmp6_ = _vala_prev;
					_tmp7_ = _tmp6_._iter[0];
					_tmp8_ = gee_concurrent_set_tower_get_next (_tmp7_, (guint8) 0);
					_gee_concurrent_set_tower_unref0 (_vala_out_curr);
					_vala_out_curr = _tmp8_;
				} else {
					GeeConcurrentSetTower* _tmp9_ = NULL;
					GeeConcurrentSetTower* _tmp10_ = NULL;
					_tmp9_ = _vala_out_curr;
					_tmp10_ = gee_concurrent_set_tower_get_next (_tmp9_, (guint8) 0);
					_gee_concurrent_set_tower_unref0 (_vala_out_curr);
					_vala_out_curr = _tmp10_;
				}
			}
			if ((&_vala_prev) != NULL) {
				{
					gint _tmp11_ = 0;
					gint i = 0;
					if ((&_vala_out_curr) != NULL) {
						_tmp11_ = 1;
					} else {
						_tmp11_ = 0;
					}
					i = _tmp11_;
					{
						gboolean _tmp12_ = FALSE;
						_tmp12_ = TRUE;
						while (TRUE) {
							gint _tmp14_ = 0;
							gint _tmp15_ = 0;
							GeeConcurrentSetRange* _tmp16_ = NULL;
							gint _tmp17_ = 0;
							gpointer _tmp18_ = NULL;
							GeeConcurrentSetTower* _tmp19_ = NULL;
							if (!_tmp12_) {
								gint _tmp13_ = 0;
								_tmp13_ = i;
								i = _tmp13_ + 1;
							}
							_tmp12_ = FALSE;
							_tmp14_ = i;
							if (!(_tmp14_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
								break;
							}
							_tmp15_ = i;
							_tmp16_ = range;
							_tmp17_ = i;
							_tmp18_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp16_->_bookmark._iter[_tmp17_], (gsize) 0, NULL);
							_gee_concurrent_set_tower_unref0 (_vala_prev._iter[_tmp15_]);
							_vala_prev._iter[_tmp15_] = (GeeConcurrentSetTower*) _tmp18_;
							_tmp19_ = _vala_prev._iter[_tmp15_];
						}
					}
				}
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			_gee_concurrent_set_tower_unref0 (_vala_out_curr);
			_vala_out_curr = NULL;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetTower* last_best = NULL;
			last_best = NULL;
			{
				gint i = 0;
				i = GEE_CONCURRENT_SET__MAX_HEIGHT - 1;
				{
					gboolean _tmp20_ = FALSE;
					_tmp20_ = TRUE;
					while (TRUE) {
						gint _tmp22_ = 0;
						GeeConcurrentSetTower* curr = NULL;
						GeeConcurrentSetRange* _tmp23_ = NULL;
						gint _tmp24_ = 0;
						gpointer _tmp25_ = NULL;
						GeeConcurrentSetTower* curr_old = NULL;
						GeeConcurrentSetTower* _tmp26_ = NULL;
						GeeConcurrentSetTower* _tmp27_ = NULL;
						GeeConcurrentSetTower* _tmp28_ = NULL;
						gint _tmp29_ = 0;
						gboolean _tmp30_ = FALSE;
						gboolean _tmp31_ = FALSE;
						GeeConcurrentSetTower* _tmp32_ = NULL;
						GeeConcurrentSetTower* _tmp43_ = NULL;
						GeeConcurrentSetTower* _tmp44_ = NULL;
						GeeConcurrentSetTower* next = NULL;
						GeeConcurrentSetTower* _tmp54_ = NULL;
						gint _tmp55_ = 0;
						GeeConcurrentSetTower* _tmp56_ = NULL;
						gboolean _tmp57_ = FALSE;
						GeeConcurrentSetTower* _tmp102_ = NULL;
						if (!_tmp20_) {
							gint _tmp21_ = 0;
							_tmp21_ = i;
							i = _tmp21_ - 1;
						}
						_tmp20_ = FALSE;
						_tmp22_ = i;
						if (!(_tmp22_ >= 0)) {
							break;
						}
						_tmp23_ = range;
						_tmp24_ = i;
						_tmp25_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp23_->_bookmark._iter[_tmp24_], (gsize) 0, NULL);
						curr = (GeeConcurrentSetTower*) _tmp25_;
						_tmp26_ = curr;
						_tmp27_ = _gee_concurrent_set_tower_ref0 (_tmp26_);
						curr_old = _tmp27_;
						_tmp28_ = curr;
						_vala_assert (_tmp28_ != NULL, "curr != null");
						_tmp29_ = i;
						gee_concurrent_set_tower_backtrace (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, &curr, (guint8) _tmp29_);
						_tmp32_ = last_best;
						if (_tmp32_ != NULL) {
							GeeConcurrentSetTower* _tmp33_ = NULL;
							GeeConcurrentSetTower* _tmp34_ = NULL;
							_tmp33_ = last_best;
							_tmp34_ = curr;
							_tmp31_ = _tmp33_ != _tmp34_;
						} else {
							_tmp31_ = FALSE;
						}
						if (_tmp31_) {
							GeeConcurrentSetRange* _tmp35_ = NULL;
							GeeConcurrentSet* _tmp36_ = NULL;
							GCompareDataFunc _tmp37_ = NULL;
							void* _tmp37__target = NULL;
							GeeConcurrentSetTower* _tmp38_ = NULL;
							GeeConcurrentSetTower* _tmp39_ = NULL;
							gint _tmp40_ = 0;
							_tmp35_ = range;
							_tmp36_ = _tmp35_->_set;
							_tmp37_ = _tmp36_->priv->_cmp;
							_tmp37__target = _tmp36_->priv->_cmp_target;
							_tmp38_ = curr;
							_tmp39_ = last_best;
							_tmp40_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp37_, _tmp37__target, _tmp38_, _tmp39_);
							_tmp30_ = _tmp40_ < 0;
						} else {
							_tmp30_ = FALSE;
						}
						if (_tmp30_) {
							GeeConcurrentSetTower* _tmp41_ = NULL;
							GeeConcurrentSetTower* _tmp42_ = NULL;
							_tmp41_ = last_best;
							_tmp42_ = _gee_concurrent_set_tower_ref0 (_tmp41_);
							_gee_concurrent_set_tower_unref0 (curr);
							curr = _tmp42_;
						}
						_tmp43_ = curr;
						_tmp44_ = curr_old;
						if (_tmp43_ != _tmp44_) {
							GeeConcurrentSetRange* _tmp45_ = NULL;
							gint _tmp46_ = 0;
							GeeConcurrentSetTower* _tmp47_ = NULL;
							GeeConcurrentSetTower* _tmp48_ = NULL;
							GeeConcurrentSetTower* _tmp49_ = NULL;
							gboolean _tmp50_ = FALSE;
							_tmp45_ = range;
							_tmp46_ = i;
							_tmp47_ = curr_old;
							_tmp48_ = curr;
							_tmp49_ = _gee_concurrent_set_tower_ref0 (_tmp48_);
							_tmp50_ = gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp45_->_bookmark._iter[_tmp46_], _tmp47_, _tmp49_, (gsize) 0, (gsize) 0, (gsize) 0);
							if (!_tmp50_) {
								GeeConcurrentSetRange* _tmp51_ = NULL;
								gint _tmp52_ = 0;
								gpointer _tmp53_ = NULL;
								_tmp51_ = range;
								_tmp52_ = i;
								_tmp53_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp51_->_bookmark._iter[_tmp52_], (gsize) 0, NULL);
								_gee_concurrent_set_tower_unref0 (curr);
								curr = (GeeConcurrentSetTower*) _tmp53_;
							}
						}
						_tmp54_ = curr;
						_tmp55_ = i;
						_tmp56_ = gee_concurrent_set_tower_get_next (_tmp54_, (guint8) _tmp55_);
						next = _tmp56_;
						if ((&_vala_out_curr) != NULL) {
							gint _tmp58_ = 0;
							_tmp58_ = i;
							_tmp57_ = _tmp58_ == 0;
						} else {
							_tmp57_ = FALSE;
						}
						if (_tmp57_) {
							GeeConcurrentSetTower* _tmp59_ = NULL;
							GeeConcurrentSetTower* _tmp60_ = NULL;
							_tmp59_ = next;
							_tmp60_ = _gee_concurrent_set_tower_ref0 (_tmp59_);
							_gee_concurrent_set_tower_unref0 (_vala_out_curr);
							_vala_out_curr = _tmp60_;
						}
						while (TRUE) {
							gboolean _tmp61_ = FALSE;
							GeeConcurrentSetTower* _tmp62_ = NULL;
							GeeConcurrentSetRange* _tmp70_ = NULL;
							GeeConcurrentSet* _tmp71_ = NULL;
							GCompareDataFunc _tmp72_ = NULL;
							void* _tmp72__target = NULL;
							gint _tmp73_ = 0;
							gboolean _tmp74_ = FALSE;
							gboolean _tmp75_ = FALSE;
							GeeConcurrentSetRange* _tmp80_ = NULL;
							GeeConcurrentSet* _tmp81_ = NULL;
							GCompareDataFunc _tmp82_ = NULL;
							void* _tmp82__target = NULL;
							GeeConcurrentSetTower* _tmp83_ = NULL;
							GeeConcurrentSetRange* _tmp84_ = NULL;
							gconstpointer _tmp85_ = NULL;
							gint _tmp86_ = 0;
							_tmp62_ = next;
							if (_tmp62_ != NULL) {
								GeeConcurrentSetRange* _tmp63_ = NULL;
								GeeConcurrentSet* _tmp64_ = NULL;
								GCompareDataFunc _tmp65_ = NULL;
								void* _tmp65__target = NULL;
								GeeConcurrentSetTower* _tmp66_ = NULL;
								GeeConcurrentSetRange* _tmp67_ = NULL;
								gconstpointer _tmp68_ = NULL;
								gint _tmp69_ = 0;
								_tmp63_ = range;
								_tmp64_ = _tmp63_->_set;
								_tmp65_ = _tmp64_->priv->_cmp;
								_tmp65__target = _tmp64_->priv->_cmp_target;
								_tmp66_ = next;
								_tmp67_ = range;
								_tmp68_ = _tmp67_->_start;
								_tmp69_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp65_, _tmp65__target, _tmp66_, _tmp68_);
								_tmp61_ = _tmp69_ < 0;
							} else {
								_tmp61_ = FALSE;
							}
							if (!_tmp61_) {
								break;
							}
							_tmp70_ = range;
							_tmp71_ = _tmp70_->_set;
							_tmp72_ = _tmp71_->priv->_cmp;
							_tmp72__target = _tmp71_->priv->_cmp_target;
							_tmp73_ = i;
							gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp72_, _tmp72__target, &curr, &next, (guint8) _tmp73_, TRUE);
							if ((&curr) != NULL) {
								gint _tmp76_ = 0;
								_tmp76_ = i;
								_tmp75_ = _tmp76_ == 0;
							} else {
								_tmp75_ = FALSE;
							}
							if (_tmp75_) {
								GeeConcurrentSetTower* _tmp77_ = NULL;
								_tmp77_ = next;
								_tmp74_ = _tmp77_ != NULL;
							} else {
								_tmp74_ = FALSE;
							}
							if (_tmp74_) {
								GeeConcurrentSetTower* _tmp78_ = NULL;
								GeeConcurrentSetTower* _tmp79_ = NULL;
								_tmp78_ = next;
								_tmp79_ = _gee_concurrent_set_tower_ref0 (_tmp78_);
								_gee_concurrent_set_tower_unref0 (_vala_out_curr);
								_vala_out_curr = _tmp79_;
							}
							_tmp80_ = range;
							_tmp81_ = _tmp80_->_set;
							_tmp82_ = _tmp81_->priv->_cmp;
							_tmp82__target = _tmp81_->priv->_cmp_target;
							_tmp83_ = curr;
							_tmp84_ = range;
							_tmp85_ = _tmp84_->_start;
							_tmp86_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp82_, _tmp82__target, _tmp83_, _tmp85_);
							if (_tmp86_ < 0) {
								GeeConcurrentSetRange* _tmp87_ = NULL;
								gint _tmp88_ = 0;
								GeeConcurrentSetTower* _tmp89_ = NULL;
								GeeConcurrentSetTower* _tmp90_ = NULL;
								GeeConcurrentSetTower* _tmp91_ = NULL;
								gboolean _tmp92_ = FALSE;
								GeeConcurrentSetTower* _tmp96_ = NULL;
								GeeConcurrentSetTower* _tmp97_ = NULL;
								_tmp87_ = range;
								_tmp88_ = i;
								_tmp89_ = curr_old;
								_tmp90_ = curr;
								_tmp91_ = _gee_concurrent_set_tower_ref0 (_tmp90_);
								_tmp92_ = gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp87_->_bookmark._iter[_tmp88_], _tmp89_, _tmp91_, (gsize) 0, (gsize) 0, (gsize) 0);
								if (!_tmp92_) {
									GeeConcurrentSetRange* _tmp93_ = NULL;
									gint _tmp94_ = 0;
									gpointer _tmp95_ = NULL;
									_tmp93_ = range;
									_tmp94_ = i;
									_tmp95_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp93_->_bookmark._iter[_tmp94_], (gsize) 0, NULL);
									_gee_concurrent_set_tower_unref0 (curr);
									curr = (GeeConcurrentSetTower*) _tmp95_;
								}
								_tmp96_ = curr;
								_tmp97_ = _gee_concurrent_set_tower_ref0 (_tmp96_);
								_gee_concurrent_set_tower_unref0 (curr_old);
								curr_old = _tmp97_;
							} else {
								break;
							}
						}
						if ((&_vala_prev) != NULL) {
							gint _tmp98_ = 0;
							GeeConcurrentSetTower* _tmp99_ = NULL;
							GeeConcurrentSetTower* _tmp100_ = NULL;
							GeeConcurrentSetTower* _tmp101_ = NULL;
							_tmp98_ = i;
							_tmp99_ = curr;
							_tmp100_ = _gee_concurrent_set_tower_ref0 (_tmp99_);
							_gee_concurrent_set_tower_unref0 (_vala_prev._iter[_tmp98_]);
							_vala_prev._iter[_tmp98_] = _tmp100_;
							_tmp101_ = _vala_prev._iter[_tmp98_];
						}
						_tmp102_ = curr;
						curr = NULL;
						_gee_concurrent_set_tower_unref0 (last_best);
						last_best = _tmp102_;
						_gee_concurrent_set_tower_unref0 (next);
						_gee_concurrent_set_tower_unref0 (curr_old);
						_gee_concurrent_set_tower_unref0 (curr);
					}
				}
			}
			_gee_concurrent_set_tower_unref0 (last_best);
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	if ((&_vala_out_curr) != NULL) {
		GeeConcurrentSetTower* _tmp105_ = NULL;
		_tmp105_ = _vala_out_curr;
		_tmp104_ = _tmp105_ != NULL;
	} else {
		_tmp104_ = FALSE;
	}
	if (_tmp104_) {
		GeeConcurrentSetRange* _tmp106_ = NULL;
		GeeConcurrentSetTower* _tmp107_ = NULL;
		gboolean _tmp108_ = FALSE;
		_tmp106_ = range;
		_tmp107_ = _vala_out_curr;
		_tmp108_ = gee_concurrent_set_range_beyond (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp106_, _tmp107_);
		_tmp103_ = _tmp108_;
	} else {
		_tmp103_ = FALSE;
	}
	if (_tmp103_) {
		_gee_concurrent_set_tower_unref0 (_vala_out_curr);
		_vala_out_curr = NULL;
	}
	if (out_curr) {
		*out_curr = _vala_out_curr;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_out_curr);
	}
	if (prev) {
		*prev = _vala_prev;
	} else {
		gee_concurrent_set_tower_iter_destroy (&_vala_prev);
	}
}


static gboolean gee_concurrent_set_range_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** curr, guint8 level) {
	gboolean result = FALSE;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRangeType _tmp1_ = 0;
	g_return_val_if_fail (range != NULL, FALSE);
	g_return_val_if_fail (*curr != NULL, FALSE);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = FALSE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp2_ = NULL;
			GeeConcurrentSet* _tmp3_ = NULL;
			GCompareDataFunc _tmp4_ = NULL;
			void* _tmp4__target = NULL;
			guint8 _tmp5_ = 0U;
			gboolean _tmp6_ = FALSE;
			_tmp2_ = range;
			_tmp3_ = _tmp2_->_set;
			_tmp4_ = _tmp3_->priv->_cmp;
			_tmp4__target = _tmp3_->priv->_cmp_target;
			_tmp5_ = level;
			_tmp6_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp4_, _tmp4__target, prev, curr, _tmp5_, FALSE);
			result = _tmp6_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetTower* tmp_prev = NULL;
			GeeConcurrentSetTower* _tmp7_ = NULL;
			GeeConcurrentSetTower* _tmp8_ = NULL;
			GeeConcurrentSetTower* tmp_curr = NULL;
			GeeConcurrentSetTower* _tmp9_ = NULL;
			GeeConcurrentSetTower* _tmp10_ = NULL;
			GeeConcurrentSetRange* _tmp11_ = NULL;
			GeeConcurrentSet* _tmp12_ = NULL;
			GCompareDataFunc _tmp13_ = NULL;
			void* _tmp13__target = NULL;
			guint8 _tmp14_ = 0U;
			gboolean _tmp15_ = FALSE;
			_tmp7_ = *prev;
			_tmp8_ = _gee_concurrent_set_tower_ref0 (_tmp7_);
			tmp_prev = _tmp8_;
			_tmp9_ = *curr;
			_tmp10_ = _gee_concurrent_set_tower_ref0 (_tmp9_);
			tmp_curr = _tmp10_;
			_tmp11_ = range;
			_tmp12_ = _tmp11_->_set;
			_tmp13_ = _tmp12_->priv->_cmp;
			_tmp13__target = _tmp12_->priv->_cmp_target;
			_tmp14_ = level;
			_tmp15_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp13_, _tmp13__target, &tmp_prev, &tmp_curr, _tmp14_, FALSE);
			if (!_tmp15_) {
				result = FALSE;
				_gee_concurrent_set_tower_unref0 (tmp_curr);
				_gee_concurrent_set_tower_unref0 (tmp_prev);
				return result;
			} else {
				GeeConcurrentSetRange* _tmp16_ = NULL;
				GeeConcurrentSet* _tmp17_ = NULL;
				GCompareDataFunc _tmp18_ = NULL;
				void* _tmp18__target = NULL;
				GeeConcurrentSetTower* _tmp19_ = NULL;
				GeeConcurrentSetRange* _tmp20_ = NULL;
				gconstpointer _tmp21_ = NULL;
				gint _tmp22_ = 0;
				_tmp16_ = range;
				_tmp17_ = _tmp16_->_set;
				_tmp18_ = _tmp17_->priv->_cmp;
				_tmp18__target = _tmp17_->priv->_cmp_target;
				_tmp19_ = tmp_curr;
				_tmp20_ = range;
				_tmp21_ = _tmp20_->_end;
				_tmp22_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp18_, _tmp18__target, _tmp19_, _tmp21_);
				if (_tmp22_ >= 0) {
					result = FALSE;
					_gee_concurrent_set_tower_unref0 (tmp_curr);
					_gee_concurrent_set_tower_unref0 (tmp_prev);
					return result;
				} else {
					GeeConcurrentSetTower* _tmp23_ = NULL;
					GeeConcurrentSetTower* _tmp24_ = NULL;
					_tmp23_ = tmp_prev;
					tmp_prev = NULL;
					_gee_concurrent_set_tower_unref0 (*prev);
					*prev = _tmp23_;
					_tmp24_ = tmp_curr;
					tmp_curr = NULL;
					_gee_concurrent_set_tower_unref0 (*curr);
					*curr = _tmp24_;
					result = TRUE;
					_gee_concurrent_set_tower_unref0 (tmp_curr);
					_gee_concurrent_set_tower_unref0 (tmp_prev);
					return result;
				}
			}
			_gee_concurrent_set_tower_unref0 (tmp_curr);
			_gee_concurrent_set_tower_unref0 (tmp_prev);
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static gboolean gee_concurrent_set_range_inside (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val) {
	gboolean result = FALSE;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRangeType _tmp1_ = 0;
	g_return_val_if_fail (range != NULL, FALSE);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp2_ = NULL;
			GeeConcurrentSet* _tmp3_ = NULL;
			GCompareDataFunc _tmp4_ = NULL;
			void* _tmp4__target = NULL;
			gconstpointer _tmp5_ = NULL;
			GeeConcurrentSetRange* _tmp6_ = NULL;
			gconstpointer _tmp7_ = NULL;
			gint _tmp8_ = 0;
			_tmp2_ = range;
			_tmp3_ = _tmp2_->_set;
			_tmp4_ = _tmp3_->priv->_cmp;
			_tmp4__target = _tmp3_->priv->_cmp_target;
			_tmp5_ = val;
			_tmp6_ = range;
			_tmp7_ = _tmp6_->_end;
			_tmp8_ = _tmp4_ (_tmp5_, _tmp7_, _tmp4__target);
			result = _tmp8_ < 0;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp9_ = NULL;
			GeeConcurrentSet* _tmp10_ = NULL;
			GCompareDataFunc _tmp11_ = NULL;
			void* _tmp11__target = NULL;
			gconstpointer _tmp12_ = NULL;
			GeeConcurrentSetRange* _tmp13_ = NULL;
			gconstpointer _tmp14_ = NULL;
			gint _tmp15_ = 0;
			_tmp9_ = range;
			_tmp10_ = _tmp9_->_set;
			_tmp11_ = _tmp10_->priv->_cmp;
			_tmp11__target = _tmp10_->priv->_cmp_target;
			_tmp12_ = val;
			_tmp13_ = range;
			_tmp14_ = _tmp13_->_start;
			_tmp15_ = _tmp11_ (_tmp12_, _tmp14_, _tmp11__target);
			result = _tmp15_ >= 0;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			gboolean _tmp16_ = FALSE;
			GeeConcurrentSetRange* _tmp17_ = NULL;
			GeeConcurrentSet* _tmp18_ = NULL;
			GCompareDataFunc _tmp19_ = NULL;
			void* _tmp19__target = NULL;
			gconstpointer _tmp20_ = NULL;
			GeeConcurrentSetRange* _tmp21_ = NULL;
			gconstpointer _tmp22_ = NULL;
			gint _tmp23_ = 0;
			_tmp17_ = range;
			_tmp18_ = _tmp17_->_set;
			_tmp19_ = _tmp18_->priv->_cmp;
			_tmp19__target = _tmp18_->priv->_cmp_target;
			_tmp20_ = val;
			_tmp21_ = range;
			_tmp22_ = _tmp21_->_start;
			_tmp23_ = _tmp19_ (_tmp20_, _tmp22_, _tmp19__target);
			if (_tmp23_ >= 0) {
				GeeConcurrentSetRange* _tmp24_ = NULL;
				GeeConcurrentSet* _tmp25_ = NULL;
				GCompareDataFunc _tmp26_ = NULL;
				void* _tmp26__target = NULL;
				gconstpointer _tmp27_ = NULL;
				GeeConcurrentSetRange* _tmp28_ = NULL;
				gconstpointer _tmp29_ = NULL;
				gint _tmp30_ = 0;
				_tmp24_ = range;
				_tmp25_ = _tmp24_->_set;
				_tmp26_ = _tmp25_->priv->_cmp;
				_tmp26__target = _tmp25_->priv->_cmp_target;
				_tmp27_ = val;
				_tmp28_ = range;
				_tmp29_ = _tmp28_->_end;
				_tmp30_ = _tmp26_ (_tmp27_, _tmp29_, _tmp26__target);
				_tmp16_ = _tmp30_ < 0;
			} else {
				_tmp16_ = FALSE;
			}
			result = _tmp16_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = FALSE;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static gboolean gee_concurrent_set_range_beyond (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower* tw) {
	gboolean result = FALSE;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRangeType _tmp1_ = 0;
	g_return_val_if_fail (range != NULL, FALSE);
	g_return_val_if_fail (tw != NULL, FALSE);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = TRUE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			result = FALSE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp2_ = NULL;
			GeeConcurrentSet* _tmp3_ = NULL;
			GCompareDataFunc _tmp4_ = NULL;
			void* _tmp4__target = NULL;
			GeeConcurrentSetTower* _tmp5_ = NULL;
			GeeConcurrentSetRange* _tmp6_ = NULL;
			gconstpointer _tmp7_ = NULL;
			gint _tmp8_ = 0;
			_tmp2_ = range;
			_tmp3_ = _tmp2_->_set;
			_tmp4_ = _tmp3_->priv->_cmp;
			_tmp4__target = _tmp3_->priv->_cmp_target;
			_tmp5_ = tw;
			_tmp6_ = range;
			_tmp7_ = _tmp6_->_end;
			_tmp8_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp4_, _tmp4__target, _tmp5_, _tmp7_);
			result = _tmp8_ >= 0;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static gint gee_concurrent_set_range_cmp (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val) {
	gint result = 0;
	GeeConcurrentSetRange* _tmp0_ = NULL;
	GeeConcurrentSetRangeType _tmp1_ = 0;
	g_return_val_if_fail (range != NULL, 0);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRangePosition _tmp2_ = 0;
			GeeConcurrentSetRange* _tmp3_ = NULL;
			GeeConcurrentSet* _tmp4_ = NULL;
			GCompareDataFunc _tmp5_ = NULL;
			void* _tmp5__target = NULL;
			gconstpointer _tmp6_ = NULL;
			GeeConcurrentSetRange* _tmp7_ = NULL;
			gconstpointer _tmp8_ = NULL;
			gint _tmp9_ = 0;
			_tmp3_ = range;
			_tmp4_ = _tmp3_->_set;
			_tmp5_ = _tmp4_->priv->_cmp;
			_tmp5__target = _tmp4_->priv->_cmp_target;
			_tmp6_ = val;
			_tmp7_ = range;
			_tmp8_ = _tmp7_->_end;
			_tmp9_ = _tmp5_ (_tmp6_, _tmp8_, _tmp5__target);
			if (_tmp9_ < 0) {
				_tmp2_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
			} else {
				_tmp2_ = GEE_CONCURRENT_SET_RANGE_POSITION_AFTER;
			}
			result = (gint) _tmp2_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRangePosition _tmp10_ = 0;
			GeeConcurrentSetRange* _tmp11_ = NULL;
			GeeConcurrentSet* _tmp12_ = NULL;
			GCompareDataFunc _tmp13_ = NULL;
			void* _tmp13__target = NULL;
			gconstpointer _tmp14_ = NULL;
			GeeConcurrentSetRange* _tmp15_ = NULL;
			gconstpointer _tmp16_ = NULL;
			gint _tmp17_ = 0;
			_tmp11_ = range;
			_tmp12_ = _tmp11_->_set;
			_tmp13_ = _tmp12_->priv->_cmp;
			_tmp13__target = _tmp12_->priv->_cmp_target;
			_tmp14_ = val;
			_tmp15_ = range;
			_tmp16_ = _tmp15_->_start;
			_tmp17_ = _tmp13_ (_tmp14_, _tmp16_, _tmp13__target);
			if (_tmp17_ >= 0) {
				_tmp10_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
			} else {
				_tmp10_ = GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE;
			}
			result = (gint) _tmp10_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRangePosition _tmp18_ = 0;
			GeeConcurrentSetRange* _tmp19_ = NULL;
			GeeConcurrentSet* _tmp20_ = NULL;
			GCompareDataFunc _tmp21_ = NULL;
			void* _tmp21__target = NULL;
			gconstpointer _tmp22_ = NULL;
			GeeConcurrentSetRange* _tmp23_ = NULL;
			gconstpointer _tmp24_ = NULL;
			gint _tmp25_ = 0;
			_tmp19_ = range;
			_tmp20_ = _tmp19_->_set;
			_tmp21_ = _tmp20_->priv->_cmp;
			_tmp21__target = _tmp20_->priv->_cmp_target;
			_tmp22_ = val;
			_tmp23_ = range;
			_tmp24_ = _tmp23_->_start;
			_tmp25_ = _tmp21_ (_tmp22_, _tmp24_, _tmp21__target);
			if (_tmp25_ >= 0) {
				GeeConcurrentSetRangePosition _tmp26_ = 0;
				GeeConcurrentSetRange* _tmp27_ = NULL;
				GeeConcurrentSet* _tmp28_ = NULL;
				GCompareDataFunc _tmp29_ = NULL;
				void* _tmp29__target = NULL;
				gconstpointer _tmp30_ = NULL;
				GeeConcurrentSetRange* _tmp31_ = NULL;
				gconstpointer _tmp32_ = NULL;
				gint _tmp33_ = 0;
				_tmp27_ = range;
				_tmp28_ = _tmp27_->_set;
				_tmp29_ = _tmp28_->priv->_cmp;
				_tmp29__target = _tmp28_->priv->_cmp_target;
				_tmp30_ = val;
				_tmp31_ = range;
				_tmp32_ = _tmp31_->_end;
				_tmp33_ = _tmp29_ (_tmp30_, _tmp32_, _tmp29__target);
				if (_tmp33_ < 0) {
					_tmp26_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
				} else {
					_tmp26_ = GEE_CONCURRENT_SET_RANGE_POSITION_AFTER;
				}
				_tmp18_ = _tmp26_;
			} else {
				_tmp18_ = GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE;
			}
			result = (gint) _tmp18_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = (gint) GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static void gee_concurrent_set_value_range_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gee_concurrent_set_value_range_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gee_concurrent_set_range_unref (value->data[0].v_pointer);
	}
}


static void gee_concurrent_set_value_range_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gee_concurrent_set_range_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gee_concurrent_set_value_range_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gee_concurrent_set_value_range_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GeeConcurrentSetRange* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gee_concurrent_set_range_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gee_concurrent_set_value_range_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GeeConcurrentSetRange** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gee_concurrent_set_range_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* gee_concurrent_set_param_spec_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GeeConcurrentSetParamSpecRange* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEE_CONCURRENT_SET_TYPE_RANGE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer gee_concurrent_set_value_get_range (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE), NULL);
	return value->data[0].v_pointer;
}


static void gee_concurrent_set_value_set_range (GValue* value, gpointer v_object) {
	GeeConcurrentSetRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gee_concurrent_set_range_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_range_unref (old);
	}
}


static void gee_concurrent_set_value_take_range (GValue* value, gpointer v_object) {
	GeeConcurrentSetRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_range_unref (old);
	}
}


static void gee_concurrent_set_range_class_init (GeeConcurrentSetRangeClass * klass) {
	gee_concurrent_set_range_parent_class = g_type_class_peek_parent (klass);
	((GeeConcurrentSetRangeClass *) klass)->finalize = gee_concurrent_set_range_finalize;
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetRangePrivate));
}


static void gee_concurrent_set_range_instance_init (GeeConcurrentSetRange * self) {
	self->priv = GEE_CONCURRENT_SET_RANGE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void gee_concurrent_set_range_finalize (GeeConcurrentSetRange* obj) {
	GeeConcurrentSetRange * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRange);
	g_signal_handlers_destroy (self);
	((self->_start == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_start = (self->priv->g_destroy_func (self->_start), NULL));
	((self->_end == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_end = (self->priv->g_destroy_func (self->_end), NULL));
	gee_concurrent_set_tower_iter_destroy (&self->_bookmark);
	_g_object_unref0 (self->_set);
}


static GType gee_concurrent_set_range_get_type (void) {
	static volatile gsize gee_concurrent_set_range_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gee_concurrent_set_value_range_init, gee_concurrent_set_value_range_free_value, gee_concurrent_set_value_range_copy_value, gee_concurrent_set_value_range_peek_pointer, "p", gee_concurrent_set_value_range_collect_value, "p", gee_concurrent_set_value_range_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetRangeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_range_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetRange), 0, (GInstanceInitFunc) gee_concurrent_set_range_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gee_concurrent_set_range_type_id;
		gee_concurrent_set_range_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeeConcurrentSetRange", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gee_concurrent_set_range_type_id__volatile, gee_concurrent_set_range_type_id);
	}
	return gee_concurrent_set_range_type_id__volatile;
}


static gpointer gee_concurrent_set_range_ref (gpointer instance) {
	GeeConcurrentSetRange* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void gee_concurrent_set_range_unref (gpointer instance) {
	GeeConcurrentSetRange* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEE_CONCURRENT_SET_RANGE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height) {
	GeeConcurrentSetTower* self = NULL;
	guint8 _tmp0_ = 0U;
	GeeConcurrentSetTowerNode* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	gpointer _tmp3_ = NULL;
	GeeConcurrentSetTowerNode* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	self = (GeeConcurrentSetTower*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = height;
	_tmp1_ = g_new0 (GeeConcurrentSetTowerNode, _tmp0_);
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = _tmp1_;
	_tmp2_ = data;
	_tmp3_ = ((_tmp2_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp2_) : ((gpointer) _tmp2_);
	_g_destroy_func0 (self->_data);
	self->_data = _tmp3_;
	self->_height = 0;
	_tmp4_ = self->_nodes;
	_tmp4__length1 = -1;
	g_atomic_pointer_set ((volatile gpointer *) (&_tmp4_[0]._backlink), NULL);
	return self;
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height) {
	return gee_concurrent_set_tower_construct (GEE_CONCURRENT_SET_TYPE_TOWER, g_type, g_dup_func, g_destroy_func, data, height);
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func) {
	GeeConcurrentSetTower* self = NULL;
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	self = (GeeConcurrentSetTower*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = g_new0 (GeeConcurrentSetTowerNode, GEE_CONCURRENT_SET__MAX_HEIGHT);
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = _tmp0_;
	self->_height = -1;
	return self;
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func) {
	return gee_concurrent_set_tower_construct_head (GEE_CONCURRENT_SET_TYPE_TOWER, g_type, g_dup_func, g_destroy_func);
}


static inline gboolean gee_concurrent_set_tower_search (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 to_level, guint8 from_level) {
	GeeConcurrentSetTower* _vala_next = NULL;
	gboolean result = FALSE;
	guint8 _tmp0_ = 0U;
	guint8 _tmp1_ = 0U;
	gboolean res = FALSE;
	g_return_val_if_fail (*prev != NULL, FALSE);
	_tmp0_ = from_level;
	_tmp1_ = to_level;
	_vala_assert (_tmp0_ >= _tmp1_, "from_level >= to_level");
	res = FALSE;
	_gee_concurrent_set_tower_unref0 (_vala_next);
	_vala_next = NULL;
	{
		gint i = 0;
		guint8 _tmp2_ = 0U;
		_tmp2_ = from_level;
		i = (gint) _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				guint8 _tmp6_ = 0U;
				GCompareDataFunc _tmp7_ = NULL;
				void* _tmp7__target = NULL;
				gconstpointer _tmp8_ = NULL;
				gint _tmp9_ = 0;
				GeeConcurrentSetTower* _tmp10_ = NULL;
				gboolean _tmp11_ = FALSE;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = to_level;
				if (!(_tmp5_ >= ((gint) _tmp6_))) {
					break;
				}
				_tmp7_ = cmp;
				_tmp7__target = cmp_target;
				_tmp8_ = key;
				_tmp9_ = i;
				_tmp11_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp7_, _tmp7__target, _tmp8_, prev, &_tmp10_, (guint8) _tmp9_);
				_gee_concurrent_set_tower_unref0 (_vala_next);
				_vala_next = _tmp10_;
				res = _tmp11_;
			}
		}
	}
	result = res;
	if (next) {
		*next = _vala_next;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_next);
	}
	return result;
}


static inline gboolean gee_concurrent_set_tower_search_from_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTowerIter* next, guint8 to_level, guint8 from_level) {
	GeeConcurrentSetTowerIter _vala_next = {0};
	gboolean result = FALSE;
	guint8 _tmp0_ = 0U;
	guint8 _tmp1_ = 0U;
	gboolean res = FALSE;
	g_return_val_if_fail (prev != NULL, FALSE);
	_tmp0_ = from_level;
	_tmp1_ = to_level;
	_vala_assert (_tmp0_ >= _tmp1_, "from_level >= to_level");
	gee_concurrent_set_tower_iter_destroy (&_vala_next);
	memset (&_vala_next, 0, sizeof (GeeConcurrentSetTowerIter));
	res = FALSE;
	{
		gint i = 0;
		guint8 _tmp2_ = 0U;
		_tmp2_ = from_level;
		i = (gint) _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				guint8 _tmp6_ = 0U;
				GeeConcurrentSetTower* tmp_prev = NULL;
				GeeConcurrentSetTowerIter _tmp7_ = {0};
				gint _tmp8_ = 0;
				GeeConcurrentSetTower* _tmp9_ = NULL;
				GeeConcurrentSetTower* tmp_next = NULL;
				GCompareDataFunc _tmp10_ = NULL;
				void* _tmp10__target = NULL;
				gconstpointer _tmp11_ = NULL;
				gint _tmp12_ = 0;
				gint _tmp13_ = 0;
				GeeConcurrentSetTower* _tmp14_ = NULL;
				gboolean _tmp15_ = FALSE;
				GeeConcurrentSetTowerIter _tmp19_ = {0};
				gint _tmp20_ = 0;
				GeeConcurrentSetTower* _tmp21_ = NULL;
				GeeConcurrentSetTower* _tmp22_ = NULL;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = to_level;
				if (!(_tmp5_ >= ((gint) _tmp6_))) {
					break;
				}
				_tmp7_ = *prev;
				_tmp8_ = i;
				_tmp9_ = _tmp7_._iter[_tmp8_];
				tmp_prev = _tmp9_;
				_tmp10_ = cmp;
				_tmp10__target = cmp_target;
				_tmp11_ = key;
				_tmp12_ = i;
				_tmp13_ = i;
				_tmp15_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp10_, _tmp10__target, _tmp11_, &(*prev)._iter[_tmp12_], &_tmp14_, (guint8) _tmp13_);
				_gee_concurrent_set_tower_unref0 (tmp_next);
				tmp_next = _tmp14_;
				res = _tmp15_;
				if ((&_vala_next) != NULL) {
					gint _tmp16_ = 0;
					GeeConcurrentSetTower* _tmp17_ = NULL;
					GeeConcurrentSetTower* _tmp18_ = NULL;
					_tmp16_ = i;
					_tmp17_ = tmp_next;
					tmp_next = NULL;
					_gee_concurrent_set_tower_unref0 (_vala_next._iter[_tmp16_]);
					_vala_next._iter[_tmp16_] = _tmp17_;
					_tmp18_ = _vala_next._iter[_tmp16_];
				}
				_tmp19_ = *prev;
				_tmp20_ = i;
				_tmp21_ = _tmp19_._iter[_tmp20_];
				_tmp22_ = tmp_prev;
				if (_tmp21_ != _tmp22_) {
					gint _tmp23_ = 0;
					GeeConcurrentSetTowerIter _tmp24_ = {0};
					gint _tmp25_ = 0;
					GeeConcurrentSetTower* _tmp26_ = NULL;
					GeeConcurrentSetTower* _tmp27_ = NULL;
					GeeConcurrentSetTower* _tmp28_ = NULL;
					gboolean _tmp29_ = FALSE;
					gint _tmp30_ = 0;
					guint8 _tmp31_ = 0U;
					_tmp23_ = i;
					_tmp24_ = *prev;
					_tmp25_ = i;
					_tmp26_ = _tmp24_._iter[_tmp25_];
					_tmp27_ = _gee_concurrent_set_tower_ref0 (_tmp26_);
					_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp23_]);
					(*prev)._iter[_tmp23_] = _tmp27_;
					_tmp28_ = (*prev)._iter[_tmp23_];
					_tmp30_ = i;
					_tmp31_ = to_level;
					if (_tmp30_ > ((gint) _tmp31_)) {
						GCompareDataFunc _tmp32_ = NULL;
						void* _tmp32__target = NULL;
						GeeConcurrentSetTowerIter _tmp33_ = {0};
						gint _tmp34_ = 0;
						GeeConcurrentSetTower* _tmp35_ = NULL;
						GeeConcurrentSetTowerIter _tmp36_ = {0};
						gint _tmp37_ = 0;
						GeeConcurrentSetTower* _tmp38_ = NULL;
						gint _tmp39_ = 0;
						_tmp32_ = cmp;
						_tmp32__target = cmp_target;
						_tmp33_ = *prev;
						_tmp34_ = i;
						_tmp35_ = _tmp33_._iter[_tmp34_ - 1];
						_tmp36_ = *prev;
						_tmp37_ = i;
						_tmp38_ = _tmp36_._iter[_tmp37_];
						_tmp39_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp32_, _tmp32__target, _tmp35_, _tmp38_);
						_tmp29_ = _tmp39_ <= 0;
					} else {
						_tmp29_ = FALSE;
					}
					if (_tmp29_) {
						gint _tmp40_ = 0;
						GeeConcurrentSetTowerIter _tmp41_ = {0};
						gint _tmp42_ = 0;
						GeeConcurrentSetTower* _tmp43_ = NULL;
						GeeConcurrentSetTower* _tmp44_ = NULL;
						GeeConcurrentSetTower* _tmp45_ = NULL;
						_tmp40_ = i;
						_tmp41_ = *prev;
						_tmp42_ = i;
						_tmp43_ = _tmp41_._iter[_tmp42_];
						_tmp44_ = _gee_concurrent_set_tower_ref0 (_tmp43_);
						_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp40_ - 1]);
						(*prev)._iter[_tmp40_ - 1] = _tmp44_;
						_tmp45_ = (*prev)._iter[_tmp40_ - 1];
					}
				}
				_gee_concurrent_set_tower_unref0 (tmp_next);
			}
		}
	}
	result = res;
	if (next) {
		*next = _vala_next;
	} else {
		gee_concurrent_set_tower_iter_destroy (&_vala_next);
	}
	return result;
}


static inline gboolean gee_concurrent_set_tower_search_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 level) {
	GeeConcurrentSetTower* _vala_next = NULL;
	gboolean result = FALSE;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	guint8 _tmp1_ = 0U;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	gboolean _tmp13_ = FALSE;
	GeeConcurrentSetTower* _tmp14_ = NULL;
	_tmp0_ = *prev;
	_tmp1_ = level;
	_tmp2_ = gee_concurrent_set_tower_get_next (_tmp0_, _tmp1_);
	_gee_concurrent_set_tower_unref0 (_vala_next);
	_vala_next = _tmp2_;
	while (TRUE) {
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		GeeConcurrentSetTower* _tmp5_ = NULL;
		_tmp5_ = _vala_next;
		if (_tmp5_ != NULL) {
			GCompareDataFunc _tmp6_ = NULL;
			void* _tmp6__target = NULL;
			GeeConcurrentSetTower* _tmp7_ = NULL;
			gconstpointer _tmp8_ = NULL;
			gint _tmp9_ = 0;
			_tmp6_ = cmp;
			_tmp6__target = cmp_target;
			_tmp7_ = _vala_next;
			_tmp8_ = key;
			_tmp9_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp6_, _tmp6__target, _tmp7_, _tmp8_);
			_tmp4_ = _tmp9_ < 0;
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			GCompareDataFunc _tmp10_ = NULL;
			void* _tmp10__target = NULL;
			guint8 _tmp11_ = 0U;
			gboolean _tmp12_ = FALSE;
			_tmp10_ = cmp;
			_tmp10__target = cmp_target;
			_tmp11_ = level;
			_tmp12_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp10_, _tmp10__target, prev, &_vala_next, _tmp11_, TRUE);
			_tmp3_ = _tmp12_;
		} else {
			_tmp3_ = FALSE;
		}
		if (!_tmp3_) {
			break;
		}
	}
	_tmp14_ = _vala_next;
	if (_tmp14_ != NULL) {
		GCompareDataFunc _tmp15_ = NULL;
		void* _tmp15__target = NULL;
		gconstpointer _tmp16_ = NULL;
		GeeConcurrentSetTower* _tmp17_ = NULL;
		gconstpointer _tmp18_ = NULL;
		gint _tmp19_ = 0;
		_tmp15_ = cmp;
		_tmp15__target = cmp_target;
		_tmp16_ = key;
		_tmp17_ = _vala_next;
		_tmp18_ = _tmp17_->_data;
		_tmp19_ = _tmp15_ (_tmp16_, _tmp18_, _tmp15__target);
		_tmp13_ = _tmp19_ == 0;
	} else {
		_tmp13_ = FALSE;
	}
	result = _tmp13_;
	if (next) {
		*next = _vala_next;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_next);
	}
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level) {
	GeeConcurrentSetTower* result = NULL;
	GCompareDataFunc _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	gconstpointer _tmp1_ = NULL;
	guint8 _tmp2_ = 0U;
	guint8 _tmp3_ = 0U;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	g_return_val_if_fail (prev != NULL, NULL);
	_tmp0_ = cmp;
	_tmp0__target = cmp_target;
	_tmp1_ = key;
	_tmp2_ = chosen_level;
	_tmp3_ = chosen_level;
	_tmp4_ = gee_concurrent_set_tower_insert_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, _tmp0__target, prev, _tmp1_, _tmp2_, _tmp3_);
	result = _tmp4_;
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level, guint8 level) {
	GeeConcurrentSetTower* result = NULL;
	GeeConcurrentSetTower* new_tower = NULL;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	gconstpointer _tmp1_ = NULL;
	guint8 _tmp2_ = 0U;
	guint8 _tmp3_ = 0U;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	guint8 _tmp6_ = 0U;
	GeeConcurrentSetTower* _tmp29_ = NULL;
	GeeConcurrentSetTower* _tmp72_ = NULL;
	GeeConcurrentSetTower* _tmp73_ = NULL;
	GeeConcurrentSetState _tmp74_ = 0;
	g_return_val_if_fail (prev != NULL, NULL);
	_tmp0_ = cmp;
	_tmp0__target = cmp_target;
	_tmp1_ = key;
	_tmp2_ = level;
	_tmp3_ = level;
	_tmp5_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, _tmp0__target, _tmp1_, &(*prev)._iter[_tmp2_], &_tmp4_, _tmp3_);
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp4_;
	if (_tmp5_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	_tmp6_ = level;
	if (((gint) _tmp6_) > 0) {
		GCompareDataFunc _tmp7_ = NULL;
		void* _tmp7__target = NULL;
		GeeConcurrentSetTowerIter _tmp8_ = {0};
		guint8 _tmp9_ = 0U;
		GeeConcurrentSetTower* _tmp10_ = NULL;
		GeeConcurrentSetTowerIter _tmp11_ = {0};
		guint8 _tmp12_ = 0U;
		GeeConcurrentSetTower* _tmp13_ = NULL;
		gint _tmp14_ = 0;
		GCompareDataFunc _tmp21_ = NULL;
		void* _tmp21__target = NULL;
		gconstpointer _tmp22_ = NULL;
		guint8 _tmp23_ = 0U;
		guint8 _tmp24_ = 0U;
		GeeConcurrentSetTower* _tmp25_ = NULL;
		_tmp7_ = cmp;
		_tmp7__target = cmp_target;
		_tmp8_ = *prev;
		_tmp9_ = level;
		_tmp10_ = _tmp8_._iter[_tmp9_];
		_tmp11_ = *prev;
		_tmp12_ = level;
		_tmp13_ = _tmp11_._iter[_tmp12_ - 1];
		_tmp14_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp7_, _tmp7__target, _tmp10_, _tmp13_);
		if (_tmp14_ >= 0) {
			guint8 _tmp15_ = 0U;
			GeeConcurrentSetTowerIter _tmp16_ = {0};
			guint8 _tmp17_ = 0U;
			GeeConcurrentSetTower* _tmp18_ = NULL;
			GeeConcurrentSetTower* _tmp19_ = NULL;
			GeeConcurrentSetTower* _tmp20_ = NULL;
			_tmp15_ = level;
			_tmp16_ = *prev;
			_tmp17_ = level;
			_tmp18_ = _tmp16_._iter[_tmp17_];
			_tmp19_ = _gee_concurrent_set_tower_ref0 (_tmp18_);
			_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp15_ - 1]);
			(*prev)._iter[_tmp15_ - 1] = _tmp19_;
			_tmp20_ = (*prev)._iter[_tmp15_ - 1];
		}
		_tmp21_ = cmp;
		_tmp21__target = cmp_target;
		_tmp22_ = key;
		_tmp23_ = chosen_level;
		_tmp24_ = level;
		_tmp25_ = gee_concurrent_set_tower_insert_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp21_, _tmp21__target, prev, _tmp22_, _tmp23_, (guint8) (_tmp24_ - 1));
		_gee_concurrent_set_tower_unref0 (new_tower);
		new_tower = _tmp25_;
	} else {
		gconstpointer _tmp26_ = NULL;
		guint8 _tmp27_ = 0U;
		GeeConcurrentSetTower* _tmp28_ = NULL;
		_tmp26_ = key;
		_tmp27_ = chosen_level;
		_tmp28_ = gee_concurrent_set_tower_new (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp26_, (guint8) (_tmp27_ + 1));
		_gee_concurrent_set_tower_unref0 (new_tower);
		new_tower = _tmp28_;
	}
	_tmp29_ = new_tower;
	if (_tmp29_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	while (TRUE) {
		GeeConcurrentSetState prev_state = 0;
		GeeConcurrentSetTower* prev_next = NULL;
		GeeConcurrentSetTowerIter _tmp30_ = {0};
		guint8 _tmp31_ = 0U;
		GeeConcurrentSetTower* _tmp32_ = NULL;
		guint8 _tmp33_ = 0U;
		GeeConcurrentSetState _tmp34_ = 0;
		GeeConcurrentSetTower* _tmp35_ = NULL;
		GeeConcurrentSetState _tmp36_ = 0;
		GCompareDataFunc _tmp67_ = NULL;
		void* _tmp67__target = NULL;
		gconstpointer _tmp68_ = NULL;
		guint8 _tmp69_ = 0U;
		guint8 _tmp70_ = 0U;
		gboolean _tmp71_ = FALSE;
		_tmp30_ = *prev;
		_tmp31_ = level;
		_tmp32_ = _tmp30_._iter[_tmp31_];
		_tmp33_ = level;
		_tmp35_ = gee_concurrent_set_tower_get_succ (_tmp32_, &_tmp34_, _tmp33_);
		prev_state = _tmp34_;
		prev_next = _tmp35_;
		_tmp36_ = prev_state;
		if (_tmp36_ == GEE_CONCURRENT_SET_STATE_FLAGGED) {
			GeeConcurrentSetTower* _tmp37_ = NULL;
			GeeConcurrentSetTowerIter _tmp38_ = {0};
			guint8 _tmp39_ = 0U;
			GeeConcurrentSetTower* _tmp40_ = NULL;
			guint8 _tmp41_ = 0U;
			_tmp37_ = prev_next;
			_tmp38_ = *prev;
			_tmp39_ = level;
			_tmp40_ = _tmp38_._iter[_tmp39_];
			_tmp41_ = level;
			gee_concurrent_set_tower_help_flagged (_tmp37_, _tmp40_, _tmp41_);
		} else {
			GeeConcurrentSetTower* _tmp42_ = NULL;
			GeeConcurrentSetTower* _tmp43_ = NULL;
			guint8 _tmp44_ = 0U;
			gboolean _result_ = FALSE;
			GeeConcurrentSetTowerIter _tmp45_ = {0};
			guint8 _tmp46_ = 0U;
			GeeConcurrentSetTower* _tmp47_ = NULL;
			GeeConcurrentSetTower* _tmp48_ = NULL;
			GeeConcurrentSetTower* _tmp49_ = NULL;
			guint8 _tmp50_ = 0U;
			gboolean _tmp51_ = FALSE;
			gboolean _tmp52_ = FALSE;
			GeeConcurrentSetTowerIter _tmp53_ = {0};
			guint8 _tmp54_ = 0U;
			GeeConcurrentSetTower* _tmp55_ = NULL;
			guint8 _tmp56_ = 0U;
			GeeConcurrentSetState _tmp57_ = 0;
			GeeConcurrentSetTower* _tmp58_ = NULL;
			GeeConcurrentSetState _tmp59_ = 0;
			guint8 _tmp65_ = 0U;
			guint8 _tmp66_ = 0U;
			_tmp42_ = new_tower;
			_tmp43_ = next;
			_tmp44_ = level;
			gee_concurrent_set_tower_set_succ (_tmp42_, _tmp43_, GEE_CONCURRENT_SET_STATE_NONE, _tmp44_);
			_tmp45_ = *prev;
			_tmp46_ = level;
			_tmp47_ = _tmp45_._iter[_tmp46_];
			_tmp48_ = next;
			_tmp49_ = new_tower;
			_tmp50_ = level;
			_tmp51_ = gee_concurrent_set_tower_compare_and_exchange (_tmp47_, _tmp48_, GEE_CONCURRENT_SET_STATE_NONE, _tmp49_, GEE_CONCURRENT_SET_STATE_NONE, _tmp50_);
			_result_ = _tmp51_;
			_tmp52_ = _result_;
			if (_tmp52_) {
				_gee_concurrent_set_tower_unref0 (prev_next);
				break;
			}
			_tmp53_ = *prev;
			_tmp54_ = level;
			_tmp55_ = _tmp53_._iter[_tmp54_];
			_tmp56_ = level;
			_tmp58_ = gee_concurrent_set_tower_get_succ (_tmp55_, &_tmp57_, _tmp56_);
			prev_state = _tmp57_;
			_gee_concurrent_set_tower_unref0 (prev_next);
			prev_next = _tmp58_;
			_tmp59_ = prev_state;
			if (_tmp59_ == GEE_CONCURRENT_SET_STATE_FLAGGED) {
				GeeConcurrentSetTower* _tmp60_ = NULL;
				GeeConcurrentSetTowerIter _tmp61_ = {0};
				guint8 _tmp62_ = 0U;
				GeeConcurrentSetTower* _tmp63_ = NULL;
				guint8 _tmp64_ = 0U;
				_tmp60_ = prev_next;
				_tmp61_ = *prev;
				_tmp62_ = level;
				_tmp63_ = _tmp61_._iter[_tmp62_];
				_tmp64_ = level;
				gee_concurrent_set_tower_help_flagged (_tmp60_, _tmp63_, _tmp64_);
			}
			_tmp65_ = level;
			_tmp66_ = level;
			gee_concurrent_set_tower_backtrace (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, &(*prev)._iter[_tmp65_], _tmp66_);
		}
		_tmp67_ = cmp;
		_tmp67__target = cmp_target;
		_tmp68_ = key;
		_tmp69_ = level;
		_tmp70_ = level;
		_tmp71_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp67_, _tmp67__target, _tmp68_, &(*prev)._iter[_tmp69_], NULL, _tmp70_);
		if (_tmp71_) {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (prev_next);
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (new_tower);
			return result;
		}
		_gee_concurrent_set_tower_unref0 (prev_next);
	}
	_tmp72_ = new_tower;
	g_atomic_int_inc ((volatile gint *) (&_tmp72_->_height));
	_tmp73_ = new_tower;
	_tmp74_ = gee_concurrent_set_tower_get_state (_tmp73_, (guint8) 0);
	if (_tmp74_ == GEE_CONCURRENT_SET_STATE_MARKED) {
		GCompareDataFunc _tmp75_ = NULL;
		void* _tmp75__target = NULL;
		guint8 _tmp76_ = 0U;
		GeeConcurrentSetTower* _tmp77_ = NULL;
		guint8 _tmp78_ = 0U;
		_tmp75_ = cmp;
		_tmp75__target = cmp_target;
		_tmp76_ = level;
		_tmp77_ = new_tower;
		_tmp78_ = level;
		gee_concurrent_set_tower_remove_level (_tmp75_, _tmp75__target, &(*prev)._iter[_tmp76_], _tmp77_, _tmp78_);
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	result = new_tower;
	_gee_concurrent_set_tower_unref0 (next);
	return result;
}


static inline gboolean gee_concurrent_set_tower_remove_key (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 from_level) {
	gboolean result = FALSE;
	GeeConcurrentSetTower* curr = NULL;
	GCompareDataFunc _tmp23_ = NULL;
	void* _tmp23__target = NULL;
	gconstpointer _tmp24_ = NULL;
	GeeConcurrentSetTower* _tmp25_ = NULL;
	gboolean _tmp26_ = FALSE;
	g_return_val_if_fail (prev != NULL, FALSE);
	{
		gint i = 0;
		guint8 _tmp0_ = 0U;
		_tmp0_ = from_level;
		i = (gint) _tmp0_;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_ = 0;
				GeeConcurrentSetTower* next = NULL;
				GCompareDataFunc _tmp4_ = NULL;
				void* _tmp4__target = NULL;
				gconstpointer _tmp5_ = NULL;
				gint _tmp6_ = 0;
				gint _tmp7_ = 0;
				GeeConcurrentSetTower* _tmp8_ = NULL;
				GCompareDataFunc _tmp9_ = NULL;
				void* _tmp9__target = NULL;
				GeeConcurrentSetTowerIter _tmp10_ = {0};
				gint _tmp11_ = 0;
				GeeConcurrentSetTower* _tmp12_ = NULL;
				GeeConcurrentSetTowerIter _tmp13_ = {0};
				gint _tmp14_ = 0;
				GeeConcurrentSetTower* _tmp15_ = NULL;
				gint _tmp16_ = 0;
				if (!_tmp1_) {
					gint _tmp2_ = 0;
					_tmp2_ = i;
					i = _tmp2_ - 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = i;
				if (!(_tmp3_ >= 1)) {
					break;
				}
				_tmp4_ = cmp;
				_tmp4__target = cmp_target;
				_tmp5_ = key;
				_tmp6_ = i;
				_tmp7_ = i;
				gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp4_, _tmp4__target, _tmp5_, &(*prev)._iter[_tmp6_], &_tmp8_, (guint8) _tmp7_);
				_gee_concurrent_set_tower_unref0 (next);
				next = _tmp8_;
				_tmp9_ = cmp;
				_tmp9__target = cmp_target;
				_tmp10_ = *prev;
				_tmp11_ = i;
				_tmp12_ = _tmp10_._iter[_tmp11_ - 1];
				_tmp13_ = *prev;
				_tmp14_ = i;
				_tmp15_ = _tmp13_._iter[_tmp14_];
				_tmp16_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp9_, _tmp9__target, _tmp12_, _tmp15_);
				if (_tmp16_ < 0) {
					gint _tmp17_ = 0;
					GeeConcurrentSetTowerIter _tmp18_ = {0};
					gint _tmp19_ = 0;
					GeeConcurrentSetTower* _tmp20_ = NULL;
					GeeConcurrentSetTower* _tmp21_ = NULL;
					GeeConcurrentSetTower* _tmp22_ = NULL;
					_tmp17_ = i;
					_tmp18_ = *prev;
					_tmp19_ = i;
					_tmp20_ = _tmp18_._iter[_tmp19_];
					_tmp21_ = _gee_concurrent_set_tower_ref0 (_tmp20_);
					_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp17_ - 1]);
					(*prev)._iter[_tmp17_ - 1] = _tmp21_;
					_tmp22_ = (*prev)._iter[_tmp17_ - 1];
				}
				_gee_concurrent_set_tower_unref0 (next);
			}
		}
	}
	_tmp23_ = cmp;
	_tmp23__target = cmp_target;
	_tmp24_ = key;
	_tmp26_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp23_, _tmp23__target, _tmp24_, &(*prev)._iter[0], &_tmp25_, (guint8) 0);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp25_;
	if (_tmp26_) {
		GCompareDataFunc _tmp27_ = NULL;
		void* _tmp27__target = NULL;
		GeeConcurrentSetTower* _tmp28_ = NULL;
		gboolean _tmp29_ = FALSE;
		_tmp27_ = cmp;
		_tmp27__target = cmp_target;
		_tmp28_ = curr;
		_tmp29_ = gee_concurrent_set_tower_remove (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp27_, _tmp27__target, prev, _tmp28_);
		result = _tmp29_;
		_gee_concurrent_set_tower_unref0 (curr);
		return result;
	} else {
		result = FALSE;
		_gee_concurrent_set_tower_unref0 (curr);
		return result;
	}
	_gee_concurrent_set_tower_unref0 (curr);
}


static inline gboolean gee_concurrent_set_tower_remove (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	gboolean result = FALSE;
	gboolean removed = FALSE;
	GCompareDataFunc _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (prev != NULL, FALSE);
	g_return_val_if_fail (curr != NULL, FALSE);
	_tmp0_ = cmp;
	_tmp0__target = cmp_target;
	_tmp1_ = curr;
	_tmp2_ = gee_concurrent_set_tower_remove_level (_tmp0_, _tmp0__target, &(*prev)._iter[0], _tmp1_, (guint8) 0);
	removed = _tmp2_;
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				GCompareDataFunc _tmp6_ = NULL;
				void* _tmp6__target = NULL;
				gint _tmp7_ = 0;
				GeeConcurrentSetTower* _tmp8_ = NULL;
				gint _tmp9_ = 0;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				if (!(_tmp5_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp6_ = cmp;
				_tmp6__target = cmp_target;
				_tmp7_ = i;
				_tmp8_ = curr;
				_tmp9_ = i;
				gee_concurrent_set_tower_remove_level (_tmp6_, _tmp6__target, &(*prev)._iter[_tmp7_], _tmp8_, (guint8) _tmp9_);
			}
		}
	}
	result = removed;
	return result;
}


static inline gboolean gee_concurrent_set_tower_remove_level (GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev, GeeConcurrentSetTower* curr, guint8 level) {
	gboolean result = FALSE;
	gboolean status = FALSE;
	gboolean flagged = FALSE;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	GCompareDataFunc _tmp1_ = NULL;
	void* _tmp1__target = NULL;
	guint8 _tmp2_ = 0U;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (*prev != NULL, FALSE);
	g_return_val_if_fail (curr != NULL, FALSE);
	_tmp0_ = curr;
	_tmp1_ = cmp;
	_tmp1__target = cmp_target;
	_tmp2_ = level;
	_tmp4_ = gee_concurrent_set_tower_try_flag (_tmp0_, _tmp1_, _tmp1__target, prev, &_tmp3_, _tmp2_);
	status = _tmp3_;
	flagged = _tmp4_;
	_tmp5_ = status;
	if (_tmp5_) {
		GeeConcurrentSetTower* _tmp6_ = NULL;
		GeeConcurrentSetTower* _tmp7_ = NULL;
		guint8 _tmp8_ = 0U;
		_tmp6_ = curr;
		_tmp7_ = *prev;
		_tmp8_ = level;
		gee_concurrent_set_tower_help_flagged (_tmp6_, _tmp7_, _tmp8_);
	}
	result = flagged;
	return result;
}


static inline gboolean gee_concurrent_set_tower_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** arg_prev, GeeConcurrentSetTower** arg_curr, guint8 level, gboolean force) {
	gboolean result = FALSE;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	GeeConcurrentSetTower* next = NULL;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	guint8 _tmp3_ = 0U;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	gboolean success = FALSE;
	GeeConcurrentSetTower* _tmp21_ = NULL;
	gboolean _tmp22_ = FALSE;
	gboolean _tmp23_ = FALSE;
	g_return_val_if_fail (*arg_curr != NULL, FALSE);
	_tmp0_ = *arg_curr;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (_tmp0_);
	curr = _tmp1_;
	_tmp2_ = curr;
	_tmp3_ = level;
	_tmp4_ = gee_concurrent_set_tower_get_next (_tmp2_, _tmp3_);
	next = _tmp4_;
	_tmp5_ = next;
	if (_tmp5_ != NULL) {
		while (TRUE) {
			gboolean _tmp6_ = FALSE;
			GeeConcurrentSetTower* _tmp7_ = NULL;
			gboolean status = FALSE;
			GeeConcurrentSetTower* _tmp10_ = NULL;
			GCompareDataFunc _tmp11_ = NULL;
			void* _tmp11__target = NULL;
			guint8 _tmp12_ = 0U;
			gboolean _tmp13_ = FALSE;
			gboolean _tmp14_ = FALSE;
			GeeConcurrentSetTower* _tmp18_ = NULL;
			guint8 _tmp19_ = 0U;
			GeeConcurrentSetTower* _tmp20_ = NULL;
			_tmp7_ = next;
			if (_tmp7_ != NULL) {
				GeeConcurrentSetTower* _tmp8_ = NULL;
				GeeConcurrentSetState _tmp9_ = 0;
				_tmp8_ = next;
				_tmp9_ = gee_concurrent_set_tower_get_state (_tmp8_, (guint8) 0);
				_tmp6_ = _tmp9_ == GEE_CONCURRENT_SET_STATE_MARKED;
			} else {
				_tmp6_ = FALSE;
			}
			if (!_tmp6_) {
				break;
			}
			_tmp10_ = next;
			_tmp11_ = cmp;
			_tmp11__target = cmp_target;
			_tmp12_ = level;
			gee_concurrent_set_tower_try_flag (_tmp10_, _tmp11_, _tmp11__target, &curr, &_tmp13_, _tmp12_);
			status = _tmp13_;
			_tmp14_ = status;
			if (_tmp14_) {
				GeeConcurrentSetTower* _tmp15_ = NULL;
				GeeConcurrentSetTower* _tmp16_ = NULL;
				guint8 _tmp17_ = 0U;
				_tmp15_ = next;
				_tmp16_ = curr;
				_tmp17_ = level;
				gee_concurrent_set_tower_help_flagged (_tmp15_, _tmp16_, _tmp17_);
			}
			_tmp18_ = curr;
			_tmp19_ = level;
			_tmp20_ = gee_concurrent_set_tower_get_next (_tmp18_, _tmp19_);
			_gee_concurrent_set_tower_unref0 (next);
			next = _tmp20_;
		}
	}
	_tmp21_ = next;
	success = _tmp21_ != NULL;
	_tmp23_ = success;
	if (_tmp23_) {
		_tmp22_ = TRUE;
	} else {
		gboolean _tmp24_ = FALSE;
		_tmp24_ = force;
		_tmp22_ = _tmp24_;
	}
	if (_tmp22_) {
		GeeConcurrentSetTower* _tmp25_ = NULL;
		GeeConcurrentSetTower* _tmp26_ = NULL;
		_tmp25_ = curr;
		curr = NULL;
		_gee_concurrent_set_tower_unref0 (*arg_prev);
		*arg_prev = _tmp25_;
		_tmp26_ = next;
		next = NULL;
		_gee_concurrent_set_tower_unref0 (*arg_curr);
		*arg_curr = _tmp26_;
	}
	result = success;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (curr);
	return result;
}


static inline void gee_concurrent_set_tower_help_marked (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev_tower, guint8 level) {
	GeeConcurrentSetTower* _tmp0_ = NULL;
	guint8 _tmp1_ = 0U;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	guint8 _tmp4_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prev_tower != NULL);
	_tmp0_ = prev_tower;
	_tmp1_ = level;
	_tmp2_ = gee_concurrent_set_tower_get_next (self, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = level;
	gee_concurrent_set_tower_compare_and_exchange (_tmp0_, self, GEE_CONCURRENT_SET_STATE_FLAGGED, _tmp3_, GEE_CONCURRENT_SET_STATE_NONE, _tmp4_);
	_gee_concurrent_set_tower_unref0 (_tmp3_);
}


static inline void gee_concurrent_set_tower_help_flagged (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev, guint8 level) {
	GeeConcurrentSetTower* _tmp0_ = NULL;
	guint8 _tmp1_ = 0U;
	guint8 _tmp2_ = 0U;
	GeeConcurrentSetState _tmp3_ = 0;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	guint8 _tmp6_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prev != NULL);
	_tmp0_ = prev;
	_tmp1_ = level;
	gee_concurrent_set_tower_set_backlink (self, _tmp0_, _tmp1_);
	_tmp2_ = level;
	_tmp3_ = gee_concurrent_set_tower_get_state (self, _tmp2_);
	if (_tmp3_ != GEE_CONCURRENT_SET_STATE_MARKED) {
		guint8 _tmp4_ = 0U;
		_tmp4_ = level;
		gee_concurrent_set_tower_try_mark (self, _tmp4_);
	}
	_tmp5_ = prev;
	_tmp6_ = level;
	gee_concurrent_set_tower_help_marked (self, _tmp5_, _tmp6_);
}


static inline void gee_concurrent_set_tower_try_mark (GeeConcurrentSetTower* self, guint8 level) {
	g_return_if_fail (self != NULL);
	{
		gboolean _tmp0_ = FALSE;
		_tmp0_ = TRUE;
		while (TRUE) {
			GeeConcurrentSetTower* next_tower = NULL;
			guint8 _tmp3_ = 0U;
			GeeConcurrentSetTower* _tmp4_ = NULL;
			gboolean _result_ = FALSE;
			GeeConcurrentSetTower* _tmp5_ = NULL;
			GeeConcurrentSetTower* _tmp6_ = NULL;
			guint8 _tmp7_ = 0U;
			gboolean _tmp8_ = FALSE;
			gboolean _tmp9_ = FALSE;
			if (!_tmp0_) {
				guint8 _tmp1_ = 0U;
				GeeConcurrentSetState _tmp2_ = 0;
				_tmp1_ = level;
				_tmp2_ = gee_concurrent_set_tower_get_state (self, _tmp1_);
				if (!(_tmp2_ != GEE_CONCURRENT_SET_STATE_MARKED)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			_tmp3_ = level;
			_tmp4_ = gee_concurrent_set_tower_get_next (self, _tmp3_);
			next_tower = _tmp4_;
			_tmp5_ = next_tower;
			_tmp6_ = next_tower;
			_tmp7_ = level;
			_tmp8_ = gee_concurrent_set_tower_compare_and_exchange (self, _tmp5_, GEE_CONCURRENT_SET_STATE_NONE, _tmp6_, GEE_CONCURRENT_SET_STATE_MARKED, _tmp7_);
			_result_ = _tmp8_;
			_tmp9_ = _result_;
			if (!_tmp9_) {
				GeeConcurrentSetState state = 0;
				guint8 _tmp10_ = 0U;
				GeeConcurrentSetState _tmp11_ = 0;
				GeeConcurrentSetTower* _tmp12_ = NULL;
				GeeConcurrentSetState _tmp13_ = 0;
				_tmp10_ = level;
				_tmp12_ = gee_concurrent_set_tower_get_succ (self, &_tmp11_, _tmp10_);
				state = _tmp11_;
				_gee_concurrent_set_tower_unref0 (next_tower);
				next_tower = _tmp12_;
				_tmp13_ = state;
				if (_tmp13_ == GEE_CONCURRENT_SET_STATE_FLAGGED) {
					GeeConcurrentSetTower* _tmp14_ = NULL;
					guint8 _tmp15_ = 0U;
					_tmp14_ = next_tower;
					_tmp15_ = level;
					gee_concurrent_set_tower_help_flagged (self, _tmp14_, _tmp15_);
				}
			}
			_gee_concurrent_set_tower_unref0 (next_tower);
		}
	}
}


static inline gboolean gee_concurrent_set_tower_try_flag (GeeConcurrentSetTower* self, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev_tower, gboolean* status, guint8 level) {
	gboolean _vala_status = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (*prev_tower != NULL, FALSE);
	while (TRUE) {
		GeeConcurrentSetTower* _tmp0_ = NULL;
		guint8 _tmp1_ = 0U;
		gboolean _tmp2_ = FALSE;
		gboolean _result_ = FALSE;
		GeeConcurrentSetTower* _tmp3_ = NULL;
		guint8 _tmp4_ = 0U;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		GeeConcurrentSetState result_state = 0;
		GeeConcurrentSetTower* result_tower = NULL;
		GeeConcurrentSetTower* _tmp7_ = NULL;
		guint8 _tmp8_ = 0U;
		GeeConcurrentSetState _tmp9_ = 0;
		GeeConcurrentSetTower* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		GeeConcurrentSetTower* _tmp12_ = NULL;
		guint8 _tmp14_ = 0U;
		GCompareDataFunc _tmp15_ = NULL;
		void* _tmp15__target = NULL;
		gconstpointer _tmp16_ = NULL;
		guint8 _tmp17_ = 0U;
		gboolean _tmp18_ = FALSE;
		_tmp0_ = *prev_tower;
		_tmp1_ = level;
		_tmp2_ = gee_concurrent_set_tower_compare_succ (_tmp0_, self, GEE_CONCURRENT_SET_STATE_FLAGGED, _tmp1_);
		if (_tmp2_) {
			_vala_status = TRUE;
			result = FALSE;
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_tmp3_ = *prev_tower;
		_tmp4_ = level;
		_tmp5_ = gee_concurrent_set_tower_compare_and_exchange (_tmp3_, self, GEE_CONCURRENT_SET_STATE_NONE, self, GEE_CONCURRENT_SET_STATE_FLAGGED, _tmp4_);
		_result_ = _tmp5_;
		_tmp6_ = _result_;
		if (_tmp6_) {
			_vala_status = TRUE;
			result = TRUE;
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_tmp7_ = *prev_tower;
		_tmp8_ = level;
		_tmp10_ = gee_concurrent_set_tower_get_succ (_tmp7_, &_tmp9_, _tmp8_);
		result_state = _tmp9_;
		result_tower = _tmp10_;
		_tmp12_ = result_tower;
		if (_tmp12_ == self) {
			GeeConcurrentSetState _tmp13_ = 0;
			_tmp13_ = result_state;
			_tmp11_ = _tmp13_ == GEE_CONCURRENT_SET_STATE_FLAGGED;
		} else {
			_tmp11_ = FALSE;
		}
		if (_tmp11_) {
			_vala_status = TRUE;
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (result_tower);
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_tmp14_ = level;
		gee_concurrent_set_tower_backtrace (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, prev_tower, _tmp14_);
		_tmp15_ = cmp;
		_tmp15__target = cmp_target;
		_tmp16_ = self->_data;
		_tmp17_ = level;
		_tmp18_ = gee_concurrent_set_tower_search_helper (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp15_, _tmp15__target, _tmp16_, prev_tower, NULL, _tmp17_);
		if (!_tmp18_) {
			_vala_status = FALSE;
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (result_tower);
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_gee_concurrent_set_tower_unref0 (result_tower);
	}
	if (status) {
		*status = _vala_status;
	}
}


static inline void gee_concurrent_set_tower_backtrace (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetTower** curr, guint8 level) {
	while (TRUE) {
		GeeConcurrentSetTower* _tmp0_ = NULL;
		guint8 _tmp1_ = 0U;
		GeeConcurrentSetState _tmp2_ = 0;
		GeeConcurrentSetTower* _tmp3_ = NULL;
		guint8 _tmp4_ = 0U;
		GeeConcurrentSetTower* _tmp5_ = NULL;
		_tmp0_ = *curr;
		_tmp1_ = level;
		_tmp2_ = gee_concurrent_set_tower_get_state (_tmp0_, _tmp1_);
		if (!(_tmp2_ == GEE_CONCURRENT_SET_STATE_MARKED)) {
			break;
		}
		_tmp3_ = *curr;
		_tmp4_ = level;
		_tmp5_ = gee_concurrent_set_tower_get_backlink (_tmp3_, _tmp4_);
		_gee_concurrent_set_tower_unref0 (*curr);
		*curr = _tmp5_;
	}
}


static inline gboolean gee_concurrent_set_tower_compare_and_exchange (GeeConcurrentSetTower* self, GeeConcurrentSetTower* old_tower, GeeConcurrentSetState old_state, GeeConcurrentSetTower* new_tower, GeeConcurrentSetState new_state, guint8 level) {
	gboolean result = FALSE;
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	GeeConcurrentSetState _tmp5_ = 0;
	GeeConcurrentSetState _tmp6_ = 0;
	gboolean _tmp7_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = old_tower;
	_tmp3_ = new_tower;
	_tmp4_ = _gee_concurrent_set_tower_ref0 (_tmp3_);
	_tmp5_ = old_state;
	_tmp6_ = new_state;
	_tmp7_ = gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._succ, _tmp2_, _tmp4_, (gsize) 3, (gsize) _tmp5_, (gsize) _tmp6_);
	result = _tmp7_;
	return result;
}


static inline gboolean gee_concurrent_set_tower_compare_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level) {
	gboolean result = FALSE;
	gsize cur = 0UL;
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	void* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetState _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = g_atomic_pointer_get ((volatile gpointer *) (&_tmp0_[_tmp1_]._succ));
	cur = (gsize) _tmp2_;
	_tmp3_ = next;
	_tmp4_ = state;
	result = cur == (((gsize) _tmp3_) | ((gsize) _tmp4_));
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_next (GeeConcurrentSetTower* self, guint8 level) {
	GeeConcurrentSetTower* result = NULL;
	guint8 _tmp0_ = 0U;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = level;
	_tmp1_ = gee_concurrent_set_tower_get_succ (self, NULL, _tmp0_);
	result = _tmp1_;
	return result;
}


static inline GeeConcurrentSetState gee_concurrent_set_tower_get_state (GeeConcurrentSetTower* self, guint8 level) {
	GeeConcurrentSetState result = 0;
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	void* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = g_atomic_pointer_get ((volatile gpointer *) (&_tmp0_[_tmp1_]._succ));
	result = (GeeConcurrentSetState) (((gsize) _tmp2_) & 3);
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_succ (GeeConcurrentSetTower* self, GeeConcurrentSetState* state, guint8 level) {
	GeeConcurrentSetState _vala_state = 0;
	GeeConcurrentSetTower* result = NULL;
	gsize rstate = 0UL;
	GeeConcurrentSetTower* succ = NULL;
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	gsize _tmp2_ = 0UL;
	gpointer _tmp3_ = NULL;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp3_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._succ, (gsize) 3, &_tmp2_);
	rstate = _tmp2_;
	succ = (GeeConcurrentSetTower*) _tmp3_;
	_vala_state = (GeeConcurrentSetState) rstate;
	_tmp4_ = succ;
	succ = NULL;
	result = _tmp4_;
	_gee_concurrent_set_tower_unref0 (succ);
	if (state) {
		*state = _vala_state;
	}
	return result;
}


static inline void gee_concurrent_set_tower_set_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level) {
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetState _tmp4_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = next;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	_tmp4_ = state;
	gee_hazard_pointer_set_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._succ, _tmp3_, (gsize) 3, (gsize) _tmp4_);
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_backlink (GeeConcurrentSetTower* self, guint8 level) {
	GeeConcurrentSetTower* result = NULL;
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	gpointer _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._backlink, (gsize) 0, NULL);
	result = (GeeConcurrentSetTower*) _tmp2_;
	return result;
}


static inline void gee_concurrent_set_tower_set_backlink (GeeConcurrentSetTower* self, GeeConcurrentSetTower* backlink, guint8 level) {
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = backlink;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._backlink, NULL, _tmp3_, (gsize) 0, (gsize) 0, (gsize) 0);
}


static inline gint gee_concurrent_set_tower_get_height (GeeConcurrentSetTower* self) {
	gint result = 0;
	gint height = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->_height));
	height = _tmp0_;
	_tmp2_ = height;
	if (_tmp2_ != (-1)) {
		gint _tmp3_ = 0;
		_tmp3_ = height;
		_tmp1_ = _tmp3_;
	} else {
		_tmp1_ = GEE_CONCURRENT_SET__MAX_HEIGHT;
	}
	result = _tmp1_;
	return result;
}


static inline gboolean gee_concurrent_set_tower_is_head (GeeConcurrentSetTower* self) {
	gboolean result = FALSE;
	gint height = 0;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->_height));
	height = _tmp0_;
	result = height == (-1);
	return result;
}


static inline gint gee_concurrent_set_tower_compare (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, GeeConcurrentSetTower* b) {
	gint result = 0;
	gboolean ah = FALSE;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gboolean bh = FALSE;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = g_atomic_int_get ((volatile gint *) (&_tmp0_->_height));
	ah = _tmp1_ == (-1);
	_tmp2_ = b;
	_tmp3_ = g_atomic_int_get ((volatile gint *) (&_tmp2_->_height));
	bh = _tmp3_ == (-1);
	_tmp5_ = ah;
	if (_tmp5_) {
		gint _tmp6_ = 0;
		gboolean _tmp7_ = FALSE;
		_tmp7_ = bh;
		if (_tmp7_) {
			_tmp6_ = 0;
		} else {
			_tmp6_ = -1;
		}
		_tmp4_ = _tmp6_;
	} else {
		gint _tmp8_ = 0;
		gboolean _tmp9_ = FALSE;
		_tmp9_ = bh;
		if (_tmp9_) {
			_tmp8_ = 1;
		} else {
			GCompareDataFunc _tmp10_ = NULL;
			void* _tmp10__target = NULL;
			GeeConcurrentSetTower* _tmp11_ = NULL;
			gconstpointer _tmp12_ = NULL;
			GeeConcurrentSetTower* _tmp13_ = NULL;
			gconstpointer _tmp14_ = NULL;
			gint _tmp15_ = 0;
			_tmp10_ = cmp;
			_tmp10__target = cmp_target;
			_tmp11_ = a;
			_tmp12_ = _tmp11_->_data;
			_tmp13_ = b;
			_tmp14_ = _tmp13_->_data;
			_tmp15_ = _tmp10_ (_tmp12_, _tmp14_, _tmp10__target);
			_tmp8_ = _tmp15_;
		}
		_tmp4_ = _tmp8_;
	}
	result = _tmp4_;
	return result;
}


static inline gint gee_concurrent_set_tower_compare_data (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, gconstpointer b) {
	gint result = 0;
	gboolean ah = FALSE;
	GeeConcurrentSetTower* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (a != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = g_atomic_int_get ((volatile gint *) (&_tmp0_->_height));
	ah = _tmp1_ == (-1);
	_tmp3_ = ah;
	if (_tmp3_) {
		_tmp2_ = -1;
	} else {
		GCompareDataFunc _tmp4_ = NULL;
		void* _tmp4__target = NULL;
		GeeConcurrentSetTower* _tmp5_ = NULL;
		gconstpointer _tmp6_ = NULL;
		gconstpointer _tmp7_ = NULL;
		gint _tmp8_ = 0;
		_tmp4_ = cmp;
		_tmp4__target = cmp_target;
		_tmp5_ = a;
		_tmp6_ = _tmp5_->_data;
		_tmp7_ = b;
		_tmp8_ = _tmp4_ (_tmp6_, _tmp7_, _tmp4__target);
		_tmp2_ = _tmp8_;
	}
	result = _tmp2_;
	return result;
}


static void gee_concurrent_set_value_tower_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gee_concurrent_set_value_tower_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gee_concurrent_set_tower_unref (value->data[0].v_pointer);
	}
}


static void gee_concurrent_set_value_tower_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gee_concurrent_set_tower_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gee_concurrent_set_value_tower_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gee_concurrent_set_value_tower_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GeeConcurrentSetTower* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gee_concurrent_set_tower_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gee_concurrent_set_value_tower_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GeeConcurrentSetTower** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gee_concurrent_set_tower_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* gee_concurrent_set_param_spec_tower (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GeeConcurrentSetParamSpecTower* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEE_CONCURRENT_SET_TYPE_TOWER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer gee_concurrent_set_value_get_tower (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER), NULL);
	return value->data[0].v_pointer;
}


static void gee_concurrent_set_value_set_tower (GValue* value, gpointer v_object) {
	GeeConcurrentSetTower* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_TOWER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gee_concurrent_set_tower_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_tower_unref (old);
	}
}


static void gee_concurrent_set_value_take_tower (GValue* value, gpointer v_object) {
	GeeConcurrentSetTower* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_TOWER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_tower_unref (old);
	}
}


static void gee_concurrent_set_tower_class_init (GeeConcurrentSetTowerClass * klass) {
	gee_concurrent_set_tower_parent_class = g_type_class_peek_parent (klass);
	((GeeConcurrentSetTowerClass *) klass)->finalize = gee_concurrent_set_tower_finalize;
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetTowerPrivate));
}


static void gee_concurrent_set_tower_instance_init (GeeConcurrentSetTower * self) {
	self->priv = GEE_CONCURRENT_SET_TOWER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void gee_concurrent_set_tower_finalize (GeeConcurrentSetTower* obj) {
	GeeConcurrentSetTower * self;
	gint height = 0;
	gint _tmp0_ = 0;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTower);
	g_signal_handlers_destroy (self);
	_tmp0_ = gee_concurrent_set_tower_get_height (self);
	height = _tmp0_;
	{
		guint8 i = 0U;
		i = (guint8) 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				guint8 _tmp3_ = 0U;
				gint _tmp4_ = 0;
				guint8 _tmp5_ = 0U;
				guint8 _tmp6_ = 0U;
				if (!_tmp1_) {
					guint8 _tmp2_ = 0U;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = height;
				if (!(((gint) _tmp3_) < _tmp4_)) {
					break;
				}
				_tmp5_ = i;
				gee_concurrent_set_tower_set_succ (self, NULL, GEE_CONCURRENT_SET_STATE_NONE, _tmp5_);
				_tmp6_ = i;
				gee_concurrent_set_tower_set_backlink (self, NULL, _tmp6_);
			}
		}
	}
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = NULL;
	self->_nodes = (g_free (self->_nodes), NULL);
	((self->_data == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_data = (self->priv->g_destroy_func (self->_data), NULL));
}


static GType gee_concurrent_set_tower_get_type (void) {
	static volatile gsize gee_concurrent_set_tower_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gee_concurrent_set_value_tower_init, gee_concurrent_set_value_tower_free_value, gee_concurrent_set_value_tower_copy_value, gee_concurrent_set_value_tower_peek_pointer, "p", gee_concurrent_set_value_tower_collect_value, "p", gee_concurrent_set_value_tower_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetTowerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_tower_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetTower), 0, (GInstanceInitFunc) gee_concurrent_set_tower_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gee_concurrent_set_tower_type_id;
		gee_concurrent_set_tower_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeeConcurrentSetTower", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gee_concurrent_set_tower_type_id__volatile, gee_concurrent_set_tower_type_id);
	}
	return gee_concurrent_set_tower_type_id__volatile;
}


static gpointer gee_concurrent_set_tower_ref (gpointer instance) {
	GeeConcurrentSetTower* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void gee_concurrent_set_tower_unref (gpointer instance) {
	GeeConcurrentSetTower* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEE_CONCURRENT_SET_TOWER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static GeeConcurrentSetTowerNode* gee_concurrent_set_tower_node_dup (const GeeConcurrentSetTowerNode* self) {
	GeeConcurrentSetTowerNode* dup;
	dup = g_new0 (GeeConcurrentSetTowerNode, 1);
	memcpy (dup, self, sizeof (GeeConcurrentSetTowerNode));
	return dup;
}


static void gee_concurrent_set_tower_node_free (GeeConcurrentSetTowerNode* self) {
	g_free (self);
}


static GType gee_concurrent_set_tower_node_get_type (void) {
	static volatile gsize gee_concurrent_set_tower_node_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_node_type_id__volatile)) {
		GType gee_concurrent_set_tower_node_type_id;
		gee_concurrent_set_tower_node_type_id = g_boxed_type_register_static ("GeeConcurrentSetTowerNode", (GBoxedCopyFunc) gee_concurrent_set_tower_node_dup, (GBoxedFreeFunc) gee_concurrent_set_tower_node_free);
		g_once_init_leave (&gee_concurrent_set_tower_node_type_id__volatile, gee_concurrent_set_tower_node_type_id);
	}
	return gee_concurrent_set_tower_node_type_id__volatile;
}


static void _vala_array_copy1 (GeeConcurrentSetTower** self, GeeConcurrentSetTower** dest) {
	int i;
	for (i = 0; i < 31; i++) {
		GeeConcurrentSetTower* _tmp0_ = NULL;
		_tmp0_ = _gee_concurrent_set_tower_ref0 (self[i]);
		dest[i] = _tmp0_;
	}
}


static void gee_concurrent_set_tower_iter_copy (const GeeConcurrentSetTowerIter* self, GeeConcurrentSetTowerIter* dest) {
	GeeConcurrentSetTower* _tmp0_[31] = {0};
	gint _tmp0__length1 = 0;
	_vala_array_copy1 ((*self)._iter, _tmp0_);
	_vala_array_destroy ((*dest)._iter, 31, (GDestroyNotify) gee_concurrent_set_tower_unref);
	memcpy ((*dest)._iter, _tmp0_, 31 * sizeof (GeeConcurrentSetTower*));
}


static void gee_concurrent_set_tower_iter_destroy (GeeConcurrentSetTowerIter* self) {
	_vala_array_destroy ((*self)._iter, 31, (GDestroyNotify) gee_concurrent_set_tower_unref);
}


static GeeConcurrentSetTowerIter* gee_concurrent_set_tower_iter_dup (const GeeConcurrentSetTowerIter* self) {
	GeeConcurrentSetTowerIter* dup;
	dup = g_new0 (GeeConcurrentSetTowerIter, 1);
	gee_concurrent_set_tower_iter_copy (self, dup);
	return dup;
}


static void gee_concurrent_set_tower_iter_free (GeeConcurrentSetTowerIter* self) {
	gee_concurrent_set_tower_iter_destroy (self);
	g_free (self);
}


static GType gee_concurrent_set_tower_iter_get_type (void) {
	static volatile gsize gee_concurrent_set_tower_iter_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_iter_type_id__volatile)) {
		GType gee_concurrent_set_tower_iter_type_id;
		gee_concurrent_set_tower_iter_type_id = g_boxed_type_register_static ("GeeConcurrentSetTowerIter", (GBoxedCopyFunc) gee_concurrent_set_tower_iter_dup, (GBoxedFreeFunc) gee_concurrent_set_tower_iter_free);
		g_once_init_leave (&gee_concurrent_set_tower_iter_type_id__volatile, gee_concurrent_set_tower_iter_type_id);
	}
	return gee_concurrent_set_tower_iter_type_id__volatile;
}


static void gee_concurrent_set_class_init (GeeConcurrentSetClass * klass) {
	GPrivate* _tmp0_ = NULL;
	gee_concurrent_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetPrivate));
	((GeeAbstractCollectionClass *) klass)->iterator = gee_concurrent_set_real_iterator;
	((GeeAbstractCollectionClass *) klass)->contains = gee_concurrent_set_real_contains;
	((GeeAbstractCollectionClass *) klass)->add = gee_concurrent_set_real_add;
	((GeeAbstractCollectionClass *) klass)->remove = gee_concurrent_set_real_remove;
	((GeeAbstractCollectionClass *) klass)->clear = gee_concurrent_set_real_clear;
	((GeeAbstractSortedSetClass *) klass)->first = gee_concurrent_set_real_first;
	((GeeAbstractSortedSetClass *) klass)->last = gee_concurrent_set_real_last;
	((GeeAbstractSortedSetClass *) klass)->iterator_at = gee_concurrent_set_real_iterator_at;
	((GeeAbstractSortedSetClass *) klass)->lower = gee_concurrent_set_real_lower;
	((GeeAbstractSortedSetClass *) klass)->higher = gee_concurrent_set_real_higher;
	((GeeAbstractSortedSetClass *) klass)->floor = gee_concurrent_set_real_floor;
	((GeeAbstractSortedSetClass *) klass)->ceil = gee_concurrent_set_real_ceil;
	((GeeAbstractSortedSetClass *) klass)->head_set = gee_concurrent_set_real_head_set;
	((GeeAbstractSortedSetClass *) klass)->tail_set = gee_concurrent_set_real_tail_set;
	((GeeAbstractSortedSetClass *) klass)->sub_set = gee_concurrent_set_real_sub_set;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_concurrent_set_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_concurrent_set_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	_tmp0_ = g_private_new (__gee_concurrent_set_rand_lambda52__gdestroy_notify);
	gee_concurrent_set_rand = _tmp0_;
}


static void gee_concurrent_set_instance_init (GeeConcurrentSet * self) {
	GeeConcurrentSetTower* _tmp0_ = NULL;
	self->priv = GEE_CONCURRENT_SET_GET_PRIVATE (self);
	self->priv->_size = 0;
	_tmp0_ = gee_concurrent_set_tower_new_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func);
	self->priv->_head = _tmp0_;
}


static void gee_concurrent_set_finalize (GObject* obj) {
	GeeConcurrentSet * self;
	GeeHazardPointerContext* ctx = NULL;
	GeeHazardPointerContext* _tmp0_ = NULL;
	GeeHazardPointerContext* _tmp1_ = NULL;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = ctx;
	gee_utils_misc_unused (_tmp1_);
	_gee_concurrent_set_tower_unref0 (self->priv->_head);
	self->priv->_head = NULL;
	_gee_hazard_pointer_context_free0 (ctx);
	_gee_concurrent_set_tower_unref0 (self->priv->_head);
	(self->priv->_cmp_target_destroy_notify == NULL) ? NULL : (self->priv->_cmp_target_destroy_notify (self->priv->_cmp_target), NULL);
	self->priv->_cmp = NULL;
	self->priv->_cmp_target = NULL;
	self->priv->_cmp_target_destroy_notify = NULL;
	G_OBJECT_CLASS (gee_concurrent_set_parent_class)->finalize (obj);
}


/**
 * A skip-linked list. This implementation is based on
 * [[http://www.cse.yorku.ca/~ruppert/Mikhail.pdf|Mikhail Fomitchev Master Thesis]].
 *
 * Many threads are allowed to operate on the same structure as well as modification
 * of structure during iteration is allowed. However the change may not be immidiatly
 * visible to other threads.
 */
GType gee_concurrent_set_get_type (void) {
	static volatile gsize gee_concurrent_set_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSet), 0, (GInstanceInitFunc) gee_concurrent_set_instance_init, NULL };
		GType gee_concurrent_set_type_id;
		gee_concurrent_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SORTED_SET, "GeeConcurrentSet", &g_define_type_info, 0);
		g_once_init_leave (&gee_concurrent_set_type_id__volatile, gee_concurrent_set_type_id);
	}
	return gee_concurrent_set_type_id__volatile;
}


static void _vala_gee_concurrent_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SIZE:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_READ_ONLY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



